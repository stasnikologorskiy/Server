unit n_OnlinePocedures; // процедуры для Web

interface
uses Windows, Classes, System.Types, System.Contnrs, SysUtils, Math, Variants, DateUtils,
     DB, IBDatabase, IBSQL, Forms, n_free_functions, v_constants, v_Functions, v_DataTrans,
     n_LogThreads, n_DataCacheInMemory, n_constants, n_DataSetsManager, n_server_common;

procedure prAutenticateOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);

procedure prCreateNewOrderCommonOrd(UserId, FirmID: integer; var NewOrderID, contID: integer;
          var ErrorMessage: string; qID: integer=-1; OrdIBS: TIBSQL=nil; currID: Integer=0);
procedure prGetOptionsOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSetOrderDefaultOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prChangePasswordOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prWebSetMainUserOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prWebCreateUserOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prWebResetPasswordOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prCheckLoginOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetRegisterTableOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);  // список регионов для формы регистрации
procedure prSaveRegOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);      // запись заявки на регистрацию в системе СВК
procedure prGetRegisterUberTowns(Stream: TBoBMemoryStream; ThreadData: TThreadData); // список городов для формы регистрации UBER
procedure prSaveRegOrderUber(Stream: TBoBMemoryStream; ThreadData: TThreadData);     // запись заявки на регистрацию UBER в системе СВК
procedure prCreateNewOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetOrderListOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);       // список заказов
procedure prShowOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowACOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prDelLineFromOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prChangeQtyInOrderLineOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prRefreshPricesOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prRefreshPricesInFormingOrdersOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetAccountListOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);       // список счетов резерва
procedure prCreateOrderByMarkedOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prJoinMarkedOrdersOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowGBAccountOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prDeleteOrderByMarkOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSetReservValueOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
//procedure prSetOrderPayTypeOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAddLinesToOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData); // Добавить строки в заказ
procedure prAddLineFromSearchResToOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData); // добавить товар в заказ непосредственно из результатов поиска
 function fnRefreshPriceInOrderOrd(var SResult: string; OrderCode: string; ThreadData: TThreadData=nil): string; // Обновляет цены в заказе

 function fnRecaclQtyByDivisible(WareID: integer; var WareQty: double): string; // Исправляет кол-во товара в заказе в соответствии с кратностью
 function fnRecaclQtyByDivisibleEx(WareID: integer; WareQty: double): string;   // Проверяет соответствие кол-ва товара с кратностью
procedure prChangeVisibilityOfStorage(Stream: TBoBMemoryStream; ThreadData: TThreadData); // изменить видимость склада клиента
procedure prClientsStoreMove(Stream: TBoBMemoryStream; ThreadData: TThreadData); // Передвинуть склад в списке видимости клиента выше/ниже

procedure prChangeClientLastContract(Stream: TBoBMemoryStream; ThreadData: TThreadData);   // изменить последний контракт клиента/контракт заказа
procedure prChangeOrderContract(FirmId, ContID, OrderID: integer;ThreadData: TThreadData); // изменить контракт заказа и пересчитать цены

 function fnGetStoragesArray_2col(Contract: TContract; ReservedOnly: boolean=false; // склады контракта - 1/2/3 колонки
                                  DefaultOnly: boolean=false): TasD;
procedure prSetCliContMargins(Stream: TBoBMemoryStream; ThreadData: TThreadData);   // изменение наценок

//------------------------------------------------------------ vc
procedure prGetAllUsersInfo(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetWaresFromAccountList(Stream: TBoBMemoryStream; ThreadData: TThreadData); // список товаров резерва
procedure prShowGBOutInvoice(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowGBBack(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetUnpayedDocs(Stream: TBoBMemoryStream; ThreadData: TThreadData);      // список неоплаченных док-тов
procedure prGetCheck(Stream: TBoBMemoryStream; ThreadData: TThreadData);            // сверка
procedure prSendMessage2Manager(Stream: TBoBMemoryStream; ThreadData: TThreadData); // отправить менеджеру письмо
procedure prGetActions(Stream: TBoBMemoryStream; ThreadData: TThreadData);          // Выдать инфу по акциям и пр
procedure prClickOnNewsCounting(Stream: TBoBMemoryStream; ThreadData: TThreadData); // Фиксация клика по новостям/акциям
procedure prSaveOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);          //
procedure prGetQtyByAnalogsAndStoragesOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData); //Выдать данные с остатками по склaдам и заказанному кол-ву по товару с аналогами и возможностью редактирования количеств
procedure prSendVINOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData);         //
procedure prDownloadPrice(Stream: TBoBMemoryStream; ThreadData: TThreadData);        //
procedure prShowNotificationOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);  //
procedure prConfirmNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);  //
procedure prContractList(Stream: TBoBMemoryStream; ThreadData: TThreadData);         //
procedure prContractList_new(Stream: TBoBMemoryStream; ThreadData: TThreadData);     // список контрактов к/а по профилям (Web)
procedure prChangeContractAccess(Stream: TBoBMemoryStream; ThreadData: TThreadData); //
procedure prSendOrderForChangeData(kind: Integer; Stream: TBoBMemoryStream; ThreadData: TThreadData); // Заявка на изменение данных (Web)
procedure prRemindPass(Stream: TBoBMemoryStream; ThreadData: TThreadData);    // Напоминание пароля
procedure prGetContracts(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetMainStoreLocation(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetBonusWares(Stream: TBoBMemoryStream; ThreadData: TThreadData); // список призовых товаров
//------------------------------------------------------------ vc

procedure prGetOrderHeaderParams(Stream: TBoBMemoryStream; ThreadData: TThreadData);  // просмотр параметров заголовка заказа
procedure prEditOrderHeaderParams(Stream: TBoBMemoryStream; ThreadData: TThreadData); // редактирование заголовка заказа
procedure prShowBonusFormingOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData); // просмотр бонусного неотправленного заказа
procedure prEditOrderSelfComment(Stream: TBoBMemoryStream; ThreadData: TThreadData);  // редактирование комментария "для себя"
procedure prCheckOrderWareRests(Stream: TBoBMemoryStream; ThreadData: TThreadData);   // проверка проблем отгрузки товаров по заказу
procedure prGetCheckBonus(Stream: TBoBMemoryStream; ThreadData: TThreadData);         // unit-движение
procedure prShowGBManual(Stream: TBoBMemoryStream; ThreadData: TThreadData);          // просмотр корректировок
procedure prGetFormingOrdersList(Stream: TBoBMemoryStream; ThreadData: TThreadData);  // Получить список неотправленных заказов
procedure prGetWareActions(Stream: TBoBMemoryStream; ThreadData: TThreadData);        // список акций для "Информации"
 function CheckOrdWaresExAndOverLimit(FirmID, UserID, ContID, OrderID, CurrID: Integer; // проверка наличия товаров в заказе и остатка лимита резерва к/а
                                    flResLimit, flExWares, flSingleLine: Boolean; ibs: TIBSQL=nil): String;
 function GetOrderOverSummMess(currID: integer; OverSumm, OrderSum, LastLineSum: Double): String; // получить превышение лимита по заказу в валюте заказа

procedure prGetBankAccountsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);    // список счетов на оплату
procedure prNewBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData);         // новый счет на оплату
procedure prSaveBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData);        // записать счет на оплату
procedure prGetBankAccountFile(Stream: TBoBMemoryStream; ThreadData: TThreadData);     // Получить файл счета на оплату
procedure prSendSMSfromBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData); // Отправить SMS из счета на оплату
procedure prGetReclamationList(Stream: TBoBMemoryStream; ThreadData: TThreadData);     // список рекламаций
procedure prGetMeetPersonsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);     // Получить список встречающих к/а

 function prSendMessAboutCreateAccount(Ord: ROrderOpts; IDq: Integer; ErrStr: string): string; overload;
 function prSendMessAboutCreateAccount(ORDRCODE, DCACCODE, FirmID, // отправить письмо о формировании счета в Grossbee
          contID, storID, crnc, IDq: Integer; SumDoc, SumLines: Double;
          DCACNUMBER, ORDRNUM, sDate, ErrStr: string; accLines: TStringList): string; overload;

implementation
uses n_CSSservice, n_CSSThreads, n_DataCacheObjects, n_DataCacheAddition, n_IBCntsPool;

//*******************************************************************************
procedure prCreateNewOrderCommonOrd(UserId, FirmID: integer; var NewOrderID, contID: integer;
          var ErrorMessage: string; qID: integer=-1; OrdIBS: TIBSQL=nil; currID: Integer=0);
const nmProc = 'prCreateNewOrderCommonOrd'; // имя процедуры/функции/потока
var acctype, delivery, dest: integer;
    FirmCode, s: string;
    OrdIBD: TIBDatabase;
    flCreate: boolean;
    Contract: TContract;
    Client: TClientInfo;
begin
  OrdIBD:= nil;
  NewOrderID:= 0;
  ErrorMessage:= '';
  flCreate:= False;
  FirmCode:= IntToStr(FirmID);
  if qID<0 then qID:= FirmID;
  try
    flCreate:= not Assigned(OrdIBS);
    if flCreate then begin
      OrdIBD:= cntsORD.GetFreeCnt;
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, qID, tpWrite);
    end else fnSetTransParams(OrdIBS.Transaction, tpWrite);

    Cache.TestClients(UserID, true);
    if not Cache.ClientExist(UserId) then raise Exception.Create(MessText(mtkNotClientExist));
    Client:= Cache.arClientInfo[UserId];

    if (contID<1) then contID:= Client.LastContract;
    Contract:= Cache.arFirmInfo[FirmID].GetContract(contID);
    if (Contract.Status=cstClosed) then         // проверка на доступность контракта
      raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');

    acctype:= Contract.PayType;
    if Client.CheckIsFinalClient then begin
      delivery:= cDelivSelfGet;
      dest    := 0;
    end else with Client.GetCliContDefs(contID) do begin
      delivery:= ID1;
      dest    := ID2;
    end;
    if (currID<>Cache.BonusCrncCode) then
      if (Contract.DutyCurrency>0) then currID:= Contract.DutyCurrency
      else currID:= fnIfInt((acctype=1) or Client.CheckIsFinalClient, cUAHCurrency, cDefCurrency);

    with OrdIBS.Transaction do if not InTransaction then StartTransaction;
    OrdIBS.SQL.Text:= 'select rOrderCode from CreateNewOrderHeaderC('+
      IntToStr(contID)+', "",'+IntToStr(acctype)+', '+IntToStr(Contract.Filial)+', '+
      Contract.MainStoreStr+','+IntToStr(cosByWeb)+', '+IntToStr(FirmID)+', '+
      IntToStr(delivery)+', '+IntToStr(currID)+', "", NULL, "", '+
      IntToStr(orstForming)+', "", NULL, '+IntToStr(UserID)+')';

    s:= RepeatExecuteIBSQL(OrdIBS, 'rOrderCode', NewOrderID);
    if s<>'' then raise Exception.Create('Not save order header: '+s);
    if NewOrderID<1  then raise Exception.Create('rOrderCode < 1');

    if (delivery=cDelivTimeTable) and (dest>0) then begin
      with OrdIBS.Transaction do if not InTransaction then StartTransaction;
      OrdIBS.SQL.Text:= 'update ORDERSREESTR set ORDRDESTPOINT='+IntToStr(dest)+
        ' where ORDRCODE='+IntToStr(NewOrderID);
      s:= RepeatExecuteIBSQL(OrdIBS);
      if s<>'' then prMessageLOGS(nmProc+'_dest: '+s, fLogCache);
    end;
  except
    on E: Exception do begin
      if Assigned(OrdIBS) then with OrdIBS.Transaction do if InTransaction then Rollback;
      NewOrderID:= 0;
      ErrorMessage:= 'Ошибка в '+nmProc+': '+E.Message
    end;
  end;
  if flcreate then begin
    prFreeIBSQL(OrdIBS);
    cntsORD.SetFreeCnt(OrdIBD);
  end;
end;
//*******************************************************************************
procedure prAutenticateOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAutenticateOrd'; // имя процедуры/функции
type RDirectParams = record
  Name: String;          // название направления
  LevelCount: Integer;   // Кол-во уровней
  ProcToNext: Integer;   // Процент участка шкалы, которого не хватает до уровня, до которого к/а не дотягивает
  FirmSales: Integer;    // округл. текущий оборот к/а
  FirmModel: TDiscModel; // текущий шаблон к/а
  NextModel: TDiscModel; // шаблон, до которого к/а не дотягивает по обороту текущего месяца
end;
var sid, UserLogin, UserPsw, IP, Ident, username, usermail,
      FirmCode, UserCode, ss, sParam: string;
    pUserId, pFirmID, i, iBlock, contID, contBonusOrd, j, command: integer;
    FullData, pResetPW, flEnterByLogin, flBaseAutorize, fl: boolean;
    ibS: TIBSQL;
    ibDb: TIBDatabase;
    Client: TClientInfo;
    firma: TFirmInfo;
    Notifics: TIntegerList;
    Contract: TContract;
    DirectParams: array of RDirectParams;
    dm: TDiscModel;
    tt: TTWoCodes;
    LocStart: TDateTime;
    prof: TCredProfile;
begin
  Stream.Position:= 0;
  ibS:= nil;
  Client:= nil;
  pFirmID:= 0;
  pUserID:= 0;
  iBlock:= 0;
  pResetPW:= false;
  contID:= 0;
  flBaseAutorize:= False;
  UserCode:= '';
  sParam:= '';
  LocStart:= now();
  try

if flLogTestClients then
    prMessageLOGS(nmProc+'-------------------- start', fLogDebug, false); // пишем в log

    UserLogin:= trim(Stream.ReadStr);
    UserPsw:= trim(Stream.ReadStr);
    sid:= trim(Stream.ReadStr);
    IP:= trim(Stream.ReadStr);
    Ident:= trim(Stream.ReadStr);
    FullData:= boolean(Stream.ReadByte);
    contID:= Stream.ReadInt;   // для контрактов

    if FullData then command:= csWebAutentication
    else command:= csBackJobAutentication;

          // логирование в ib_css - формат НЕ ТРОГАТЬ, обрабатывается в базе !!!
    sParam:= 'Login='+UserLogin+#13#10'Password='+UserPsw+#13#10'sid='+sid+
             #13#10'IP='+IP+#13#10'Browser='+Ident+#13#10'ContID='+IntToStr(contID);
    try
  //---------------------------------------------------- проверяем параметры входа
      flEnterByLogin:= (UserLogin<>'') and (UserPsw<>''); // признак входа по логину
      if flEnterByLogin then begin
        i:= Cache.CliLoginLength;
        if (Length(UserLogin)>i) then
          raise EBOBError.Create('Некорректный логин - '+UserLogin+'. '+MessText(mtkNotValidLogin, IntToStr(i)));
        i:= Cache.CliPasswLength;
        if (Length(UserPsw)>i) then
          raise EBOBError.Create('Некорректный пароль. '+MessText(mtkNotValidPassw, IntToStr(i)));
  //      if not fnCheckOrderWebLogin(UserLogin) then
  //        raise EBOBError.Create(MessText(mtkNotValidLogin));
  //      if not fnCheckOrderWebPassword(UserPsw) then
  //        raise EBOBError.Create(MessText(mtkNotValidPassw));
      end else if (sid='') then raise EBOBError.Create(MessText(mtkNotParams))
      else if (Length(sid)>Cache.CliSessionLength) then raise EBOBError.Create(
        'Некорректный идентификатор сессии. Авторизуйтесь с использованием логина и пароля.');

  //---------------------------------------------- пытаемся авторизоваться по кешу
      if flEnterByLogin then with Cache.arClientInfo.WorkLogins do begin
        i:= IndexOf(UserLogin);
        if (i>-1) then pUserID:= Integer(Objects[i]);
        flBaseAutorize:= True; // авторизация по базе
      end else begin
        i:= pos('|', sid);
        if (i>1) then UserCode:= copy(sid, 1, i-1);
        if (UserCode<>'') then begin
          pUserID:= StrToIntDef(UserCode, 0);
          if (pUserID<1) then UserCode:= '';
        end;
      end;
      if (pUserID>0) then
        if not Cache.ClientExist(pUserID) then pUserID:= 0
        else begin

if flLogTestClients then begin
    prMessageLOGS(nmProc+': TestClients start ----------', fLogDebug, false); // пишем в log
    LocStart:= now();
end;
          Cache.TestClients(pUserID, true); // проверка данных клиента в кэше

if flLogTestClients then begin
    prMessageLOGS(nmProc+': TestClients - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log
    LocStart:= now();
end;
          Client:= Cache.arClientInfo[pUserID];
        end;
      if Assigned(Client) then begin // если нашли клиента - проверяем необходимость авторизции по базе
        if not flEnterByLogin then flBaseAutorize:= flBaseAutorize or (sid<>Client.Sid);
        flBaseAutorize:= flBaseAutorize or
          ((Now>IncMinute(Client.LastBaseAutorize, Cache.ClientActualInterval))
          and cntsGRB.NotManyLockConnects and cntsORD.NotManyLockConnects);
      end;
      flBaseAutorize:= flBaseAutorize or not Assigned(Client);

      if flBaseAutorize then begin

if flLogTestClients then begin
    prMessageLOGS(nmProc+': BaseAutorize start ----------', fLogDebug, false); // пишем в log
    LocStart:= now();
end;

  //---------------------------------------------------------- авторизация по базе
        ibDb:= cntsORD.GetFreeCnt;
        try
          ibS:= fnCreateNewIBSQL(ibDb, 'ibS_'+nmProc, ThreadData.ID, tpWrite, true);
          ibS.SQL.Text:= 'Select * from AutenticateUserCSS(:LOGIN, :PASSW, :Ses, '+
            Cache.GetConstItem(pcClientTimeOutWeb).StrValue+', '+IntToStr(cosByWeb)+')';
          ibS.ParamByName('LOGIN').AsString:= UserLogin;
          ibS.ParamByName('PASSW').AsString:= UserPsw;
          ibS.ParamByName('Ses').AsString:= sid;
          ibS.Prepare;
          for i:= 1 to RepeatCount do try
            with ibS.Transaction do if not InTransaction then StartTransaction;
            ibS.ExecQuery;
            if (ibS.Bof and ibS.Eof) then
              raise Exception.Create('AutenticateUserCSS - Empty');
            if ibS.FieldByName('rErrText').AsString<>'' then
              raise EBOBError.Create(ibS.FieldByName('rErrText').AsString);
            pUserID  := ibS.FieldByName('rWOCLCODE').AsInteger;
            UserCode := ibS.FieldByName('rWOCLCODE').AsString;
            UserLogin:= ibS.FieldByName('rWOCLLOGIN').AsString;
            UserPsw  := ibS.FieldByName('rWOCLPASSWORD').AsString;
            pResetPW := GetBoolGB(ibs, 'rWOCLRESETPASWORD');
            sid      := ibS.FieldByName('rWOCLSESSIONID').AsString;
            iBlock   := ibS.FieldByName('rBlock').AsInteger;
            ibS.Transaction.Commit;
            ibS.Close;
            break;
          except
            on E: EBOBError do raise EBOBError.Create(E.Message);
            on E: Exception do begin
              if ibS.Transaction.InTransaction then ibS.Transaction.RollbackRetaining;
              ibS.Close;
              if (Pos('lock', E.Message)>0) or ((Pos('Empty', E.Message)>0)) then begin
                if (i<RepeatCount) then Sleep(RepeatSaveInterval) // ждем немного
                else raise Exception.Create('try '+IntToStr(RepeatCount)+': '+CutLockMess(E.Message));
              end else raise Exception.Create(E.Message);
            end;
          end;
        finally
          prFreeIBSQL(ibS);
          cntsOrd.SetFreeCnt(ibDb);
        end;
        if not Assigned(Client) then begin
          Cache.TestClients(pUserID, true);
          if not Cache.ClientExist(pUserID) then
            raise EBOBError.Create(MessText(mtkNotClientExist, UserCode));
          Client:= Cache.arClientInfo[pUserID];
        end;
        Client.CS_client.Enter;
        try
          Client.LastBaseAutorize:= Now;
          Client.Login:= UserLogin;
          Client.Password:= UserPsw;
          Client.resetPW:= pResetPW;
          Client.BlockKind:= iBlock;
          Client.Sid:= sid;
        finally
          Client.CS_client.Leave;
        end;

if flLogTestClients then begin
    prMessageLOGS(nmProc+': BaseAutorize - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log
    LocStart:= now();
end;
      end // if flBaseAutorize
      else begin
        UserCode:= IntToStr(pUserID);
      end;
    finally
      if (pFirmID<1) and Assigned(Client) then pFirmID:= Client.FirmID;
      prSetThLogParams(ThreadData, command, pUserID, pFirmID, sParam); // логирование в ib_css
    end;
    Client.CS_client.Enter;
    try
      Client.LastAct:= Now;
    finally
      Client.CS_client.Leave;
    end;

//---------------------------------------------------------- проверка блокировки
    ss:= Client.CheckBlocked(True, True, cosByWeb);
    if Client.Blocked then raise EBOBError.Create(ss);

    firma:= Cache.arFirmInfo[pFirmID];
    if firma.Arhived or firma.Blocked then
      raise EBOBError.Create(MessText(mtkNotFirmProcess, firma.Name));
    if (firma.FirmContracts.Count<1) then
      raise EBOBError.Create('Не найдены контракты контрагента');

    if flBlockUber and firma.IsFinalClient then // блокировка работы конечных пользователей
      raise EBOBError.Create('Сервис временно недоступен. Попробуйте позже, пожалуйста.');

    Contract:= Client.GetCliContract(contID, True);

    FirmCode:= IntToStr(pFirmID);
    username:= fnCutFIO(Client.Name)+', '+firma.Name+' ('+firma.UPPERSHORTNAME+')'; // наименование фирмы
    usermail:= ExtractFictiveEmail(Client.Mail);      // Email должностного лица

    with Client do begin
      if Arhived then raise EBOBError.Create(MessText(mtkNotLoginProcess, Client.Login));
      if Blocked then raise EBOBError.Create(MessText(mtkBlockCountLogin, Client.Login));
    end;
//------------------------------------------------------------------ уведомления
    if flEnterByLogin then begin
      Notifics:= Cache.Notifications.GetFirmNotifications(pFirmID); // список уведомлений фирмы
      if (Notifics.Count>0) then begin
        ibDb:= cntsORD.GetFreeCnt;
        ss:= fnIntegerListToStr(Notifics); // строка с кодами уведомлений фирмы

if flLogTestClients then begin
    prMessageLOGS(nmProc+': Notifications - start', fLogDebug, false); // пишем в log
    LocStart:= now();
end;
        try
          ibS:= fnCreateNewIBSQL(ibDb, 'ibS_'+nmProc, ThreadData.ID, tpRead, true);
          ibS.SQL.Text:= 'Select noclnote from notifiedclients'+
            ' left join Notifications on NoteCODE=NoClNote'+
            ' where (NoClClient='+UserCode+') and (NoClNote in ('+ss+'))'+
            ' and (NoClViewTime is not null or (NoClShowTime is not null and'+
            ' (DATEADD(HOUR, NoteHourInterval, NoClShowTime)>current_timestamp)))';
          ibS.ExecQuery;
          while not ibs.Eof do begin // удаляем уведомления, с кот.ознакомлен или повторно показывать рано
            Notifics.Remove(ibS.FieldByName('noclnote').AsInteger);
            TestCssStopException;
            ibs.Next;
          end;
        finally
          prFreeIBSQL(ibS);
          cntsOrd.SetFreeCnt(ibDb);
        end;

if flLogTestClients then begin
    prMessageLOGS(nmProc+': Notifications - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log
    LocStart:= now();
end;
      end; // if (Notifics.Count>0)
    end // if flEnterByLogin
    else Notifics:= TIntegerList.Create; // на всяк.случай
//------------------------------------------------------------------------------

    Stream.Clear;
    Stream.WriteInt(aeSuccess);       // знак того, что запрос обработан корректно
    Stream.WriteInt(Client.ID);       // код пользователя
    Stream.WriteStr(Client.Login);    // логин пользователя
    Stream.WriteStr(Client.Password); // пароль пользователя на случай, если будет принудительный сброс
    Stream.WriteInt(Client.FirmID);   // код фирмы
    Stream.WriteStr(Client.Sid);      // id сессии
    Stream.WriteBool(Client.resetPW); // признак сброса пароля
    Stream.WriteInt(Cache.GetConstItem(pcClientTimeOutWeb).IntValue);
    Stream.WriteStr(username);        // наименование клиента и фирмы
    Stream.WriteStr(usermail);        // Email должностного лица

    Stream.WriteBool(firma.SUPERVISOR=pUserID); // Является ли пользователь супервизором
    if (firma.SUPERVISOR<>pUserID) then begin   // если не является, то передаем его права
      Stream.WriteBool(false); // WOCLRIGHTSENDORDER
      Stream.WriteBool(false); // WOCLRIGHTOWNPRICE
      Stream.WriteBool(false); // WOCLRIGHTVIEWDISCOUNTABLE
    end;

    Stream.WriteInt(ContID); // код контракта (если надо - измененный)

    if FullData then begin
      prof:= firma.GetFirmCredProfile(Contract.CredProfile);
      if not Assigned(prof) then prof:= ZeroCredProfile;

//      Stream.WriteDouble(Contract.CredLimit);
      Stream.WriteDouble(prof.ProfCredLimit);
      Stream.WriteDouble(Contract.DebtSum);

//      Stream.WriteDouble(Contract.OrderSum); // резерв по контракту
      Stream.WriteDouble(firma.AllOrderSum);  // общий резерв по к/а
      Stream.WriteDouble(firma.ResLimit);     // лимит резерва
      if (firma.ResLimit>0) then
        Stream.WriteDouble(firma.ResLimit-firma.AllOrderSum) // остаток лимита
      else Stream.WriteDouble(0);
// ResLimit<0 - ничего не делаем, >=0 дописываем к резерву через /,
// в подсказке на этой цифре "Лимит резерва (остаток/превышение - ...)"
      Stream.WriteDouble(Contract.PlanOutSum);
      i:= Contract.CredCurrency;
      Stream.WriteInt(i);
      Stream.WriteStr(Cache.GetCurrName(i, True));

      ss:= Contract.WarnMessage;
      if firma.SaleBlocked then begin
        fl:= True;
        ss:= 'Нарушены условия одного или более контрактов';
      end else if (Contract.Status=cstClosed) then begin
        fl:= True;
        if (ss='') then ss:= 'Контракт закрыт';
      end else begin
        fl:= Contract.SaleBlocked or prof.Blocked;
        if fl and (ss='') then ss:= prof.WarnMessage;
      end;

      Stream.WriteStr(ss);
      Stream.WriteBool(fl);
//      Stream.WriteInt(Contract.CredDelay);
      Stream.WriteInt(prof.ProfCredDelay);
      if not fl then Stream.WriteInt(Contract.WhenBlocked); // если отгрузка не блокирована

      Stream.WriteBool(firma.HasVINmail);
      ss:= '';
      if (firma.ActionText<>'') and
        (pos(cActionTextDelim, Cache.GetConstItem(pcCommonActionText).StrValue)>0) then
        ss:= StringReplace(Cache.GetConstItem(pcCommonActionText).StrValue,
             cActionTextDelim, firma.ActionText, []);
      Stream.WriteStr(ss); // общий текст акции + состояние участия в акции
      Stream.WriteDouble(Cache.DefCurrRate);
      Stream.WriteDouble(Cache.BonusVolumeCoeff);
      Stream.WriteDouble(Trunc(firma.BonusQty));
      Stream.WriteInt(Client.CliContracts.Count); // кол-во доступных контрактов
      Stream.WriteStr(Contract.Name);
      Stream.WriteStr(Contract.LegalFirmName); // юр.лицо
      if (Contract.Status=cstClosed) then Stream.WriteStr('')
      else Stream.WriteStr(Cache.GetDprtMainName(Contract.MainStorage));
      Stream.WriteStr(Cache.Currencies.GetItemName(Cache.BonusCrncCode)); // название валюты бонусов
      contBonusOrd:= firma.ContUnitOrd;
      if (contBonusOrd>0) and not Client.CheckContract(contBonusOrd) then contBonusOrd:= -1;
      Stream.WriteInt(contBonusOrd); // контракт UNIT-Заказа, <0 - недоступен
      Stream.WriteDouble(Trunc(firma.BonusRes)); // UNIT-резерв

//--------------------------------------------------------------- уровни оборота
      try
        SetLength(DirectParams, Cache.DiscountModels.ProdDirectList.Count); // Кол-во направлений
        for i:= 0 to High(DirectParams) do with DirectParams[i] do begin // 1- параметры направления
          Name:= Cache.DiscountModels.ProdDirectList[i]; // название направления
          j:= Integer(Cache.DiscountModels.ProdDirectList.Objects[i]);
          LevelCount:= Cache.DiscountModels.GetDirectModelsCount(j); // Кол-во уровней
          ProcToNext:= 0;
          FirmSales:= 0;
          FirmModel:= nil;
          NextModel:= nil;
        end;

        for i:= 0 to firma.FirmDiscModels.Count-1 do begin // 2- текущие параметры к/а
          tt:= TTwoCodes(firma.FirmDiscModels[i]);
          j:= Cache.DiscountModels.GetDirectIndex(tt.ID1); // индекс направления
          if (j>High(DirectParams)) then Continue;
          with DirectParams[j] do begin
            FirmModel:= Cache.DiscountModels[tt.ID2]; // текущий шаблон к/а
            FirmSales:= Round(tt.Qty);                // округл. текущий оборот к/а
          end;
        end;

        j:= -1;
        for i:= 0 to Cache.DiscountModels.DiscModels.Count-1 do begin // 3- ищем уровни, до которых к/а не дотягивает
          dm:= TDiscModel(Cache.DiscountModels.DiscModels[i]);
          if (j<>dm.DirectInd) then begin // смена направления
            j:= dm.DirectInd;
            iBlock:= 0;
          end;
          with DirectParams[j] do begin
            if Assigned(NextModel) then Continue         // пропускаем, если уже нашли
            else if ((FirmSales<0) and (dm.Sales=0)) then Continue // оборот<0 - пропускаем 1-й уровень
            else if (FirmSales>=dm.Sales) then begin
              iBlock:= dm.Sales; // запоминаем оборот шаблона
              Continue; // пропускаем уровни, до которых к/а уже дотянул
            end;
            NextModel:= dm; // шаблон уровня, до которого к/а не дотягивает
            if (FirmSales<0) then ProcToNext:= 100  // оборот<0 - Процент участка шкалы 100%
            else begin
              iBlock:= dm.Sales-iBlock; // Процент участка шкалы, которого не хватает до уровня, до которого к/а не дотягивает
              if (iBlock<>0) then ProcToNext:= Round((dm.Sales-FirmSales)*100/iBlock);
            end;
          end;
        end;
        //------------------------------------------------------- передача в CGI
        Stream.WriteInt(Length(DirectParams)); // Кол-во направлений
        for i:= 0 to High(DirectParams) do with DirectParams[i] do begin
          dm:= Cache.DiscountModels.EmptyModel;
          if not Assigned(FirmModel) then FirmModel:= dm;
          if not Assigned(NextModel) then NextModel:= dm;
          Stream.WriteStr(Name);             // название направления
          Stream.WriteInt(LevelCount);       // Кол-во уровней
          Stream.WriteInt(FirmModel.Rating); // Текущий уровень
          Stream.WriteInt(FirmModel.Sales);  // Показатель оборота текущего уровня
          Stream.WriteInt(NextModel.Rating); // Уровень, до которого к/а не дотягивает по обороту текущего месяца
          Stream.WriteInt(NextModel.Sales);  // Показатель оборота уровня, до которого к/а не дотягивает
          Stream.WriteInt(ProcToNext);       // Процент участка шкалы, которого не хватает до уровня, до которого к/а не дотягивает
          Stream.WriteInt(FirmSales);        // Показатель текущего оборота к/а
        end;
      finally
        SetLength(DirectParams, 0);
      end;
//--------------------------------------------------------------- уровни оборота
      Stream.WriteBool(Cache.GBAttributes.HasNewGroups); // признак наличия новых групп атрибутов
    end; // if FullData

    Stream.WriteDouble(Now);
    Stream.WriteStr(FirmCode);
//    Stream.WriteBool(Contract.SysID=constIsMoto); // признак Мото
//    Stream.WriteBool(false); // заглушка
    Stream.WriteBool(firma.IsFinalClient); // признак конечного клиента

    Stream.WriteInt(Notifics.Count); //----------------------------- уведомления
    for i:= 0 to Notifics.Count-1 do Stream.WriteInt(Notifics[i]);

  except
    on E: EBOBError do  // 'Ошибка авторизации. '
      prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка входа.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(Notifics);
end;
//*******************************************************************************
procedure prGetOptionsOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetOptionsOrd'; // имя процедуры/функции
var UserId, FirmID, i, j, ContID, ind, iCount, deliv, destID, ii: integer;
    Stores: Tasd;
//    Store: TStoreInfo;
    Client, cli: TClientInfo;
    firma: TFirmInfo;
    Contract: TContract;
    iList: TIntegerList;  // not Free
    errmess, destName, destAdr: String;
    grp: TWareInfo;
    cq: TCodeAndQty;
    fl: Boolean;
    dest: TDestPoint;
    lst: TStringList;
    fpp: TFirmPhoneParams;
begin
  Stream.Position:= 0;
  ContID:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetOptions, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    Client:= Cache.arClientInfo[UserID];
    if (contID<1) then contID:= Client.LastContract;
    firma:= Cache.arFirmInfo[FirmID];
    Contract:= firma.GetContract(contID);
//    iList:= EmptyIntegerList;
    if firma.IsFinalClient then begin
      deliv:= cDelivSelfGet;
      destID:= 0;
    end else with Client.GetCliContDefs(contID) do begin
      deliv:= ID1;
      destID:= ID2;
    end;
//----------------------------------------------------------- настройки и склады
    with Client do begin
      Stream.WriteByte(Contract.PayType);
      Stream.WriteByte(deliv);
      destName:= '';
      destAdr := '';
      if (destID>0) then begin
        dest:= Contract.GetContDestPoint(destID);
        if Assigned(dest) then begin
          destName:= dest.Name;
          destAdr := dest.Adress;
        end else destID:= 0;
      end;
      Stream.WriteInt(destID);  // торговая точка
      Stream.WriteStr(destName);
      Stream.WriteStr(destAdr);
      Stream.WriteBool(NOTREMINDCOMMENT);
      Stream.WriteInt(SearchCurrencyID);
      Stream.WriteStr(IntToStr(MaxRowShowAnalogs));
      Stream.WriteBool(DocsByCurrContr);
      SetLength(Stores, 0)
    end; // with Client
    prSendStorages(Stores, Stream);
    Stream.WriteBool(firma.EnablePriceLoad);
//---------------------------------------------------------- персональные данные
    with Client do begin
      Stream.WriteStr(Name);
      Stream.WriteStr(Post);
      Stream.WriteInt(CliPhones.Count); // Client.CliPhones
      for i:= 0 to CliPhones.Count-1 do Stream.WriteStr(CliPhones[i]);
      lst:= ExtractFictiveEmail(CliMails);
      try
        Stream.WriteInt(lst.Count);
        for i:= 0 to lst.Count-1 do Stream.WriteStr(lst[i]);
      finally
        prFree(lst);
      end;
      Stream.WriteBool(firma.SendInvoice); // признак рассылки накладных
    end; //  with Client

if flMargins then begin
//---------------------------------------------------------------------- наценки
    iCount:= 0;
    ind:= Stream.Position;
    Stream.WriteInt(iCount); // место под кол-во строк
    with Client.GetContMarginListAll(contID, False) do try
      for i:= 0 to Count-1 do begin
        cq:= Items[i];
        grp:= TWareInfo(Pointer(cq.ID));
        if not grp.IsGrp and not grp.IsPgr then Continue;
        if grp.IsGrp then Stream.WriteInt(0) else Stream.WriteInt(grp.PgrID); // 0     /группа
        Stream.WriteInt(grp.ID);                                             // группа/подгруппа
        Stream.WriteStr(grp.Name);                                           // наименование
        Stream.WriteDouble(cq.Qty);                                         // наценка
        inc(iCount);
//if flDebug then prMessageLOGS('группа '+fnMakeAddCharStr(gr.Name, 60, True)+' наценка '+FloatToStr(cq.Qty), fLogDebug, false); // debug
      end;
    finally
      Free;
    end;
    if (iCount>0) then begin
      Stream.Position:= ind;
      Stream.WriteInt(iCount); // кол-во строк
      Stream.Position:= Stream.Size;
    end;
end; // if flMargins

//-------------------------------------------------------- настройка SMS   begin
    if (Client.ID<>firma.SUPERVISOR) then // если не главный
      Stream.WriteInt(0)
    else if firma.IsFinalClient then      // если конечный покупатель
      Stream.WriteInt(0)
    else try
      lst:= TStringList.Create;
      iCount:= Cache.SMSmodelsList.Count; //----------- готовим список телефонов

      for i:= 0 to High(firma.FirmClients) do begin // сотрудники к/а
        deliv:= firma.FirmClients[i];
        if not Cache.ClientExist(deliv) then Continue;
        Cli:= Cache.arClientInfo[deliv];
        if Cli.Arhived or (Cli.CliPhones.Count<1) then Continue;

        destAdr:= Cli.Name+fnIfStr(Cli.Post<>'', ', ', '')+Cli.Post; // ФИО+должность сотрудника
        for ii:= 0 to Cli.CliPhones.Count-1 do begin
          destName:= Cli.CliPhones[ii]; // телефон

          if not CheckMobileNumber(destName) then Continue; // проверка мобильного номера телефона

          ind:= lst.IndexOf(destName);
          if (ind<0) then begin
            fpp:= TFirmPhoneParams.Create(destAdr, iCount);
            lst.AddObject(destName, fpp);
          end else begin
            fpp:= TFirmPhoneParams(lst.Objects[ind]);
            fpp.Names:= fpp.Names+fnIfStr(fpp.Names='', '', '; ')+destAdr;
          end;

          iList:= TIntegerList(Cli.CliPhones.Objects[ii]);
          for j:= 0 to Cache.SMSmodelsList.Count-1 do begin
            destID:= Integer(Cache.SMSmodelsList.Objects[j]);
            if (iList.IndexOf(destID)>-1) then Inc(fpp.arSMSind[j]);
          end;
        end; // for ii:= 0 to Cli.CliPhones.Count
      end; // for i:= 0 to High(firma.FirmClients)

                                           //-------------------------- передаем
      Stream.WriteInt(iCount); //-------- кол-во шаблонов SMS
      for j:= 0 to Cache.SMSmodelsList.Count-1 do begin
        destID:= Integer(Cache.SMSmodelsList.Objects[j]);
//        Stream.WriteInt(destID);                        // код шаблона SMS
        destName:= Cache.GetSMSmodelName(destID);
        Stream.WriteStr(destName); // название шаблона SMS
      end;

      Stream.WriteInt(lst.Count); //-------- кол-во телефонов
      for j:= 0 to lst.Count-1 do begin
        fpp:= TFirmPhoneParams(lst.Objects[j]);
        Stream.WriteStr(lst[j]);    // телефон
        Stream.WriteStr(fpp.Names); // список сотрудников
        for i:= 0 to High(fpp.arSMSind) do begin // флаги SMS по шаблонам
          fl:= (fpp.arSMSind[i]>0);
          Stream.WriteBool(fl);
        end;
      end; // for j:= 0 to lst.Count-1
    finally
      for i:= 0 to lst.Count-1 do begin
        fpp:= TFirmPhoneParams(lst.Objects[i]);
        prFree(fpp);
      end;
      prFree(lst);
    end;
//---------------------------------------------------------- настройка SMS   end

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(Stores, 0);
  Stream.Position:= 0;
end;
//============================================ изменить видимость склада клиента
procedure prChangeVisibilityOfStorage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prChangeVisibilityOfStorage'; // имя процедуры/функции
var {IBD: TIBDatabase;
    IBS: TIBSQL;
    UserID, FirmID, i, j, index, contID, StoreID, opt: integer;
    StoreCode, Visibility, errmess: string; }
    Storages: Tasd;
{    Contract: TContract;
    Client: TClientInfo;
    CliStores: TIntegerList;  // not Free  }
begin
  Stream.Position:= 0;
  SetLength(Storages, 0);
//  IBS:= nil;
//  contID:= 0;
//  opt:= 0;
  try
{    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
//    ContID:= Stream.ReadInt; // для контрактов - здесь не нужен
    StoreCode:= Stream.ReadStr;
    Visibility:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csChangeVisibilityOfStorage, UserID, FirmID, 'StoreCode='+StoreCode+' Visibility='+Visibility); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    StoreID:= StrToIntDef(StoreCode, 0);
    Client:= Cache.arClientInfo[UserID];
                               // Проверяем, доступен ли вообще этот склад
    Contract:= Cache.arFirmInfo[FirmID].GetContract(contID);
    if (Client.CliContracts.IndexOf(contID)<0) then raise EBOBError.Create('Контракт не найден');

    index:= Contract.GetСontStoreIndex(StoreID);
    if (index<0) then raise EBOBError.Create('Склад не найден');
    if (Visibility='false') and Contract.ContStorages[index].IsReserve then
      raise EBOBError.Create('Склад, доступный для резервирования, нельзя сделать невидимым');

    index:= Client.GetCliStoreIndex(contID, StoreID);
    If (Visibility='false') then begin
      if (index>-1) then opt:= 1000;
    end else If (index<0) then opt:= 100;

    if (opt>0) then begin
      IBD:= cntsORD.GetFreeCnt;
      try
        IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpWrite, true);
        IBS.SQL.Text:= 'execute procedure ChangeCliContrStoreOrder('+
          IntToStr(UserID)+', '+IntToStr(contID)+', '+IntToStr(StoreID)+', '+IntToStr(opt)+')';
        IBS.ExecQuery;
        IBS.Transaction.Commit;
        IBS.Close;
      finally
        prFreeIBSQL(IBS);
        cntsORD.SetFreeCnt(IBD);
      end;
      If (opt=1000) then Client.DelCliStoreCode(contID, StoreID)
      else If (opt=100) then Client.AddCliStoreCode(contID, StoreID);
    end;

    //------------------------------------- тупо формируем наново все и передаем
    // сначала загоняем те склады, которые юзер обозначил как видимые
    CliStores:= Client.GetContStoreCodes(contID);
    SetLength(Storages, CliStores.Count);
    for i:= 0 to CliStores.Count-1 do begin
      StoreID:= CliStores[i];
      Storages[i].Code:= IntToStr(StoreID);
      Storages[i].FullName:= Cache.GetDprtMainName(StoreID);
      Storages[i].IsVisible:= true;
      index:= Contract.GetСontStoreIndex(StoreID);
      Storages[i].IsReserve:= Contract.ContStorages[index].IsReserve;
    end;
    // потом все остальные
    if (Length(Contract.ContStorages)>CliStores.Count) then
      for i:= 0 to High(Contract.ContStorages) do begin
        StoreID:= Contract.ContStorages[i].DprtID;
        if (CliStores.IndexOf(StoreID)>-1) then Continue;
        j:= Length(Storages);
        SetLength(Storages, j+1);
        Storages[j].Code:= IntToStr(StoreID);
        Storages[j].FullName:= Cache.GetDprtMainName(StoreID);
        Storages[j].IsVisible:= false;
        Storages[j].IsReserve:= Contract.ContStorages[i].IsReserve;
      end;
}
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    prSendStorages(Storages, Stream);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(Storages, 0);
  Stream.Position:= 0;
end;
//======================= Передвинуть склад в списке видимости клиента выше/ниже
procedure prClientsStoreMove(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prClientsStoreMove'; // имя процедуры/функции
var {IBD: TIBDatabase;
    IBS: TIBSQL;
    UserID, FirmID, i, j, jj, index, contID, StoreID, opt: integer;
    StoreCode, Direct, errmess: string; }
    Storages: Tasd;
{    Contract: TContract;
    Client: TClientInfo;
    CliStores: TIntegerList;  // not Free    }
begin
  Stream.Position:= 0;
  SetLength(Storages, 0);
//  IBS:= nil;
//  contID:= 0;
//  opt:= 0;
  try
{    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
//    ContID:= Stream.ReadInt; // для контрактов - здесь не нужен
    StoreCode:= Stream.ReadStr;
    Direct:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csClientsStoreMove, UserID, FirmID, 'StoreCode='+StoreCode+' Direct='+Direct); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    StoreID:= StrToIntDef(StoreCode, 0);
    Client:= Cache.arClientInfo[UserID];

    Contract:= Cache.arFirmInfo[FirmID].GetContract(contID);
    if (Client.CliContracts.IndexOf(contID)<0) then raise EBOBError.Create('Контракт не найден');

    // Проверяем, доступен ли вообще этот склад
    index:= Contract.GetСontStoreIndex(StoreID);
    if (index<0) then raise EBOBError.Create('Склад не найден');

    CliStores:= Client.GetContStoreCodes(contID);
    index:= CliStores.IndexOf(StoreID);
    if (index<0) then raise EBOBError.Create('Склад не найден');

    If (Direct='up') then begin
      if (index>0) then opt:= -1;
    end else If (index<(CliStores.Count-1)) then opt:= 1;

    if (opt<>0) then begin
      IBD:= cntsORD.GetFreeCnt;
      try
        IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpWrite, true);
        IBS.SQL.Text:= 'execute procedure ChangeCliContrStoreOrder('+
          IntToStr(UserID)+', '+IntToStr(contID)+', '+IntToStr(StoreID)+', '+IntToStr(opt)+')';
        IBS.ExecQuery;
        IBS.Transaction.Commit;
        IBS.Close;
      finally
        prFreeIBSQL(IBS);
        cntsORD.SetFreeCnt(IBD);
      end;
      j:= index+opt;
      jj:= CliStores[j];
      Client.CS_client.Enter;
      try
        CliStores[j]:= StoreID;
        CliStores[index]:= jj;
      finally
        Client.CS_client.Leave;
      end;
    end;

    //------------------------------------- тупо формируем наново все и передаем
    // сначала загоняем те склады, которые юзер обозначил как видимые
    CliStores:= Client.GetContStoreCodes(contID);
    SetLength(Storages, CliStores.Count);
    for i:= 0 to CliStores.Count-1 do begin
      StoreID:= CliStores[i];
      Storages[i].Code:= IntToStr(StoreID);
      Storages[i].FullName:= Cache.GetDprtMainName(StoreID);
      Storages[i].IsVisible:= true;
      index:= Contract.GetСontStoreIndex(StoreID);
      Storages[i].IsReserve:= Contract.ContStorages[index].IsReserve;
    end;
    // потом все остальные
    if (Length(Contract.ContStorages)>CliStores.Count) then
      for i:= 0 to High(Contract.ContStorages) do begin
        StoreID:= Contract.ContStorages[i].DprtID;
        if (CliStores.IndexOf(StoreID)>-1) then Continue;
        j:= Length(Storages);
        SetLength(Storages, j+1);
        Storages[j].Code:= IntToStr(StoreID);
        Storages[j].FullName:= Cache.GetDprtMainName(StoreID);
        Storages[j].IsVisible:= false;
        Storages[j].IsReserve:= Contract.ContStorages[i].IsReserve;
      end;
}
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    prSendStorages(Storages, Stream);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(Storages, 0);
  Stream.Position:= 0;
end;
//========================== изменить последний контракт клиента/контракт заказа
procedure prChangeClientLastContract(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prChangeClientLastContract'; // имя процедуры/функции
var UserID, FirmID, contID, contIdNew, OrderID: integer;
    errmess: String;
begin
  Stream.Position:= 0;
  errmess:= '';
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    OrderID:= Stream.ReadInt; //

    prSetThLogParams(ThreadData, csChangeContract, UserID, FirmID,
      'ContID='+IntToStr(ContID)+#13#10'OrderID='+IntToStr(OrderID)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if (OrderID=0) then
      errmess:= Cache.arClientInfo[UserID].SetLastContract(contID)
    else begin
      contIdNew:= ContID;
      Cache.arClientInfo[UserID].GetCliContract(contIdNew);
      if (contIdNew=contId) then
        prChangeOrderContract(FirmId, contID, OrderID, ThreadData)
      else errmess:= 'Контракт не соответствует заказу.';
    end;
    if (errmess<>'') then raise EBOBError.Create(errmess);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//================================== изменить контракт заказа и пересчитать цены
procedure prChangeOrderContract(FirmID, ContID, OrderID: integer; ThreadData: TThreadData);
const nmProc = 'prChangeOrderContract'; // имя процедуры/функции
// корректность FirmID, ContID проверяется до вызова !!!
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    lst: TStringList;
    curr, i: Integer;
    exlines: Boolean;
    CurrPrice: Double;
    s: String;
    ware: TWareInfo;
begin
  OrdIBS:=  nil;
  OrdIBD:= nil;
  lst:= TStringList.Create;
  try

    OrdIBD:= cntsOrd.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, true);
    OrdIBS.SQL.Text:= 'select ORDRCONTRACT, ORDRFIRM, ORDRSTATUS, ORDRCURRENCY,'+
      ' iif(exists(select * from ORDERSLINES where ORDRLNORDER=ORDRCODE), 1, 0) ex'+
      ' from ORDERSREESTR where ORDRCODE='+IntToStr(OrderID);
    OrdIBS.ExecQuery;
    if (OrdIBS.Eof and OrdIBS.Bof) then
      raise EBOBError.Create(MessText(mtkNotFoundOrder, IntToStr(OrderID)))
    else if (OrdIBS.fieldByName('ORDRFIRM').AsInteger<>FirmID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' контрагента')
    else if (OrdIBS.fieldByName('ORDRSTATUS').AsInteger<>orstForming) then
      raise EBOBError.Create(MessText(mtkOnlyFormingOrd))
    else  // if (ContID<1) then ContID:= Cache.arClientInfo[UserID].GetCliCurrContID;
    if (OrdIBS.fieldByName('ORDRCONTRACT').AsInteger=ContID) then Exit;

    curr:= OrdIBS.fieldByName('ORDRCURRENCY').AsInteger;
    exlines:= (OrdIBS.fieldByName('ex').AsInteger=1); // признак наличия товаров в заказе
    OrdIBS.Close;

    if exlines then begin
      OrdIBS.SQL.Text:= 'select ORDRLNCODE, ORDRLNWARE, ORDRLNPRICE'+
                        ' from ORDERSLINES where ORDRLNORDER='+IntToStr(OrderID);
      OrdIBS.ExecQuery;
      while not OrdIBS.EOF do begin
        ware:= Cache.GetWare(OrdIBS.FieldByName('ORDRLNWARE').AsInteger);

        CurrPrice:= ware.SellingPrice(FirmID, curr, contID);
        if fnNotZero(OrdIBS.FieldByName('ORDRLNPRICE').AsFloat-CurrPrice) then
          lst.Add('UPDATE ORDERSLINES set ORDRLNPRICE='+ // строки для пересчета цен
            StringReplace(FloatToStr(CurrPrice), ',', '.', [rfReplaceAll])+
            ' where ORDRLNCODE='+OrdIBS.FieldByName('ORDRLNCODE').AsString+';');
        TestCssStopException;
        OrdIBS.Next;
      end;
      OrdIBS.Close;
    end; // if exlines

    i:= lst.Count;
    lst.Insert(0, 'execute block as begin');
    lst.Add('update ORDERSREESTR set ORDRCONTRACT='+IntToStr(ContID)+
      fnIfStr(i>0, ', ORDRRECALCTIME="NOW"', '')+
      ' where ORDRCODE='+IntToStr(OrderID)+'; end');

    OrdIBS.SQL.Clear;
    fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
    OrdIBS.SQL.AddStrings(lst);
    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(nmProc+': '+s);
  finally
    prFreeIBSQL(OrdIBS);
    cntsOrd.SetFreeCnt(OrdIBD);
    prFree(lst);
  end;
end;
//****************** Устанавливаются параметры заказа по умолчанию пользователем
procedure prSetOrderDefaultOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSetOrderDefaultOrd'; // имя процедуры/функции
var OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
    UserId, FirmID, iAnaRows: integer;
    paytype, reserv, AnaRows, NotRemind, SearchCurr, Semafor, s: string;
begin
  OrdIBS:= nil;
  OrdIBD:= nil;
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    paytype:= Stream.ReadStr;  // заглушка
    reserv:= Stream.ReadStr;
    NotRemind:= Stream.ReadStr;
    SearchCurr:= Stream.ReadStr;
    AnaRows:= trim(Stream.ReadStr);
    Semafor:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csSetOrderDefault, UserID, FirmID,
      'paytype='+paytype+#13#10'reserv='+reserv+#13#10'NotRemind='+NotRemind+
      #13#10'SearchCurr='+SearchCurr+#13#10'AnaRows='+AnaRows); // логирование

    iAnaRows:= StrToIntDef(AnaRows, -1);
    if (iAnaRows<0) then
      raise EBOBError.Create('Количество строк должно быть целым числом.');

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, true);
    OrdIBS.SQL.Text:= 'UPDATE WEBORDERCLIENTS SET WOCLNOTREMINDCOMMENT=:s'+
      ', WOCLSEARCHCURRENCY='+fnIfStr(SearchCurr='1', SearchCurr, cStrDefCurrCode)+
      ', WOCLDEFAULTDELIVERYTYPE='+fnIfStr(reserv='1', '1', '0')+
      ', WOCLMAXROWFORSHOWANALOGS='+AnaRows+
      ', WOCLWARERESTSEMAFOR=:semafor '+
      ' where WOCLCODE='+IntToStr(UserID);
    OrdIBS.ParamByName('s').AsString:= fnIfStr(NotRemind='on', 'T', 'F');
    OrdIBS.ParamByName('semafor').AsString:= fnIfStr(Semafor='on', 'T', 'F');
    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(s);
    with Cache.arClientInfo[UserID] do begin
      MaxRowShowAnalogs:= iAnaRows;
      SearchCurrencyId:= StrToInt(SearchCurr);
      NOTREMINDCOMMENT:= (NotRemind='on');
      DEFDELIVERYTYPE:= StrToIntDef(reserv, 0);
      WareSemafor:= (Semafor='on');
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(OrdIBS), 'OrdIBS.SQL.Text='+OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end;
//************************************************ Меняется пароль пользователем
procedure prChangePasswordOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prChangePasswordOrd'; // имя процедуры/функции
var OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
    UserId, FirmID, i: integer;
    oldpass, newpass1, newpass2, s, ss: string;
begin
  OrdIBS:= nil;
  OrdIBD:= nil;
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    oldpass:= Stream.ReadStr;
    newpass1:= Stream.ReadStr;
    newpass2:= Stream.ReadStr;
                                     // csChangePass   ???
    prSetThLogParams(ThreadData, csChangePassword, UserID, FirmID,
      'oldpass='+oldpass+#13#10'newpass1='+newpass1+#13#10'newpass2='+newpass2); // логирование

    if (newpass1=oldpass) then
      raise EBOBError.Create('Новый пароль не должен совпадать со старым.');
    i:= Cache.CliPasswLength;
    if not fnCheckOrderWebPassword(newpass1) then
      raise EBOBError.Create(MessText(mtkNotValidPassw, IntToStr(i)));
    if (newpass1<>newpass2) then
      raise EBOBError.Create('Новый пароль и его повтор не совпадают.');
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    with Cache.arClientInfo[UserId] do begin
      if (newpass1=Login) then
        raise EBOBError.Create('Пароль не должен совпадать с логином.');
      if (Password<>oldpass) then
        raise EBOBError.Create('Старый пароль указан неверно.');

      OrdIBD:= cntsORD.GetFreeCnt;
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, true);
      OrdIBS.SQL.Text:= 'select rErrText from SetUserPassword('+IntToStr(UserID)+', :p, 0, 0)';
      OrdIBS.ParamByName('p').AsString:= newpass1;
      s:= RepeatExecuteIBSQL(OrdIBS, 'rErrText', ss);
      if s<>'' then raise Exception.Create(s);
      if ss<>'' then raise EBOBError.Create(ss);
      Password:= newpass1;
    end; // with Cache.arClientInfo[UserId]
    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr('Ваш пароль успешно изменен.');
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(OrdIBS), 'OrdIBS.SQL.Text='+OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end; 
//*******************************************************************************
procedure prWebSetMainUserOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebSetMainUserOrd'; // имя процедуры/функции
var OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
    UserId, FirmID, inewcode: integer;
    newcode, s, CliMail: string;
    Client: TClientInfo;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    newcode:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csWebSetMainUser, UserID, FirmID, 'newcode='+newcode); // логирование

    inewcode:= StrToIntDef(newcode, -1);
    if (inewcode<0) then raise EBOBError.Create(MessText(mtkErrorUserID));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    if (Cache.arFirmInfo[FirmId].SUPERVISOR<>UserId) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if not Cache.ClientExist(inewcode) then
      raise EBOBError.Create(MessText(mtkNotClientExist));

    Client:= Cache.arClientInfo[inewcode];
    if (Client.FirmID<>FirmId) then raise EBOBError.Create(MessText(mtkNotClientOfFirm));
    if (Client.Login='') then raise EBOBError.Create('не найдена учетная запись пользователя.');
    if (Client.Name='') then raise EBOBError.Create('Не задано имя пользователя.');
//    if (Client.Post='') then raise EBOBError.Create('Не задана должность пользователя.');
    CliMail:= ExtractFictiveEmail(Client.Mail);
    if (CliMail='') then raise EBOBError.Create('Не задан E-mail пользователя.');
    if not fnCheckEmail(CliMail) then raise EBOBError.Create('Некорректный E-mail пользователя - '+CliMail);

    OrdIBD:= cntsORD.GetFreeCnt;

    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, true);
    OrdIBS.SQL.Text:= 'UPDATE WEBORDERFIRMS SET WOFRSUPERVISOR='+newcode+
                          ' WHERE WOFRCODE='+IntToStr(FirmID);
    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(s);
    Cache.arFirmInfo[FirmId].SUPERVISOR:= inewcode;

    s:= SetMainUserToGB(FirmID, inewcode, Date()); // запись в Grossbee
    if (s<>'') then prMessageLOGS(nmProc+': '+s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(OrdIBS), 'OrdIBS.SQL.Text='+OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end; 
//*******************************************************************************
procedure prWebResetPasswordOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebResetPasswordOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, inewcode: integer;
    newpass, newcode, s: string;
    Client: TClientInfo;
    FnamesValues: Tas;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  SetLength(FnamesValues, 2);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    newcode:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csWebResetPassword, UserID, FirmID, 'newcode='+newcode); // логирование

    inewcode:= StrToIntDef(newcode, -1);
    if (inewcode<0) then raise EBOBError.Create(MessText(mtkErrorUserID));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    if (Cache.arFirmInfo[FirmId].SUPERVISOR<>UserId) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.ClientExist(inewcode) then
      raise EBOBError.Create(MessText(mtkNotClientExist));

    Client:= Cache.arClientInfo[inewcode];
    if (Client.FirmID<>FirmId) or (Client.Login=''){ or (Client.Post='')} then
      raise EBOBError.Create(MessText(mtkNotClientOfFirm));

    OrdIBD:= cntsORD.GetFreeCnt;

    FnamesValues[0]:= 'rPassword';
    FnamesValues[1]:= 'rErrText';
//    FnamesValues:= ('rPassword', 'rErrText');

    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, True);
    OrdIBS.SQL.Text:= 'select rPassword, rErrText from SetUserPassword('+newcode+', :p, 1, 0)';
    OrdIBS.ParamByName('p').AsString:= '';
    s:= RepeatExecuteIBSQL(OrdIBS, FnamesValues);
    if (s<>'') then raise Exception.Create(s);
    s:= FnamesValues[1];
    if (s<>'') then raise EBOBError.Create(s);
    newpass:= FnamesValues[0];
    Client.Password:= newpass;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(newpass);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(OrdIBS), 'OrdIBS.SQL.Text='+OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  SetLength(FnamesValues, 0);
  Stream.Position:= 0;
end; 
//******************************************************* Создается пользователь
procedure prWebCreateUserOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebCreateUserOrd'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    UserId, FirmID, inewcode: integer;
    newpass, newlogin, newcode, s, CliMail: string;
    Client: TClientInfo;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  IBS:= nil;
  IBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    newcode:= Stream.ReadStr;
    newlogin:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csWebCreateUser, UserID, FirmID,
      'newcode='+newcode+#13#10'newlogin='+newlogin); // логирование

    inewcode:= StrToIntDef(newcode, -1);
    if (inewcode<0) then raise EBOBError.Create(MessText(mtkErrorUserID));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    firma:= Cache.arFirmInfo[FirmId];
    if (firma.SUPERVISOR<>UserId) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.ClientExist(inewcode)then
      raise EBOBError.Create(MessText(mtkNotClientOfFirm));

    Client:= Cache.arClientInfo[inewcode];
    if (Client.FirmID<>FirmId) then raise EBOBError.Create(MessText(mtkNotClientOfFirm));
    if (Client.Login<>'') then
      raise EBOBError.Create('Пользователь уже имеет учетную запись в системе.');

    if (Client.Name='') then raise EBOBError.Create('Не задано имя пользователя.');
//    if (Client.Post='') then raise EBOBError.Create('Не задана должность пользователя.');
    s:= CheckClientFIO(Client.Name); // проверка соответствия ФИО пользователя шаблону
    if (s<>'') then raise EBOBError.Create(s);

    CliMail:= ExtractFictiveEmail(Client.Mail);
    if (CliMail='') then raise EBOBError.Create('Не задан E-mail пользователя.');
    if not fnCheckEmail(CliMail) then
      raise EBOBError.Create('Некорректный E-mail пользователя - '+CliMail);

    if (newLogin='') or not fnCheckOrderWebLogin(newLogin) then
      raise EBOBError.Create(MessText(mtkNotValidLogin, IntToStr(Cache.CliLoginLength)));
    if not fnNotLockingLogin(newlogin) then // проверяем, не относится ли логин к запрещенным
      raise EBOBError.Create(MessText(mtkLockingLogin, newLogin));
    try
      IBD:= cntsORD.GetFreeCnt;
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpWrite, True);
      IBS.SQL.Text:= 'select rPassword, rErrText from AddNewWebClientU('+
                         newCode+', '+IntToStr(FirmID)+', :login, 0, 0)'; // 4-й парам.=0 - обычный пользователь
      IBS.ParamByName('login').AsString:= newlogin;
      IBS.ExecQuery;
      if not (IBS.Bof and IBS.Eof) and (IBS.FieldByName('rErrText').AsString<>'') then
        raise EBOBError.Create(IBS.FieldByName('rErrText').AsString);
      newpass:= IBS.FieldByName('rPassword').AsString;
      IBS.Transaction.Commit;
      IBS.Close;
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD);
    end;
    try
      IBD:= cntsGRB.GetFreeCnt;
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpWrite, True);
      IBS.SQL.Text:= 'UPDATE PERSONS SET PRSNLOGIN=:login WHERE PRSNCODE='+newCode;
      IBS.ParamByName('login').AsString:= newlogin;
      IBS.ExecQuery;
      if IBS.Transaction.InTransaction then IBS.Transaction.Commit;
    finally
      prFreeIBSQL(IBS);
      cntsGRB.SetFreeCnt(IBD);
    end;
    Cache.TestClients(UserId, True, False);

    s:= prSendMailWithClientPassw(kcmCreateUser, Client.Login, Client.Password, CliMail, ThreadData);
    if (s<>'') then raise EBOBError.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);   // знак того, что запрос обработан корректно
    Stream.WriteStr(Client.Post); // должность

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(IBS), 'IBS.SQL.Text='+IBS.SQL.Text, ''), False);
  end;
  Stream.Position:= 0;
end;
//============================================= Запрашивается доступность логина
procedure prCheckLoginOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// возвращает текстовое сообщение о валидности или доступности логина
const nmProc = 'prCheckLoginOrd'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    Login: string;
begin
  Stream.Position:= 0;
  IBS:= nil;
  IBD:= nil;
  try
    Login:= Stream.ReadStr;
    prSetThLogParams(ThreadData, csCheckLogin, 0, 0, 'Login='+Login); // логирование

    if not fnCheckOrderWebLogin(Login) then
      raise EBOBError.Create(MessText(mtkNotValidLogin, IntToStr(Cache.CliLoginLength)));
    if not fnNotLockingLogin(Login) then // проверяем, не относится ли логин к запрещенным
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));

    IBD:= cntsORD.GetFreeCnt; // проверяем, не относится ли логин к уже сущетвующим
    IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, True);
    IBS.SQL.Text:= 'Select WOCLCODE from WEBORDERCLIENTS where WOCLUPPERLOGIN=:Login';
    IBS.ParamByName('login').AsString:= UpperCase(Login);
    IBS.ExecQuery;
    if not (IBS.Bof and IBS.Eof) then
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));
    IBS.Close;
    
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr('Логин `'+Login+'` доступен для использования.');
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(IBS), 'IBS.SQL.Text='+IBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(IBS);
  cntsORD.SetFreeCnt(IBD);
  Stream.Position:= 0;
end; 
//*******************************************************************************
procedure prCreateNewOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCreateNewOrderOrd'; // имя процедуры/функции/потока
var NewOrderID, UserId, FirmID, ContID: integer;
    ErrorMessage: string;
begin
  Stream.Position:= 0;
  ContID:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов

    prSetThLogParams(ThreadData, csCreateNewOrder, UserID, FirmID, 'ContID='+IntToStr(ContID)); // логирование

    prCreateNewOrderCommonOrd(UserId, FirmID, NewOrderID, ContID, ErrorMessage, ThreadData.ID);
    if ErrorMessage<>'' then raise EBOBError.Create(ErrorMessage);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteInt(NewOrderID);
    Stream.WriteInt(ContID);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;  // prCreateNewOrderOrd
//*******************************************************************************
procedure prCreateOrderByMarkedOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCreateOrderByMarkedOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, OrderID, WareID, CurrencyID, ContID{, SysID}: integer;
    s, ErrorMessage, OrderCode, DivisibleMess, sStore, sWare, sPrice, sQty: string;
    Ware: TWareInfo;
    Qty: Double;
    Client: TClientInfo;
    Contract: TContract;
    lst: TStringList;
begin
  Stream.Position:= 0;
  OrdIBD:= nil;
  OrdIBS:= nil;
  DivisibleMess:= '';
  ContID:= 0;
  try
    lst:= TStringList.Create;
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    s:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csCreateOrderByMarked, UserID, FirmID,
      'Orders='+s+#13#10'ContID='+IntToStr(ContID)); // логирование

    if s='' then  raise EBOBError.Create(MessText(mtkNotFoundOrders));
    if CheckNotValidUser(UserID, FirmID, ErrorMessage) then raise EBOBError.Create(ErrorMessage);
//    if not Cache.ClientExist(UserID) then raise EBOBError.Create(MessText(mtkNotClientExist));
    ErrorMessage:= '';

    Client:= Cache.arClientInfo[UserID];
    Contract:= Client.GetCliContract(ContID);
    if (Contract.Status=cstClosed) then         // проверка на доступность контракта
      raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');
//    SysID:= Contract.SysID;
    sStore:= IntToStr(Contract.MainStorage);

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);

    prCreateNewOrderCommonOrd(UserId, FirmID, OrderID, ContID, ErrorMessage, ThreadData.ID, OrdIBS);
    if (ErrorMessage<>'') then raise EBOBError.Create(ErrorMessage);
    if (OrderID<1) then raise Exception.Create('NewOrderID<1');

    OrderCode:= IntToStr(OrderID);

    if (contID>0) then CurrencyID:= Cache.Contracts[contID].DutyCurrency
    else CurrencyID:= Client.SearchCurrencyID;

    lst.Add('execute block as declare variable xCode integer; begin');

    with OrdIBS.Transaction do if not InTransaction then StartTransaction;
    OrdIBS.SQL.Text:= 'select sum(ORDRLNCLIENTQTY) qty, ORDRLNWARE'+
      ' from ORDERSREESTR left join ORDERSLINES on ORDRLNORDER=ORDRCODE'+
      ' where ORDRFIRM='+IntToStr(FirmID)+  // ' AND ORDRSTATUS='+IntToSTr(orstForming)+
      ' and ORDRCODE in ('+s+') and ORDRCURRENCY<>'+IntToStr(Cache.BonusCrncCode)+ // пропускаем бонусные заказы
      ' and ORDRLNCLIENTQTY>0 group by ORDRLNWARE order by ORDRLNWARE';
    OrdIBS.ExecQuery;
    while not OrdIBS.EOF do begin
      WareID:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger;
      Ware:= Cache.GetWare(WareID, True);
      if not Assigned(Ware) or (Ware=NoWare) then
        raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));

      sWare:= OrdIBS.FieldByName('ORDRLNWARE').AsString;
      Qty:= Ware.SellingPrice(FirmID, CurrencyID, contID);
      sPrice:= StringReplace(FloatToStr(Qty), ',', '.', [rfReplaceAll]);
      Qty:= OrdIBS.FieldByName('qty').AsFloat;
      s:= fnRecaclQtyByDivisible(WareID, Qty); // проверяем кратность
      if s<>'' then DivisibleMess:= DivisibleMess+fnIfStr(DivisibleMess='','',#13#10)+s;
      sQty:= StringReplace(FloatToStr(Qty), ',', '.', [rfReplaceAll]);

      lst.Add('select rNewOrderLnCode from AddOrderLineQty('+OrderCode+', '+
        sWare+', 0, '+IntToStr(Ware.measID)+', '+sPrice+', 0, 0) into :xCode;');
      lst.Add('if (xCode is null or xCode<1) then exception NotCorrect "Ошибка записи строки";');
      lst.Add('EXECUTE PROCEDURE AEWareByStorages('+OrderCode+', '+sWare+', '+sStore+', '+sQty+');');

      TestCssStopException;
      OrdIBS.Next;
    end;
    OrdIBS.Close;
    lst.Add(' end');

    OrdIBS.SQL.Clear;
    OrdIBS.ParamCheck:= False;
    fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
    OrdIBS.SQL.AddStrings(lst);
    sQty:= RepeatExecuteIBSQL(OrdIBS);
    if (sQty<>'') then raise Exception.Create(sQty);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteInt(OrderID);
    Stream.WriteInt(ContID);
    if DivisibleMess<>'' then
      DivisibleMess:= 'В некоторых товарах количество пересчитано по кратности отпуска.';
    Stream.WriteStr(DivisibleMess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(Assigned(OrdIBS), 'OrdIBS.SQL.Text='+OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  prFree(lst);
  Stream.Position:= 0;
end; 
//*******************************************************************************
procedure prJoinMarkedOrdersOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prJoinMarkedOrdersOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    FirmID, UserID, i, j: integer;
    s, ErrorMessage: string;
    codes: Tai;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  setLength(codes, 100);
  try
    UserID:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    Stream.ReadInt;       // ContID
    s:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csJoinMarkedOrders, UserID, FirmID, 'Orders='+s); // логирование

    if s='' then  raise EBOBError.Create(MessText(mtkNotFoundOrders));
    if CheckNotValidUser(UserID, FirmID, ErrorMessage) then raise EBOBError.Create(ErrorMessage);

    OrdIBD:= cntsORD.GetFreeCnt;
    try
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
      OrdIBS.SQL.Text:= 'select ORDRCODE, ORDRSTATUS FROM ORDERSREESTR'+
        ' WHERE ORDRFIRM='+IntToStr(FirmID)+' and ORDRCODE in ('+s+')'+
        ' and ORDRCURRENCY<>'+IntToStr(Cache.BonusCrncCode); // пропускаем бонусные заказы
      OrdIBS.ExecQuery;
      j:= 0; // счетчик
      while not OrdIBS.Eof do begin
        if (OrdIBS.FieldByName('ORDRSTATUS').AsInteger<>orstForming) then
          raise EBOBError.Create(MessText(mtkOnlyFormingOrd));
        i:= OrdIBS.FieldByName('ORDRCODE').AsInteger;
        if Length(codes)<(i+1) then setLength(codes, i+100);
        codes[j]:= i;
        inc(j);
        TestCssStopException;
        OrdIBS.Next;
      end;
      OrdIBS.Close;

      Stream.Position:= 0;
      prCreateOrderByMarkedOrd(Stream, ThreadData);

      Stream.Position:= 0;
      if Stream.ReadInt=aeSuccess then begin
        if (j<1) then Exit;

        fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
        OrdIBS.SQL.Text:= 'execute procedure DelOrder(:CODE)';
        OrdIBS.Prepare;
        for i:= 0 to j-1 do try
          with OrdIBS.Transaction do if not InTransaction then StartTransaction;
          OrdIBS.ParamByName('CODE').AsInteger:= codes[i];
          OrdIBS.ExecQuery;
          OrdIBS.Close;
          OrdIBS.Transaction.Commit;
        except
          on E: Exception do fnWriteToLog(ThreadData, lgmsSysError, nmProc,
            'can not delete order '+IntToStr(codes[i]), E.Message, '');
        end;
      end;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  setLength(codes, 0);
  Stream.Position:= 0;
end;
//======================================= Получить список неотправленных заказов
procedure prGetFormingOrdersList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFormingOrdersList'; // имя процедуры/функции
type RorderOpts = record
  ordID, contID, currID: Integer;
  contName, ordNum, comm, strDate, strSum, OverMess: String;
end;
var i, ii, UserId, FirmID, iCount, WareCount: integer;
    s, sMess, OverMessAll: string;
    OrdIBS, ibs: TIBSQL;
    OrdIBD, ibd: TIBDatabase;
    Client: TClientInfo;
    Contract: TContract;
    fl, flResLimit{, flCheckRes}: Boolean;
    arOpts: array of RorderOpts;
    sum: Double;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  IBS:= nil;
  IBD:= nil;
  Contract:= nil;
  SetLength(arOpts, FormingOrdersLimit);
  sMess:= '';
  OverMessAll:= '';
//  flResLimit:= False;
//  flCheckRes:= False;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetFormingOrdersList, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    Client:= Cache.arClientInfo[UserID];
    firma:= Cache.arFirmInfo[FirmID];

    if (firma.ResLimit=0) then OverMessAll:= 'Резервирование заблокировано';
    flResLimit:= (firma.ResLimit>0);
//    flCheckRes:= flResLimit;
    if flResLimit then begin
      IBD:= cntsORD.GetFreeCnt;
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead);
    end;

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrdIBS.SQL.Text:= 'SELECT ORDRCODE, ORDRDATE, ORDRNUM, ORDRSUMORDER,'+
      ' ORDRCURRENCY, ORDRCONTRACT, ORDRSELFCOMMENT, OrdrWareLineCount'+
      ' from ORDERSREESTR where ORDRFIRM='+IntToStr(FirmID)+
      '   and ORDRSTATUS='+IntToStr(orstForming)+
      '   and ORDRCURRENCY<>'+IntToStr(Cache.BonusCrncCode)+ // без бонусного заказа
      ' order by ORDRCODE desc'; // начиная с последних
    OrdIBS.ExecQuery;

    iCount:= 0;
    s:= '';
    while not OrdIBS.EOF do begin
      ii:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
      //------------------------------- фильтр по контрактам
      s:= '';
      fl:= (ii>0) and Client.CheckContract(ii);
      if fl then begin
        Contract:= Client.GetCliContract(ii);
        fl:= (Contract.ID=ii) and (Contract.Status<>cstClosed);
      end;
      if fl and Client.DocsByCurrContr then // заказы только по текущему
        fl:= (ii=Client.GetCliCurrContID);
      if fl then s:= Contract.Name
      else begin
        OrdIBS.Next;                              // - пропускаем
        Continue;
      end;

      if (iCount>High(arOpts)) then begin
        sMess:= 'Слишком много неотправленных заказов, выведены последние '+IntToStr(iCount);
        break;
      end;
      sum:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;

      arOpts[iCount].contID:= ii;
      arOpts[iCount].contName:= s;
      arOpts[iCount].ordID:= OrdIBS.FieldByName('ORDRCODE').AsInteger;
      arOpts[iCount].currID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
      arOpts[iCount].strDate:= FormatDateTime(cDateFormatY2, OrdIBS.FieldByName('ORDRDATE').AsDateTime);
      arOpts[iCount].ordNum:= OrdIBS.FieldByName('ORDRNUM').AsString;
      arOpts[iCount].strSum:= FormatFloat(cFloatFormatSumm, sum);
      arOpts[iCount].comm:= OrdIBS.FieldByName('ORDRSELFCOMMENT').AsString;
      arOpts[iCount].OverMess:= OverMessAll;

      if flResLimit and fnNotZero(sum) then begin
        WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
//          if flCheckRes then begin
//            firma.CheckReserveLimit; // проверяем лимит 1 раз на 1-м заказе  ???
//            flCheckRes:= False;
//          end;
                                       // проверка превышения лимита резерва к/а
        arOpts[iCount].OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID, ii,
           arOpts[iCount].ordID, arOpts[iCount].CurrID, True, False, (WareCount<2), ibs)
      end; // if flResLimit

      TestCssStopException;
      OrdIBS.Next;
      Inc(iCount);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(sMess); // сообщение
    Stream.WriteInt(iCount);    // кол-во строк
    for i:= iCount-1 downto 0 do begin // меняем порядок на естественный
      Stream.WriteInt(arOpts[i].ordID);
      Stream.WriteInt(arOpts[i].contID);   // код контракта
      Stream.WriteStr(arOpts[i].contName); // назание этого контракта или пусто, если неопределен
      Stream.WriteStr(arOpts[i].strDate);
      Stream.WriteStr(arOpts[i].ordNum);
      Stream.WriteStr(arOpts[i].OverMess);
      Stream.WriteStr(arOpts[i].strSum);
      Stream.WriteStr(Cache.GetCurrName(arOpts[i].currID, True));
      Stream.WriteStr(arOpts[i].comm); // личный комментарий
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  prFreeIBSQL(IBS);
  cntsORD.SetFreeCnt(IBD);
  SetLength(arOpts, 0);
  Stream.Position:= 0;
end;
//*******************************************************************************
procedure prGetOrderListOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetOrderListOrd'; // имя процедуры/функции
var i, ii, UserId, FirmID, Status, sPos, ContID, currID, OrderID, WareCount: integer;
    Accounts, Invoices: TDocRecArr;
    s, err, SortOrder, SortDesc, stat, dat, ss, sParam, OverMess, OverMessAll, ErrMess: string;
    DateStart, DateFinish, TestDate, OrdProcDate: TDateTime;
    OrdIBS, ibs: TIBSQL;
    OrdIBD, ibd: TIBDatabase;
    Firm: TFirmInfo;
    Client: TClientInfo;
    Contract: TContract;
    sum: Double;
    {flCheckRes,} flResLimit, flErrMess, flCreateFilter: Boolean;
begin
  Stream.Position:= 0;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  OrdIBS:= nil;
  OrdIBD:= nil;
  IBS:= nil;
  IBD:= nil;
  ContID:= 0;
  sParam:= '';
  DateStart:= 0;
  DateFinish:= 0;
  Client:= nil;
  Firm:= nil;
  flResLimit:= False;
  OverMessAll:= '';
  ErrMess:= '';
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    flErrMess:= (OrderListLimit>0);
    try
      if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
      Firm:= Cache.arFirmInfo[FirmID];
      Client:= Cache.arClientInfo[UserID];
      Contract:= Client.GetCliContract(ContID);

      if (firm.ResLimit=0) then OverMessAll:= 'Резервирование заблокировано';
      flResLimit:= (firm.ResLimit>0);
//      flCheckRes:= flResLimit;

      stat:= '';  // перечень статусов
      if Stream.ReadByte=1 then stat:= stat+fnIfStr(stat='', '', ',')+IntToStr(orstForming);
      if Stream.ReadByte=1 then stat:= stat+fnIfStr(stat='', '', ',')+IntToStr(orstClosed);
      if Stream.ReadByte=1 then stat:= stat+fnIfStr(stat='', '', ',')+IntToStr(orstProcessing);
      if Stream.ReadByte=1 then stat:= stat+fnIfStr(stat='', '', ',')+IntToStr(orstAnnulated);
      if Stream.ReadByte=1 then stat:= stat+fnIfStr(stat='', '', ',')+IntToStr(orstAccepted);
      DateStart:= Stream.ReadDouble;
      DateFinish:= Stream.ReadDouble;
      SortOrder:= Stream.ReadStr;
      SortDesc:= Stream.ReadStr;
      sParam:= 'Statuses='+stat+
        #13#10'DateStart='+FormatDateTime(cDateFormatY2, DateStart)+
        #13#10'DateFinish='+FormatDateTime(cDateFormatY2, DateFinish)+
        #13#10'SortOrder='+SortOrder+#13#10'SortDesc='+SortDesc;
    finally
      prSetThLogParams(ThreadData, csGetOrderList, UserID, FirmID, sParam); // логирование
    end;

    TestDate:= IncYear(Date, -5);
    dat:= ''; // фильтр по дате
    DateFinish:= DateFinish+1;
    if (DateStart>TestDate)  then dat:= dat+' AND ORDRDATE>=:DATESTART';
    if (DateFinish>TestDate) then dat:= dat+' AND ORDRDATE<=:DATEFINISH';

    s:= ' ORDER BY '+SortOrder+' '+SortDesc+', ORDRDATE '+SortDesc+', ORDRNUM '+SortDesc;

    ss:= 'SELECT ORDRSTATUS, ORDRCODE, ORDRDATE, ORDRNUM, ORDRSUMORDER, ORDRCURRENCY,'+
         ' ORDRTOPROCESSDATE, ORDRCONTRACT, ORDRSELFCOMMENT, OrdrWareLineCount'+
         ' from ORDERSREESTR where ORDRFIRM='+IntToStr(FirmID);

    flCreateFilter:= (stat='') and (dat='');
    if flCreateFilter then begin // если фильтры не заданы
      flErrMess:= False;
      ss:= ss+' and (ORDRSTATUS<'+IntToStr(orstClosed)+
              ' or (ORDRSTATUS='+IntToStr(orstClosed)+' and (("TODAY"-ORDRDATE)<7)))';
    end else ss:= ss+' AND ORDRSTATUS'+
                 fnIfStr(stat='', '<>'+IntToStr(orstDeleted), ' in ('+stat+')')+dat;
    if Firm.IsFinalClient then ss:= ss+' and ORDRCURRENCY<>'+IntToStr(Cache.BonusCrncCode);

    if flResLimit then begin
      IBD:= cntsORD.GetFreeCnt;
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead);
    end;

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrdIBS.SQL.Text:= ss+s;
    if DateStart>TestDate  then OrdIBS.paramByName('DATESTART').AsDateTime:= DateStart;
    if DateFinish>TestDate then OrdIBS.paramByName('DATEFINISH').AsDateTime:= DateFinish;
    OrdIBS.ExecQuery;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    sPos:= Stream.Position;
    Stream.WriteInt(0); // забиваем место под кол-во строк
    i:= 0;
    while not OrdIBS.EOF do begin
      ii:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
      currID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
//      if Firm.IsFinalClient and (currID=Cache.BonusCrncCode) then begin
//        OrdIBS.Next;                              // пропускаем
//        Continue;
//      end;
      //------------------------------- фильтр по контрактам
      if (ii<1) then s:= ''                       // контракт неопределен
      else if (ii=ContID) then s:= Contract.Name  // текущий контракт
      else if //(currID<>Cache.BonusCrncCode) and   // если обычный заказ и
        (Client.DocsByCurrContr or                   // заказы только по текущему
        not Client.CheckContract(ii)) then begin     // или контракт недоступен
        OrdIBS.Next;                              // - пропускаем
        Continue;
      end else s:= firm.GetContract(ii).Name;

      SetLength(Accounts, 0);
      SetLength(Invoices, 0);
      OrderID:= OrdIBS.FieldByName('ORDRCODE').AsInteger;
      Status:= OrdIBS.FieldByName('ORDRSTATUS').AsInteger;
      if ((Status>orstProcessing) and (Status<orstAnnulated)) then begin
        err:= fnGetClosingDocsOrd(IntToStr(OrderID), Accounts, Invoices, Status, ThreadData.ID);
        if (err<>'') then raise Exception.Create(err);
      end;
      OrdProcDate:= OrdIBS.FieldByName('ORDRTOPROCESSDATE').AsDateTime;
      sum:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;

      Stream.WriteInt(Length(Accounts));
      Stream.WriteInt(OrderID);
      Stream.WriteInt(ii); // код контракта
      Stream.WriteStr(s);  // назание этого контракта или пусто, если неопределен
      Stream.WriteStr(FormatDateTime(cDateFormatY2, OrdIBS.FieldByName('ORDRDATE').AsDateTime));
      Stream.WriteStr(OrdIBS.FieldByName('ORDRNUM').AsString);
      OverMess:= '';

      if (Status=orstForming) and fnNotZero(sum) then begin // формирующийся заказ непустой
        if flResLimit then begin
//          if flCheckRes then begin
  //          firm.CheckReserveLimit; // проверяем лимит 1 раз на 1-м заказе ???
//            flCheckRes:= False;
//          end;
          WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
                                       // проверка превышения лимита резерва к/а
          OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID, ii, OrderID,
                     CurrID, flResLimit, False, (WareCount<2), ibs);
        end else OverMess:= OverMessAll;
      end; // if (Status=orstForming)
      Stream.WriteStr(OverMess);

      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));
      Stream.WriteStr(Cache.GetCurrName(currID, True));
      Stream.WriteStr(arOrderStatusNames[Status]);
      if Status<>orstProcessing then s:= ''
      else s:= ' с '+FormatDateTime(cDateTimeFormatTnD, OrdProcDate);
      Stream.WriteStr(s);
      Stream.WriteStr(FormatDateTime(cDateTimeFormatY2N, OrdProcDate));
      for ii:= Low(Accounts) to High(Accounts) do begin
        if Invoices[ii].Number='' then begin
          Stream.WriteByte(fnIfInt(Accounts[ii].Processed, byte('t'), byte('f'))); // т.е. если f -счет необр., если t-  обр., если ничего - накладная
          Stream.WriteStr(fnGetGBDocName(docAccount)+fnIfStr(Accounts[ii].Processed, cWebProcessed, ''));
          Stream.WriteStr(IntToStr(docAccount));
          Stream.WriteStr(IntToStr(Accounts[ii].ID));
          Stream.WriteStr(Cache.GetDprtMainName(Accounts[ii].DprtID));
          Stream.WriteStr(Accounts[ii].Number);
          Stream.WriteStr(Accounts[ii].Commentary);
          Stream.WriteStr(FormatFloat(cFloatFormatSumm, Accounts[ii].Summa));
          Stream.WriteStr(Accounts[ii].CurrencyName);
          Stream.WriteStr(FormatDateTime(cDateFormatY2, Accounts[ii].Data));
        end else begin
          Stream.WriteByte(0);//
          Stream.WriteStr(fnGetGBDocName(docInvoice));
          Stream.WriteStr(IntToStr(docInvoice));
          Stream.WriteStr(IntToStr(Invoices[ii].ID));
          Stream.WriteStr(Cache.GetDprtMainName(Invoices[ii].DprtID));
          Stream.WriteStr(Invoices[ii].Number);
          Stream.WriteStr(Accounts[ii].Commentary);
          Stream.WriteStr(FormatFloat(cFloatFormatSumm, Invoices[ii].Summa));
          Stream.WriteStr(Invoices[ii].CurrencyName);
          Stream.WriteStr(FormatDateTime(cDateFormatY2, Invoices[ii].Data));
        end;
      end;
      Stream.WriteStr(OrdIBS.FieldByName('ORDRSELFCOMMENT').AsString); // личный комментарий
      TestCssStopException;
      OrdIBS.Next;
      Inc(i);

      if flErrMess and (i>OrderListLimit) then begin // защита от зависания при большом кол-ве заказов
        ErrMess:= 'Слишком много заказов, выведены первые '+
          IntToStr(OrderListLimit)+'. Измените параметры фильтра.';
        break;
      end;
    end;
    Stream.WriteStr(ErrMess);  // сообщение - предупреждение
    if (i>0) then begin
      Stream.Position:= sPos;
      Stream.WriteInt(i); // передаем кол-во строк
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  prFreeIBSQL(IBS);
  cntsORD.SetFreeCnt(IBD);
  Stream.Position:= 0;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
end;
//************************************************** просмотр заказа - 2 колонки
procedure prShowOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowOrderOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, Status, i, j, spos, LineCount, contID, MainStore,
      DestID, ShipTableID, DelivType, ShipMetID, ShipTimeID, currID, accType: integer;
    OrderCode, err, s, s1, sLine, sStore, sDestName, sDestAdr,
      sArrive, sShipMet, sShipTime, sShipView, OverMess, ordNum: string;
    Accounts, Invoices: TDocRecArr;
    Storages: TaSD;
    Ware: TWareInfo;
    HasAnalogs, GBdirection, flResLimit: Boolean;
    qty, qtyM, price, bonus, totalbonus, ShipDate, sum, LineSum, OverSumm: Double;
    arlstSQL: TASL;
    Contract: TContract;
    Client: TClientInfo;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  totalbonus:= 0;
  OrdIBS:= nil;
//  OrdIBD:= nil;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  SetLength(arlstSQL, 1);
  arlstSQL[0]:= TStringList.Create;
  contID:= 0;
  sPos:= 0;
  LineCount:= 0;            // счетчик - кол-во строк
  GBdirection:= False;
  OverMess:= '';
//  flResLimit:= False;
  OverSumm:= 0;
  LineSum:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    OrderCode:= Stream.ReadStr;
    GBdirection:= Stream.ReadBool;

    prSetThLogParams(ThreadData, csShowOrder, UserID, FirmID,
      'OrderCode='+OrderCode+#13#10'ContID='+IntToStr(ContID)); // логирование

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    Client:= Cache.arClientInfo[UserID];
    Contract:= Client.GetCliContract(contID);
    MainStore:= Contract.MainStorage;

    OrdIBD:= cntsORD.GetFreeCnt;
    try
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
      OrdIBS.SQL.Text:= 'SELECT  ORDRSTATUS, ORDRNUM, ORDRGBACCNUMBER, ORDRDATE,'+
        ' ORDRSUMORDER, ORDRCURRENCY, ORDRACCOUNTINGTYPE, ORDRDELIVERYTYPE,'+
        ' ORDRTOPROCESSDATE, ORDRCREATORPERSON, ORDRTOPROCESSPerson, ORDRWARRANT,'+
        ' ORDRWARRANTDATE, ORDRWARRANTPERSON, ORDRSTORAGECOMMENT, ORDRSELFCOMMENT,'+
        ' ORDRDESTPOINT, ORDRSHIPDATE, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID,'+
        ' ORDRANNULATEDATE, ORDRANNULATEREASON, ORDRCONTRACT'+
        fnIfStr(flMeetPerson, ', ordrAccMeetText', '')+
        ' from ORDERSREESTR where ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmId);
      OrdIBS.ExecQuery;
      if OrdIBS.Bof and OrdIBS.Eof then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

      currID:= OrdIBS.FieldByName('ORDRCURRENCY').asInteger;
      Status:= OrdIBS.FieldByName('ORDRSTATUS').AsInteger;

      if (currID=Cache.BonusCrncCode) and (Status=orstForming) then // unit-заказ формируется
        raise Exception.Create('Некорректная команда просмотра unit-заказа со статусом "формируется"');

      if ((Status>orstProcessing) and (Status<orstAnnulated)) then begin
        err:= fnGetClosingDocsOrd(OrderCode, Accounts, Invoices, Status, ThreadData.ID);
        if (err<>'') then raise Exception.Create(err);
      end;

      if (OrdIBS.FieldByName('ORDRCONTRACT').AsInteger<1) then begin
        arlstSQL[0].Add('update ORDERSREESTR set ORDRCONTRACT='+IntToStr(contID));
        arlstSQL[0].Add(' where ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmId)+';');
      end else if (contID<>OrdIBS.FieldByName('ORDRCONTRACT').AsInteger) then
         raise EBOBError.Create('Заказ не соответствует текущему контракту');

      accType:= OrdIBS.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;
      if (Contract.PayType<>accType) then begin
        accType:= Contract.PayType;
        arlstSQL[0].Add('update ORDERSREESTR set ORDRACCOUNTINGTYPE='+IntToStr(accType));
        arlstSQL[0].Add(' where ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmId)+';');
      end;

      DelivType:= OrdIBS.FieldByName('ORDRDELIVERYTYPE').AsInteger;
      DestID:= OrdIBS.FieldByName('ORDRDESTPOINT').AsInteger;
      ShipTableID:= OrdIBS.FieldByName('ORDRTIMETIBLE').AsInteger;
      ShipDate:= OrdIBS.FieldByName('ORDRSHIPDATE').AsDateTime;
      ShipMetID:= OrdIBS.FieldByName('ORDRSHIPMETHOD').AsInteger;
      ShipTimeID:= OrdIBS.FieldByName('ORDRSHIPTIMEID').AsInteger;
      sum:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;
      ordNum:= OrdIBS.FieldByName('ORDRNUM').AsString;

      firma:= Cache.arFirmInfo[FirmID]; // в бонусных заказах лимит не проверяем
      flResLimit:= (firma.ResLimit>=0) and (currID<>Cache.BonusCrncCode)
                   and (Status=orstForming) and fnNotZero(sum);
      if flResLimit then begin //-------------------- вычисляем общее превышение
        OverMess:= firma.GetOverSummAll(currID, OverSumm);
        flResLimit:= (OverMess='');
      end; // if flResLimit

      Stream.Clear;
      Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
      Stream.WriteStr(ordNum);
      Stream.WriteStr(OrdIBS.FieldByName('ORDRGBACCNUMBER').AsString);
      Stream.WriteStr(FormatDateTime(cDateFormatY2, OrdIBS.FieldByName('ORDRDATE').AsDateTime));
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));
      Stream.WriteStr(Cache.GetCurrName(currID, True));
      Stream.WriteInt(accType);
      Stream.WriteInt(DelivType);
      Stream.WriteInt(Status);
      Stream.WriteStr(arOrderStatusDecor[Status].StatusName);
      if (Status=orstProcessing) then s:= ' с '+
        FormatDateTime(cDateTimeFormatTnD, OrdIBS.FieldByName('ORDRTOPROCESSDATE').AsDateTime)
      else s:= '';
      Stream.WriteStr(s);
      Stream.WriteStr('');      // ORDRTOTALWEIGHT

      i:= OrdIBS.FieldByName('ORDRCREATORPERSON').AsInteger;
      if (i=0) or not Cache.ClientExist(i) then s:= ''
      else s:= fnCutFIO(Cache.arClientInfo[i].Name);
      Stream.WriteStr(s); // Передаем создателя заказа

      j:= OrdIBS.FieldByName('ORDRTOPROCESSPerson').AsInteger;
      if (j<>i) then
        if (j=0) or not Cache.ClientExist(j) then s:= ''
        else s:= fnCutFIO(Cache.arClientInfo[j].Name);
      Stream.WriteStr(s); // Передаем отправителя на выполнение

      Stream.WriteStr(BOBBoolToStr(Client.NOTREMINDCOMMENT));

      err:= fnGetShipParamsView(contID, MainStore, DestID, ShipTableID, ShipDate,
            DelivType, ShipMetID, ShipTimeID, sDestName, sDestAdr, sArrive,
            sShipMet, sShipTime, sShipView, GBdirection);
      if (err<>'') then sShipView:= '';
      Stream.WriteStr(sShipView); // Передаем строку с параметрами доставки

      Stream.WriteStr(OrdIBS.FieldByName('ORDRWARRANT').AsString);
      Stream.WriteDouble(OrdIBS.FieldByName('ORDRWARRANTDATE').AsDateTime);
      Stream.WriteStr(OrdIBS.FieldByName('ORDRWARRANTPERSON').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('ORDRSTORAGECOMMENT').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('ORDRSELFCOMMENT').AsString);

      if Status=orstAnnulated then s:= 'Аннулирован '+
        FormatDateTime(cDateTimeFormatY2N, OrdIBS.FieldByName('ORDRANNULATEDATE').AsDateTime)+
        ' Причина аннуляции: '+OrdIBS.FieldByName('ORDRANNULATEREASON').AsString
      else s:= '';
      Stream.WriteStr(s);

if flMeetPerson then
      Stream.WriteStr(trim(OrdIBS.FieldByName('ordrAccMeetText').AsString)); // встречающий

      OrdIBS.Close;
      s:= '';
      s1:= '';
      sStore:= '';
      if Status=orstForming then begin // если заказ на стадии формирования
        Storages:= fnGetStoragesArray_2col(Contract, true, True);
        prSendStorages(Storages, Stream);
        s:= s +', OWBSQTY QtyMain';
        sStore:= IntToStr(MainStore);
        s1:= s1 +' left join ORDERSWAREBYSTORAGES on '+
             'OWBSORDERLINE=OL.ORDRLNCODE and OWBSSTORAGE='+sStore;
      end;

      sPos:= Stream.Position;
      Stream.WriteInt(0); //  место под кол-во строк

      OrdIBS.SQL.Text:= 'SELECT OL.ORDRLNWARE, OL.ORDRLNCODE, OL.ORDRLNCLIENTQTY, OL.ORDRLNPRICE'+s+
        ' FROM ORDERSLINES OL'+s1+' where ORDRLNORDER='+OrderCode+' order by ORDRLNCODE';
      OrdIBS.ExecQuery;
      j:= 0;
      sum:= 0;
      while not OrdIBS.EOF do begin
        i:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger;
        qty:= OrdIBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;
        price:= OrdIBS.FieldByName('ORDRLNPRICE').AsFloat;

        Ware:= Cache.GetWare(i);
        if not Assigned(Ware) or (Ware=NoWare) then
          raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(i)));
        Stream.WriteInt(OrdIBS.FieldByName('ORDRLNCODE').AsInteger);
        Stream.WriteStr(OrdIBS.FieldByName('ORDRLNWARE').AsString);

        if (currID=Cache.BonusCrncCode) then HasAnalogs:= False // unit-заказ
        else HasAnalogs:= (ware.AnalogLinks.LinkCount>0);       // обычный заказ
        Stream.WriteStr(fnIfStr(HasAnalogs, '1', '0'));

        Stream.WriteStr(Ware.WareBrandName);
        Stream.WriteStr(Ware.Name);
        Stream.WriteDouble(qty);

        if (Status=orstForming) then begin                // если заказ на стадии формирования -
          qtyM:= OrdIBS.FieldByName('QtyMain').AsFloat; // строки в переброску на главный склад
          if (qtyM<>qty) then begin
            sLine:= OrdIBS.FieldByName('ORDRLNCODE').AsString;
            if (arlstSQL[j].Count>240) then begin
              inc(j);
              SetLength(arlstSQL, j+1);
              arlstSQL[j]:= TStringList.Create;
            end;
            if (qtyM<1) then begin
              arlstSQL[j].Add('insert into ORDERSWAREBYSTORAGES (OWBSORDERLINE, OWBSSTORAGE, OWBSQTY)');
              arlstSQL[j].Add('values ('+sLine+', '+sStore+', (select ORDRLNCLIENTQTY');
              arlstSQL[j].Add('  from ORDERSLINES where ORDRLNCODE='+sLine+'));');
            end else begin
              arlstSQL[j].Add('update ORDERSWAREBYSTORAGES set OWBSQTY=');
              arlstSQL[j].Add(' (select ORDRLNCLIENTQTY from ORDERSLINES where ORDRLNCODE='+sLine+')');
              arlstSQL[j].Add('  where OWBSORDERLINE='+sLine+' and OWBSSTORAGE='+sStore+';');
            end;
            arlstSQL[j].Add('delete from ORDERSWAREBYSTORAGES');
            arlstSQL[j].Add('  where OWBSORDERLINE='+sLine+' and OWBSSTORAGE<>'+sStore+';');
            qtyM:= qty;
          end; // if (qtyM<>qty)
          Stream.WriteStr(trim(FormatFloat('###0.#', qtyM))); // передаем текущее кол-во заказа
        end; // if (Status=orstForming)

        Stream.WriteStr(Ware.MeasName);
        s:= FormatFloat(cFloatFormatSumm, price);                                   // цена
        Stream.WriteStr(s);
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, RoundToHalfDown(price*qty))); // сумма по строке

        if (currID=Cache.BonusCrncCode) then begin // unit-заказ
          s:= '';
          bonus:= 0;
        end else begin                             // обычный заказ
          s:= trim(FormatFloat(cFloatFormatSumm, ware.MarginPrice(FirmID, UserID, currID, contID)));
          bonus:= price*qty*Cache.GetPriceBonusCoeff(currID);
        end;
        Stream.WriteStr(s); // цена товара с наценкой (% к продажной) для клиента

        s:= trim(FormatFloat(cFloatFormatSumm, bonus));
        Stream.WriteStr(s); // баллы
        totalbonus:= totalbonus+bonus;

        if flResLimit then begin
          price:= Ware.SellingPrice(FirmID, CurrID, contID);
          LineSum:= price*qty;
          sum:= sum+LineSum;
        end; // if flResLimit

        inc(LineCount);
        TestCssStopException;
        OrdIBS.Next;
      end; // while not OrdIBS.EOF
      OrdIBS.Close;

      if flResLimit then  //---------------- проверяем возможное превышение
        OverMess:= GetOrderOverSummMess(currID, OverSumm, Sum, LineSum);

      s:= trim(FormatFloat(cFloatFormatSumm, totalbonus)); // баллы
      Stream.WriteStr(s);

      if (arlstSQL[0].Count>0) then begin // переброска кол-ва на главный склад, запись кода контракта
        fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
        for j:= 0 to High(arlstSQL) do
        if (arlstSQL[j].Count>0) then begin
          arlstSQL[j].Insert(0, 'execute block as begin');
          arlstSQL[j].Add('end');
          OrdIBS.SQL.Clear;
          OrdIBS.SQL.AddStrings(arlstSQL[j]);
          OrdIBS.ExecQuery;
        end;
        OrdIBS.Transaction.Commit;
      end;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;

    Stream.Position:= sPos;
    Stream.WriteInt(LineCount); // кол-во строк
    Stream.Position:= Stream.Size;

    Stream.WriteInt(Length(Accounts));
    for i:= Low(Accounts) to High(Accounts) do begin
      Stream.WriteInt(Accounts[i].ID);
      if Accounts[i].ID>0 then with Accounts[i] do begin
                  // если f -счет необр., если t-  обр., если ничего - накладная
        Stream.WriteByte(fnIfInt(Accounts[i].Processed, byte('t'), byte('f')));
        Stream.WriteStr(Cache.GetDprtMainName(DprtID));
        Stream.WriteStr(Number+cWebSpace+fnIfStr(Accounts[i].Processed, cWebProcessed, ''));
        Stream.WriteStr(Commentary);
        Stream.WriteDouble(Data);
        Stream.WriteDouble(Summa);
        Stream.WriteStr(CurrencyName);
      end;
      Stream.WriteInt(Invoices[i].ID);
      if Invoices[i].ID>0 then with Invoices[i] do begin
        Stream.WriteStr(Cache.GetDprtMainName(DprtID));
        Stream.WriteStr(Number);
        Stream.WriteDouble(Data);
        Stream.WriteDouble(Summa);
        Stream.WriteStr(CurrencyName);
      end;
    end;

    Stream.WriteStr(OverMess); // сообщение о превышении лимита
//if flDebug and (OverMess<>'') then prMessageLOGS(' firm= '+IntToStr(firmID)+
//  ', ordnum= '+OrdNUM+'- mess= '+OverMess, fLogDebug, False);

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
//  SetLength(anw, 0);
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  SetLength(Storages, 0);
  for i:= 0 to High(arlstSQL) do prFree(arlstSQL[i]);
  SetLength(arlstSQL, 0);
end;
//*******************************************************************************
procedure prShowACOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowACOrderOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, Status, spos, LineCount, i, {SysID,} contID, currID, currTo: integer;
    OrderCode, AccType, s, CurrName: string;
    CoeffCurr, sum: Double;
    Ware: TWareInfo;
    HasAnalogs: Boolean;
//    ar: Tai;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    OrderCode:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csShowACOrder, UserID, FirmID,
      'OrderID='+OrderCode+#13#10'ContID='+IntToStr(ContID)); // логирование

    spos:= StrToIntDef(OrderCode, 0);
    if (spos<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrdIBS.SQL.Text:= 'SELECT ORDRNUM, ORDRACCOUNTINGTYPE, ORDRGBACCNUMBER,'+
      ' ORDRDATE, ORDRSUMORDER, ORDRDELIVERYTYPE, ORDRSTATUS, ORDRTOPROCESSDATE,'+
      ' ORDRANNULATEDATE, ORDRANNULATEREASON, ORDRCONTRACT, ORDRCURRENCY'+
      fnIfStr(flMeetPerson, ', ordrAccMeetText', '')+
      ' from ORDERSREESTR where ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmId);
    OrdIBS.ExecQuery;
    if OrdIBS.Bof and OrdIBS.Eof then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

    if (OrdIBS.FieldByName('ORDRCONTRACT').AsInteger>0) and
      (contID<>OrdIBS.FieldByName('ORDRCONTRACT').AsInteger) then
      raise EBOBError.Create('Заказ не соответствует текущему контракту');

    AccType:= OrdIBS.FieldByName('ORDRACCOUNTINGTYPE').AsString;
    // определяем альтернативную валюту просмотра заказа и коэфф.пересчета сумм
    currID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;

    if (currID=cUAHCurrency) then begin  // грн -> валюта
      currTo:= cDefCurrency;
      CoeffCurr:= Cache.Currencies.GetCurrRate(currTo); // курс к гривне альтерн.валюты
      if fnNotZero(Coeffcurr) then CoeffCurr:= 1/CoeffCurr;
    end else begin                       // валюта -> грн
      CoeffCurr:= Cache.Currencies.GetCurrRate(currID); // курс к гривне валюты заказа
      currTo:= cUAHCurrency;
    end;
    CurrName:= Cache.GetCurrName(currTo, True); // наименование альтерн.валюты
    sum:= RoundToHalfDown(OrdIBS.FieldByName('ORDRSUMORDER').AsFloat*CoeffCurr);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(OrdIBS.FieldByName('ORDRNUM').AsString);
    Stream.WriteStr(OrdIBS.FieldByName('ORDRGBACCNUMBER').AsString); // определяем номер счета по заказу
    Stream.WriteStr(FormatDateTime(cDateFormatY2, OrdIBS.FieldByName('ORDRDATE').AsDateTime));
    Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));
    Stream.WriteStr(CurrName);
    Stream.WriteStr(AccType);
    Stream.WriteInt(OrdIBS.FieldByName('ORDRDELIVERYTYPE').AsInteger);
    Status:= OrdIBS.FieldByName('ORDRSTATUS').AsInteger;
    Stream.WriteInt(Status);
    Stream.WriteStr(arOrderStatusDecor[Status].StatusName);
    if Status=orstProcessing then s:= ' с '+
      FormatDateTime(cDateTimeFormatTnD, OrdIBS.FieldByName('ORDRTOPROCESSDATE').AsDateTime)
    else s:= '';
    Stream.WriteStr(s);
    Stream.WriteStr('');       // ORDRTOTALWEIGHT

    if Status=orstAnnulated then s:= 'Аннулирован '+
      FormatDateTime(cDateTimeFormatY2N, OrdIBS.FieldByName('ORDRANNULATEDATE').AsDateTime)+
      ' Причина аннуляции: '+OrdIBS.FieldByName('ORDRANNULATEREASON').AsString
    else s:= '';
    Stream.WriteStr(s);

if flMeetPerson then
    Stream.WriteStr(OrdIBS.FieldByName('ordrAccMeetText').AsString); // встречающий

    OrdIBS.Close;
    LineCount:= 0;      // счетчик - кол-во строк
    sPos:= Stream.Position;
    Stream.WriteInt(0); //  место под кол-во строк
    OrdIBS.SQL.Text:= 'SELECT ORDRLNWARE, ORDRLNCODE, ORDRLNCLIENTQTY, ORDRLNPRICE'+
      ' FROM ORDERSLINES where ORDRLNORDER='+OrderCode;
    OrdIBS.ExecQuery;    //
    while not OrdIBS.EOF do begin
      i:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger;
      Ware:= Cache.GetWare(i);
      if not Assigned(Ware) or (Ware=NoWare) then
        raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(i)));

      Stream.WriteInt(OrdIBS.FieldByName('ORDRLNCODE').AsInteger);
      Stream.WriteStr(OrdIBS.FieldByName('ORDRLNWARE').AsString);
      HasAnalogs:= (ware.AnalogLinks.LinkCount>0);
      Stream.WriteStr(fnIfStr(HasAnalogs, '1', '0'));
      Stream.WriteStr(Ware.WareBrandName);
      Stream.WriteStr(Ware.Name);
      Stream.WriteDouble(OrdIBS.FieldByName('ORDRLNCLIENTQTY').AsFloat);
      Stream.WriteStr(Ware.MeasName);

      sum:= RoundToHalfDown(OrdIBS.FieldByName('ORDRLNPRICE').AsFloat*CoeffCurr);
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));
      sum:= sum*OrdIBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));

      inc(LineCount);
      TestCssStopException;
      OrdIBS.Next;
    end;
    OrdIBS.Close;
    Stream.Position:= sPos;
    Stream.WriteInt(LineCount);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end;
//**************************************************** Удаление строки из заказа
procedure prDelLineFromOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prDelLineFromOrderOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, CurrID, ContID, OrderID, WareCount, i: integer;
    OrderCode, LineID, s, OverMess, ordNum, ErrLineCodes, sLog: string;
    sum, bon: Double;
    firma: TFirmInfo;
    arLineCodes: Tai;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  OverMess:= '';
  SetLength(arLineCodes, 0);
  ErrLineCodes:= '';
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    LineID:= Stream.ReadStr;  // в новом дизайне - несколько кодов через запятую

    sLog:= 'OrderId='+OrderCode+#13#10'LineID='+LineID;
    try
      OrderID:= StrToIntDef(OrderCode, 0);
      if (OrderID<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

      i:= Length(LineID);
      if (copy(LineID, 1, 1)=',') then LineID:= copy(LineID, 2, i-1);
      if (copy(LineID, i, 1)=',') then LineID:= copy(LineID, 1, i-1);
      arLineCodes:= fnArrOfCodesFromString(LineID);
      i:= Length(arLineCodes);

      if (i<1) then raise EBOBError.Create(MessText(mtkNotValidParam, ' - код строки'));

      OrdIBD:= cntsORD.GetFreeCnt;
      OrdIBS:= fnCreateNewIBSQL(OrdIBD,'OrdIBS_'+nmProc,ThreadData.ID, tpRead, true);
      OrdIBS.SQL.Text:= 'SELECT ORDRFIRM, ORDRSTATUS, ORDRCURRENCY, (select'+
        ' list(ORDRLNWARE) from ORDERSLINES where ORDRLNCODE in ('+LineID+')) warecodes'+
        ' from ORDERSREESTR where ORDRCODE='+OrderCode;
      OrdIBS.ExecQuery;
      if OrdIBS.Bof and OrdIBS.Eof then // проверяем, существует ли такой заказ
        raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
      // проверяем, можно ли заказ редактировать
      if (OrdIBS.FieldByName('ORDRSTATUS').AsInteger>orstForming)  then
        raise EBOBError.Create(MessText(mtkNotEditOrder));
      // проверяем, имеет ли право этот человек редактировать этот заказ
      if OrdIBS.FieldByName('ORDRFIRM').AsInteger<>FirmID then
        raise EBOBError.Create(MessText(mtkNotRightExists));
      sLog:= sLog+#13#10'Wares='+OrdIBS.FieldByName('warecodes').asString+#13#10'IsPrize='+
             fnIfStr(OrdIBS.FieldByName('ORDRCURRENCY').AsInteger=Cache.BonusCrncCode, '1', '0');
      OrdIBS.Close;
    finally
      prSetThLogParams(ThreadData, csDelLineFromOrder, UserID, FirmID, sLog); // логирование
    end;

    // вроде все проверено, удаляем строку (строки)
    fnSetTransParams(OrdIBS.Transaction, tpWrite, True);

    OrdIBS.SQL.Text:= 'execute procedure DelOrderLine(:LineID)';
    for i:= 0 to High(arLineCodes) do begin
      OrdIBS.ParamByName('LineID').AsInteger:= arLineCodes[i];
      s:= RepeatExecuteIBSQL(OrdIBS);
      if (s<>'') then begin
        ErrLineCodes:= ErrLineCodes+fnIFStr(ErrLineCodes='', '', ',')+IntToStr(arLineCodes[i]);
        fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', MessText(mtkErrDelRecord)+': '+s, '');
      end;
    end; // for

    // узнаем новую сумму счета и валюту
    fnSetTransParams(OrdIBS.Transaction, tpRead, True);
    OrdIBS.SQL.Text:= 'SELECT ORDRSUMORDER, ORDRCURRENCY, ORDRCONTRACT, ORDRNUM,'+
                      ' OrdrWareLineCount from ORDERSREESTR where ORDRCODE='+OrderCode;
    OrdIBS.ExecQuery;
    if (OrdIBS.Bof and OrdIBS.Eof) then raise EBOBError.Create(MessText(mtkNotValidParam));
    sum:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;
    CurrID:= OrdIBS.FieldByName('ORDRCURRENCY').asInteger;
    ContID:= OrdIBS.FieldByName('ORDRCONTRACT').asInteger;
    ordNum:= OrdIBS.FieldByName('ORDRNUM').AsString;
    bon:= sum*Cache.GetPriceBonusCoeff(CurrID);
//----------------------------- передаем новую сумму счета и валюту в CGI-модуль
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    if (currID=Cache.BonusCrncCode) then begin // unit-заказ
      Stream.WriteStr(FloatToStr(RoundToHalfDown(sum))); // новая сумма заказа
      Stream.WriteStr(Cache.GetCurrName(CurrID, True));  // наименование валюты
      Stream.WriteStr('0');
    end else begin                             // обычный заказ
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));    // новая сумма заказа
      Stream.WriteStr(Cache.GetCurrName(CurrID, True)); // наименование валюты
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, bon));    // бонусы по заказу
    end;

    firma:= Cache.arFirmInfo[FirmID];
    if (firma.ResLimit>=0) and (currID<>Cache.BonusCrncCode) and fnNotZero(sum) then begin
      WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
      OrdIBS.Close;
      OrdIBS.SQL.Clear;                // проверка превышения лимита резерва к/а
      OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID,
                 ContID, OrderID, CurrID, True, False, (WareCount<2), OrdIBS);
    end;
    Stream.WriteStr(OverMess);

    Stream.WriteStr(ErrLineCodes); // коды строк, кот. не удалились

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  SetLength(arLineCodes, 0);
  Stream.Position:= 0;
end; 
//******************************************************************************
procedure prChangeQtyInOrderLineOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prChangeQtyInOrderLineOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserID, FirmID, i, WareID, contID, currID, OrderID, WareCount: integer;
    OrderCode, WareCode, Qty, s, StorageCode, UserMessage, OverMess, ordNum: string;
    QtyD, bon, price, sum, sumLn: double;
    Storages: TaSD;
    Contract: TContract;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  UserMessage:='';
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    WareCode:= Stream.ReadStr;
    OrderCode:= Stream.ReadStr;
    Qty:= Stream.ReadStr;
    QtyD:= StrToFloatDef(Qty, 0);

    prSetThLogParams(ThreadData, csChangeQtyInOrderLine, UserID, FirmID,
      'OrderId='+OrderCode+#13#10'WareCode='+WareCode+#13#10'Qty='+Qty); // логирование

    OrderID:= StrToIntDef(OrderCode, 0);
    if (OrderID<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    if (QtyD<0) then raise EBOBError.Create('Количество не может быть отрицательным');

    i:= Pos('_', WareCode);
    if (i<1) then raise EBOBError.Create('Ошибка передачи кодов товара и склада.');
    StorageCode:= Copy(WareCode, i+1, 10000);
    WareCode:= Copy(WareCode, 1, i-1);
    WareID:= StrToIntDef(WareCode, 0);
    if (WareID<1) then raise EBOBError.Create(MessText(mtkNotFoundWare, WareCode));

    if not Cache.WareExist(WareID) or Cache.GetWare(WareID).IsArchive then
      raise EBOBError.Create(MessText(mtkNotFoundWare, WareCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    s:= fnRecaclQtyByDivisibleEx(WareID, QtyD);   // проверяем кратность
    if (s<>'') then raise EBOBError.Create(s);

    OrdIBD:= cntsORD.GetFreeCnt; // сначал проверяем, существует ли такой заказ
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, true);
    OrdIBS.SQL.Text:= 'SELECT ORDRFIRM, ORDRSTATUS, ORDRCONTRACT, ORDRLNCODE, ORDRNUM'+ // , ORDRSTORAGE
      ' from ORDERSREESTR left join ORDERSLINES on ORDRLNORDER=ORDRCODE and ORDRLNWARE='+
      WareCode+' where ORDRCODE='+OrderCode;
    OrdIBS.ExecQuery;
    if OrdIBS.Bof and OrdIBS.Eof then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    // потом проверяем, можно ли заказ редактировать
    if (OrdIBS.FieldByName('ORDRSTATUS').AsInteger>orstForming) then
      raise EBOBError.Create(MessText(mtkNotEditOrder));
    // потом проверяем, имеет ли право этот человек редактировать этот заказ
    if OrdIBS.FieldByName('ORDRFIRM').AsInteger<>FirmID then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    // проверяем, существует ли такая строка
    if OrdIBS.FieldByName('ORDRLNCODE').IsNull then      //  ??? проверить
      raise EBOBError.Create(MessText(mtkNotFoundRecord));
    contID:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
    ordNum:= OrdIBS.FieldByName('ORDRNUM').AsString;
//    StorageCode:= OrdIBS.FieldByName('ORDRSTORAGE').AsString;
    OrdIBS.Close;

    with Cache.arFirmInfo[FirmID] do begin // проверяем доступность контракта
      if not CheckContract(contID) then
        contID:= Cache.arClientInfo[UserID].LastContract;
      Contract:= GetContract(contID);
      if (Contract.Status=cstClosed) then         // проверка на доступность контракта
        raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');
    end;

    i:= StrToInt(StorageCode);
    if (i<>Contract.MainStorage) then
      raise EBOBError.Create('Не найден склад для резервирования');

    // вроде все проверено, редактируем строку
    fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
    OrdIBS.SQL.Text:= 'EXECUTE PROCEDURE AEWareByStorages('+OrderCode+', '+
                      WareCode+', '+ StorageCode+', :Qty)';
    OrdIBS.ParamByName('Qty').AsFloat:= QtyD;
    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(s);

    // переоткрываем строку, чтобы получить новые цифры
    fnSetTransParams(OrdIBS.Transaction, tpRead, True);
    OrdIBS.SQL.Text:= 'SELECT ORDRSUMORDER, ORDRCURRENCY, ORDRLNCLIENTQTY, ORDRLNPRICE, OrdrWareLineCount'+
      ' from ORDERSREESTR left join ORDERSLINES on ORDRLNORDER=ORDRCODE and ORDRLNWARE='+
      WareCode+' where ORDRCODE='+OrderCode;
    OrdIBS.ExecQuery;
    if OrdIBS.Bof and OrdIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundRecord));
    if OrdIBS.FieldByName('ORDRLNCLIENTQTY').IsNull then
      raise EBOBError.Create(MessText(mtkNotValidParam));
//--------------------------------------------------- и передаем ее в CGI-модуль
    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(FormatFloat('# ##0.#', QtyD));       // входное кол-во в строке

    QtyD:= OrdIBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;
    price:= OrdIBS.FieldByName('ORDRLNPRICE').AsFloat;
    sum:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;
    CurrID:= OrdIBS.FieldByName('ORDRCURRENCY').asInteger;
    bon:= Cache.GetPriceBonusCoeff(CurrID);
    sumLn:= RoundToHalfDown(price*QtyD);

    Stream.WriteStr(FormatFloat('# ##0.#', QtyD));      // новое кол-во в строке
    if (currID=Cache.BonusCrncCode) then begin // unit-заказ
      Stream.WriteStr(FloatToStr(sumLn));                // новая сумма в строке
      Stream.WriteStr(FloatToStr(RoundToHalfDown(sum))); // новая сумма заказа
      Stream.WriteStr(Cache.GetCurrName(CurrID, True));  // наименование валюты
      Stream.WriteStr('0');
      Stream.WriteStr('0');
    end else begin                             // обычный заказ
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sumLn));     // новая сумма в строке
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));       // новая сумма заказа
      Stream.WriteStr(Cache.GetCurrName(CurrID, True));          // наименование валюты
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sumLn*bon)); // бонусы по строке
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum*bon));   // бонусы по заказу
    end;
    Stream.WriteStr(UserMessage);

    firma:= Cache.arFirmInfo[FirmID];
    if (firma.ResLimit>=0) and (currID<>Cache.BonusCrncCode) and fnNotZero(sum) then begin
      WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
      OrdIBS.Close;
      OrdIBS.SQL.Clear;                // проверка превышения лимита резерва к/а
      OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID,
                 ContID, OrderID, CurrID, True, False, (WareCount<2), OrdIBS);
    end;
    Stream.WriteStr(OverMess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
  SetLength(Storages, 0);
end;
//******************************************************************************
procedure prRefreshPricesOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prRefreshPricesOrd'; // имя процедуры/функции
var OrderCode, SResult, s: string;
    UserID, FirmID, i: integer;
begin
  SResult:= '';
  Stream.Position:= 0;
  try
    OrderCode:= Stream.ReadStr;
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csRefreshPrices, UserID, FirmID, // логирование
      'OrderCode='+OrderCode+' UserID='+IntToStr(UserID)+' FirmID='+IntToStr(FirmID));

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    s:= fnRefreshPriceInOrderOrd(SResult, OrderCode, ThreadData);
    if (s<>'') then // если функция выполнилась с ошибкой - отправляем ошибку
      if copy(s, 1, 3)='EB:' then raise EBOBError.Create(copy(s, 4, length(s)))
      else raise Exception.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(SResult);                      //  добавить номер заказа ???
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; 
//*********************************** Обновляет цены в заказе и меняет тип учета
function fnRefreshPriceInOrderOrd(var SResult: string; OrderCode: string; ThreadData: TThreadData=nil): string;
const nmProc = 'fnRefreshPriceInOrderOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    CurPrice: Double;
    OrderID, FirmID, CurrencyOld, i, j, AccTypeOld, AccTypeNew, CurrencyNew, contID: integer;
    ChangeCodes: Tai;
    ChangePrices: TDoubleDynArray;
    s: string;
    fltype: Boolean;
    Contract: TContract;
begin
  Result:= '';
  setLength(ChangeCodes, 0);
  setLength(ChangePrices, 0);
  OrdIBS:= nil;
  OrdIBD:= nil;
//  CurrencyNew:= 1;
  j:= 0;
  try
    OrderID:= StrToIntDef(OrderCode, -1);
    if (OrderID<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    try
      OrdIBD:= cntsORD.GetFreeCnt;
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, OrderID, tpRead, true);
      OrdIBS.SQL.Text:= 'select ORDRFIRM, ORDRSTATUS, ORDRCURRENCY, ORDRACCOUNTINGTYPE,'+
        ' ORDRCONTRACT from ORDERSREESTR where ORDRCODE='+OrderCode;
      OrdIBS.ExecQuery;
      if OrdIBS.Bof and OrdIBS.Eof then
        raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
      if OrdIBS.FieldByName('ORDRSTATUS').AsInteger<>orstForming then
        raise EBOBError.Create(MessText(mtkOnlyFormingOrd));

      FirmID:= OrdIBS.FieldByName('ORDRFIRM').AsInteger;
      contID:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
      CurrencyOld:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
      AccTypeOld:= OrdIBS.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;
      OrdIBS.Close;

      with Cache.arFirmInfo[FirmID] do
        if not CheckContract(contID) then contID:= GetDefContractID;
      Contract:= Cache.Contracts[ContID];

      if (CurrencyOld<>Cache.BonusCrncCode) then begin
        AccTypeNew:= Contract.PayType;
        CurrencyNew:= Contract.DutyCurrency;
      end else begin
        CurrencyNew:= CurrencyOld;
        AccTypeNew:= AccTypeOld;
      end;
      fltype:= (AccTypeNew<>AccTypeOld) or (CurrencyNew<>CurrencyOld);
      if fltype then begin
        fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
        OrdIBS.SQL.Text:= 'Update ORDERSREESTR set ORDRACCOUNTINGTYPE=:ORDRACCOUNTINGTYPE,'+  //
          'ORDRCURRENCY=:ORDRCURRENCY WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
        OrdIBS.ParamByName('ORDRACCOUNTINGTYPE').AsInteger:= AccTypeNew;
        OrdIBS.ParamByName('ORDRCURRENCY').AsInteger:= CurrencyNew;
        s:= RepeatExecuteIBSQL(OrdIBS);
        if s<>'' then raise Exception.Create(s);
        fnSetTransParams(OrdIBS.Transaction, tpRead, True);
      end;

      OrdIBS.SQL.Text:= 'select ORDRLNWARE, ORDRLNPRICE, ORDRLNCODE'+
        ' from ORDERSLINES where ORDRLNORDER='+OrderCode;
      OrdIBS.ExecQuery;
      j:= 0; // счетчик
      while not OrdIBS.EOF do begin
        i:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger;
        CurPrice:= Cache.GetWare(i).SellingPrice(FirmID, CurrencyNew, contID);
        if fnNotZero(OrdIBS.FieldByName('ORDRLNPRICE').AsFloat-CurPrice) then begin
          if Length(ChangeCodes)<(j+1) then begin
            setLength(ChangeCodes, j+10);
            setLength(ChangePrices, j+10);
          end;
          ChangeCodes[j]:= OrdIBS.FieldByName('ORDRLNCODE').AsInteger;
          ChangePrices[j]:= CurPrice;
          inc(j);
        end;
        TestCssStopException;
        OrdIBS.Next;
      end;
      OrdIBS.Close;

      fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
      if (j>0) then begin
        OrdIBS.SQL.Text:= 'UPDATE ORDERSLINES set ORDRLNPRICE=:ORDRLNPRICE where ORDRLNCODE=:ORDRLNCODE';
        OrdIBS.Prepare;
        for i:= 0 to j-1 do begin
          with OrdIBS.Transaction do if not InTransaction then StartTransaction;
          OrdIBS.ParamByName('ORDRLNCODE').AsInteger:= ChangeCodes[i];
          OrdIBS.ParamByName('ORDRLNPRICE').AsFloat:= ChangePrices[i];
          s:= RepeatExecuteIBSQL(OrdIBS);
          if s<>'' then raise Exception.Create(s);
        end;
      end;
      with OrdIBS.Transaction do if not InTransaction then StartTransaction;
      OrdIBS.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRRECALCTIME="NOW" WHERE ORDRCODE='+OrderCode;
      s:= RepeatExecuteIBSQL(OrdIBS);
      if s<>'' then raise Exception.Create(s);
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;
    if (j>0) then SResult:= 'Цены в заказе обновлены.'  // замена Result на SResult
    else SResult:= 'Цены в заказе не изменились.';
  except
    on E: EBOBError do Result:= 'EB:'+E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
  setLength(ChangeCodes, 0);
  setLength(ChangePrices, 0);
end;
//******************************************************************************
procedure prRefreshPricesInFormingOrdersOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prRefreshPricesInFormingOrdersOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, iCount: integer;
    s, sResult, sErr: string;
begin
  sResult:= '';
  sErr:= '';
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  iCount:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csRefreshPricesInFormingOrders, UserID, FirmID, ''); // логирование

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrdIBS.SQL.Text:= 'SELECT ORDRCODE, ORDRNUM FROM ORDERSREESTR WHERE ORDRSTATUS='+ // вставка ORDRNUM
      IntToStr(orstForming)+' and ORDRFIRM='+IntToStr(FirmId);
    OrdIBS.ExecQuery;
    while not OrdIBS.EOF do begin
      s:= fnRefreshPriceInOrderOrd(SResult, OrdIBS.FieldByName('ORDRCODE').AsString, ThreadData);
      if (s<>'') then                               // собираем все ошибки
        sErr:= sErr+fnIfStr(sErr='', '', #13#10)+OrdIBS.FieldByName('ORDRNUM').AsString+' '+s;
      Inc(iCount);
      TestCssStopException;
      OrdIBS.Next;
    end;
    OrdIBS.Close;
    if (iCount<1) then raise EBOBError.Create('Не найдены неотправленные заказы.');
    if (sErr<>'') then raise Exception.Create(sErr);   // если были ошибки

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end;
//======================================================== список счетов резерва
procedure prGetAccountListOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetAccountListOrd'; // имя процедуры/функции
var GBIBD, OrdIBD: TIBDatabase;
    GBIBS, OrdIBS: TIBSQL;
    i, UserId, FirmID, sPos, contID, ii: integer;
    SortOrder, SortDesc, s: string;
    Client: TClientInfo;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  GBIBS:= nil;
  GBIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    SortOrder:= Stream.ReadStr;
    SortDesc:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csGetAccountList, UserID, FirmID,
      'SortOrder='+SortOrder+#13#10'SortDesc='+SortDesc); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Client:= Cache.arClientInfo[UserID];
    ContID:= Client.GetCliCurrContID;  // код текущего/доступного контракта клиента

    OrdIBD:= cntsORD.GetFreeCnt;
    GBIBD:= cntsGRB.GetFreeCnt;

    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrdIBS.SQL.Text:= 'select ORDRCODE, ORDRNUM, ORDRDATE from ORDERSREESTR WHERE ORDRFIRM='+
      IntToStr(FirmID)+' and ORDRGBACCCODE=:ORDRGBACCCODE';
    OrdIBS.Prepare;

    GBIBS:= fnCreateNewIBSQL(GBIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'select rPInvCode DCACCODE, rPInvNumber DCACNUMBER,'+
      ' rPInvDate DCACDATE, rPInvSumm DCACSUMM, rPROCESSED DCACPROCESSED,'+
      ' rCLIENTCOMMENT, rPInvCrnc DCACCRNCCODE, rPInvLocked, rContCode'+
      ' from Vlad_CSS_GetFirmReserveDocsN('+IntToStr(FirmID)+', '+
      fnIfStr(Client.DocsByCurrContr, IntToStr(contID), '0')+')'+
      ' ORDER BY '+SortOrder+' '+SortDesc+', DCACDATE '+SortDesc+', DCACNUMBER '+SortDesc;

    GBIBS.Prepare;
    GBIBS.ExecQuery;
    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    sPos:= Stream.Position;
    Stream.WriteInt(0); // забиваем место под кол-во
    i:= 0;
    while not GBIBS.EOF do begin
      //------------------------------- фильтр по контрактам
      ii:= GBIBS.FieldByName('rContCode').AsInteger;
      if (ii<1) then s:= ''                                  // контракт неопределен
      else if (Client.CliContracts.IndexOf(ii)<0) or         // контракт недоступен
        (Client.DocsByCurrContr and (ii<>ContID)) then begin // выдаем только по текущему
        GBIBS.Next;
        Continue;
      end else s:= Client.GetCliContract(ii).Name;

      Stream.WriteInt(GBIBS.FieldByName('DCACCODE').AsInteger);
      Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('DCACDATE').AsDateTime));
      Stream.WriteByte(fnIfInt(GetBoolGB(GBibs, 'DCACPROCESSED'), byte('t'), byte('f')));
      Stream.WriteStr(GBIBS.FieldByName('DCACNUMBER').AsString+fnIfStr(GetBoolGB(GBibs, 'DCACPROCESSED'), cWebProcessed, ''));
      Stream.WriteStr(GBIBS.FieldByname('rCLIENTCOMMENT').AsString);
      Stream.WriteDouble(GBIBS.FieldByName('DCACSUMM').AsFloat);
      Stream.WriteStr(Cache.GetCurrName(GBIBS.FieldByName('DCACCRNCCODE').AsInteger, True));
      Stream.WriteStr(s);                                     // номер контракта
      Stream.WriteBool(GetBoolGB(GBibs, 'rPInvLocked')); // признак блокировки счета
      OrdIBS.ParamByName('ORDRGBACCCODE').AsInteger:= GBIBS.FieldByName('DCACCODE').AsInteger;
      OrdIBS.ExecQuery;
      if OrdIBS.Bof and OrdIBS.Eof then Stream.WriteStr('')
      else begin
        Stream.WriteStr(OrdIBS.FieldByname('ORDRCODE').AsString);
        Stream.WriteStr(FormatDateTime(cDateFormatY2, OrdIBS.FieldByname('ORDRDATE').AsDateTime));
        Stream.WriteStr(OrdIBS.FieldByname('ORDRNUM').AsString);
      end;
      OrdIBS.Close;
      TestCssStopException;
      GBIBS.Next;
      Inc(i);
    end;
    GBIBS.Close;
    Stream.Position:= sPos;
    Stream.WriteInt(i); // передаем кол-во
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(GBIBD);
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end;
//******************************************************************************
procedure prShowGBAccountOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowGBAccountOrd'; // имя процедуры/функции
var GBIBD, OrdIBD: TIBDatabase;
    GBIBS, OrdIBS: TIBSQL;
    UserId, FirmID, spos, LineCount, i, DprtID, currID, contID, ForFirmID: integer;
    AccountCode, Summa, bonuses, s, sDestName, sDestAdr, sArrive, sShipMet, sShipTime, sShipView, ss: string;
    Ware: TWareInfo;
    Client: TClientInfo;
    ShipDate, wCount, price, pDate, sum, bon: Double;
    GBdirection: Boolean;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  GBIBS:= nil;
  GBIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    AccountCode:= Stream.ReadStr;
    GBdirection:= Stream.ReadBool;

    if (FirmID<>IsWe) then ForFirmID:= FirmID  // Web
    else try
      ForFirmID:= Stream.ReadInt; // Webarm  код к/а - добавить передачу !!!
    except
      ForFirmID:= 0;
    end;

    s:= 'AccountID='+AccountCode;
    if (FirmID=IsWe) then s:= s+#10#13'ForFirmID='+IntToStr(ForFirmID);

    prSetThLogParams(ThreadData, csShowGBAccount, UserID, FirmID, s); // логирование

    if (ForFirmID<1) then
      raise EBOBError.Create(MessText(mtkNotFirmExists, IntToStr(ForFirmID)));
    i:= StrToIntDef(AccountCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundDocum, AccountCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    if (FirmID<>IsWe) then begin
      Client:= Cache.arClientInfo[UserID];
      s:= fnIntegerListToStr(Client.CliContracts); // TIntegerList - в строку через запятую
    end else s:= '';

    GBIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(GBIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'select sss.*, s.shmhname sShipMet, ss.shtiname sShipTime'+
      ' from (SELECT PInvCode, PInvNumber, PInvDate, PInvProcessed,'+
      ' PInvRecipientCode, PInvSupplyDprtCode, PINVCLIENTCOMMENT, PInvSumm,'+
      ' PINVSHIPMENTDATE, PInvCrncCode, PINVCONTRACTCODE, fddprtname,'+
      ' iif(TRTBSHIPMETHODCODE is null, PINVSHIPMENTMETHODCODE, TRTBSHIPMETHODCODE) ShipMet,'+
      ' iif(TRTBSHIPTIMECODE is null, PINVSHIPMENTTIMECODE, TRTBSHIPTIMECODE) ShipTime,'+
      ' iif(trtblnarrivetime is null, null,'+
      '   DATEADD(MINUTE, round(trtblnarrivetime), PINVSHIPMENTDATE)) arrive,'+
      ' TRTBLNDOCMCODE shiptab, gm.'+fnIfStr(GBdirection, 'RFullName ', '')+'rAdress'+
      fnIfStr(flMeetPerson, ', pphphone, prsnname', '')+
      fnIfStr(FirmID<>IsWe, '', ', gn.rNum contnum')+
      ' from PayInvoiceReestr'+
      fnIfStr(flMeetPerson,
      ' left join personphones on pphcode=PINVMEETPERSON'+
      ' left join persons on prsncode=PPhPersonCode', '')+
      ' left join TRANSPORTTIMETABLESLINES on TRTBLNCODE=pinvtripcode'+
      ' left join TRANSPORTTIMETABLESREESTR tt on tt.TRTBCODE=TRTBLNDOCMCODE'+
      ' left join FIRMDEPARTMENT on fdcode=PINVSUPPLIERFIRMDPRT'+
      fnIfStr(FirmID<>IsWe, '',
      ' left join CONTRACT on contcode=PINVCONTRACTCODE'+
      ' left join Vlad_CSS_GetFullContNum(contnumber, contnkeyyear, contpaytype) gn on 1=1')+
      ' left join '+fnIfStr(GBdirection, 'GETANRGFULLLOCATIONNAME', 'GETADRESSSTR')+
      '   (fdplasement) gm on 1=1) sss'+
      ' left join shipmentmethods s on s.shmhcode=ShipMet'+
      ' left join shipmenttimes ss on ss.shticode=ShipTime'+
      ' where PInvCode='+AccountCode+' and PInvRecipientCode='+IntToStr(ForFirmID)+
      fnIfStr(s='', '', ' and PINVCONTRACTCODE in ('+s+')');
    GBIBS.ExecQuery;
    if GBIBS.Bof and GBIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundDocum, AccountCode));

    DprtID:= GBIBS.FieldByName('PInvSupplyDprtCode').AsInteger;
    currID:= GBIBS.FieldByName('PInvCrncCode').AsInteger;
    sum:= GBIBS.FieldByName('PInvSumm').AsFloat;
    Summa:= FormatFloat(cFloatFormatSumm, sum)+' '+Cache.GetCurrName(currID, True);
    bon:= Cache.GetPriceBonusCoeff(currID);
    bonuses:= FormatFloat(cFloatFormatSumm, sum*bon);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(GBIBS.FieldByName('PInvNumber').AsString);
    Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('PInvDate').AsDateTime));

    contID:= GBIBS.FieldByName('PINVCONTRACTCODE').AsInteger;
    s:= '';
    if (FirmID=IsWe) then s:= GBIBS.FieldByName('contnum').AsString
    else if Client.CheckContract(contID) then s:= Cache.Contracts[contID].Name;
    Stream.WriteStr(s); // номер контракта

    s:= fnIfStr(GetBoolGB(GBibs, 'PInvProcessed'), 'док-т обработан', 'док-т не обработан');
    Stream.WriteStr(s+', склад резервирования "'+Cache.GetDprtMainName(DprtID)+'"');

    s:= '';
    ss:= '';
    if (FirmID<>IsWe) then try
      OrdIBD:= cntsORD.GetFreeCnt;
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
      OrdIBS.SQL.Text:= 'SELECT ORDRCODE, ORDRNUM, ORDRDATE from ORDERSREESTR'+
        ' where ORDRGBACCCODE='+AccountCode+' AND ORDRFIRM='+IntToStr(ForFirmID);
      OrdIBS.ExecQuery;
      if not (OrdIBS.Bof and OrdIBS.Eof) then begin
        s:= OrdIBS.FieldByName('ORDRCODE').AsString;
        ss:= OrdIBS.FieldByName('ORDRNUM').AsString+' от '+
          FormatDateTime(cDateFormatY2, OrdIBS.FieldByName('ORDRDATE').AsDateTime);
      end;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;
    Stream.WriteStr(s);
    Stream.WriteStr(ss);
    Stream.WriteStr(fnReplaceQuotedForWeb(GBIBS.FieldByName('PINVCLIENTCOMMENT').AsString));

    ShipDate:= GBIBS.FieldByName('pinvshipmentdate').AsDateTime;
    sDestAdr:= trim(GBIBS.FieldByName('rAdress').AsString);
    if (GBIBS.FieldByName('shiptab').AsInteger>0) and not GBIBS.FieldByName('arrive').IsNull then begin
      pDate:= GBIBS.FieldByName('arrive').AsDateTime;
      if (pDate>DateNull) then sArrive:= FormatDateTime(cDateTimeFormatY2N, pDate);
    end;
    sShipMet:= trim(GBIBS.FieldByName('sShipMet').AsString);
    sShipTime:= trim(GBIBS.FieldByName('sShipTime').AsString);
    sDestName:= trim(GBIBS.FieldByName('fddprtname').AsString);
    GBIBS.Close;

    sShipView:= '';
    if (ShipDate>DateNull) then sShipView:= sShipView+FormatDateTime(cDateFormatY2, ShipDate);
    if (sShipTime<>'') then sShipView:= sShipView+fnIfStr(sShipView='', '', ', ')+sShipTime;
    if (sShipMet<>'') then sShipView:= sShipView+fnIfStr(sShipView='', '', ', ')+sShipMet;
    if (sDestName<>'') then sShipView:= sShipView+fnIfStr(sShipView='', '', ', ')+sDestName;
    if (sDestAdr<>'') then sShipView:= sShipView+fnIfStr(sShipView='', '', ', ')+sDestAdr;
    if (sArrive<>'') then sShipView:= sShipView+fnIfStr(sShipView='', '', ', ')+'План.приб.'+sArrive;
    if (sShipView<>'') then sShipView:= 'Отгрузка: '+sShipView;
    Stream.WriteStr(sShipView);

if flMeetPerson then begin
    s:= trim(GBIBS.FieldByName('prsnname').AsString);
    ss:= GBIBS.FieldByName('pphphone').AsString;
    if (s<>'') or (ss<>'') then s:= s+' ('+ss+')';
    Stream.WriteStr(s); // встречающий
end; // flMeetPerson

    LineCount:= 0;       // счетчик - кол-во строк
    sPos:= Stream.Position;
    Stream.WriteInt(0);  //  место под кол-во строк

    GBIBS.SQL.Text:= 'select PInvLnWareCode aWARECODE,'+
      ' PInvLnOrder aORDER, PInvLnCount aCOUNT, PInvLnPrice aPRICE'+
      ' from PayInvoiceLines where PInvLnDocmCode='+AccountCode;
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      i:= GBIBS.FieldByName('aWARECODE').AsInteger;
      wCount:= GBIBS.FieldByName('aCOUNT').AsFloat;
      price:= GBIBS.FieldByName('aPRICE').AsFloat;
      Ware:= Cache.GetWare(i);
      if not Assigned(Ware) or (Ware=NoWare) then
        raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(i)));
      Stream.WriteStr(Ware.WareBrandName);
      Stream.WriteStr(Ware.Name);
      Stream.WriteStr(GBIBS.FieldByName('aORDER').AsString);
      Stream.WriteStr(GBIBS.FieldByName('aCOUNT').AsString);
      Stream.WriteStr(Ware.MeasName);
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));     // цена
      price:= RoundToHalfDown(price*wCount);                     // сумма по строке
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, price*bon)); // бонусы по строке (не unit-счет)
      inc(LineCount);
      TestCssStopException;
      GBIBS.Next;
    end;
    GBIBS.Close;
    Stream.WriteStr(Summa);   // сумма + валюта счета
    Stream.WriteStr(bonuses); // бонусы по счету
    s:= Cache.GetCurrName(Cache.BonusCrncCode, True);
    Stream.WriteStr(s);

    Stream.Position:= sPos;
    Stream.WriteInt(LineCount);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(GBIBD);
  Stream.Position:= 0;
end; 
//******************************************************************************
procedure prDeleteOrderByMarkOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prDeleteOrderByMarkOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS, OrdIBS1: TIBSQL;
    UserId, FirmID: integer;
    s, ss: string;
begin
  Stream.Position:= 0;
  OrdIBD:= nil;
  OrdIBS:= nil;
  OrdIBS1:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    s:= trim(Stream.ReadStr);

    prSetThLogParams(ThreadData, csDeleteOrderByMark, UserID, FirmID, 'IDs='+s); // логирование

    if (s='') then raise EBOBError.Create('Не найдены документы, коды='+s);

    if CheckNotValidUser(UserID, FirmID, ss) then raise EBOBError.Create(ss);

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite);
    OrdIBS1:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS1_'+nmProc, ThreadData.ID, tpWrite);
    OrdIBD.DefaultTransaction.StartTransaction;

    OrdIBS.SQL.Text:= 'SELECT r.ORDRCODE, r.ORDRNUM, r.ORDRDATE,'+
    ' IIF(exists(select ordrlncode from ORDERSLINES where ORDRLNORDER=r.ORDRCODE), 1, 0) LineCount'+
    ' from ORDERSREESTR r where r.ORDRCODE in ('+s+') and r.ORDRFIRM='+IntToStr(FirmId);
    OrdIBS.ExecQuery;
    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    while not OrdIBS.EOF do begin
      if OrdIBS.FieldByName('LineCount').AsInteger=0 then begin
        OrdIBS1.SQL.Text:= 'DELETE FROM ORDERSREESTR WHERE ORDRCODE='+OrdIBS.FieldByName('ORDRCODE').AsString;
      end else begin
        OrdIBS1.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstDeleted)+
          ' WHERE ORDRCODE='+OrdIBS.FieldByName('ORDRCODE').AsString;
      end;
      OrdIBS1.ExecQuery;
      TestCssStopException;
      OrdIBS.Next;
    end;
    OrdIBD.DefaultTransaction.Commit;
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  prFreeIBSQL(OrdIBS1);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end; 
//******************************************************************************
procedure prSetReservValueOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSetReservValueOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, i: integer;
    s, OrderCode: string;
begin
  Stream.Position:= 0;
  OrdIBD:= nil;
  OrdIBS:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    s:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csSetReservValue, UserID, FirmID,
      'OrderCode='+OrderCode+#13#10'Delivery='+s); // логирование

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

// ищем  заказ
    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, True);
    OrdIBS.SQL.Text:= 'Select ORDRSTATUS FROM ORDERSREESTR'+
      ' WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
    OrdIBS.ExecQuery;
    if OrdIBS.Bof and OrdIBS.Eof then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    // потом проверяем, можно ли заказ редактировать
    if (OrdIBS.FieldByName('ORDRSTATUS').AsInteger<>orstForming) then
      raise EBOBError.Create(MessText(mtkNotEditOrder));
    OrdIBS.Close;

    OrdIBS.SQL.Text:= 'Update ORDERSREESTR set ORDRDELIVERYTYPE=:ORDRDELIVERYTYPE'+
      ' WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
    OrdIBS.ParamByName('ORDRDELIVERYTYPE').AsInteger:= ord(S='1');
    OrdIBS.ExecQuery;
    OrdIBS.Close;
    OrdIBS.Transaction.Commit;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
      fnIfStr(assigned(OrdIBS), OrdIBS.SQL.Text, ''), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end; 
{//********************************* Установить значение поля "Тип оплаты" заказа
procedure prSetOrderPayTypeOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSetOrderPayTypeOrd'; // имя процедуры/функции
var UserId, FirmID, i: integer;
    acctype, OrderCode, SResult, s: string;
begin
  SResult:= '';
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    acctype:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csSetOrderPayType, UserID, FirmID,
      'OrderID='+OrderCode+#13#10'acctype='+acctype); // логирование

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

    s:= fnRefreshPriceInOrderOrd(SResult, OrderCode, ThreadData);
    if (s<>'') then // если функция выполнилась с ошибкой - отправляем ошибку
      if copy(s, 1, 3)='EB:' then raise EBOBError.Create(copy(s, 4, length(s)))
      else raise Exception.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; }
//************************************ Добавить строки в заказ - 2 колонки (Web)
procedure prAddLinesToOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAddLinesToOrderOrd'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS, OrdIBS1, OrdIBS2: TIBSQL;
    UserId, FirmID, WareCount, DataCount, i, j, k, ResLineQty, ii,
      LineID, sPos, WareID, OrderID, contID, currID: integer;
    s, OrderCode, WareCode, Currency, acctype, UserMessage,
      DivisibleMess, WrongWares, sSQL, OverMess, ordnum: string;
    OrderExists, LineExists, flBonusOrder: boolean;
    AnalogQty, price, bon, sum: double;
    WareCodes: Tas;
    WareQties: TDoubleDynArray; // кол-ва товара по складам
    WareQty: TDoubleDynArray; // кол-ва по товарам
    Storages: TaSD;
    Ware: TWareInfo;
    firma: TFirmInfo;
    HasAnalogs: Boolean;
    AnCodes: Tai;
    Contract: TContract;
begin
  UserMessage:= '';
  WrongWares:='';
  Stream.Position:= 0;
//  IBD:= nil;
  IBS:= nil;
  OrdIBS1:= nil;
  OrdIBS2:= nil;
  UserId:= 0;
  FirmId:= 0;
  price:= 0;
  LineExists:= False;
  LineID:= 0;
  SetLength(AnCodes, 0);
  contID:= 0;
  OverMess:= '';
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    contID:= Stream.ReadInt;  // для контрактов
    DataCount:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    sPos:= Stream.Position;
    WareCode:= Stream.ReadStr;
    Stream.Position:= sPos;

    i:= Pos('_', WareCode);
    if (i>0) then WareCode:= Copy(WareCode, 1, i-1);

    prSetThLogParams(ThreadData, csAddLinesToOrder, UserID, FirmID,
      'WareCode='+WareCode+#13#10'ContID='+IntToStr(ContID)); // логирование

    WareID:= StrToIntDef(WareCode, 0);
    if not Cache.WareExist(WareID) then
      raise Exception.Create(MessText(mtkNotFoundWare, WareCode));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    OrderID:= StrToIntDef(OrderCode, -1);
    firma:= Cache.arFirmInfo[FirmID];

    IBD:= cntsORD.GetFreeCnt;
    try
      IBS:= fnCreateNewIBSQL(IBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite);
      OrdIBS1:= fnCreateNewIBSQL(IBD, 'OrdIBS1_'+nmProc, ThreadData.ID, tpWrite);
      OrdIBS2:= fnCreateNewIBSQL(IBD, 'OrdIBS2_'+nmProc, ThreadData.ID, tpWrite);
      IBD.DefaultTransaction.StartTransaction;

      sSQL:= 'Select ORDRCURRENCY, ORDRACCOUNTINGTYPE, ORDRCONTRACT, ORDRNUM'+
          ' FROM ORDERSREESTR WHERE ORDRCODE=:ORDRCODE and ORDRSTATUS='+IntToStr(orstForming);
      OrderExists:= (OrderID>0);
      if OrderExists then begin
        IBS.SQL.Text:= sSQL;
        IBS.ParamByName('ORDRCODE').AsInteger:= OrderID;
        IBS.ExecQuery;
        OrderExists:= not (IBS.Bof and IBS.Eof);
      end;
      if OrderExists then begin
        contID:= IBS.FieldByName('ORDRCONTRACT').AsInteger;
        ordnum:= IBS.FieldByName('ORDRNUM').AsString;
      end else begin // если нет заказа - создаем
        IBS.Close;
        prCreateNewOrderCommonOrd(UserId, FirmID, OrderID, contID, s, ThreadData.ID, OrdIBS1);
        if s<>'' then raise EBOBError.Create(s);
        OrderCode:= IntToStr(OrderID);
        with IBD.DefaultTransaction do if not InTransaction then StartTransaction;
        IBS.SQL.Text:= sSQL;
        IBS.ParamByName('ORDRCODE').AsInteger:= OrderID;
        IBS.ExecQuery;
        if (IBS.Bof and IBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
      end;
  // кое-что запоминаем для себя
      currID:= IBS.FieldByName('ORDRCURRENCY').AsInteger;
      CURRENCY:= IBS.FieldByName('ORDRCURRENCY').AsString;
      acctype:= IBS.FieldByName('ORDRACCOUNTINGTYPE').AsString;
      IBS.Close;

      flBonusOrder:= (currID=Cache.BonusCrncCode);
      Ware:= Cache.GetWare(WareID);
      if (flBonusOrder<>ware.IsPrize) then
        raise EBOBError.Create('Товар '+Ware.Name+' нельзя добавить в этот заказ');

      if not firma.CheckContract(contID) then
        contID:= Cache.arClientInfo[UserId].LastContract;
      Contract:= firma.GetContract(contID);
      if (Contract.Status=cstClosed) then         // проверка на доступность контракта
        raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');

  // +++ формируем массив кодов резервируемых складов
      Storages:= fnGetStoragesArray_2col(Contract, true, True);

      SetLength(WareCodes, 10);
      WareCodes[0]:= WareCode;
      j:= 1;
      AnCodes:= fnGetAllAnalogs(WareID); // ware.Analogs;
      for i:= 0 to High(AnCodes) do
        if Cache.GetWare(AnCodes[i]).IsMarketWare(FirmID, ContID) then begin
          if (High(WareCodes)<j) then SetLength(WareCodes, j+10);
          WareCodes[j]:= IntToStr(AnCodes[i]);
          inc(j);
        end;
      if Length(WareCodes)>j then SetLength(WareCodes, j);
      SetLength(AnCodes, 0);
      WareCount:= Length(WareCodes);

      SetLength(WareQties, WareCount);   // инициация массивов
      SetLength(WareQty, WareCount);
      for i:= 0 to WareCount-1 do begin
        WareQty[i]:= 0;
        WareQties[i]:= 0;
      end;

      DivisibleMess:= '';
      for i:= 0 to DataCount-1 do begin // заполнение массивов
        s:= Stream.ReadStr;
        AnalogQty:= Stream.ReadDouble;


        k:= Pos('_', s);
        if (k<1) then Continue;

        j:= StrToIntDef(Copy(s, 1, k-1), 0);
        if (j<1) then Continue;
        j:= fnInStrArray(IntToStr(j), WareCodes); // тут получаем индекс товара
        if (j<0) then Continue;

        k:= StrToIntDef(Copy(s, k+1, 10000), 0);
        if (k<1) or (k<>Contract.MainStorage) then Continue;

        WareID:= StrToIntDef(WareCodes[j], 0);

        Ware:= Cache.GetWare(WareID);
        if (flBonusOrder<>ware.IsPrize) then
          raise EBOBError.Create('Товар '+Ware.Name+' нельзя добавить в этот заказ');

        if (AnalogQty<0) then
          raise EBOBError.Create('Товар '+Ware.Name+' - количество не может быть отрицательным');

        DivisibleMess:= fnRecaclQtyByDivisibleEx(WareID, AnalogQty); // проверяем кратность
        if (DivisibleMess<>'') then raise EBOBError.Create(DivisibleMess);

        WareQties[j]:= AnalogQty;
        WareQty[j]:= WareQty[j]+AnalogQty;
      end;
  //----------------------------------------- теперь собственно добавляем строки
      Stream.Clear;
      Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
      Stream.WriteBool(OrderExists); // Будут ли передаваться строки
      sPos:= Stream.Position;
      Stream.WriteInt(OrderID); // Код нового заказа. А если заказ старый, то тут будет место под кол-во возвращаемых строк.
      ResLineQty:= 0;
      if OrderExists then begin // если заказ формируется и открыт, то передаем все эти мутные данные
        Stream.WriteStr(AccType); // Тип оплаты. Нужен для формирования ссылки на аналоги, чтобы определить валюту.
        prSendStorages(Storages, Stream);
      end;

      IBS.SQL.Text:= 'select rNewOrderLnCode, rLineExists from AddOrderLineQty'+
        '('+OrderCode+', :ORDRLNWARE, 0, :ORDRLNWAREMEASURE, :ORDRLNPRICE, 0, 0)';
      IBS.Prepare;

      OrdIBS1.SQL.Text:='EXECUTE PROCEDURE AEWareByStorages('+OrderCode+', :WareCode, :Storage, :WareQty)';
      OrdIBS1.Prepare;

      OrdIBS2.SQL.Text:= 'execute procedure DelOrderWareLine('+OrderCode+', :WARE)';
      OrdIBS2.Prepare;

      bon:= Cache.GetPriceBonusCoeff(currID);

      SetLength(AnCodes, 0);
      for i:= 0 to WareCount-1 do begin
        Ware:= Cache.GetWare(StrToInt(WareCodes[i]));
        if not Ware.IsMarketWare(FirmID, ContID) then Continue;
//------------------------------------------------------------------------------
        if fnNotZero(WareQty[i]) then begin
          price:= Ware.SellingPrice(FirmID, currID, ContID);
          with IBS.Transaction do if not InTransaction then StartTransaction;
          IBS.ParamByName('ORDRLNWARE').AsString        := WareCodes[i]; // код товара
          IBS.ParamByName('ORDRLNWAREMEASURE').AsInteger:= Ware.MeasId;  // ед.изм.
          IBS.ParamByName('ORDRLNPRICE').AsFloat        := price;        // цена
          for ii:= 1 to RepeatCount do try
            with IBS.Transaction do if not InTransaction then StartTransaction;
            IBS.ExecQuery;
            if (IBS.Bof and IBS.Eof) then raise Exception.Create('empty IBS');
            LineID:= IBS.FieldByName('rNewOrderLnCode').AsInteger;
            LineExists:= (IBS.FieldByName('rLineExists').AsInteger=1);
            IBS.Transaction.Commit;
            IBS.Close;
            break;
          except
            on E: Exception do begin
              IBS.Transaction.RollbackRetaining;
              LineID:= 0;
              LineExists:= False;
              if (ii<RepeatCount) then sleep(RepeatSaveInterval)
              else raise Exception.Create(E.Message);
            end;
          end;
          if LineID<1 then raise Exception.Create('Ошибка записи строки товара.');

          // сажаем детализацию на главный склад
          with OrdIBS1.Transaction do if not InTransaction then StartTransaction;
          OrdIBS1.ParamByName('WareCode').AsString:= WareCodes[i];
          OrdIBS1.ParamByName('Storage').AsString:= Contract.MainStoreStr;
          OrdIBS1.ParamByName('WareQty').AsFloat := WareQties[i];
          s:= RepeatExecuteIBSQL(OrdIBS1);
          if s<>'' then raise Exception.Create(s);

          if OrderExists then begin // если заказ формируется и открыт, то передаем все эти мутные данные
            // и передаем ее в CGI-модуль
            Stream.WriteByte(fnIfInt(LineExists, constOpEdit, constOpAdd));
            Stream.WriteInt(LineID);
            Stream.WriteStr(WareCodes[i]);

//            AnCodes:= fnGetAllAnalogs(StrToInt(WareCodes[i]));
            HasAnalogs:= (ware.AnalogLinks.LinkCount>0); // Length(AnCodes)>0;
//            SetLength(AnCodes, 0);
            sum:= RoundToHalfDown(price*WareQty[i]); // сумма по строке

            Stream.WriteStr(fnIfStr(HasAnalogs, '1', '0'));
            Stream.WriteStr(Ware.WareBrandName);
            Stream.WriteStr(Ware.Name);
            Stream.WriteStr(FormatFloat('# ##0', WareQty[i]));
            Stream.WriteStr(Ware.MeasName);
            if (currID=Cache.BonusCrncCode) then begin // unit-заказ
              Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));  // цена
              Stream.WriteStr(FloatToStr(sum));                     // сумма по строке
              Stream.WriteStr('0');
            end else begin                             // обычный заказ
              Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));   // цена
              Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));     // сумма по строке
              Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum*bon)); // бонусы
            end;
            Stream.WriteStr(trim(FormatFloat('###0.#', WareQties[i])));  // передаем текущее кол-во заказа
            Inc(ResLineQty);
          end; //  if not OrderExists then begin // если не новый заказ, то передаем все эти мутные данные
//------------------------------------------------------------------------------
        end else if OrderExists then begin // если товара заказано 0 и заказ существует, то удаляем строку заказа и раскладку товара по складам
          with OrdIBS2.Transaction do if not InTransaction then StartTransaction;
          OrdIBS2.ParamByName('WARE').AsString:= WareCodes[i];
          s:= RepeatExecuteIBSQL(OrdIBS2);
          if s<>'' then raise Exception.Create(s);
          Stream.WriteByte(constOpDel);
          Stream.WriteStr(WareCodes[i]);
          Inc(ResLineQty);
        end; // if fnNotZero(WareQty[i])
        IBS.Close;
        OrdIBS1.Close;
        OrdIBS2.Close;
      end; // for i:=0 to WareCount-1 do begin

      if OrderExists then begin // если заказ формируется и открыт, то передаем новую сумму заказа и валюту
        with IBS.Transaction do if not InTransaction then StartTransaction;
        IBS.SQL.Text:= 'SELECT ORDRSUMORDER, OrdrWareLineCount'+
                       ' from ORDERSREESTR where ORDRCODE='+OrderCode;
        IBS.ExecQuery;
        if (IBS.Bof and IBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
        price:= IBS.FieldByName('ORDRSUMORDER').AsFloat;
        if (currID=Cache.BonusCrncCode) then begin // unit-заказ
          Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));
          Stream.WriteStr(Cache.GetCurrName(currID, True));
          Stream.WriteStr('0');
        end else begin                             // обычный заказ
          Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
          Stream.WriteStr(Cache.GetCurrName(currID, True));
          Stream.WriteStr(FormatFloat(cFloatFormatSumm, price*bon));
        end;
        Stream.WriteStr(UserMessage);
        Stream.Position:= sPos;
        Stream.WriteInt(ResLineQty); // записываем кол-во товаров (возвращаемых записей)

        if (firma.ResLimit>=0) and OrderExists and not flBonusOrder and fnNotZero(price) then begin
          WareCount:= IBS.FieldByName('OrdrWareLineCount').AsInteger;
          IBS.Close;
          IBS.SQL.Clear;               // проверка превышения лимита резерва к/а
          OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID,
                     ContID, OrderID, CurrID, True, False, (WareCount<2), IBS);
        end;
        Stream.Position:= Stream.Size;
        Stream.WriteStr(OverMess);

      end else Stream.WriteStr(UserMessage);
    finally
      prFreeIBSQL(IBS);
      prFreeIBSQL(OrdIBS1);
      prFreeIBSQL(OrdIBS2);
      cntsORD.SetFreeCnt(IBD);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
                      ' UID='+IntToStr(UserID)+' FID='+IntToStr(FirmID)+' OID='+OrderCode+
                      ' price='+FormatFloat(cFloatFormatSumm, price), False);
  end;
  Stream.Position:= 0;
  SetLength(Storages, 0);
  SetLength(WareCodes, 0);
  SetLength(WareQty, 0);
  SetLength(AnCodes, 0);
end;
//=========== добавить товар в заказ непосредственно из результатов поиска (Web)
procedure prAddLineFromSearchResToOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAddLineFromSearchResToOrderOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, j, LineID, OrderID, WareID, CurrID, ContID, WareCount: integer;
    s, OrderCode, WareCode, UserMessage, OverMess, ordNum: string;
    OrderExists, flBonusOrder: boolean;
    WareQty, price, bon, sum: double;
    Storages: TaSD;
    Ware: TWareInfo;
    HasAnalogs{, NotSendLine}: Boolean;
    anw: Tai;
    firma: TFirmInfo;
    Contract: TContract;
  //-------------------------------
  procedure AddWareLine; // запись строки товара и детализации
  begin
    with OrdIBS.Transaction do if not InTransaction then StartTransaction;
    OrdIBS.SQL.Text:= 'select rNewOrderLnCode from AddOrderLineQty'+
      '('+OrderCode+', '+WareCode+', 0, :ORDRLNMEAS, :ORDRLNPRICE, 0, 0)'; // код заказа, код товара, ...
    OrdIBS.ParamByName('ORDRLNMEAS').AsInteger:= Ware.MeasId;  // ед.изм.
    OrdIBS.ParamByName('ORDRLNPRICE').AsFloat := price;        // цена
    LineID:= 0;
    s:= RepeatExecuteIBSQL(OrdIBS, 'rNewOrderLnCode', LineID);
    if (s<>'') then raise Exception.Create(s);
    if (LineID<1) then raise Exception.Create('rNewOrderLnCode < 1');

    with OrdIBS.Transaction do if not InTransaction then StartTransaction;
    OrdIBS.SQL.Text:= 'EXECUTE PROCEDURE AEWareByStorages('+
      OrderCode+', '+WareCode+', '+Contract.MainStoreStr+', :WareQty)';
    OrdIBS.ParamByName('WareQty').AsFloat:= WareQty;
    s:= RepeatExecuteIBSQL(OrdIBS);
    if (s<>'') then raise Exception.Create(s);
  end;
  //-------------------------------
begin
  Stream.Position:= 0;
  OrdIBD:= nil;
  OrdIBS:= nil;
  UserId:= 0;
  FirmId:= 0;
  price:= 0;
  LineID:= 0;
  CurrID:= 0;
  contID:= 0;
  OverMess:= '';
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    OrderCode:= Stream.ReadStr;
    WareCode:= Stream.ReadStr;
    WareQty:= StrToFloatDef(Stream.ReadStr, 1);
//    NotSendLine:= (Stream.ReadInt=1); // не передавать строки

    prSetThLogParams(ThreadData, csAddLineFromSearchResToOrder, UserID, FirmID,
      'WareCode='+WareCode+#13#10'WareQty='+FormatFloat('###0.#', WareQty)+
      #13#10'OrderCode='+OrderCode+#13#10'ContID='+IntToStr(ContID)); // логирование

    WareID:= StrToIntDef(WareCode, 0);
    if not Cache.WareExist(WareID) or Cache.GetWare(WareID).IsArchive then
      raise EBOBError.Create(MessText(mtkNotFoundWare, WareCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    if (WareQty<0) then
      raise EBOBError.Create('Количество не может быть отрицательным');

    firma:= Cache.arFirmInfo[FirmId];
    OrderID:= StrToIntDef(OrderCode, -1);
    OrderCode:= IntToStr(OrderID);

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, true);
    OrderExists:= (OrderID>0);
    if OrderExists then begin
      OrdIBS.SQL.Text:= 'Select ORDRCURRENCY, ORDRCONTRACT, ORDRNUM FROM ORDERSREESTR'+
        ' WHERE ORDRCODE='+OrderCode+' and ORDRSTATUS='+IntToStr(orstForming);
      OrdIBS.ExecQuery;
      OrderExists:= not (OrdIBS.Bof and OrdIBS.Eof);
      if OrderExists then begin       // кое-что запоминаем для себя
        CURRID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
        j:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
        if firma.CheckContract(j) then ContID:= j;
        ordNum:= OrdIBS.FieldByName('ORDRNUM').AsString;
      end;
      OrdIBS.Close;
    end;
    if not firma.CheckContract(contID) then
      contID:= Cache.arClientInfo[UserID].LastContract;
    Contract:= firma.GetContract(contID);
    if (Contract.Status=cstClosed) then         // проверка на доступность контракта
      raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteBool(OrderExists); // Будут ли передаваться строки

    Ware:= Cache.GetWare(WareID);
//------------------------------------------------------------------- заказ есть
    if OrderExists then begin
      flBonusOrder:= (currID=Cache.BonusCrncCode);
      if (flBonusOrder<>ware.IsPrize) then
        raise EBOBError.Create('Товар '+Ware.Name+' нельзя добавить в этот заказ');
                                               // кое-что запоминаем для себя
      OrdIBS.SQL.Text:= 'Select ORDRLNCODE FROM ORDERSLINES WHERE ORDRLNORDER='+
                        OrderCode+' and ORDRLNWARE='+WareCode;
      OrdIBS.ExecQuery;      // если товар уже есть, то сообщаем пользователю
      if not (OrdIBS.Bof and OrdIBS.Eof) then raise Exception.Create('WareExists');
      OrdIBS.Close;

      UserMessage:= fnRecaclQtyByDivisibleEx(WareID, WareQty);   // проверяем кратность
      if UserMessage<>'' then raise EBOBError.Create(UserMessage);

  // формируем массив кодов видимых резервируемых складов
      Storages:= fnGetStoragesArray_2col(Contract, true, True);

      price:= Ware.SellingPrice(FirmID, CURRID, ContID);
      if flBonusOrder then HasAnalogs:= False       // unit-заказ
      else begin                                    // обычный заказ
//        anw:= fnGetAllAnalogs(WareID);
        HasAnalogs:= (ware.AnalogLinks.LinkCount>0);  // Length(anw)>0;
//        SetLength(anw, 0);
      end;

  // теперь собственно добавляем строки
      // если заказ формируется и открыт, то передаем все эти мутные данные
      prSendStorages(Storages, Stream);

      AddWareLine; // запись строки товара и детализации
      sum:= RoundToHalfDown(price*WareQty);
      bon:= Cache.GetPriceBonusCoeff(CURRID);

      Stream.WriteInt(LineID);        // передаем посаженную строку в CGI-модуль
      Stream.WriteStr(WareCode);

      Stream.WriteStr(fnIfStr(HasAnalogs, '1', '0'));
      Stream.WriteStr(Ware.WareBrandName);
      Stream.WriteStr(Ware.Name);
      Stream.WriteStr(FormatFloat('# ##0', WareQty));
      Stream.WriteStr(Ware.MeasName);
      if flBonusOrder then begin                // unit-заказ
        Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));
        Stream.WriteStr(FloatToStr(sum));
        Stream.WriteStr('0');
      end else begin                            // обычный заказ
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum));
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, RoundToHalfDown(price*WareQty*bon)));
      end;
      Stream.WriteStr(trim(FormatFloat('###0.#', WareQty))); // передаем текущее кол-во заказа

      OrdIBS.Close;
      with OrdIBS.Transaction do if not InTransaction then StartTransaction;
      OrdIBS.SQL.Text:= 'Select ORDRSUMORDER, OrdrWareLineCount'+
        ' FROM ORDERSREESTR WHERE ORDRCODE='+OrderCode+' and ORDRSTATUS='+IntToStr(orstForming);
      OrdIBS.ExecQuery;
      if (OrdIBS.Bof and OrdIBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
      price:= OrdIBS.FieldByName('ORDRSUMORDER').AsFloat;
      if flBonusOrder then begin                 // unit-заказ
        Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));
        Stream.WriteStr(Cache.GetCurrName(CURRID, True));
        Stream.WriteStr('0');
      end else begin                             // обычный заказ
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
        Stream.WriteStr(Cache.GetCurrName(CURRID, True));
        Stream.WriteStr(FormatFloat(cFloatFormatSumm, RoundToHalfDown(price*bon)));
      end;
      Stream.WriteStr(UserMessage);

      if (firma.ResLimit>=0) and OrderExists and not flBonusOrder and fnNotZero(price) then begin
        WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
        OrdIBS.Close;
        OrdIBS.SQL.Clear;              // проверка превышения лимита резерва к/а
        OverMess:= CheckOrdWaresExAndOverLimit(FirmID, UserID,
                                    ContID, OrderID, CurrID, True, False, (WareCount<2), OrdIBS);
      end;
      Stream.WriteStr(OverMess);

//------------------------------------------------------------------- нет заказа
    end else begin
      //------------------------------------------------------- призовой заказ
      if ware.IsPrize then begin
        CurrID:= Cache.BonusCrncCode;
        OrdIBS.SQL.Text:= 'SELECT ORDRCODE, ORDRCONTRACT,'+ // ищем бонусный заказ
          ' iif(exists(select * from ORDERSLINES where ORDRLNORDER='+OrderCode+
          '   and ORDRLNWARE='+WareCode+'), 1, 0) WareEx'+
          ' from ORDERSREESTR where ORDRFIRM='+IntToStr(FirmID)+
          ' and ORDRSTATUS='+IntToStr(orstForming)+' and ORDRCURRENCY='+IntToStr(CurrID);
        OrdIBS.ExecQuery;
        if not (OrdIBS.Bof and OrdIBS.Eof) then begin // нашли
          if (OrdIBS.FieldByName('WareEx').AsInteger>0) then // такой товар в заказе есть
            raise Exception.Create('WareExists');
          contID:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger; // код заказа
          OrderID:= OrdIBS.FieldByName('ORDRCODE').AsInteger;    // код счета
          OrdIBS.Close;
        end else begin // если нет - создаем новый бонусный заказ
          OrdIBS.Close;
//          contID:= Cache.arClientInfo[UserID].LastContract;
          contID:= 0;
          prCreateNewOrderCommonOrd(UserId, FirmID, OrderID, contID, s, ThreadData.ID, OrdIBS, CurrID);
          if (s<>'') then raise EBOBError.Create(s);
        end;
        OrderCode:= IntToStr(OrderID);

      //-------------------------------------------------------- обычный заказ
      end else begin                   // создаем
        prCreateNewOrderCommonOrd(UserId, FirmID, OrderID, ContID, s, ThreadData.ID, OrdIBS);
        if s<>'' then raise EBOBError.Create(s);
        OrderCode:= IntToStr(OrderID);
        with OrdIBD.DefaultTransaction do if not InTransaction then StartTransaction;
        OrdIBS.SQL.Text:= 'Select ORDRCURRENCY FROM ORDERSREESTR'+
          ' WHERE ORDRCODE='+OrderCode+' and ORDRSTATUS='+IntToStr(orstForming);
        OrdIBS.ExecQuery;              // кое-что запоминаем для себя
        if (OrdIBS.Bof and OrdIBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
        CURRID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
        OrdIBS.Close;
      end;

      UserMessage:= fnRecaclQtyByDivisibleEx(WareID, WareQty);   // проверяем кратность
      if (UserMessage<>'') then raise EBOBError.Create(UserMessage);

      price:= Ware.SellingPrice(FirmID, CURRID, ContID);
      //-------------------------------- теперь собственно добавляем строку
      AddWareLine; // запись строки товара и детализации
      Stream.WriteStr(UserMessage);
      Stream.WriteStr(OrderCode);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do if (E.Message='WareExists') then begin
        Stream.Clear;
        Stream.WriteInt(erFindedDouble)
      end else prSaveCommonError(Stream, ThreadData, nmProc, E.Message,
        ' UID='+IntToStr(UserID)+' FID='+IntToStr(FirmID)+' OID='+OrderCode+
        ' price='+FormatFloat(cFloatFormatSumm, price), False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
  SetLength(Storages, 0);
  SetLength(anw, 0);
end;
//================================== список регионов для формы регистрации фирмы
procedure prGetRegisterTableOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetRegisterTableOrd'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    j, sPos: integer;
begin
  ibs:= nil;
  ibd:= nil;
  Stream.Position:= 0;
  try
    prSetThLogParams(ThreadData, csGetRegisterTable, 0, 0, ''); // логирование

    ibd:= cntsORD.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, ThreadData.ID, tpRead, True);
    ibs.SQL.Text:= 'select RGZNCODE, RGZNNAME from REGIONALZONES z'+
                   ' where not RGZNNAME="" and not z.rgznemail="" order by RGZNNAME';
    ibs.ExecQuery;
    if (IBS.Bof and IBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    sPos:= Stream.Position;
    Stream.WriteInt(0); // место под кол-во строк
    j:= 0; // счетчик
    while not ibs.EOF do begin
      Stream.WriteInt(ibs.FieldByName('RGZNCODE').AsInteger);
      Stream.WriteStr(ibs.FieldByName('RGZNNAME').AsString);
      inc(j);
      TestCssStopException;
      ibs.Next;
    end;
    ibs.Close;
    Stream.Position:= sPos;
    Stream.WriteInt(j);
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(ibs);
  cntsORD.SetFreeCnt(ibd);
  Stream.Position:= 0;
end;
//============================= запись заявки на регистрацию фирмы в системе СВК
procedure prSaveRegOrderOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveRegOrderOrd'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    Firm, FIO, Post, Login, Address, Phones, Email, IP, s, RegName, RegMail,
      link, Town, sFirmType, sRegion: string;
    IsClient: boolean;
    Region, FirmType, dprtID,i: integer;
    Strings: TStringList;
  //------------------------------- задаем значения
  procedure SetIbsParams;
  begin
    ibs.ParamByName('OREGFIRMNAME').AsString    := Firm;
    ibs.ParamByName('OREGREGION').AsInteger     := Region;
    ibs.ParamByName('OREGMAINUSERFIO').AsString := FIO;
    ibs.ParamByName('OREGMAINUSERPOST').AsString:= Post;
    ibs.ParamByName('OREGLOGIN').AsString       := Login;
    ibs.ParamByName('OREGCLIENT').AsString      := fnIfStr(IsClient, 'T', 'F');
    ibs.ParamByName('OREGADDRESS').AsString     := Address;
    ibs.ParamByName('OREGPHONES').AsString      := Phones;
    ibs.ParamByName('OREGEMAIL').AsString       := Email;
    ibs.ParamByName('OREGTYPE').AsInteger       := FirmType;
    ibs.ParamByName('OREGIP').AsString          := IP;
    ibs.ParamByName('OREGDPRTCODE').AsInteger   := dprtID;
  end;
  //-------------------------------
begin
  Stream.Position:= 0;
  link:= 'order';
  dprtID:= 0;
  ibs:= nil;
  ibd:= nil;
  Strings:= nil;
  try
    Firm:= trim(Stream.ReadStr);
    sRegion:= trim(Stream.ReadStr);
    FIO:= trim(Stream.ReadStr);
    Post:= trim(Stream.ReadStr);
    Login:= trim(Stream.ReadStr);
    IsClient:= trim(Stream.ReadStr)='1';
    Town:= trim(Stream.ReadStr);
    Address:= trim(Stream.ReadStr);
    Phones:= trim(Stream.ReadStr);
    Email:= trim(Stream.ReadStr);
    sFirmType:= trim(Stream.ReadStr);
    IP:= trim(Stream.ReadStr);

    prSetThLogParams(ThreadData, csSaveRegOrder, 0, 0, 'Firm='+Firm+ // логирование
      #13#10' Region='+sRegion+#13#10' FIO='+FIO+#13#10' Post='+Post+
      #13#10' Login='+Login+#13#10+fnIfStr(IsClient, 'is Client', 'not Client')+
      #13#10' Town='+Town+#13#10' Address='+Address+#13#10' Phones='+Phones+
      #13#10' Email='+Email+#13#10' FirmType='+sFirmType+#13#10' IP='+IP);

    Region:= StrToInt(sRegion);
    FirmType:= StrToInt(sFirmType);

    if (Firm='') then raise EBOBError.Create('Не задано наименование организациии.');
    if (FIO='') then raise EBOBError.Create('Не задано ФИО главного пользователя.');
    if (Post='') then raise EBOBError.Create('Не задана Должность главного пользователя.');
    if (Town='') then raise EBOBError.Create('Не задан город/пгт');
    if (Address='') then raise EBOBError.Create('Не задан адрес');
    if (Phones='') then raise EBOBError.Create('Не задан телефон');
    if (Email='') then raise EBOBError.Create('Не задан Email');
    if not fnCheckEmail(Email) then raise EBOBError.Create('Некорректный Email');
    if (not FirmType in [0..3]) then raise EBOBError.Create('Некорректный тип организации');
    if (Login='') then raise EBOBError.Create('Не задан логин главного пользователя');
    if not fnCheckOrderWebLogin(Login) then  // проверяем логин
      raise EBOBError.Create(MessText(mtkNotValidLogin, IntToStr(Cache.CliLoginLength)));
    if not fnNotLockingLogin(Login) then // проверяем, не относится ли логин к запрещенным
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));

    ibd:= cntsORD.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, ThreadData.ID, tpRead, True);
    ibs.SQL.Text:= 'Select WOCLCODE from WEBORDERCLIENTS where WOCLUPPERLOGIN='+QuotedStr(UpperCase(Login));
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then // проверяем, не относится ли логин к уже сущетвующим
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));
    ibs.Close;

    ibs.SQL.Text:= 'select RGZNNAME, RGZNFILIALLINK'+  // , RGZNEMAIL
      ' from REGIONALZONES WHERE RGZNCODE='+IntToStr(Region);
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise EBOBError.Create('Некорректный регион.');
    dprtID:= ibs.FieldByName('RGZNFILIALLINK').AsInteger;
    RegName:= ibs.FieldByName('RGZNNAME').AsString;
//    RegMail:= ibs.FieldByName('RGZNEMAIL').AsString;
    ibs.Close;

    if Cache.DprtExist(dprtID) and Cache.arDprtInfo[dprtID].IsFilial then begin
      s:= Cache.arDprtInfo[dprtID].MailOrder;
      link:= copy(s, 1, pos('@', s)-1);
    end else dprtID:= Cache.arDprtInfo[1].FilialID; // центр

    Strings:= TStringList.Create;      // готовим письмо с необрезанными значениями
    Strings.Add('Организация: '+Firm);
    Strings.Add('Регион: '+RegName);
    Strings.Add('Город/пгт: '+Town);
    Strings.Add('Адрес: '+Address);
    Strings.Add('ФИО главного пользователя: '+FIO);
    Strings.Add('Должность главного пользователя: '+Post);
    Strings.Add('Логин главного пользователя: '+Login);
    Strings.Add('Клиент Компании: '+fnIfStr(IsClient, 'Да', 'Нет'));
    Strings.Add('Телефон: '+Phones);
    Strings.Add('Email: '+Email);
    case FirmType of
      0: s:= 'СТО';
      1: s:= 'Магазин';
      2: s:= 'Стол заказов';
      else s:= 'Другой';
    end;
    Strings.Add('Тип организации: '+s);

    Address:= Town+', '+Address;
                                // обрезаем текстовые значения по размерам полей
    ibs.SQL.Text:= 'select f.RDB$FIELD_NAME fname, ff.RDB$FIELD_LENGTH fsize'+
    ' from rdb$relation_fields f, rdb$fields ff'+
    ' where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE and f.RDB$RELATION_NAME=:table';
    ibs.ParamByName('table').AsString:= 'ORDERTOREGISTER';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      s:= trim(ibs.FieldByName('fname').AsString);
      i:= ibs.FieldByName('fsize').AsInteger;
      if (s='OREGFIRMNAME')          and (length(Firm)>i)    then Firm:= Copy(Firm, 1, i)
      else if (s='OREGMAINUSERFIO')  and (length(FIO)>i)     then FIO:= Copy(FIO, 1, i)
      else if (s='OREGMAINUSERPOST') and (length(Post)>i)    then Post:= Copy(Post, 1, i)
      else if (s='OREGLOGIN')        and (length(Login)>i)   then Login:= Copy(Login, 1, i)
      else if (s='OREGADDRESS')      and (length(Address)>i) then Address:= Copy(Address, 1, i)
      else if (s='OREGPHONES')       and (length(Phones)>i)  then Phones:= Copy(Phones, 1, i)
      else if (s='OREGEMAIL')        and (length(Email)>i)   then Email:= Copy(Email, 1, i)
      else if (s='OREGIP')           and (length(IP)>i)      then IP:= Copy(IP, 1, i);
      TestCssStopException;
      ibs.Next;
    end;  
    ibs.Close;
                                   // проверяем, нет ли уже такой заявки
    ibs.SQL.Text:= 'select OREGCODE FROM ORDERTOREGISTER'+
      ' where OREGFIRMNAME=:OREGFIRMNAME and OREGREGION=:OREGREGION'+
      ' and OREGMAINUSERFIO=:OREGMAINUSERFIO and OREGMAINUSERPOST=:OREGMAINUSERPOST'+
      ' and OREGLOGIN=:OREGLOGIN and OREGCLIENT=:OREGCLIENT'+
      ' and OREGADDRESS=:OREGADDRESS and OREGPHONES=:OREGPHONES'+
      ' and OREGEMAIL=:OREGEMAIL and OREGTYPE=:OREGTYPE'+
      ' and OREGIP=:OREGIP and OREGDPRTCODE=:OREGDPRTCODE';
    SetIbsParams; // задаем значения
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then
      raise EBOBError.Create('Такая заявка уже зарегистрирована в системе.');
    ibs.Close;

    fnSetTransParams(ibs.Transaction, tpWrite, True);
    ibs.SQL.Text:= 'insert into ORDERTOREGISTER'+
      ' (OREGFIRMNAME, OREGREGION, OREGMAINUSERFIO, OREGMAINUSERPOST,'+
      ' OREGLOGIN, OREGCLIENT, OREGADDRESS, OREGPHONES,'+
      ' OREGEMAIL, OREGTYPE, OREGIP, OREGDPRTCODE) values'+
      ' (:OREGFIRMNAME, :OREGREGION, :OREGMAINUSERFIO, :OREGMAINUSERPOST,'+
      ' :OREGLOGIN, :OREGCLIENT, :OREGADDRESS, :OREGPHONES,'+
      ' :OREGEMAIL, :OREGTYPE, :OREGIP, :OREGDPRTCODE)';
    SetIbsParams; // задаем значения
    s:= RepeatExecuteIBSQL(IBS);
    if s<>'' then raise Exception.Create(s);

    RegMail:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // СП
    s:= n_SysMailSend(RegMail, 'Заявка на регистрацию в системе СВК', Strings, nil, '', '', true);
    if s<>'' then fnWriteToLog(ThreadData, lgmsCryticalSysError, nmProc,
      'Ошибка отправки письма о новой заявке на регистрацию: ', s, '');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(link);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(erMissRegData);
      Stream.WriteStr(fnReplaceQuotedForWeb(E.Message));
    end;
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(ibs);
  cntsORD.SetFreeCnt(ibd);
  prFree(Strings);
  Stream.Position:= 0;
end;
//==================================== список городов для формы регистрации UBER
procedure prGetRegisterUberTowns(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetRegisterUberTowns'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    j: integer;
    lst, ls: TStringList;
begin
  ibs:= nil;
  ibd:= nil;
  Stream.Position:= 0;
  lst:= fnCreateStringList(True, dupIgnore);
  ls:= TStringList.Create;
  try
    prSetThLogParams(ThreadData, csGetRegisterUberTowns, 0, 0, ''); // логирование

    ibd:= cntsORD.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, ThreadData.ID, tpRead, True);
    ibs.SQL.Text:= 'select RGZNuberTowns from REGIONALZONES z'+
                   ' where RGZNuberTowns is not null and RGZNuberTowns<>""';
    ibs.ExecQuery;
    while not ibs.EOF do begin
      ls:= fnSplit(',', ibs.FieldByName('RGZNuberTowns').AsString);
      try
        for j:= 0 to ls.Count-1 do lst.Add(ls[j]);
      finally
        ls.Clear;
      end;
      TestCssStopException;
      ibs.Next;
    end;
    ibs.Close;
    if (lst.Count<1) then raise EBOBError.Create('Не найден список городов');
    if (lst.Count>1) then lst.Sort;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(lst.Count); // кол-во строк
    for j:= 0 to lst.Count-1 do Stream.WriteStr(lst[j]);

  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(ibs);
  cntsORD.SetFreeCnt(ibd);
  prFree(lst);
  prFree(ls);
  Stream.Position:= 0;
end;
//============================== запись заявки на регистрацию UBER в системе СВК
procedure prSaveRegOrderUber(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveRegOrderUber'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    Firm, FIO, Login, Phone, Email, IP, s, RegName, RegMail, link, Town, Card: string;
    Region, dprtID, i: integer;
    Strings: TStringList;
  //------------------------------- задаем значения
  procedure SetIbsParams;
  begin
    ibs.ParamByName('OREGFIRMNAME').AsString    := Firm;
    ibs.ParamByName('OREGREGION').AsInteger     := Region;
    ibs.ParamByName('OREGMAINUSERFIO').AsString := FIO;
    ibs.ParamByName('OREGMAINUSERPOST').AsString:= '-';    // должность
    ibs.ParamByName('OREGLOGIN').AsString       := Login;
    ibs.ParamByName('OREGADDRESS').AsString     := Town;
    ibs.ParamByName('OREGPHONES').AsString      := Phone;
    ibs.ParamByName('OREGEMAIL').AsString       := Email;
    ibs.ParamByName('OREGTYPE').AsInteger       := 3;      // Другой
    ibs.ParamByName('OREGIP').AsString          := IP;
    ibs.ParamByName('OREGDPRTCODE').AsInteger   := dprtID;
  end;
  //-------------------------------
begin
  Stream.Position:= 0;
  link:= 'order';
  ibs:= nil;
  ibd:= nil;
  Strings:= nil;
  Region:= 0;
  dprtID:= 0;
  RegName:= '';
  try
    Card:= trim(Stream.ReadStr);   // Номер карты UBER
    Town:= trim(Stream.ReadStr);   // Город (пока - Киев, Одесса, Харьков, Львов, Днепр)
    FIO:= trim(Stream.ReadStr);    // ФИО
    Phone:= trim(Stream.ReadStr);  // Телефон
    Email:= trim(Stream.ReadStr);  // E-mail
    IP:= trim(Stream.ReadStr);

    prSetThLogParams(ThreadData, csSaveRegOrderUber, 0, 0, 'Card='+Card+ // логирование
      #13#10' Town='+Town+#13#10' FIO='+FIO+#13#10' Phone='+Phone+
      #13#10' Email='+Email+#13#10' IP='+IP);

    if (Card='')  then raise EBOBError.Create('Не задан N карты.');
    if (FIO='')   then raise EBOBError.Create('Не задано ФИО пользователя.');
    if (Town='')  then raise EBOBError.Create('Не задан город');
    if (Email='') then raise EBOBError.Create('Не задан Email');
    if not fnCheckEmail(Email) then raise EBOBError.Create('Некорректный Email');
    if (Phone='') then raise EBOBError.Create('Не задан телефон');
//    if not CheckMobileNumber(Phone) then raise EBOBError.Create('Некорректный номер мобильного телефона');
    Login:= GetMobileNumber10(Phone); // номер мобильного телефона без +38 или пусто, если номер некорректный
    if (Login='') then raise EBOBError.Create('Некорректный номер мобильного телефона');
    Phone:= '+38'+Login; // приводим к меж/нар
    Firm:= 'UBER '+Card;

{   if not fnCheckOrderWebLogin(Login) then  // проверяем логин
      raise EBOBError.Create(MessText(mtkNotValidLogin, IntToStr(Cache.CliLoginLength)));
    if not fnNotLockingLogin(Login) then // проверяем, не относится ли логин к запрещенным
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));   }

    ibd:= cntsORD.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, ThreadData.ID, tpRead, True);
    ibs.SQL.Text:= 'Select WOCLCODE from WEBORDERCLIENTS where WOCLUPPERLOGIN='+QuotedStr(UpperCase(Login));
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then // проверяем, не относится ли логин к уже сущетвующим
      raise EBOBError.Create(MessText(mtkLockingLogin, Login));
    ibs.Close;

    ibs.SQL.Text:= 'select RGZNCODE, RGZNNAME, RGZNFILIALLINK from REGIONALZONES'+
      ' WHERE ","||RGZNuberTowns||"," containing ",'+Town+',"';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise EBOBError.Create('Не найден регион.');
    Region:= ibs.FieldByName('RGZNCODE').AsInteger;
    dprtID:= ibs.FieldByName('RGZNFILIALLINK').AsInteger;
    RegName:= ibs.FieldByName('RGZNNAME').AsString;
    ibs.Close;

    if Cache.DprtExist(dprtID) and Cache.arDprtInfo[dprtID].IsFilial then begin
      s:= Cache.arDprtInfo[dprtID].MailOrder;
      link:= copy(s, 1, pos('@', s)-1);
    end else dprtID:= Cache.arDprtInfo[1].FilialID; // центр

    Strings:= TStringList.Create;      // готовим письмо с необрезанными значениями
    Strings.Add('Наименование: '+Firm);
    Strings.Add('Город: '+Town);
    Strings.Add('ФИО пользователя: '+FIO);
    Strings.Add('Телефон: '+Phone);
    Strings.Add('Email: '+Email);
    Strings.Add('Логин пользователя: '+Login);
    Strings.Add('Регион: '+RegName);
                                // обрезаем текстовые значения по размерам полей
    ibs.SQL.Text:= 'select f.RDB$FIELD_NAME fname, ff.RDB$FIELD_LENGTH fsize'+
    ' from rdb$relation_fields f, rdb$fields ff'+
    ' where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE and f.RDB$RELATION_NAME=:table';
    ibs.ParamByName('table').AsString:= 'ORDERTOREGISTER';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      s:= trim(ibs.FieldByName('fname').AsString);
      i:= ibs.FieldByName('fsize').AsInteger;
      if (s='OREGFIRMNAME')          and (length(Firm)>i)  then Firm := Copy(Firm, 1, i)
      else if (s='OREGMAINUSERFIO')  and (length(FIO)>i)   then FIO  := Copy(FIO, 1, i)
      else if (s='OREGLOGIN')        and (length(Login)>i) then Login:= Copy(Login, 1, i)
      else if (s='OREGADDRESS')      and (length(Town)>i)  then Town := Copy(Town, 1, i)
      else if (s='OREGPHONES')       and (length(Phone)>i) then Phone:= Copy(Phone, 1, i)
      else if (s='OREGEMAIL')        and (length(Email)>i) then Email:= Copy(Email, 1, i)
      else if (s='OREGIP')           and (length(IP)>i)    then IP   := Copy(IP, 1, i);
      TestCssStopException;
      ibs.Next;
    end;
    ibs.Close;
                                   // проверяем, нет ли уже такой заявки
    ibs.SQL.Text:= 'select OREGCODE FROM ORDERTOREGISTER'+
      ' where OREGFIRMNAME=:OREGFIRMNAME and OREGREGION=:OREGREGION'+
      ' and OREGMAINUSERFIO=:OREGMAINUSERFIO and OREGLOGIN=:OREGLOGIN'+
      ' and OREGMAINUSERPOST=:OREGMAINUSERPOST and OREGCLIENT=:OREGCLIENT'+
      ' and OREGADDRESS=:OREGADDRESS and OREGPHONES=:OREGPHONES'+
      ' and OREGEMAIL=:OREGEMAIL and OREGTYPE=:OREGTYPE'+
      ' and OREGIP=:OREGIP and OREGDPRTCODE=:OREGDPRTCODE';
    SetIbsParams; // задаем значения
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then
      raise EBOBError.Create('Такая заявка уже зарегистрирована в системе.');
    ibs.Close;

    fnSetTransParams(ibs.Transaction, tpWrite, True); // пишем заявку в базу
    ibs.SQL.Text:= 'insert into ORDERTOREGISTER (OREGFIRMNAME, OREGREGION,'+
      ' OREGMAINUSERFIO, OREGMAINUSERPOST, OREGLOGIN, OREGADDRESS, OREGPHONES,'+
      ' OREGEMAIL, OREGTYPE, OREGIP, OREGDPRTCODE) values (:OREGFIRMNAME,'+
      ' :OREGREGION, :OREGMAINUSERFIO, :OREGMAINUSERPOST, :OREGLOGIN,'+
      ' :OREGADDRESS, :OREGPHONES, :OREGEMAIL, :OREGTYPE, :OREGIP, :OREGDPRTCODE)';
    SetIbsParams; // задаем значения
    s:= RepeatExecuteIBSQL(IBS);
    if s<>'' then raise Exception.Create(s);

    RegMail:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // СП
    s:= n_SysMailSend(RegMail, 'Заявка на регистрацию UBER в системе СВК', Strings, nil, '', '', true);
    if s<>'' then fnWriteToLog(ThreadData, lgmsCryticalSysError, nmProc,
      'Ошибка отправки письма о новой заявке на регистрацию UBER: ', s, '');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(link);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(erMissRegData);
      Stream.WriteStr(fnReplaceQuotedForWeb(E.Message));
    end;
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(ibs);
  cntsORD.SetFreeCnt(ibd);
  prFree(Strings);
  Stream.Position:= 0;
end;

//******************************************************************************
//================ Исправляет кол-во товара в заказе в соответствии с кратностью
function fnRecaclQtyByDivisible(WareID: integer; var WareQty: double): string;
var Ware: TWareInfo;
    d: Double;
begin
  Result:= '';
  Ware:= Cache.GetWare(WareID);
  d:= WareQty/Ware.Divis;
  if not (fnNotZero(d-Round(d))) then Exit;
  WareQty:= (Trunc(d)+1)*Ware.Divis;
  Result:= 'Кол-во товара изменено на '+FormatFloat('# ##0.#', WareQty)+
    ' в соответствии с кратностью '+FormatFloat('# ##0.#', Ware.Divis);
end;
//============================ Проверяет соответствие кол-ва товара с кратностью
function fnRecaclQtyByDivisibleEx(WareID: integer; WareQty: double): string;
var Ware: TWareInfo;
    d: Double;
begin
  Result:= '';
  Ware:= Cache.GetWare(WareID);
  d:= WareQty/Ware.Divis;
  if not fnNotZero(d-Round(d)) then Exit;
  WareQty:= (Trunc(d)+1)*Ware.Divis;
  Result:= 'Кол-во товара '+Ware.Name+' не соответствует кратности '+
    FormatFloat('# ##0.#', Ware.Divis)+', рекомендуем заказать '+FormatFloat('# ##0.#', WareQty);
end;
//************************************ для вывода остатков в 1/2/3 колонки (Web)
procedure prGetQtyByAnalogsAndStoragesOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetQtyByAnalogsAndStoragesOrd'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserID, FirmID, i, ia, StorageCount, WareCount, WareID, sPos, currID, aCode: integer;
    s, WareCode, OrderCode, ErrPos, PriceFormat, ActTitle, ActText: string;
    Storages: TaSD;
    WareQty, WareTotal: double;
    qty, qty0, qty1, qty2: double;
    OrderExists, WareOrAnalogInOrder, flAdd: boolean;
    Ware: TWareInfo;
//    OList: TObjectList;
    ar: Tai;
    firma: TFirmInfo;
    arOrderWareQties: Tas;
    owID, owIndex: integer;
    contID: integer;
    Contract: TContract;
    prices, rests: TDoubleDynArray;
//    wa: TWareAction;
begin
  Stream.Position:= 0;
  FirmID:= 0;
  UserID:= 0;
  OrdIBD:= nil;
  OrdIBS:= nil;
  SetLength(ar, 0);
  SetLength(arOrderWareQties, 0);
  OrderExists:= false;
  WareTotal:= 0;
  WareOrAnalogInOrder:= false;
  WareQty:= -1;
  contID:= 0;
  currID:= 0;
  try
ErrPos:= '1';
    try
      UserID:= Stream.ReadInt;
      FirmID:= Stream.ReadInt;
      ContID:= Stream.ReadInt; // для контрактов
      OrderCode:= trim(Stream.ReadStr);
      WareCode:= trim(Stream.ReadStr);
      WareQty:= Stream.ReadDouble;
      if (WareQty<constDeltaZero) then WareQty:= 1;
ErrPos:= '2';
    finally
      prSetThLogParams(ThreadData, csGetQtyByAnalogsAndStorages, UserID, FirmID,
        'OrderCode='+OrderCode+', WareCode='+WareCode+', WareQty='+FloatToStr(WareQty)+
        #13#10'ContID='+IntToStr(ContID)); // логирование
    end;
ErrPos:= '3';
    aCode:= StrToIntDef(OrderCode, 0);
    WareID:= StrToIntDef(WareCode, 0);
    if not Cache.WareExist(WareID) then raise Exception.Create(MessText(mtkNotFoundWare, WareCode));
ErrPos:= '4';
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    firma:= Cache.arFirmInfo[FirmID];
    Cache.arClientInfo[UserID].CheckQtyCount; // счетчик запросов наличия

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
    OrderExists:= (aCode>0);

    if OrderExists then try
      OrdIBS.SQL.Text:= 'Select ORDRCURRENCY, ORDRLNCODE, ORDRCONTRACT FROM ORDERSREESTR'+
        ' left join ORDERSLINES on ORDRLNORDER=ORDRCODE and ORDRLNWARE='+WareCode+
        ' WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmId)+' and ORDRSTATUS='+IntToStr(orstForming);
      OrdIBS.ExecQuery;
      OrderExists:= not (OrdIBS.Bof and OrdIBS.Eof);
      if OrderExists then begin // если товар уже есть в заказе - потом будем игнорировать ввод
        WareOrAnalogInOrder:= not OrdIBS.FieldByName('ORDRLNCODE').IsNull;
        currID:= OrdIBS.FieldByName('ORDRCURRENCY').AsInteger;
        contID:= OrdIBS.FieldByName('ORDRCONTRACT').AsInteger;
      end;
    finally
      OrdIBS.Close;
    end;

    Contract:= firma.GetContract(contID);
    if (Contract.Status=cstClosed) then         // проверка на доступность контракта
      raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');
//    if (not OrderExists) then Currency:= IntToStr(Contract.DutyCurrency); // если заказа нет, берем валюту из текущего контракта
    if not OrderExists then  // если заказа нет
      currID:= Cache.arClientInfo[UserID].SearchCurrencyID;  // берем валюту из настроек пользователя

ErrPos:= '5';
    ar:= fnGetAllAnalogs(WareID);  // Cache.GetWare(WareID).Analogs;
ErrPos:= '6';
    Storages:= fnGetStoragesArray_2col(Contract); // формируем массив кодов складов - 2 колонки
    StorageCount:= Length(Storages);
    flAdd:= (StorageCount>2);

    if OrderExists then try
      SetLength(arOrderWareQties, Length(ar)+1); // сначала вход.товар(индекс 0), потом аналоги(индексы от 1)
      for i:= 0 to High(arOrderWareQties) do arOrderWareQties[i]:= '0';

      OrdIBS.SQL.Text:= 'Select OWBSSTORAGE, OWBSQTY, ORDRLNWARE'+
        ' FROM ORDERSLINES, ORDERSWAREBYSTORAGES'+
        ' WHERE OWBSORDERLINE=ORDRLNCODE AND ORDRLNORDER='+OrderCode+
        ' order by ORDRLNWARE, OWBSSTORAGE';
ErrPos:= '11';
      OrdIBS.ExecQuery; // запоминаем строковые количества из заказа в массив
      while not OrdIBS.Eof do begin
        owID:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger; // ищем индекс товара
        if (owID=WareID) then owIndex:= 0   // сначала вход.товар
        else begin
          owIndex:= fnInIntArray(owID, ar); // потом аналоги
          if (owIndex>-1) then Inc(owIndex);
        end;
        qty:= 0;
        while not OrdIBS.Eof and (owID=OrdIBS.FieldByName('ORDRLNWARE').AsInteger) do begin
          if owIndex>-1 then qty:= qty+OrdIBS.FieldByName('OWBSQTY').AsFloat;
          TestCssStopException;
          OrdIBS.Next;
        end;
        if fnNotZero(qty) then arOrderWareQties[owIndex]:= trim(FormatFloat('###0.#', qty));
      end;
    finally
      OrdIBS.Close;
    end; // if OrderExists

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    sPos:= Stream.Position;
    Stream.WriteInt(0); // место под кол-во возвращаемых товаров. Логичней было бы его
                        // передать позже, но сюда удобней потом адресоваться для вписывания факта
    Stream.WriteStr(Cache.GetCurrName(currID, True)); //
    Stream.WriteStr(FormatFloat('###0.#', WareQty)); //
    Stream.WriteStr(WareCode); //
    prSendStorages(Storages, Stream);

    WareCount:= 0;
    for ia:= 0 to High(ar)+1 do begin
      if (ia=0) then Ware:= Cache.GetWare(WareID) else Ware:= Cache.GetWare(ar[ia-1]);
      Stream.WriteInt(Ware.ID);            // код товара
      Stream.WriteStr(Ware.PgrName);
      Stream.WriteStr(Ware.Name);
      Stream.WriteBool(Ware.IsSale);       // признак распродажи
      Stream.WriteBool(ware.IsNonReturn);  // признак невозврата
      Stream.WriteBool(ware.IsCutPrice);   // признак уценки
      Stream.WriteStr(Ware.PrDirectName);  // название направления по продуктам

      aCode:= Ware.GetActionParams(ActTitle, ActText);
      Stream.WriteInt(aCode);         // код акции
      Stream.WriteStr(ActTitle);      // заголовок
      Stream.WriteStr(ActText);       // текст

//------------------------------------------------- цены Гроссби
      prices:= ware.CalcFirmPrices(FirmID, currID, contID); // цены (0- Розница, 1- со скидкой, 2- со след.скидкой)
      if Ware.IsPrize then PriceFormat:= '# ##0.#' else PriceFormat:= cFloatFormatSumm;
      for i:= 0 to High(prices) do Stream.WriteStr(trim(FormatFloat(PriceFormat, prices[i])));
//------------------------------------------------- цены Гроссби
      Stream.WriteStr(Ware.MeasName);
//      qty0:= 0; // кол-во на складе по умолчанию
//      qty1:= 0; // кол-во на остальных видимых складах
//      qty2:= 0; // кол-во на складах доп.видимости
      rests:= GetContWareRestsByCols(ware.ID, ContID, StorageCount);
      qty0:= rests[0];                                        // кол-во на складе по умолчанию
      if (StorageCount>1) then qty1:= rests[1] else qty1:= 0; // кол-во на складах поставки на завтра
      if flAdd then qty2:= rests[2] else qty2:= 0;             // кол-во на складах поставки > 1 дня

      Stream.WriteStr(fnRestValuesForWeb(WareQty, qty0)); // 1 - кол-во на складе по умолчанию
      if (ia=0) then begin // товар
        WareTotal:= qty0+qty1+qty2;
        if WareOrAnalogInOrder then s:= arOrderWareQties[ia]  // передаем текущее кол-во заказа
        else s:= FormatFloat('###0.#', WareQty); // в строку ввода должно попасть первоначальное значение
      end else begin       // аналог
        if OrderExists then s:= arOrderWareQties[ia] else s:= '0';
      end;
      Stream.WriteStr(s);

      Stream.WriteStr(fnRestValuesForWeb(WareQty, qty1)); // 2 - кол-во на складах поставки на завтра
      if flAdd then
        Stream.WriteStr(fnRestValuesForWeb(WareQty, qty2)); // 3 - кол-во на складах поставки > 1 дня

      Inc(WareCount);
    end;

    Stream.Position:= sPos;
    Stream.WriteInt(WareCount); // записываем кол-во товаров (возвращаемых записей)

//---------------- Записываем факт интереса пользователя для дальнейшего анализа
ErrPos:= '18-1';
    fnSetTransParams(OrdIBS.Transaction, tpWrite, True);
    OrdIBS.SQL.Text:= 'INSERT INTO WareRequests (WRWAREID, WRUSERID, WRFROM,'+
      ' WRQTY, WRREST, WRTIME)VALUES ('+WareCode+', '+IntToStr(UserID)+', '+
      fnIfStr(OrderExists, '1', '0')+', :clientqty, :totalqty, "NOW")';
    OrdIBS.ParamByName('clientqty').AsFloat:= WareQty;
    OrdIBS.ParamByName('totalqty').AsFloat:= WareTotal;
ErrPos:= '18-2';
    s:= RepeatExecuteIBSQL(OrdIBS);
    if (s<>'') then fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', s, 'ErrPos='+ErrPos);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, 'ErrPos='+ErrPos, False);
  end;
  Stream.Position:= 0;
  SetLength(ar, 0);
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  SetLength(Storages, 0);
  SetLength(prices, 0);
  SetLength(rests, 0);
  if OrderExists then SetLength(arOrderWareQties, 0);
//  prFree(OList);
end;
//============================================= склады контракта - 1/2/3 колонки
function fnGetStoragesArray_2col(Contract: TContract; ReservedOnly: boolean=false;
                                 DefaultOnly: boolean=false): TasD;
var j, StoreID: integer;
    s: string;
    flAdd: Boolean;
begin
  SetLength(Result, 0);
  StoreID:= Contract.MainStorage;
  flAdd:= Cache.arDprtInfo[Contract.MainStorage].HasDprtFrom2;
  s:= '-'+Cache.GetDprtMainName(StoreID);

  if DefaultOnly then SetLength(Result, 1)
  else if not flAdd then SetLength(Result, 2)
  else SetLength(Result, 3);

  j:= 0;
  Result[j].Code     := IntToStr(StoreID);
  Result[j].FullName := s+', сегодня';
  Result[j].ShortName:= Cache.GetDprtColName(StoreID);
  Result[j].IsVisible:= True;
  Result[j].IsReserve:= True;
  Result[j].IsSale   := True;
  if DefaultOnly then Exit;

  j:= 1;
  Result[j].Code     := IntToStr(cAggregativeStorage);
  Result[j].FullName := s+', завтра';
  Result[j].ShortName:= 'Завтра';
  Result[j].IsVisible:= True;
  Result[j].IsReserve:= False;
  Result[j].IsSale   := False;
  if not flAdd then Exit;

  j:= 2;
  Result[j].Code     := IntToStr(cAggregativeStorage+1);
  Result[j].FullName := s+', > 1 дня';
  Result[j].ShortName:= '> 1 дня';
  Result[j].IsVisible:= True;
  Result[j].IsReserve:= False;
  Result[j].IsSale   := False;
end;
//************************************************************ изменение наценок
procedure prSetCliContMargins(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSetCliContMargins'; // имя процедуры/функции
var UserId, FirmID, contID, i, iCount, grpID, parID, errCount: integer;
    errmess, s, ss: string;
    mlst: TLinkList;
    link, ParLink: TQtyLink;
    Client: TClientInfo;
    grp: TWareInfo;
    marg: Double;
    err: array of TCodeAndQty;
begin
  Stream.Position:= 0;
//  contID:= 0;
  errCount:= 0;
  errmess:= '';
  SetLength(err, 0);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    contID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csSetCliContMargins, UserID, FirmID, 'ContID='+IntToStr(ContID)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Client:= Cache.arClientInfo[UserID];
    if not Client.CheckContract(contID) then raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));

    mlst:= Client.GetContMarginLinks(contID);         // ссылки на наценки клиента

    iCount:= Stream.ReadInt; // кол-во строк
    SetLength(err, iCount);
    for i:= 1 to iCount do begin
      grpID:= Stream.ReadInt;
      marg:= Stream.ReadDouble;

      if not Cache.GrPgrExists(grpID) then begin
        ss:= 'не найдена группа, код '+IntToStr(grpID);
        errmess:= errmess+fnIfStr(errmess='', '', #13#10)+ss;
        err[errCount].ID:= grpID;
        err[errCount].Qty:= 0;
        Inc(errCount);
        Continue;
      end;

      link:= mlst.GetLinkListItemByID(grpID, lkLnkByID);
      if Assigned(link) and fnNotZero(marg)
        and not fnNotZero(link.Qty-marg) then Continue; // такая наценка есть

      grp:= Cache.arWareInfo[grpID];
      if grp.IsPgr and fnNotZero(marg) then begin  // если подгруппа и наценка<>0
        parID:= grp.PgrID; // код группы
        ParLink:= mlst.GetLinkListItemByID(parID, lkLnkByID);
        if Assigned(ParLink) and not fnNotZero(ParLink.Qty-marg) then begin
          marg:= 0; // убираем дубляж наценки группы
          if not Assigned(link) then Continue;
        end;
      end;

      s:= Client.CheckCliContMargin(contID, grpID, marg); // пишем в базу

      if (s<>'') then begin // ошибки
        ss:= 'ошибка записи наценки по группе '+grp.Name;
        errmess:= errmess+fnIfStr(errmess='', '', #13#10)+ss+' ('+IntToStr(grpID)+'): '+s;
        err[errCount].ID:= grpID;
        if Assigned(link) then marg:= link.Qty else marg:= 0;
        err[errCount].Qty:= marg;
        Inc(errCount);
        Continue;
      end;

      if not Assigned(link) and fnNotZero(marg) then begin // добавляем
        link:= TQtyLink.Create(0, marg, grp);
        mlst.AddLinkListItem(link, lkLnkByID, Client.CS_client);
      end else if Assigned(link) then
        if not fnNotZero(marg) then                        // удаляем
          mlst.DelLinkListItemByID(grpID, lkLnkByID, Client.CS_client)
        else try                                           // меняем
          Client.CS_client.Enter;
          link.Qty:= marg;
        finally
          Client.CS_client.Leave;
        end;
    end; // for

    if (errmess<>'') then prMessageLOGS(nmProc+': '+errmess);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteInt(errCount); // кол-во ошибок
    for i:= 0 to errCount-1 do begin
      Stream.WriteInt(err[i].ID);     // код группы/подгруппы
      Stream.WriteDouble(err[i].Qty); // текущая наценка группы/подгруппы
    end;

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(err, 0);
  Stream.Position:= 0;
end;

//------------------------------------------------------------ vc
//========================= передает данные по правам юзеров данного контрагента
procedure prGetAllUsersInfo(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetAllUsersInfo'; // имя процедуры/функции
var UserId, FirmID, i, ii: integer;
    Users, NonUsers: Tai;
    Person: TClientInfo;
    s: string;
    Firm: TFirmInfo;
    Contracts: TIntegerList;
    Contract: TContract;
begin
  Stream.Position:= 0;
  SetLength(Users, 0);
  SetLength(NonUsers, 0);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetAllUsersInfo, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Firm:= Cache.arFirmInfo[FirmId];
    // сначала проверяем, есть ли у пользователя право на такой запрос
    if (UserID<>Firm.SUPERVISOR) or Firm.IsFinalClient then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    for i:= 0 to High(Firm.FirmClients) do begin  // получаем список должн.лиц, исключая главного
      ii:= Firm.FirmClients[i];
      if not Cache.ClientExist(ii) or (ii=UserID) then Continue;
      Person:= Cache.arClientInfo[ii];
      if (Person.Login<>'') then
        prAddItemToIntArray(ii, Users)
      else if (ExtractFictiveEmail(Person.Mail)<>'') // наличие нефиктивного Email
//        and (Person.Post<>'') then                   // наличие должности
        and (CheckClientFIO(Person.Name)='') then    // соответствие ФИО пользователя шаблону
        prAddItemToIntArray(ii, NonUsers);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    Contracts:= Firm.FirmContracts;
    for i:= 0 to Contracts.Count-1 do begin
      ii:= Contracts[i];
      Contract:= Cache.Contracts[ii];
      Stream.WriteInt(Contract.ID);
      Stream.WriteStr(Contract.Name);
      Stream.WriteInt(0);  //      Stream.WriteInt(Contract.SysID);
    end;

    Stream.WriteInt(Length(Users));  // кол-во пользователей с логинами
    for i:= 0 to High(Users) do begin
      ii:= Users[i];
      Person:= Cache.arClientInfo[ii];
      Stream.WriteInt(ii);           // код
      Stream.WriteStr(Person.Name);  // ФИО
      Stream.WriteStr(Person.Post);  // должность
      Stream.WriteStr(Person.Login); // логин
      for ii:= 0 to Contracts.Count-1 do
        Stream.WriteBool(Person.CheckContract(Contracts[ii]));
    end;

    Stream.WriteInt(Length(NonUsers)); // кол-во пользователей б/логинов
    for i:= 0 to High(NonUsers) do begin
      ii:= NonUsers[i];
      Stream.WriteInt(ii);             // код
      Person:= Cache.arClientInfo[ii];
      Stream.WriteStr(Person.Name);    // ФИО
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(Users, 0);
  SetLength(NonUsers, 0);
  Stream.Position:= 0;
end;
//============================================= Заявка на изменение данных (Web)
procedure prSendOrderForChangeData(kind: Integer; Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSendOrderForChangeData'; // имя процедуры/функции
var UserId, FirmID, UserDel, i, j, command, jj: integer;
    Person: TClientInfo;
    Firm: TFirmInfo;
    text, s, sKind, sUser, sFirm, FIO: string;
    lstBodyMail: TStringList;
begin
  Stream.Position:= 0;
  lstBodyMail:= nil;
  UserDel:= 0;
  FIO:= '';
  lstBodyMail:= TStringList.Create;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    case kind of // принимаем данные в зависимости от вида
      resAdded: begin
        command:= csSendOrderForAddContactPerson;
        text:= '';
        FIO:= trim(Stream.ReadStr);  // FIO
        s:= 'FIO='+FIO;
        if (FIO<>'') then text:= 'ФИО      : '+FIO;
        sFirm:= trim(Stream.ReadStr);  // Post
        s:= s+#13#10'Post='+sFirm;
        if (sFirm<>'') then
          text:= text+fnIfStr(s='', '', #13#10)+'Должность: '+sFirm;
        sFirm:= trim(Stream.ReadStr);  // Mail
        if not fnCheckEmail(sFirm) then
          raise EBOBError.Create('Некорректный E-mail: '+sFirm);
        s:= s+#13#10'Mail='+sFirm;
        if (sFirm<>'') then
          text:= text+fnIfStr(s='', '', #13#10)+'Email    : '+sFirm;
        sFirm:= trim(Stream.ReadStr);  // Phones
        s:= s+#13#10'Phones='+sFirm;
        if (sFirm<>'') then
          text:= text+fnIfStr(s='', '', #13#10)+'Телефоны : '+sFirm;
      end; // resAdded

      resEdited: begin
        command:= csSendOrderForChangePersonData;
        text:= trim(Stream.ReadStr);
        lstBodyMail.Text:= text;
        for i:= 0 to lstBodyMail.Count-1 do begin // ищем email
          sFirm:= lstBodyMail[i];
          j:= pos('Удалить', sFirm);
          if (j>0) then Continue;    // строки удаления не проверяем
          j:= pos('email', sFirm);
          if (j<1) then Continue;    // не email не проверяем

          sFirm:= copy(sFirm, j+6, length(sFirm));
          jj:= pos('на', sFirm); // если "Заменить ... на ..."
          if (jj>0) then sFirm:= copy(sFirm, jj+2, length(sFirm));
          if not fnCheckEmail(sFirm) then
            raise EBOBError.Create('Некорректный E-mail: '+sFirm);
        end;
        lstBodyMail.Clear;
        s:= 'text='+text;
      end; // resEdited

      resDeleted: begin
        command:= csSendOrderForDelContactPerson;
        UserDel:= Stream.ReadInt;
        s:= 'UserDel='+IntToStr(UserDel);
      end; // resDeleted
      else raise Exception.Create('Неизвестный вид заявки - '+IntToStr(kind));
    end;

    prSetThLogParams(ThreadData, command, UserID, FirmID, s); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Firm:= Cache.arFirmInfo[FirmID];
    if Firm.IsFinalClient and (kind in [resAdded, resDeleted]) then
      raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

    if (UserID=Firm.SUPERVISOR) then sUser:= 'Главный пользователь'
    else sUser:= 'Пользователь';

    case kind of
      resAdded: begin
        if (text='') then raise EBOBError.Create(MessText(mtkNotFoundData));
        if (UserID<>Firm.SUPERVISOR) then // проверяем право пользователя на запрос
          raise EBOBError.Create(MessText(mtkNotRightExists));
        sKind:= 'добавление контактного лица';
      end; // resAdded

      resEdited: begin
        if (text='') then raise EBOBError.Create(MessText(mtkNotFoundData));
        sKind:= 'изменение персональных'+
          fnIfStr((UserID=Firm.SUPERVISOR), ' или контактных', '')+' данных';
      end; // resEdited

      resDeleted: begin
        if (UserID<>Firm.SUPERVISOR) then // проверяем право пользователя на запрос
          raise EBOBError.Create(MessText(mtkNotRightExists));
        if CheckNotValidUser(UserDel, FirmID, s) then raise EBOBError.Create(s);
        sKind:= 'удаление контактного лица';
        Person:= Cache.arClientInfo[UserDel];
        text:= 'ФИО      : '+Person.Name+#13#10'Должность: '+Person.Post+
               #13#10'Логин    : '+Person.Login;
      end; // resDeleted
    end;

    Person:= Cache.arClientInfo[UserID];
    sFirm:= '(к/а '+Firm.Name+' ['+Firm.UPPERSHORTNAME+'])';
    sUser:= sUser+' '+Person.Name+' с логином `'+Person.Login+'`';
    if (FIO='') then FIO:= Person.Name;

    lstBodyMail.Add(sUser+#13#10'  '+sFirm+#13#10'  отправил заявку на '+sKind+':'#13#10);
    lstBodyMail.Add(text);

    s:= n_SysMailSend(Cache.GetConstItem(pcUIKdepartmentMail).StrValue,
                      'Заявка на '+sKind+' '+FIO+' '+sFirm, lstBodyMail);
    if s<>'' then begin
      if (Pos(MessText(mtkErrMailToFile), s)<1) then
        s:= 'Ошибка отправки письма.'#13#10+'Заявка записана и будет отправлена позже.'
      else s:= 'Ошибка отправки письма: '#13#10+s;
      raise EBOBError.Create(s);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(lstBodyMail);
end;
//================================================ отметка доступности контракта
procedure prChangeContractAccess(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prChangeContractAccess'; // имя процедуры/функции
var UserId, FirmID, Victim, Contract: integer;
    Person: TClientInfo;
    s: string;
    AllowContract: boolean;
begin
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    Victim:= Stream.ReadInt;
    Contract:= Stream.ReadInt;
    AllowContract:= Stream.ReadBool;

    prSetThLogParams(ThreadData, csChangeContractAccess, UserID, FirmID, // логирование
      'Victim='+IntToStr(Victim)+#13#10'Contract='+IntToStr(Contract)+
      #13#10'AllowContract='+BoBBoolToStr(AllowContract));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    // сначала проверяем, есть ли у пользователя право на такой запрос
    if (UserID<>Cache.arFirmInfo[FirmId].SUPERVISOR) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    if CheckNotValidUser(Victim, FirmID, s) then raise EBOBError.Create(s);

    Person:= Cache.arClientInfo[Victim];
    if (AllowContract) then Person.AddCliContract(Contract)
    else Person.DelCliContract(Contract);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//======================================================= список товаров резерва
procedure prGetWaresFromAccountList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetWaresFromAccountList'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    i, UserId, FirmID, ii, contID, pos: Integer;
    SortOrder, SortDesc, s: string;
    Ware: TWareInfo;
    Client: TClientInfo;
    fl: Boolean;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    SortOrder:= Stream.ReadStr;
    SortDesc:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csGetWaresFromAccountList, UserID, FirmID,
      'SortOrder='+SortOrder+#13#10'SortDesc='+SortDesc); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Client:= Cache.arClientInfo[UserID];
    ContID:= Client.GetCliCurrContID;  // код текущего/доступного контракта клиента

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'select PINVLNWARECODE DCACLNWARECODE, '+
      ' WAREOFFICIALNAME, PINVLNCOUNT DCACLNCOUNT, rPROCESSED DCACPROCESSED,'+
      ' PINVLNPRICE DCACLNPRICE, rPInvCrnc DCACCRNCCODE, rPInvCode DCACCODE,'+
      ' rPInvNumber DCACNUMBER, rPInvDate DCACDATE, rContCode'+
      ' from Vlad_CSS_GetFirmReserveDocsN('+IntToStr(FirmID)+ ', '+
      fnIfStr(Client.DocsByCurrContr, IntToStr(contID), '0')+')'+
      ' left join PAYINVOICELINES on PINVLNDOCMCODE=rPInvCode'+
      ' left join WARES on WARECODE=PINVLNWARECODE where PINVLNCOUNT>0'+
      ' ORDER BY '+SortOrder+' '+SortDesc+', WAREOFFICIALNAME '+SortDesc+
      ', DCACDATE '+SortDesc+', DCACNUMBER '+SortDesc;
    GBIBS.Prepare;
    GBIBS.ExecQuery;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    pos:= Stream.Position;
    Stream.WriteInt(0); // забиваем место под кол-во
    i:= 0;
    while not GBIBS.EOF do begin
      //------------------------------- фильтр по контрактам
      ii:= GBIBS.FieldByName('rContCode').AsInteger;
      if (ii<1) then s:= ''                                  // контракт неопределен
      else if (Client.CliContracts.IndexOf(ii)<0) or         // контракт недоступен
        (Client.DocsByCurrContr and (ii<>ContID)) then begin // выдаем только по текущему
        TestCssStopException;
        GBIBS.Next;
        Continue;
      end else s:= Client.GetCliContract(ii).Name;
      fl:= GetBoolGB(GBIBS, 'DCACPROCESSED');
      Ware:= Cache.GetWare(GBIBS.FieldByName('DCACLNWARECODE').AsInteger);
      Stream.WriteStr(Ware.WareBrandName);
      Stream.WriteStr(GBIBS.FieldByName('WAREOFFICIALNAME').AsString);
      Stream.WriteDouble(GBIBS.FieldByName('DCACLNCOUNT').AsFloat);
      Stream.WriteDouble(GBIBS.FieldByName('DCACLNPRICE').AsFloat);
      Stream.WriteStr(Cache.GetCurrName(GBIBS.FieldByName('DCACCRNCCODE').AsInteger, True));
      Stream.WriteStr(s);                                     // номер контракта
      Stream.WriteByte(fnIfInt(fl, byte('t'), byte('f')));
      Stream.WriteStr(GBIBS.FieldByName('DCACCODE').AsString);
      Stream.WriteStr(GBIBS.FieldByName('DCACNUMBER').AsString+fnIfStr(fl, cWebProcessed, ''));
      Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('DCACDATE').AsDateTime));
      TestCssStopException;
      GBIBS.Next;
      Inc(i);
    end;
    GBIBS.Close;
    Stream.Position:= pos;
    Stream.WriteInt(i); // передаем кол-во
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//=========================================================== просмотр накладной
procedure prShowGBOutInvoice(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowGBOutInvoice'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, ForFirmID, LineCount, Pos, contID, WareID: integer;
    OutInvoiceID, Summa, s, ss: string;
    Ware: TWareInfo;
    Client: TClientInfo;
    price, qty: Double;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  Client:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OutInvoiceID:= Stream.ReadStr;

    if (FirmID<>IsWe) then ForFirmID:= FirmID  // Web
    else try
      ForFirmID:= Stream.ReadInt; // Webarm  код к/а - добавить передачу !!!
    except
      ForFirmID:= 0;
    end;

    s:= 'OutInvoiceID='+OutInvoiceID;
    if (FirmID=IsWe) then s:= s+#10#13'ForFirmID='+IntToStr(ForFirmID);

    prSetThLogParams(ThreadData, csShowGBOutInvoice, UserID, FirmID, s); // логирование

    LineCount:= StrToIntDef(OutInvoiceID, 0);
    if (LineCount<1) then raise EBOBError.Create(MessText(mtkNotFoundDocum, OutInvoiceID));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    s:= '';
    if (FirmID<>IsWe) then begin
      Client:= Cache.arClientInfo[UserID];
      s:= fnIntegerListToStr(Client.CliContracts); // TIntegerList - в строку через запятую
    end;

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'SELECT INVCNUMBER, INVCDATE, INVCSUMM, INVCCRNCCODE,'+
      ' INVCCONTRACTCODE, bc.bnclcalcbonussumm'+
      fnIfStr(flMeetPerson, ', pphphone, prsnname', '')+
      fnIfStr(FirmID=IsWe, ', gn.rNum contnum', '')+
      ' from INVOICEREESTR left outer join bonuscalculations bc'+
      ' on bc.bncldocmcode=invccode and bc.bncldocmtype='+IntToStr(docInvoice)+
      fnIfStr(flMeetPerson,
      ' left join personphones on pphcode=INVCMEETPERSON'+
      ' left join persons on prsncode=PPhPersonCode', '')+
      fnIfStr(FirmID=IsWe, '',
      ' left join CONTRACT on contcode=INVCCONTRACTCODE'+
      ' left join Vlad_CSS_GetFullContNum(contnumber, contnkeyyear, contpaytype) gn on 1=1')+
      ' where INVCCODE='+OutInvoiceID+' and INVCRECIPIENTCODE='+IntToStr(FirmId)+
      fnIfStr(s='', '', ' and INVCCONTRACTCODE in ('+s+')');
    GBIBS.ExecQuery;
    if GBIBS.Bof and GBIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundDocum, OutInvoiceID));
    Summa:= FormatFloat(cFloatFormatSumm, GBIBS.FieldByName('INVCSUMM').AsFloat)+' '+
            Cache.GetCurrName(GBIBS.FieldByName('INVCCRNCCODE').AsInteger, True);
    LineCount:= 0;            // счетчик - кол-во строк

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(GBIBS.FieldByName('INVCNUMBER').AsString);
    Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('INVCDATE').AsDateTime));
    contID:= GBIBS.FieldByName('INVCCONTRACTCODE').AsInteger;

    s:= '';
    if (FirmID=IsWe) then s:= GBIBS.FieldByName('contnum').AsString
    else if Assigned(Client) and Client.CheckContract(contID) then
      s:= Cache.Contracts[contID].Name;
    Stream.WriteStr(s); // номер контракта

    Stream.WriteDouble(GBIBS.FieldByName('bnclcalcbonussumm').AsDouble);
    Stream.WriteStr(Cache.GetCurrName(Cache.BonusCrncCode, True));

if flMeetPerson then begin
    s:= trim(GBIBS.FieldByName('prsnname').AsString);
    ss:= GBIBS.FieldByName('pphphone').AsString;
    if (s<>'') or (ss<>'') then s:= s+' ('+ss+')';
    Stream.WriteStr(s); // встречающий
end; // flMeetPerson

    Pos:= Stream.Position;
    Stream.WriteInt(0); //  место под кол-во строк

    GBIBS.Close;
    GBIBS.SQL.Text:= 'select INVCLNWARECODE, INVCLNCOUNT, INVCLNPRICE'+
                     ' from INVOICELINES where INVCLNDOCMCODE='+OutInvoiceID;
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      WareID:= GBIBS.FieldByName('INVCLNWARECODE').AsInteger;
      Ware:= Cache.GetWare(WareID);
      if (Ware=nil) or (Ware=NoWare) then
        raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));
      price:= GBIBS.FieldByName('INVCLNPRICE').AsFloat;
      qty  := GBIBS.FieldByName('INVCLNCOUNT').AsFloat;
      Stream.WriteStr(Ware.WareBrandName);
      Stream.WriteStr(Ware.Name);
      Stream.WriteStr(GBIBS.FieldByName('INVCLNCOUNT').AsString);
      Stream.WriteStr(Ware.MeasName);
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, RoundToHalfDown(price*qty, -2)));
      inc(LineCount);
      TestCssStopException;
      GBIBS.Next;
    end;
    GBIBS.Close;
    Stream.WriteStr(Summa);

    Stream.Position:= Pos;
    Stream.WriteInt(LineCount);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//================================================ просмотр возвратной накладной
procedure prShowGBBack(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowGBBack'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, LineCount, Pos, ContID: integer;
    OutInvoiceID, Summa, s: string;
    Client: TClientInfo;
    price, qty: Double;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OutInvoiceID:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csShowGBBack, UserID, FirmID, 'DocID='+OutInvoiceID); // логирование

    LineCount:= StrToIntDef(OutInvoiceID, 0);
    if (LineCount<1) then raise EBOBError.Create(MessText(mtkNotFoundDocum, OutInvoiceID));

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Client:= Cache.arClientInfo[UserID];
    s:= fnIntegerListToStr(Client.CliContracts); // TIntegerList - в строку через запятую

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'SELECT RTINNUMBER, RTINDATE, RTINSUMM, RTINCRNCCODE, RTINCONTRACTCODE,'+
      ' bc.bnclcalcbonussumm from RETURNINVOICEREESTR left outer join bonuscalculations bc'+
      '   on bc.bncldocmcode=rtincode and bc.bncldocmtype='+IntToStr(docBackInvoice)+
      ' where RTINCODE='+OutInvoiceID+' and RTINRECIPIENTCODE='+IntToStr(FirmId)+
      ' and RTINCONTRACTCODE in ('+s+')';
    GBIBS.ExecQuery;
    if GBIBS.Bof and GBIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundDocum, OutInvoiceID));

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(GBIBS.FieldByName('RTINNUMBER').AsString);
    Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('RTINDATE').AsDateTime));

    contID:= GBIBS.FieldByName('RTINCONTRACTCODE').AsInteger;
    if Client.CheckContract(contID) then s:= Cache.Contracts[contID].Name else s:= '';
    Stream.WriteStr(s); // номер контракта

    Summa:= FormatFloat(cFloatFormatSumm, GBIBS.FieldByName('RTINSUMM').AsFloat)+
      ' '+Cache.GetCurrName(GBIBS.FieldByName('RTINCRNCCODE').AsInteger, True);

    Stream.WriteDouble(GBIBS.FieldByName('bnclcalcbonussumm').AsDouble);
    Stream.WriteStr(Cache.GetCurrName(Cache.BonusCrncCode, True));
    GBIBS.Close;

    LineCount:= 0;            // счетчик - кол-во строк
    Pos:= Stream.Position;
    Stream.WriteInt(0);       //  место под кол-во строк

    GBIBS.SQL.Text:= 'select RTINLNWARECODE, RTINLNCOUNT, RTINLNPRICE, RTINLNUNITCODE'+
      ' from RETURNINVOICELINES where RTINLNDOCMCODE='+OutInvoiceID;
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      with Cache.GetWare(GBIBS.FieldByName('RTINLNWARECODE').AsInteger) do begin
        Stream.WriteStr(GrpName);
        Stream.WriteStr(Name);
      end;
      price:= GBIBS.FieldByName('RTINLNPRICE').AsFloat;
      qty:= GBIBS.FieldByName('RTINLNCOUNT').AsFloat;
      Stream.WriteStr(GBIBS.FieldByName('RTINLNCOUNT').AsString);
      Stream.WriteStr(Cache.GetMeasName(GBIBS.FieldByName('RTINLNUNITCODE').AsInteger));
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, price));
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, RoundToHalfDown(price*qty, -2)));
      inc(LineCount);
      TestCssStopException;
      GBIBS.Next;
    end;
    GBIBS.Close;
    Stream.WriteStr(Summa);
    Stream.Position:= Pos;
    Stream.WriteInt(LineCount);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//======================================================= просмотр корректировок
procedure prShowGBManual(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowGBManual'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, ManualID, DocmType: integer;
    s, DocmCode: string;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    ManualID:= Stream.ReadInt;
    DocmType:= Stream.ReadInt;

    DocmCode:= IntToStr(ManualID);
    prSetThLogParams(ThreadData, csShowGBManual, UserID, FirmID,
      'DocType='+IntToStr(DocmType)+#13#10'DocID='+DocmCode); // логирование

    if not (DocmType in [docManualCorr, docHandOper]) then
      raise EBOBError.Create('неизвестный тип документа - '+IntToStr(DocmType));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);

    if (DocmType=docManualCorr) then
      GBIBS.SQL.Text:= 'select bnmcnumber rNumber, bnmcdate rDate, bnmcsumm rSumma,'+
        ' BNMCCOMMENT rComment from BNManualCorrectReestr where BNMCCode='+DocmCode+
        ' and bnmcsubfirmcode=1 and bnmcfirmcode='+IntToStr(FirmID)
    else
      GBIBS.SQL.Text:= 'select BNHONumber rNumber, BNHODate rDate,  BNHOCOMMENT rComment,'+
        ' (select sum(BNHOLnSumm) from BNHandOperLines where BNHOLNDocmCode=BNHOCode'+
        '   and BNHOLnFirmCode='+IntToStr(FirmID)+') rSumma'+
        ' from BNHANDOPERREESTR where BNHOCode='+DocmCode+' and BNHOSubFirmCode=1';

    GBIBS.ExecQuery;
    if GBIBS.Bof and GBIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundDocum, DocmCode));

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(GBIBS.FieldByName('rNumber').AsString);
    Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('rDate').AsDateTime));
    Stream.WriteStr(FormatFloat(cFloatFormatSumm, GBIBS.FieldByName('rSumma').AsFloat));
    Stream.WriteStr(GBIBS.FieldByName('rComment').AsString);

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//================================================== список неоплаченных док-тов
procedure prGetUnpayedDocs(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetUnpayedDocs'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, iCount, index, curr, iDate, contID, ii, pos{, i}: Integer;
    Currencies, conts: tai;
    RedSumms, VioletSumms: array of double;
    ShowRed, ShowViolet: boolean;
    sum: double;
    Client: TClientInfo;
    s: String;
//-----------------------------------------
  function fnGetWarningText(Summs: array of double): string;
  var i: integer;
  begin
    Result:= '';
    for i:= 0 to High(Summs) do if (Summs[i]>0) then
      Result:= Result+fnIfStr(Result<>'', ', ', '')+
        FormatFloat(cFloatFormatSumm, Summs[i])+' '+Cache.GetCurrName(Currencies[i], True);
  end;
//-----------------------------------------
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  SetLength(Currencies, 0);
  SetLength(RedSumms, 0);
  SetLength(VioletSumms, 0);
  SetLength(conts, 0);
  ShowRed:= false;
  ShowViolet:= false;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetUnpayedDocs, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Client:= Cache.arClientInfo[UserID];
    ContID:= Client.GetCliCurrContID;  // код текущего/доступного контракта клиента

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'select rDocmTYPE, rDocmCODE, rDocmDate, rDocmCrnc RCrncCode,'+
      ' rDocmDuty RDutySumm, rDocmDPRT DPRTCODE, rDocmDELAY DELAYCALC,'+
      ' rDocmSUMM DTLNSUMM, rDocmNUMBER DTLNNUMBER, rContCode from'+
      ' Vlad_CSS_GetFirmDutyDocms('+IntToStr(FirmID)+ ', '+
      fnIfStr(Client.DocsByCurrContr, IntToStr(contID), '0')+', '+
      Cache.GetConstItem(pcDutyDocsWithPlan).StrValue+')';

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    pos:= Stream.Position;
    Stream.WriteInt(0); // место под кол-во строк

    GBIBS.ExecQuery;
    iCount:= 0;
    while not GBIBS.EOF do begin
      //------------------------------- фильтр по контрактам +++
      ii:= GBIBS.FieldByName('rContCode').AsInteger;
      if (ii<1) then s:= ''                                  // контракт неопределен
      else if (Client.CliContracts.IndexOf(ii)<0)         // контракт недоступен клиенту
        or (Client.DocsByCurrContr and (ii<>ContID))      // выдаем только по текущему ???
      then begin
        TestCssStopException;
        GBIBS.Next;
        Continue;
      end else begin
         s:= Client.GetCliContract(ii).Name;
         prAddItemToIntArray(ii, conts);
      end;
      //------------------------------- фильтр по контрактам ---

      Stream.WriteInt(GBIBS.FieldByName('RDOCMTYPE').AsInteger); // код типа документа
      Stream.WriteStr(FormatDateTime(cDateFormatY2, GBIBS.FieldByName('RDOCMDATE').AsDateTime));  // дата документа
      Stream.WriteStr(GBIBS.FieldByName('RDOCMCODE').AsString);  // код документа (id)
      Stream.WriteStr(GBIBS.FieldByName('DTLNNUMBER').AsString); // номер документа

      sum:= RoundToHalfDown(GBIBS.FieldByName('DTLNSUMM').AsFloat);
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum)); // сумма документа

      sum:= RoundToHalfDown(GBIBS.FieldByName('RDUTYSUMM').AsFloat);
      Stream.WriteStr(FormatFloat(cFloatFormatSumm, sum)); // неоплаченная сумма

      curr:= GBIBS.FieldByName('RCrncCode').AsInteger;
      Stream.WriteStr(Cache.GetCurrName(curr, True)); // валюта документа
      Stream.WriteStr(s);                             // номер контракта документа

      if (fnInIntArray(curr, Currencies)=-1) then begin
        prAddItemToIntArray(curr, Currencies);
        index:= Length(Currencies);
        SetLength(RedSumms, index);
        SetLength(VioletSumms, index);
        RedSumms[index-1]:= 0;
        VioletSumms[index-1]:= 0;
      end;

      iDate:= Trunc(GBIBS.FieldByName('RDOCMDATE').AsDateTime)+
              GBIBS.FieldByName('DELAYCALC').AsInteger;
      if (iDate<Date) then begin
        Stream.WriteByte(2); // красный код
        index:= fnInIntArray(curr, Currencies);
        RedSumms[index]:= RedSumms[index]+sum; // неоплаченная сумма
        ShowRed:= true;
      end else if ((iDate-Date)<constDaysForBlockWarninig) then begin
        Stream.WriteByte(1); // фиолетовый код
        index:= fnInIntArray(curr, Currencies);
        VioletSumms[index]:= VioletSumms[index]+sum; // неоплаченная сумма
        ShowViolet:= true;
      end else Stream.WriteByte(0);
      Stream.WriteInt(iDate);
//------------------------------------------------------------------------------
      TestCssStopException;
      GBIBS.Next;
      Inc(iCount)
    end;
    GBIBS.Close;

    s:= 'необходимо оплатить ';
    if ShowRed then begin
      Stream.WriteByte(2);
      Stream.WriteStr('По просроченным документам '+s+fnGetWarningText(RedSumms));
    end else if ShowViolet then begin
      Stream.WriteByte(1);
      Stream.WriteStr('В ближайшее время '+s+fnGetWarningText(VioletSumms));
    end else Stream.WriteByte(0);

    Stream.Position:= pos;
    Stream.WriteInt(iCount); // кол-во строк
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
  SetLength(Currencies, 0);
  SetLength(RedSumms, 0);
  SetLength(VioletSumms, 0);
  SetLength(conts, 0);
end;
//======================================================================= сверка
procedure prGetCheck(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetCheck'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, i, contID, ipos: integer;
    DateBegin, DateEnd, DateMin, DateTemp: TDateTime;
    CurrCode, c, s: string;
    Debt: double;
    Client: TClientInfo;
    Contract: TContract;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  contID:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    DateBegin:= Trunc(Stream.ReadDouble);
    DateEnd:= Trunc(Stream.ReadDouble);

    prSetThLogParams(ThreadData, csGetCheck, UserID, FirmID,
      'DateBegin='+FormatDateTime(cDateFormatY2, DateBegin)+
      #13#10'DateEnd='+FormatDateTime(cDateFormatY2, DateEnd)+
      #13#10'ContID='+IntToStr(ContID)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Client:= Cache.arClientInfo[UserID];
    if Client.CheckIsFinalClient then raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

    if not Client.CheckContract(ContID) then ContID:= Client.LastContract; // ???
    Contract:= Client.GetCliContract(contID);
    CurrCode:= IntToStr(Contract.DutyCurrency);

    If DateEnd<DateBegin then begin
      DateTemp:= DateEnd;
      DateEnd:= DateBegin;
      DateBegin:= DateTemp;
    end;
    if DateEnd>Date() then DateEnd:= Date();
    //------------------------------- определяю минимально возможную дату начала
    DateMin:= IncMonth(EncodeDate(CurrentYear, CurrentMonth, 1), -1);
    if DateBegin<DateMin then DateBegin:= DateMin;
    Debt:= 0;

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    //------------------------------------------ Задолженность на текущий момент
    GBIBS.SQL.Text:= 'select ABDTCURRECYCODE DUTYCRNCCODE, ABDTSUMM DUTYCURRENT'+
      ' from ABSOLUTEDUTY where ABDTCURRECYCODE='+CurrCode+
      ' and ABDTFIRMCODE='+IntToStr(FirmId)+' and ABDTCONTRACTCODE='+IntToStr(contID);
    GBIBS.ExecQuery;
    while not GBIBS.Eof do begin
      Debt:= Debt+GBIBS.FieldByName('DUTYCURRENT').AsFloat;
      TestCssStopException;
      GBIBS.Next;
    end;
    GBIBS.Close;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    ipos:= Stream.Position;
    Stream.WriteInt(0);         // место под кол-во строк
    Stream.WriteDouble(Debt/100);    // Задолженность на текущий момент
    Stream.WriteDouble(DateBegin);   // Дата начала сверки
    Stream.WriteDouble(DateEnd);     // Дата окончания сверки
    Stream.WriteStr(Contract.Name);  // наименование контракта
    Stream.WriteStr(fnIfStr(CurrCode=cStrUAHCurrCode, 'грн.', 'у.е.')); // валюта сверки (для отображения с заголовке)
    Stream.WriteDouble(DateMin);     // Минимально возможная дата (чтоб не вычислять ее на клиенте) начала сверки
    Stream.WriteDouble(Date());      // Максиимально возможная дата (чтоб не вычислять ее на клиенте) конца сверки
    //-------------------------------------------------- Начальное сальдо сверки
    Debt:= 0;
    GBIBS.SQL.Text:= 'select rDuty from GETDUTYONDATE(:DateBegin, '+
      IntToStr(FirmId)+', 1, '+CurrCode+', '+IntToStr(contID)+', 0)';
    GBIBS.Prepare;
    GBIBS.ParamByName('DateBegin').AsDateTime:= DateBegin;
    GBIBS.ExecQuery;
    if not (GBIBS.EOF and GBIBS.Bof) then Debt:= GBIBS.Fields[0].AsFloat/100;
    GBIBS.Close;
    Stream.WriteDouble(Debt); // Начальное сальдо сверки
    i:= 0;
//------------------------------------------------------------- документы сверки
    GBIBS.SQL.Text:= 'select rSUMM, rDATE, rDOCMTYPE, rDOCMCODE, rDUTYTYPE,'+
      ' rNUMBER from Vlad_CSS_GetFirmCheckDocs('+IntToStr(FirmId)+', '+
      IntToStr(contID)+', :DateBegin, :DateEnd) where rCRNC='+CurrCode;
    GBIBS.ParamByName('DateBegin').AsDateTime:= DateBegin;
    GBIBS.ParamByName('DateEnd').AsDateTime:= DateEnd;
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      c:= GBIBS.FieldByName('rDUTYTYPE').AsString;                // тип задолженности  0 - дебет, 5 - кредит
      Stream.WriteByte(byte(c[1]));                               // тип задолженности
      Stream.WriteDouble(GBIBS.FieldByName('rDATE').AsDateTime);  // дата документа
      Stream.WriteInt(GBIBS.FieldByName('rDOCMTYPE').AsInteger);  // код типа документа
      Stream.WriteStr(GBIBS.FieldByName('rDOCMCODE').AsString);   // код документа (id)
      Stream.WriteStr(GBIBS.FieldByName('rNUMBER').AsString);     // номер документа
      Stream.WriteDouble(GBIBS.FieldByName('rSUMM').AsFloat/100); // сумма документа
      TestCssStopException;
      GBIBS.Next;
      Inc(i)
    end;
    GBIBS.Close;
    if (i>0) then begin
      Stream.Position:= ipos;
      Stream.WriteInt(i); // кол-во строк
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//================================================================ unit-движение
procedure prGetCheckBonus(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetCheckBonus'; // имя процедуры/функции
var gbIBD: TIBDatabase;
    GBIBS: TIBSQL;
    UserId, FirmID, i, ipos: integer;
    DateBegin, DateEnd, DateTemp: TDateTime;
    c, s: string;
    Debt, sum: double;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  gbIBD:= nil;
  Debt:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    DateBegin:= Trunc(Stream.ReadDouble);
    DateEnd:= Trunc(Stream.ReadDouble);

    prSetThLogParams(ThreadData, csGetCheckBonus, UserID, FirmID,
      'DateBegin='+FormatDateTime(cDateFormatY2, DateBegin)+
      #13#10'DateEnd='+FormatDateTime(cDateFormatY2, DateEnd)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    firma:= Cache.arFirmInfo[FirmID];
    if firma.IsFinalClient then raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

    If DateEnd<DateBegin then begin
      DateTemp:= DateEnd;
      DateEnd:= DateBegin;
      DateBegin:= DateTemp;
    end;
    if DateEnd>Date() then DateEnd:= Date();

    gbIBD:= cntsGRB.GetFreeCnt;
    GBIBS:= fnCreateNewIBSQL(gbIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);

    //-------------------------------------- проверяем остаток на текущий момент
    GBIBS.SQL.Text:= 'select bnrssumm from bonusrest'+
                     ' where bnrssubfirmcode=1 and bnrsfirmcode='+IntToStr(FirmID);
    GBIBS.ExecQuery;
    if not (GBIBS.Eof and GBIBS.Bof) then Debt:= RoundTo(GBIBS.FieldByName('bnrssumm').AsFloat, -2);
    GBIBS.Close;
    if fnNotZero(firma.BonusQty-Debt) then try
      firma.CS_firm.Enter;
      firma.BonusQty:= Debt;
    finally
      firma.CS_firm.Leave;
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    ipos:= Stream.Position;
    Stream.WriteInt(0);         // место под кол-во строк док-тов
    Stream.WriteDouble(DateBegin);   // начальная дата сверки
    Stream.WriteDouble(DateEnd);     // конечная дата сверки
    //-------------------------------------------------- Начальное сальдо сверки
    GBIBS.SQL.Text:= 'select sum(InSumm-OutSumm) from'+  // оборот от начальной даты
      ' (select iif(BnTrDirection="0", BnTrSumm, 0) as InSumm,'+
      '  iif(BnTrDirection="1", BnTrSumm, 0) as OutSumm from BonusTransactions'+
      '  join UnitedReestr on UnTdDocmType=BnTrDocmType and UnTdDocmCode=BnTrDocmCode'+
      '  where BnTrFirmCode='+IntToStr(FirmId)+' and UnTdDate Between :DateBegin and "today")';
    GBIBS.ParamByName('DateBegin').AsDateTime:= DateBegin;
    GBIBS.ExecQuery;
    if not (GBIBS.EOF and GBIBS.Bof) then Debt:= RoundTo(Debt-GBIBS.Fields[0].AsFloat, -2);
    GBIBS.Close;

    Stream.WriteDouble(-Debt); // Начальное сальдо сверки

    i:= 0;
//------------------------------------------------------------- документы сверки
    GBIBS.SQL.Text:= 'select BnTrDocmType rType, BnTrDocmCode rDocm, UnTdNumber rNUMBER,'+
      '  UnTdDate rDate, BnTrDirection rDUTYTYPE, BnTrSumm rSumma from BonusTransactions'+
      '  join UnitedReestr on UnTdDocmType=BnTrDocmType and UnTdDocmCode=BnTrDocmCode'+
      '  where BnTrFirmCode='+IntToStr(FirmId)+' and UnTdDate Between :DateBegin'+
      '    and :DateEnd and BnTrSumm<>0 order by UnTdDate, UnTdNumber';
    GBIBS.ParamByName('DateBegin').AsDateTime:= DateBegin;
    GBIBS.ParamByName('DateEnd').AsDateTime:= DateEnd;
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      c:= GBIBS.FieldByName('rDUTYTYPE').AsString;               // тип: 0 - начислено, 1 - использовано
      Stream.WriteByte(byte(c[1]));
      Stream.WriteDouble(GBIBS.FieldByName('rDATE').AsDateTime); // дата документа
      Stream.WriteInt(GBIBS.FieldByName('rType').AsInteger);     // код типа документа
      Stream.WriteStr(GBIBS.FieldByName('rDocm').AsString);      // код документа (id)
      Stream.WriteStr(GBIBS.FieldByName('rNUMBER').AsString);    // номер документа
      sum:= RoundTo(GBIBS.FieldByName('rSumma').AsFloat, -2);
      Stream.WriteDouble(sum);   // сумма бонусов
      TestCssStopException;
      GBIBS.Next;
      Inc(i)
    end;
    GBIBS.Close;
    if (i>0) then begin
      Stream.Position:= ipos;
      Stream.WriteInt(i); // кол-во строк
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(gbIBD);
  Stream.Position:= 0;
end;
//=================================================== отправить менеджеру письмо
procedure prSendMessage2Manager(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSendMessage2Manager'; // имя процедуры/функции
var UserId, FirmID, contID: Integer;
    Mess, mes, s, To_, From, ToAdm: string;
    Strings: TStrings;
    firma: TFirmInfo;
    Client: TClientInfo;
    Contract: TContract;
begin
  Stream.Position:= 0;
  contID:= 0;
  Strings:= TStringList.Create;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    Mess:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csSendMessage2Manager, UserID, FirmID,
      'Mess='+Mess+#13#10'ContID='+IntToStr(ContID)); // логирование

    if (trim(Mess)='') then raise EBOBError.Create('Нельзя отправить пустое сообщение');
    if not Cache.ClientExist(UserID) then
      raise Exception.Create(MessText(mtkNotClientExist, IntToStr(UserID)));

    Client:= Cache.arClientInfo[UserID];
    if not Cache.FirmExist(FirmID) then FirmID:= Client.FirmID;
    if not Cache.FirmExist(FirmID) then
      raise Exception.Create(MessText(mtkNotFirmExists, IntToStr(FirmID)));
    if (FirmID<>Client.FirmID) then raise Exception.Create(MessText(mtkNotClientOfFirm));

    From:= ExtractFictiveEmail(Client.Mail);
    if (From='') then
      raise EBOBError.Create('Отправка сообщения невозможна - Вашего E-mail нет в базе'+
        ' данных. Сообщите свои логин и E-mail торговому представителю Компании.');

    firma:= Cache.arFirmInfo[FirmID];
    Contract:= firma.GetContract(contID);
    mes:= '';
    if (Contract.Name<>'') then mes:= 'из интерфейса контракта № '+Contract.Name;
    if (Contract.Status=cstClosed) then begin
      if (mes<>'') then mes:= mes+' (недоступен)';
      Contract:= Firma.GetDefContract;
    end;
                                                 // вставляем в начало шапку
    Strings.Add('Письмо создано сервером СВК по запросу пользователя');
    Strings.Add('с логином '+Client.Login+' [к/а '+firma.Name+']');
    if (mes<>'') then Strings.Add(mes);
    Strings.Add(' ');

// 20.10.2016 - изменения из-за проблемы с переадресацией на order@motogorodok.com
//    Strings.Add('E-mail пользователя указан как отправитель письма для ответа.');
    Strings.Add('E-mail пользователя для ответа: '+From);

    Strings.Add(' ');
    Strings.Add('Текст сообщения:');
    Strings.Add(StringOfChar('-', 40));
    Strings.Add(Mess); // текст пользователя
    Strings.Add(StringOfChar('-', 40));

    ToAdm:= Cache.GetConstEmails(pcEmplORDERAUTO);
    if (ToAdm='') then ToAdm:= fnGetSysAdresVlad(caeOnlyWorkDay); // 3 - не отправлять смс по ночам и выходным

    To_:= fnGetManagerMail(Contract.Filial, ToAdm);
    if (To_=ToAdm) then begin
      To_:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // если не нашли куда - отправляем в УиК
      Strings.Add('Не найден E-mail филиала клиента для отправки письма');
    end;

// 20.10.2016 - изменения из-за проблемы с переадресацией на order@motogorodok.com
//    s:= n_SysMailSend(To_, 'Сообщение от пользователя СВК', Strings, nil, From, '', true);
    s:= n_SysMailSend(To_, 'Сообщение от пользователя СВК', Strings, nil, cNoReplayEmail, '', true);

    if (s<>'') then
      if (Pos(MessText(mtkErrMailToFile), s)>0) then begin  // если не записали в файл
        Strings.Insert(0, GetMessageFromSelf);
        if ToAdm<>'' then begin
          Strings.Add(#10'Текст ошибки:'#10+s); // добавляем Текст ошибки 1-й отправки и отправляем админам
          ToAdm:= n_SysMailSend(ToAdm, MessText(mtkErrSendMess, 'от пользователя'), Strings, nil, '', '', true);
          if ToAdm<>'' then s:= s+#10+MessText(mtkErrSendMess, 'админам')+#10+ToAdm+
                                #10'Текст письма: '+Strings.Text;
        end;
        raise Exception.Create(s);
      end else raise EBOBError.Create('Ошибка отправки письма.'+
        #13#10'Сообщение записано и будет отправлено позже.');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFree(Strings);
  Stream.Position:= 0;
end;
//=================================================== Выдать инфу по акциям и пр
procedure prGetActions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetActions'; // имя процедуры/функции
var UserId, FirmID, i, arlen, Count, Count1, Pos, pos1, {ContractID,} MaxCount{, iVis}: integer;
    Wares: tai;
    InfoBoxItem: TInfoBoxItem;
    ErrorPos: string;
begin
  Stream.Position:= 0;
  ErrorPos:= '0';
  MaxCount:= 10;
  SetLength(Wares, 0);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetActions, UserID, FirmID, ''); // логирование

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    pos1:= Stream.Position;
    Stream.WriteInt(0); // заглушка под кол-во

    Count:= 0;
    Count1:= 0;
    Pos:= 0;
    arlen:= Cache.InfoNews.ItemsList.Count-1;
  ErrorPos:='5';
    // сначала формируем обязательный блок
    while (Pos<=arlen) and (TInfoBoxItem(Cache.InfoNews.ItemsList[Pos]).Priority>0) do begin
      InfoBoxItem:= Cache.InfoNews.ItemsList[Pos];
      Stream.WriteBool(InfoBoxItem.InWindow);
      Stream.WriteStr(InfoBoxItem.Title);
      Stream.WriteInt(InfoBoxItem.ID);
      Stream.WriteStr(InfoBoxItem.LinkToSite);
      Stream.WriteStr(InfoBoxItem.LinkToPict);
      Inc(Count);
      Inc(Pos);
    end;
    // при необходимости - дополнительный
    if (Count<MaxCount) and (Pos<=arlen) then begin
      Setlength(Wares, arlen-Pos+1);
      while (Count<MaxCount) and (Pos<=arlen) do begin
        Wares[Count1]:= Pos;
        Inc(Count1);
        Inc(Pos);
      end;
      Setlength(Wares, Count1);
      // получить массив длиной не более 10-Count рандомно выбранных из заданного массива элементов
      Wares:= fnGetRandomArray(Wares, MaxCount-Count);
      arlen:= Length(Wares)-1;
      for i:=0  to arlen do begin
        InfoBoxItem:= Cache.InfoNews.ItemsList[Wares[i]];
        Stream.WriteBool(InfoBoxItem.InWindow);
        Stream.WriteStr(InfoBoxItem.Title);
        Stream.WriteInt(InfoBoxItem.ID);
        Stream.WriteStr(InfoBoxItem.LinkToSite);
        Stream.WriteStr(InfoBoxItem.LinkToPict);
      end;
      Count:= Count+arlen+1;
    end;
  ErrorPos:='20';
    Stream.Position:= pos1;
    Stream.WriteInt(Count); // кол-во
  except
    on E: Exception do
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10' ErrorPos='+ErrorPos, '');
  end;
  Stream.Position:= 0;
  SetLength(Wares, 0);
end;
//============================================ Фиксация клика по новостям/акциям
procedure prClickOnNewsCounting(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prClickOnNewsCounting'; // имя процедуры/функции
var UserId, FirmID, ActionID : integer;
    ordIBD: TIBDatabase;
    OrdIBS: TIBSQL;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  ordIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ActionID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csClickOnNewsCounting, UserID, FirmID,
      'ActionID='+IntToStr(ActionID)); // логирование

    ordIBD:= cntsOrd.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(ordIBD,'OrdIBS_'+nmProc,ThreadData.ID, tpWrite, true);
    OrdIBS.SQL.Text:= 'Update INFOBOXVIEWS set IBVCLICKCOUNT=IBVCLICKCOUNT+1 where IBVCODE='+IntToStr(ActionID);
    OrdIBS.ExecQuery;
    OrdIBS.Transaction.Commit;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: Exception do fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(ordIBD);
end;
//==============================================================================
procedure prSaveOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveOption'; // имя процедуры/функции
var UserId, FirmID, ActionID, Value : integer;
    ordIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    s, sUser: string;
    Client: TClientInfo;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  ordIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ActionID:= Stream.ReadInt;
    Value:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csSaveOption, UserID, FirmID,
      'ActionID='+IntToStr(ActionID)+#13#10'Value='+IntToStr(Value)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    Client:= Cache.arClientInfo[UserID];

    s:= 'UPDATE WEBORDERCLIENTS SET ';
    sUser:= ' where WOCLCODE='+IntToStr(UserID);
    case ActionID of
//      optPayType:
//        s:= s+'WOCLDEFAULTACCOUNTINGTYPE='+fnIfStr(Value=1, '1', '0')+sUser;
//      optDeliveryType:
//        s:= s+'WOCLDEFAULTDELIVERYTYPE='+fnIfStr(Value=1, '1', '0')+sUser;
      optNoRemindAboutComment: begin
        s:= s+'WOCLNOTREMINDCOMMENT='+fnIfStr(Value=1, '"T"', '"F"')+sUser;
      end;
      optThisContractDocsOnly: begin
        s:= s+'WOCLDOCSBYCONTR='+fnIfStr(Value=1, '"T"', '"F"')+sUser;
      end;
      optSearchCurrency: begin
        s:= s+'WOCLSEARCHCURRENCY='+fnIfStr(Value=1, cStrUAHCurrCode, cStrDefCurrCode)+sUser;
      end;
      optResultLimitForAnalog: begin
        if (Value<1) then Value:= 1 else if (Value>30) then Value:= 30;
        s:= s+'WOCLMAXROWFORSHOWANALOGS='+IntToStr(Value)+sUser;
      end;
      else begin
        s:= 'UPDATE WEBCLIENTCONTRACTS set ';
        sUser:= ' where WCCCLIENT='+IntToStr(UserID)+
          ' and WCCCONTRACT='+IntToStr(Client.LastContract);
        case ActionID of
          optDeliveryType: begin
            if not (Value in [cDelivTimeTable, cDelivReserve, cDelivSelfGet]) then
              raise EBOBError.Create('Неизвестный вид доставки - '+IntToStr(Value));
            s:= s+'WCCDeliveryDef='+IntToStr(Value)+sUser;
          end;
          optDestPoint: begin
            s:= s+'wccDestDef='+IntToStr(Value)+sUser;
          end;
          else raise EBOBError.Create('Неизвестный номер настройки - '+IntToStr(ActionID));
        end;
      end;
    end;

    ordIBD:= cntsOrd.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(ordIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, true);
    OrdIBS.SQL.Text:= s;

    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(s);

    with Client do case ActionID of
      optNoRemindAboutComment: NOTREMINDCOMMENT:= (Value=1);
      optThisContractDocsOnly: DocsByCurrContr:= (Value=1);
      optSearchCurrency      : SearchCurrencyId:= fnIfint(Value=1, cUAHCurrency, cDefCurrency);
      optResultLimitForAnalog: MaxRowShowAnalogs:= Value;
//      optDeliveryType        : DEFDELIVERYTYPE:= fnIfInt(Value=1, 1, 0);
      optDeliveryType        : GetCliContDefs.ID1:= Value;  // на LastContract
      optDestPoint           : GetCliContDefs.ID2:= Value;  // на LastContract
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(ordIBD);
end;
//==============================================================================
procedure prSendVINOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSendVINOrder'; // имя процедуры/функции
var UserId, FirmID : integer;
    s1, s2, s3, mail, s: string;
    Body: TStringList;
begin
  Stream.Position:= 0;
  Body:= TStringList.Create;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    s1:= Stream.ReadStr;
    s2:= Stream.ReadStr;
    s3:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csSendVINOrder, UserID, FirmID); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Body.Add('Представитель контрагента '+Cache.arFirmInfo[FirmID].Name+
      ' под логином '+Cache.arClientInfo[UserID].Login+' '+
      FormatDateTime('dd.mm.yyyy в hh:nn', Now)+' отправил запрос по вин-коду'#13#10);
    Body.Add(s1);
    Body.Add('Необходимые запчасти:'#13#10);
    Body.Add(s2);
    Body.Add('Контактные данные:'#13#10);
    Body.Add(s3);
    mail:= Cache.GetConstEmails(pcVINmailEmpl_list, s);
    if mail='' then raise EBOBError.Create('Извините, но Ваш запрос не может быть отправлен -'+
                                     ' в системе отсутствует E-mail доставки запроса');
    s:= n_SysMailSend(mail, 'Запрос по VIN-коду', Body, nil, '', '', True);
    if s<>'' then
      fnWriteToLog(ThreadData, lgmsSysError, nmProc,
        'Не найдены E-mail сотрудников в списке E-mail для приема заказов по VIN-коду', s, '');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(Body);
end;
//================================================================ выдача прайса
procedure prDownloadPrice(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prDownloadPrice'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    UserId, FirmID, i, Version, contID, LoadLimit, LoadCount, currID, pDirect: integer;
    s, sParam, PrDirName, sAddVis: String;
    rbs, FileName: RawByteString;
    Body: TStringList;
    Ware: TWareInfo;
    Firm: TFirmInfo;
    RestMain, RestAll, RestThird: double;
    Stream1: TBoBMemoryStream;
    Contract: TContract;
    ForbiddenBrands: Tai;
    rests: TDoubleDynArray;
    flAdd: Boolean;
begin
  Stream.Position:= 0;
  Stream1:= nil;
  Body:= nil;
  contID:= 0;
  SetLength(ForbiddenBrands, 0);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt; // для контрактов
    Version:= Stream.ReadInt; // направление
    sParam:= 'version='+IntToStr(Version)+#13#10'ContID='+IntToStr(ContID);
    try
      if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

      Firm:= Cache.arFirmInfo[FirmId];
      if not Firm.EnablePriceLoad or Firm.IsFinalClient then
        raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

      Contract:= firm.GetContract(contID);
      if (Contract.Status=cstClosed) then
        raise EBOBError.Create('Контракт закрыт, зайдите в действующий контракт');

     //------------------------------- проверяем лимит скачиваний, если он задан
      LoadLimit:= Cache.GetConstItem(pcLoadPriceBlockLimit).IntValue;
      if (LoadLimit>0) then begin
        IBD:= cntsLOG.GetFreeCnt;
        try
          IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, True);
          IBS.SQL.Text:= 'Select LUCLOADPRICE FROM LOGUSERCOUNTS WHERE LUCDATE="today"'+
            ' and LUCFIRMID='+IntToStr(FirmId)+' and LUCUSERID='+IntToStr(UserID);
          IBS.ExecQuery;
          if (IBS.EOF and ibs.Bof) then LoadCount:= 0
          else LoadCount:= IBS.FieldByName('LUCLOADPRICE').AsInteger;
        finally
          prFreeIBSQL(IBS);
          cntsLOG.SetFreeCnt(IBD);
        end;
        if (LoadCount>=LoadLimit) then
          raise EBOBError.Create('Превышен лимит скачиваний прайсов');
      end; // if (LoadLimit>0)

      ForbiddenBrands:= Cache.GetDownLoadExcludeBrands;

      flAdd:= Cache.arDprtInfo[Contract.MainStorage].HasDprtFrom2;
      if flContCurrPrice then currID:= Contract.DutyCurrency else currID:= cDefCurrency;

      Body:= TStringList.Create;
      for i:= 0 to High(Cache.arWareInfo) do begin
        if not Cache.WareExist(i) then continue;
        Ware:= Cache.GetWare(i);
        if not Ware.isWare or Ware.IsArchive then continue;
        if Ware.IsINFOgr or Ware.IsPrize then continue;                        // пропускаем ИНФО и призы
        if (Ware.PgrID=0) or (Ware.PgrID=Cache.pgrDeliv) then continue;        // пропускаем доставки
        if not Ware.IsMarketWare(FirmID, contID) then continue;                // пропускаем непродажные
        if (fnInIntArray(Ware.WareBrandID, ForbiddenBrands)>-1) then continue; // пропускаем запрещенные бренды

        PrDirName:= Ware.PrDirectName;
        pDirect:= Ware.ProdDirect;
        case Version of // пропускаем невыбранные направления
          cpdAuto         : if (pDirect<>cpdCodeAuto)  then Continue;
          cpdMoto         : if (pDirect<>cpdCodeMoto)  then Continue;
          cpdMotul        : if (pDirect<>cpdCodeMotul) then Continue;
          cpdHD           : if (pDirect<>cpdCodeHD)    then Continue;
          cpdAutoMoto     : if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeMoto)  then Continue;
          cpdAutoMotul    : if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeMotul) then Continue;
          cpdMotoMotul    : if (pDirect<>cpdCodeMoto)  and (pDirect<>cpdCodeMotul) then Continue;
          cpdAutoHD       : if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeHD)    then Continue;
          cpdMotoHD       : if (pDirect<>cpdCodeMoto)  and (pDirect<>cpdCodeHD)    then Continue;
          cpdMotulHD      : if (pDirect<>cpdCodeMotul) and (pDirect<>cpdCodeHD)    then Continue;
          cpdAutoMotoHD   : if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeMoto)  and (pDirect<>cpdCodeHD)    then Continue;
          cpdAutoMotulHD  : if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeMotul) and (pDirect<>cpdCodeHD)    then Continue;
          cpdMotoMotulHD  : if (pDirect<>cpdCodeMoto)  and (pDirect<>cpdCodeMotul) and (pDirect<>cpdCodeHD)    then Continue;
          cpdAutoMotoMotul: if (pDirect<>cpdCodeAuto)  and (pDirect<>cpdCodeMoto)  and (pDirect<>cpdCodeMotul) then Continue;
        end;

        rests:= GetContWareRestsByCols(ware.ID, ContID, fnIfInt(flAdd, 3, 2));
        RestMain:= rests[0];
        RestAll:= rests[1];
        if flAdd then RestThird:= rests[2] else RestThird:= 0;
        sAddVis:= fnIfStr(flAdd, '"'+fnRestValuesForReport(RestThird)+'"', '');

        Body.Add('"'+IntToStr(Ware.ID)+'";"'+Ware.WareBrandName+
          '";"'+Ware.Name+'";"'+Ware.WareSupName+'";"'+
          FormatFloat(cFloatFormatSumm, Ware.SellingPrice(FirmID, currID, contID))+'";"'+
          fnRestValuesForReport(RestMain)+'";"'+fnRestValuesForReport(RestAll)+'";"'+
          StringReplace(Ware.Comment, '"', '""', [rfReplaceAll])+'";'+sAddVis+';"'+PrDirName+'"');
      end; // for i:= 0 to High(Cache.arWareInfo)
//      Body.Sort;

      s:= '"Внутренний код";"Бренд";"Полное наименование";"Артикул";'+
          '"Цена,'+Cache.GetCurrName(currID, True)+
          '";"Остаток на складе по умолчанию";"Суммарный остаток на доступных складах";'+
          '"Комментарий";'+fnIfStr(flAdd, 'Доставка >1 дня', '')+';Направление';

      Body.Insert(0, s);

      Stream.Clear;
      Stream.WriteInt(aeSuccess);

      FileName:= RawByteString('pricevlad_'+FormatDateTime('yyyymmdd_hhnnss', Now())+'_Contr#'+Contract.Name);
      rbs:= RawByteString(Body.Text);
      i:= Length(rbs);

      Stream1:= TBoBMemoryStream.Create;
      Stream1.Write(Pointer(rbs)^, i);
      rbs:= RawByteString(GetAppExePath);
      Stream1.Position:= 0;
      ZipStream(Stream1, rbs, FileName+'.csv');

      Stream.WriteStr('application/zip');
      Stream.WriteStr(String(FileName+'.zip'));
      Stream.WriteInt(Stream1.Size);
      Stream.CopyFrom(Stream1, Stream1.Size);
      sParam:= sParam+#13#10'Succes=true'; // логирование - признак успешной загрузки
    finally
      prSetThLogParams(ThreadData, csDownloadPrice, UserID, FirmID, sParam);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(Body);
  prFree(Stream1);
  SetLength(ForbiddenBrands, 0);
  SetLength(rests, 0);
end;

//==============================================================================
procedure prShowNotificationOrd(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowNotification'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    ordIBS: TIBSQL;
    UserId, FirmID, NotifyID : integer;
    s: string;
begin
  Stream.Position:= 0;
  OrdIBD:= nil;
//  ordIBS:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    NotifyID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csShowNotification, UserID, FirmID, 'NotifyID='+IntToStr(NotifyID)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    if (FirmID<>isWe) then begin
      s:= Cache.SetClientNotifiedKind(UserId, NotifyID, 0);
      if s<>'' then raise EBOBError.Create(s);
      s:= Cache.Notifications[NotifyID].Name;
    end else try
      OrdIBD:= cntsORD.GetFreeCnt;
      ordIBS:= fnCreateNewIBSQL(OrdIBD, 'ordIBS_'+nmProc, ThreadData.ID, tpRead, True);
      ordIBS.SQL.Text:= 'Select * FROM NOTIFICATIONS WHERE NOTECODE='+IntToStr(NotifyID);
      ordIBS.ExecQuery;
      if ordIBS.EOF then raise EBOBError.Create('Не найдено уведомление с кодом '+IntToStr(NotifyID));
      s:= ordIBS.FieldByName('NOTETEXT').AsString;
    finally
      prFreeIBSQL(ordIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(s);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//==============================================================================
procedure prConfirmNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prConfirmNotification'; // имя процедуры/функции
var UserId, FirmID, NotifyID : integer;
    s: string;
begin
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    NotifyID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csConfirmNotification, UserID, FirmID, 'NotifyID='+IntToStr(NotifyID)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Cache.SetClientNotifiedKind(UserId, NotifyID, 1);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//================================================== список контрактов к/а (Web)
procedure prContractList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prContractList'; // имя процедуры/функции
var UserId, FirmID, i, iCount, j: integer;
    s: string;
    Contract: TContract;
    Client: TClientInfo;
    fl: Boolean;
begin

if flCredProfile then begin
  prContractList_new(Stream, ThreadData);
  Exit;
end;

  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csContractList, UserID, FirmID); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Client:= Cache.arClientInfo[UserID];
    iCount:= Client.CliContracts.Count;
    Stream.WriteInt(iCount);
    for i:= 0 to iCount-1 do begin
      j:= Client.CliContracts[i];
      Contract:= Client.GetCliContract(j);
      Stream.WriteInt(Contract.ID);
      Stream.WriteStr(Contract.Name);
      Stream.WriteInt(Contract.PayType);
      Stream.WriteStr(Contract.LegalFirmName); // юр.лицо
      Stream.WriteInt(Contract.DutyCurrency);
      if (Contract.Status=cstClosed) then begin
        Stream.WriteStr('');
        Stream.WriteStr('');
      end else begin
        Stream.WriteStr(Cache.GetDprtShortName(Contract.MainStorage));
        Stream.WriteStr(Cache.GetDprtMainName(Contract.MainStorage));
      end;

      Stream.WriteDouble(Contract.CredLimit);
      Stream.WriteStr(Cache.GetCurrName(Contract.CredCurrency, True));
      Stream.WriteInt(Contract.CredDelay);

      Stream.WriteDouble(Contract.DebtSum);
      Stream.WriteDouble(Contract.OrderSum); // резерв
      s:= Contract.WarnMessage;
      Stream.WriteInt(Contract.Status);
      fl:= Contract.SaleBlocked;
// Status=cstClosed, WarnMessage=""   - закрыт              - без фона
// Status=cstWorked, WarnMessage=""   - действует           - зеленый фон
// SaleBlocked=True, WarnMessage<>""  - заблокирован/закрыт - красный фон
// SaleBlocked=False, WarnMessage<>"" - действует/закрыт    - сиреневый фон
      Stream.WriteBool(fl);
      Stream.WriteStr(s);
      Stream.WriteDouble(Contract.RedSum);
      Stream.WriteDouble(Contract.VioletSum);
      Stream.WriteStr(Contract.ContComments); // комментарий
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//====================================== список контрактов к/а по профилям (Web)
procedure prContractList_new(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prContractList'; // имя процедуры/функции
var UserId, FirmID, i, ii, j, posProf, posCont, ProfCount, contCount: integer;
    sWarn: string;
    Contract: TContract;
    Client: TClientInfo;
    firma: TFirmInfo;
    prof: TCredProfile;
    flBlock: Boolean;
begin
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csContractList, UserID, FirmID); // логирование

    if CheckNotValidUser(UserID, FirmID, sWarn) then raise EBOBError.Create(sWarn);

    firma:= Cache.arFirmInfo[FirmID];
    Client:= Cache.arClientInfo[UserID];

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    posProf:= Stream.Position;
    Stream.WriteInt(0); // место под кол-во профилей
    ProfCount:= 0;      // счетчик профилей

    for ii:= 0 to firma.FirmCredProfiles.Count-1 do begin
      prof:= TCredProfile(firma.FirmCredProfiles[ii]);
      if not Assigned(prof) then prof:= ZeroCredProfile;

      posCont:= Stream.Position;
      Stream.WriteInt(0); // место под кол-во контрактов в профиле
      contCount:= 0;      // счетчик контрактов в профиле

      for i:= 0 to Client.CliContracts.Count-1 do begin
        j:= Client.CliContracts[i];
        Contract:= Client.GetCliContract(j);

        if (Contract.CredProfile<>prof.ID) then Continue; // отбор по профилю

        flBlock:= Contract.SaleBlocked or prof.Blocked;
        sWarn:= Contract.WarnMessage;
        if flBlock and (sWarn='') then sWarn:= prof.WarnMessage;

        Stream.WriteInt(Contract.ID);
        Stream.WriteStr(Contract.Name);
        Stream.WriteInt(Contract.PayType);
        Stream.WriteStr(Contract.LegalFirmName); // юр.лицо
        Stream.WriteInt(Contract.DutyCurrency);
        if (Contract.Status=cstClosed) then begin
          Stream.WriteStr('');
          Stream.WriteStr('');
        end else begin
          Stream.WriteStr(Cache.GetDprtShortName(Contract.MainStorage));
          Stream.WriteStr(Cache.GetDprtMainName(Contract.MainStorage));
        end;
//------------------------------------------------- объединенные ячейки таблицы
        Stream.WriteDouble(prof.ProfCredLimit); // общий лимит кредита
        Stream.WriteStr(Cache.GetCurrName(prof.ProfCredCurrency, True)); // валюта
        Stream.WriteInt(prof.ProfCredDelay);    // общая отсрочка

        Stream.WriteDouble(prof.ProfDebtAll);   // общий долг - добавлена строка !!!

//-------------------------------------------------
        Stream.WriteDouble(Contract.DebtSum);  // долг контракта
        Stream.WriteDouble(Contract.OrderSum); // резерв контракта
        Stream.WriteInt(Contract.Status);      // статус контракта
// Status=cstClosed, WarnMessage=""   - закрыт              - без фона
// Status=cstWorked, WarnMessage=""   - действует           - зеленый фон
// SaleBlocked=True, WarnMessage<>""  - заблокирован/закрыт - красный фон
// SaleBlocked=False, WarnMessage<>"" - действует/закрыт    - сиреневый фон
        Stream.WriteBool(flBlock); // SaleBlocked
        Stream.WriteStr(sWarn);    // WarnMessage
        Stream.WriteDouble(Contract.RedSum);    // просрочено
        Stream.WriteDouble(Contract.VioletSum); // истекает срок
        Stream.WriteStr(Contract.ContComments); // комментарий

        Inc(contCount);
      end; // for i:= 0 to Client.CliContracts.Count-1

      Stream.Position:= posCont; // возвращаемся на позицию счетчика контрактов
      if (contCount>0) then begin // есть контракты по профилю
        Stream.WriteInt(contCount);    // пишем кол-во контрактов
        Stream.Position:= Stream.Size; // идем в конец Stream
        Inc(ProfCount);
      end;
    end; // for ii:= 0 to firma.FirmCredProfiles.Count-1

    if (ProfCount>0) then begin
      Stream.Position:= posProf;
      Stream.WriteInt(ProfCount); // кол-во профилей
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//==============================================================================
procedure prRemindPass(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prRemindPass'; // имя процедуры/функции
      ErrStr = 'Ошибка восстановления пароля - ';
var IBS: TIBSQL;
    IBD: TIBDatabase;
    UserId, FirmID, ind, ps: integer;
    s, login, IP, CliMail: string;
    Client: TClientInfo;
    flMail: Boolean;
    ilst: TIntegerList;
    lst: TStringList;
begin
  Stream.Position:= 0;
  IBS:= nil;
  IBD:= nil;
//  Client:= nil;
  ilst:= TIntegerList.Create; // поиск по Email: коды к/а
  lst:= TStringList.Create;   // поиск по Email: текст в письмо
//  flMail:= False;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    login:= Stream.ReadStr;  // или Email
    IP:= Stream.ReadStr;

    ps:= pos('@', login);
    flMail:= (ps>0); // флаг поиска по Email

    prSetThLogParams(ThreadData, csRemindPass, UserID, FirmID,
      fnIfStr(flMail, 'Email=', 'login=')+login+' IP='+IP); // логирование
//    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    if (login='') then raise EBOBError.Create('отсутствует логин или Email.');

    UserId:= -1;
    if flMail then begin //-------------------------------------------- по Email
      CliMail:= ExtractFictiveEmail(Login);
      if not fnCheckEmail(CliMail) then  // проверяем Email
        raise EBOBError.Create('Некорректный Email');
      try                     // ищем в базе
        IBD:= cntsGRB.GetFreeCnt;
        IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, True);
        IBS.SQL.Text:= 'Select PEPERSONCODE from PERSONEMAILS'+
          ' inner join PERSONS on PRSNCODE=PEPERSONCODE and PRSNARCHIVEDKEY="F"'+
          '   and PRSNLOGIN is not null and trim(PRSNLOGIN)<>""'+
          ' inner join firms on firmcode=PRSNFIRMCODE and FIRMARCHIVEDKEY="F"'+
          '   and FirmServiceFirm="F" where PEARCHIVEDKEY="F"'+
          '   and :email containing ","||PEUPPEREMAIL||","';
        IBS.ParamByName('email').AsString:= ','+UpperCase(CliMail)+',';
        IBS.ExecQuery;
        while not IBS.Eof do begin
          UserId:= IBS.FieldByName('PEPERSONCODE').AsInteger;
          Cache.TestClients(UserId, true); // загрузка данных клиента в кэш
          if Cache.ClientExist(UserId) then begin
            Client:= Cache.arClientInfo[UserId];
            if Client.Blocked then
              s:= ErrStr+'логин "'+Client.Login+'" заблокирован.'
            else s:= 'логин: '+Client.Login+' - пароль: '+Client.Password;
            lst.AddObject(s, Pointer(UserId));
            ilst.Add(Client.FirmID);
          end; // if Cache.ClientExist
          TestCssStopException;
          IBS.Next;
        end;
        IBS.Close;
      finally
        prFreeIBSQL(IBS);
        cntsGRB.SetFreeCnt(IBD);
      end;
      if (lst.Count<1) then raise EBOBError.Create(ErrStr+'Email "'+login+'" не найден.');

    end //--------------------- по Email
    else begin //----------------------------------------------------- по логину

      if not fnCheckOrderWebLogin(Login) then  // проверяем логин
        raise EBOBError.Create(MessText(mtkNotValidLogin, IntToStr(Cache.CliLoginLength)));

      ind:= Cache.arClientInfo.WorkLogins.IndexOf(login);
      if (ind>-1) then UserId:= integer(Cache.arClientInfo.WorkLogins.Objects[ind])
      else try                     // если не нашли в кэше, то ищем в базе
        IBD:= cntsORD.GetFreeCnt;
        IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, True);
        IBS.SQL.Text:= 'Select WOCLCODE from WEBORDERCLIENTS where WOCLLOGIN=:LOGIN';
        IBS.ParamByName('LOGIN').AsString:= login;
        IBS.ExecQuery;
        if not (IBS.Bof and IBS.Eof) then UserId:= IBS.FieldByName('WOCLCODE').AsInteger;
        IBS.Close;
      finally
        prFreeIBSQL(IBS);
        cntsORD.SetFreeCnt(IBD);
      end;
      if (UserId<1) then raise EBOBError.Create(ErrStr+'логин "'+login+'" не найден.');
      Cache.TestClients(UserId, true); // загрузка данных клиента в кэш
      if not Cache.ClientExist(UserId) then
        raise EBOBError.Create(ErrStr+'логин "'+login+'" не найден.');

      Client:= Cache.arClientInfo[UserId];
      if Client.Blocked then raise EBOBError.Create(ErrStr+'логин "'+login+'" заблокирован.');

      s:= '';
      CliMail:= ExtractFictiveEmail(Client.Mail);
      if (CliMail='') then s:= 'отсутствует e-mail.'
      else if not fnCheckEmail(CliMail) then s:= 'некорректный e-mail: '+CliMail+'.';
      if (s<>'') then raise EBOBError.Create(ErrStr+'в учетной записи с логином "'+login+'" '+s+
        ' Сообщите свой логин и e-mail обслуживающему Вашу организацию менеджеру Компании "Владислав".');

      lst.Add('Логин: '+Client.Login);
      lst.Add('Пароль: '+Client.Password);
      lst.Add('Учетная запись принадлежит организации '+Client.FirmName);
      ilst.Add(Client.FirmID);
    end; //--------------------- по логину
    s:= '';
    try
      IBD:= cntsLOG.GetFreeCnt;
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpWrite, True);
      IBS.SQL.Text:= 'select rErrText from CheckFirmIPRePass(:FirmID, :IP, '+
        Cache.GetConstItem(pcClientRePassTryLimit).StrValue+', '+
        Cache.GetConstItem(pcClientRePassMinutes).StrValue+')';
      IBS.ParamByName('IP').AsString:= IP;
      for ind:= 0 to ilst.Count-1 do begin
        with IBS.Transaction do if not InTransaction then StartTransaction;
        IBS.ParamByName('FirmID').AsInteger:= ilst[ind];
        IBS.ExecQuery;
        if (IBS.Bof and IBS.Eof) then raise Exception.Create(MessText(mtkNotValidParam));
        if (IBS.FieldByName('rErrText').AsString<>'') then
          s:= s+fnIfStr(s='', '', ' ')+IBS.FieldByName('rErrText').AsString;
        IBS.Transaction.Commit;
      end;
    finally
      prFreeIBSQL(IBS);
      cntsLOG.SetFreeCnt(IBD);
    end;
    if (s<>'') then raise EBOBError.Create(s);

//    if flMail then  //--------------------- по Email
      s:= prSendMailWithClientPassw(kcmRemindPass, '', '', CliMail, ThreadData, '', lst);
//    else            //--------------------- по логину
//      s:= prSendMailWithClientPassw(kcmRemindPass, Client.Login, Client.Password,
//                                    CliMail, ThreadData, Client.FirmName);

    if (s='') then s:= 'Напоминание пароля отправлено на Email '+
      fnIfStr(flMail, CliMail, 'пользователя с логином '+login)+
      '. ВНИМАНИЕ! Если письма нет в папке Входящие - проверьте папку Спам.';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(s);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(ilst);
  prFree(lst);
end;
//==============================================================================
procedure prGetContracts(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetContracts'; // имя процедуры/функции
var UserId, FirmID, ContID, MainStorage: integer;
    Client: TClientInfo;
    Firm: TFirmInfo;
    Contract: TContract;
    errmess: string;
begin
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetContracts, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Client:= Cache.arClientInfo[UserID];
    Firm:= Cache.arFirmInfo[FirmID];
    ContID:= Client.LastContract;
    Contract:= firm.GetContract(ContID);
    MainStorage:= Contract.MainStorage;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(Cache.arDprtInfo[MainStorage].ColumnName); //
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//==============================================================================
procedure prGetMainStoreLocation(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetMainStoreLocation'; // имя процедуры/функции
var UserId, FirmID, ContID, MainStorage: integer;
    firm: TFirmInfo;
    Contract: TContract;
    s: string;
    x, y: Single;
    dprt: TDprtInfo;
begin
  Stream.Position:= 0;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetMainStoreLocation, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    s:= '';
    x:= 0;
    y:= 0;
    ContID:= Cache.arClientInfo[UserID].LastContract;
    firm:= Cache.arFirmInfo[FirmID];
    Contract:= firm.GetContract(ContID);
    if (Contract.Status=cstClosed) then Contract:= firm.GetDefContract;
    MainStorage:= Contract.MainStorage;
    if Cache.DprtExist(MainStorage) then begin
      dprt:= Cache.arDprtInfo[MainStorage];
      s:= dprt.Adress;
      x:= dprt.AdrLatitude;
      y:= dprt.AdrLongitude;
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(s);    // адрес
    Stream.WriteDouble(x); // широта
    Stream.WriteDouble(y); // долгота
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
{//== сортировка TStringList призов - цена по возрастанию/убыванию + наименование
function BonusWaresSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
// в Object записывается Integer(Round(price)), в List.Delimiter: 'U'- Up, 'D'- Down
// сортировка вызывается List.CustomSort(BonusWaresSortCompare);
var i1, i2: integer;
    s1, s2, delim: String;
begin
  try
    i1:= 0;
    i2:= 0;
    delim:= '=';
    if Assigned(List.Objects[Index1]) then i1:= Integer(List.Objects[Index1]);
    if Assigned(List.Objects[Index2]) then i2:= Integer(List.Objects[Index2]);
    s1:= fnGetBefore(delim, List[Index1]);
    s2:= fnGetBefore(delim, List[Index2]);
    if i1=i2 then Result:= AnsiCompareText(s1, s2)
    else if (List.Delimiter='D') then begin
      if i1<i2 then Result:= 1 else Result:= -1;
    end else if i1<i2 then Result:= -1 else Result:= 1;
  except
    Result:= 0;
  end;
end; }
//============================================ сортировка по бонусам по убыванию
function BonusDescSortCompare(Item1, Item2: Pointer): Integer;
var R1, R2: Double;
    cq1, cq2: TCodeAndQty;
//    ware: TWareInfo;
//    s1, s2: String;
begin
  try
    cq1:= TCodeAndQty(Item1);
    cq2:= TCodeAndQty(Item2);
    R1:= cq1.Qty;
    R2:= cq2.Qty;
    if (R1>R2) then result:= -1 else if (R1<R2) then result:= 1
    else begin
{      ware:= Cache.arWareInfo[cq1.ID];
      s1:= ware.Name;
      ware:= Cache.arWareInfo[cq2.ID];
      s2:= ware.Name;
      result:= AnsiCompareText(s1, s2); }
      Result:= 0;
    end;
  except
    Result:= 0;
  end;
end;
(*
//====================================================== список призовых товаров
procedure prGetBonusWares(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetBonusWares'; // имя процедуры/функции
var UserId, FirmID, ContID, Pos, i, j, ii, kAtt, kAttv: integer;
    errmess: string;
    olWares:  TObjectList;
    pSelling: Double;
    cq: TCodeAndQty;
    Client: TClientInfo;
    ware: TWareInfo;
    Files: TarWareFileOpts;
    linkt: TTwoLink;
    lst: TList;
  //------------------------------------------ запись в поток атрибутов подарков
  procedure prSaveToStreamPrizAttributes;
  var i, ii, j, grPos, grCount: Integer;
      lstGr, lst: TList;
      flNew: Boolean;
      attgr: TSubDirItem;
  begin
    grCount:= 0;
    grPos:= Stream.Position;
    Stream.WriteInt(0);             // место под кол-во групп атрибутов
    lstGr:= Cache.GBPrizeAttrs.Groups.ItemsList; // Список групп атрибутов (TList) not Free !!!
    for i:= 0 to lstGr.Count-1 do begin
      attgr:= lstGr[i];
      if (attgr.Links.LinkCount<1) then Continue; // пропускаем группы атрибутов без товаров
      flNew:= (attgr.SrcID=1);
  //    Stream.WriteInt(attgr.ID+cGBattDelta); // код со сдвигом
      Stream.WriteInt(attgr.ID);             // код группы атрибутов
      Stream.WriteStr(attgr.Name);           // название
      Stream.WriteBool(flNew);               // признак новой группы атрибутов
      Inc(grCount);

      lst:= Cache.GBPrizeAttrs.GetGBGroupAttsList(attgr.ID); // Список атрибутов группы
      try
        Stream.WriteInt(lst.Count);       // кол-во атрибутов
        for j:= 0 to lst.Count-1 do with TGBAttribute(lst[j]) do begin
  //        Stream.WriteInt(ID+cGBattDelta);   // код атрибута со сдвигом
          Stream.WriteInt(ID);               // код атрибута
          Stream.WriteStr(Name);             // название
          Stream.WriteByte(SrcID);           // Тип
          with Links.ListLinks do begin //----- список линков на значения атрибута
            Stream.WriteInt(Count);                     // Количество значений
            for ii:= 0 to Count-1 do begin
  //            Stream.WriteInt(GetLinkID(Items[ii])+cGBattDelta); // код значения со сдвигом
              Stream.WriteInt(GetLinkID(Items[ii]));    // код значения
              Stream.WriteStr(GetLinkName(Items[ii]));  // само значение
            end;
          end;
        end; // for
      finally
        lst.free;
      end;
    end; // for i= 0
    if (grCount<1) then raise EBOBError.Create(MessText(mtkNotFoundData));
    Stream.Position:= grPos;
    Stream.WriteInt(grCount);  // кол-во групп
    Stream.Position:= Stream.Size;
  end;
  //--------------------------------------------------------------
begin
  Stream.Position:= 0;
  olWares:= TObjectList.Create;
  SetLength(Files, 0);
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetBonusWares, UserID, FirmID, 'ContID='+IntToStr(ContID)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Client:= Cache.arClientInfo[UserID];
    ContID:= Client.LastContract;

    for i:= 1 to High(Cache.arWareInfo) do if Cache.WareExist(i) then begin
      ware:= Cache.arWareInfo[i];
      if ware.IsArchive then Continue;              // отсев по архивности
      if not ware.IsPrize then Continue;            // отсев по непризовости
      if (ware.PgrID=Cache.pgrDeliv) then Continue; // пропускаем доставки
      pSelling:= ware.SellingPrice(FirmID, Cache.BonusCrncCode, contID);
      if not fnNotZero(pSelling) then Continue;     // пропускаем товары без цены
      cq:= TCodeAndQty.Create(ware.ID, pSelling, ware.Name);
      olWares.Add(cq);
    end;

    olWares.Sort(BonusDescSortCompare);   // сортировка по бонусам по убыванию

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

if flBonusAttr then
    prSaveToStreamPrizAttributes; // запись в поток атрибутов подарков

    Pos:= Stream.Position;
    j:= 0;
    Stream.WriteInt(0); //
    for I:= 0 to olWares.Count-1 do begin
      cq:= TCodeAndQty(olWares[i]);
      ware:= Cache.arWareInfo[cq.ID];
      Stream.WriteInt(cq.ID);        // код товара
      Stream.WriteDouble(cq.Qty);    // кол-во бонусов
      Stream.WriteStr(ware.Name);    // наименование товара
      Stream.WriteStr(ware.Comment); // описание товара
      inc(j);
if flBonusAttr then begin
      lst:= ware.PrizAttLinks.ListLinks;
      Stream.WriteInt(ware.PrizAttGroup); // передаем код группы атрибутов
      Stream.WriteInt(lst.Count);         // передаем кол-во значений атрибутов
      for ii:= 0 to lst.Count-1 do begin
        linkt:= TTwoLink(lst[ii]);
        kAtt:= TGBAttribute(linkt.LinkPtr).ID;     // код атрибута
        kAttv:= TBaseDirItem(linkt.LinkPtrTwo).ID; // код значения
        Stream.WriteInt(kAtt);   // передаем код атрибута
        Stream.WriteInt(kAttv);  // передаем код значения
      end;
end; // if flBonusAttr
    end;
    if (j>0) then begin
      Stream.Position:= Pos;
      Stream.WriteInt(j);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(olWares);
  SetLength(Files, 0);
end;
*)
//====================================================== список призовых товаров
procedure prGetBonusWares(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetBonusWares'; // имя процедуры/функции
var UserId, FirmID, ContID, Pos, AttvPos, i, wareCount, ii, j, kAtt, kAttv,
      attCount, gr, storeMain, sem: integer;
    errmess, sPrev, s, ss, sArrive: string;
    olWares, olExcludes, olPrevPrices: TObjectList;
    pSelling, curr: Single;
    cq, tc: TTwoCodes;
    Client: TClientInfo;
    ware: TWareInfo;
    linkt: TTwoLink;
    lst: TList;
    StorageCodes: Tai;
    GBIBD: TIBDatabase;
    GBIBS: TIBSQL;
  //------------------------------------------ запись в поток атрибутов подарков
  procedure prSaveToStreamPrizAttributes;
  var i, ii, j, grPos, grCount: Integer;
      lstGr, lst: TList;
      flNew: Boolean;
      attgr: TSubDirItem;
  begin
    grCount:= 0;
    grPos:= Stream.Position;
    Stream.WriteInt(0);             // место под кол-во групп атрибутов
    lstGr:= Cache.GBPrizeAttrs.Groups.ItemsList; // Список групп атрибутов (TList) not Free !!!
    for i:= 0 to lstGr.Count-1 do begin
      attgr:= lstGr[i];
      if (attgr.Links.LinkCount<1) then Continue; // пропускаем группы атрибутов без товаров

      flNew:= (attgr.SrcID=1);
  //    Stream.WriteInt(attgr.ID+cGBattDelta); // код со сдвигом
      Stream.WriteInt(attgr.ID);             // код группы атрибутов
      Stream.WriteStr(attgr.Name);           // название
      Stream.WriteBool(flNew);               // признак новой группы атрибутов
      Inc(grCount);

      lst:= Cache.GBPrizeAttrs.GetGBGroupAttsList(attgr.ID); // Список атрибутов группы
      for j:= lst.Count-1 downto 0 do with TGBAttribute(lst[j]) do
        if (Links.ListLinks.Count<2) then begin // если значений атрибута < 2
          tc:= TTwoCodes.Create(attgr.ID, ID);
          olExcludes.Add(tc); // запоминаем исключения - коды группы и атрибута
          lst.Delete(j);      // удаляем
        end;

      try
        Stream.WriteInt(lst.Count);       // кол-во атрибутов
        for j:= 0 to lst.Count-1 do with TGBAttribute(lst[j]) do begin
  //        Stream.WriteInt(ID+cGBattDelta);   // код атрибута со сдвигом
          if (Links.ListLinks.Count<2) then Continue;
          Stream.WriteInt(ID);               // код атрибута
          Stream.WriteStr(Name);             // название
          Stream.WriteByte(SrcID);           // Тип
          with Links.ListLinks do begin //----- список линков на значения атрибута
            Stream.WriteInt(Count);                     // Количество значений
            for ii:= 0 to Count-1 do begin
  //            Stream.WriteInt(GetLinkID(Items[ii])+cGBattDelta); // код значения со сдвигом
              Stream.WriteInt(GetLinkID(Items[ii]));    // код значения
              Stream.WriteStr(GetLinkName(Items[ii]));  // само значение
            end;
          end;
        end; // for
      finally
        lst.free;
      end;
    end; // for i= 0
    if (grCount<1) then raise EBOBError.Create(MessText(mtkNotFoundData));
    Stream.Position:= grPos;
    Stream.WriteInt(grCount);  // кол-во групп
    Stream.Position:= Stream.Size;
  end;
  //--------------------------------------------------------------
  function GetPrizeRestSem(wareID: Integer): Integer;
  // -1 - нет нигде, 0- нет на складах контракта, 1- есть на потом, 2- есть на сегодня
  var j: Integer;
      q: TCodeAndQty;
      OList: TObjectList;
  begin
    Result:= -1;
    sArrive:= '';
    OList:= Cache.GetWareRestsByStores(wareID); // подарки
    try
      for j:= 0 to OList.Count-1 do begin
        q:= TCodeAndQty(OList[j]);
        if (q.Qty<constDeltaZero) then Continue; // остатка нет
        if (Result<0) then Result:= 0;           // где-то есть

        if (fnInIntArray(q.ID, StorageCodes)<0) then Continue; // склад не тот
        if (q.ID=storeMain) then begin // главный склад
          Result:= 2;        // есть на сегодня
          break;
        end else if (Result<1) then Result:= 1; // есть на потом
      end; // for j:= 0 to OList.Count-1

if flSpecRestSem then
      //------------- проверяем возможность поставки на сегодня (спец.семафор=3)
      if (Result=1) then begin
        sArrive:= CheckDprtTodayFill(StoreMain, OList); // подсказка для спец.семафора
        if (sArrive<>'') then Result:= 3;
      end;
    finally
      prFree(OList);
    end;

  end;
  //--------------------------------------------------------------
begin
  Stream.Position:= 0;
  GBIBD:= nil;
  GBIBS:= nil;
  olWares:= TObjectList.Create;
  olExcludes:= TObjectList.Create;
  olPrevPrices:= TObjectList.Create;
  SetLength(StorageCodes, 0);
  storeMain:= 0;
  sPrev:= '';
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetBonusWares, UserID, FirmID, 'ContID='+IntToStr(ContID)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Client:= Cache.arClientInfo[UserID];

    if Client.CheckIsFinalClient then raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

    ContID:= Client.LastContract;          // ???

    storeMain:= fnGetContMainStoreAndStoreCodes(FirmID, ContID, StorageCodes);

    for i:= 1 to High(Cache.arWareInfo) do if Cache.WareExist(i) then begin
      ware:= Cache.arWareInfo[i];
      if ware.IsArchive then Continue;               // отсев по архивности
      if (ware.PgrID=Cache.pgrDeliv) then Continue;  // пропускаем доставки
      if not ware.IsPrize then Continue;             // отсев по непризовости
      pSelling:= ware.SellingPrice(FirmID, Cache.BonusCrncCode, contID);
      if not fnNotZero(pSelling) then Continue;     // пропускаем товары без цены
      sem:= GetPrizeRestSem(i);
//      if (sem<0) then Continue;                      // отсев по наличию - нет нигде
      if (sem<1) then Continue;                      // отсев по наличию - нет на складах контракта
      cq:= TTwoCodes.Create(ware.ID, sem, pSelling, sArrive);
      olWares.Add(cq);

      if ware.IsCatchMom then begin // список предыдущих цен для "Лови момент"
        cq:= TTwoCodes.Create(ware.ID, 0);
        olPrevPrices.Add(cq);
        sPrev:= sPrev+fnIfStr(sPrev='', '', ',')+IntToStr(ware.ID);
      end;

    end; // for i:= 1 to High(Cache.arWareInfo)

    if (olPrevPrices.Count>0) then begin // ищем предыдущие цены
      GBIBD:= CntsGRB.GetFreeCnt();
      try
        s:= IntToStr(Cache.arFirmInfo[FirmID].GetContract(contID).ContPriceType);
        ss:= cStrDefCurrCode;
        GBIBS:= fnCreateNewIBSQL(GBIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
        GBIBS.SQL.Text:='select warecode, coalesce(cm.RESULTVALUE, cm1.RESULTVALUE) prev'+
          '  from (select w.warecode, w.waremeas, (select MAX(PriceDate) from PRICELIST'+
          '    where PriceSubFirmCode=1 and PriceWareCode=w.warecode'+
          '      and PriceTypeCode='+s+' and PriceDate<="today") xDate'+
          '    from wares w where w.warecode in ('+sPrev+'))'+
          '  left join GETWAREPRICE(xDate-1, warecode, '+s+', waremeas) p on 1=1'+
          '  left join ConvertMoney(p.RPRICEWARE, p.RCRNCCODE, '+ss+', xDate-1) cm'+
          '    on exists(select * from RateCrnc where RateCrncCode=p.RCRNCCODE)'+
          '  left join GETWAREPRICE("today", warecode, '+s+', waremeas) p1 on 1=1'+
          '  left join ConvertMoney(p1.RPRICEWARE, p1.RCRNCCODE, '+ss+', "today") cm1'+
          '    on exists(select * from RateCrnc where RateCrncCode=p1.RCRNCCODE)'+
          '  where xDate is not null';
        GBIBS.ExecQuery;
        while not GBIBS.EOF do begin
          i:= GBIBS.FieldByName('WareCode').AsInteger;
          for ii:= 0 to olPrevPrices.Count-1 do begin
            tc:= TTwoCodes(olPrevPrices[ii]);
            if (i<>tc.ID1) then Continue;

            pSelling:= GBIBS.FieldByName('prev').AsFloat; // пред.цена в Euro
            curr:= Cache.Currencies.GetCurrRate(Cache.BonusCrncCode);
            if fnNotZero(curr) then                       // пред.цена в бонусах
              pSelling:= pSelling*Cache.Currencies.GetCurrRate(cDefCurrency)/curr;
            tc.Qty:= RoundToHalfDown(pSelling);
            break;
          end; // for ii:= 0 to olPrevPrices.Count-1
          TestCssStopException;
          GBIBS.Next;
        end;
      finally
        prFreeIBSQL(GBIBS);
        cntsGRB.SetFreeCnt(GBIBD);
      end;
    end; // if (olPrevPrices.Count>0)

    olWares.Sort(BonusDescSortCompare);   // сортировка по бонусам по убыванию

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

if flBonusAttr then
    prSaveToStreamPrizAttributes; // запись в поток атрибутов подарков

    Pos:= Stream.Position;
    wareCount:= 0;
    Stream.WriteInt(0); //
    for i:= 0 to olWares.Count-1 do begin
      cq:= TTwoCodes(olWares[i]);
      ware:= Cache.arWareInfo[cq.ID1];
      Stream.WriteInt(ware.ID);      // код товара
      Stream.WriteDouble(cq.Qty);    // бонусы (цена)
      Stream.WriteStr(ware.Name);    // наименование товара
      Stream.WriteStr(ware.Comment); // описание товара

if flNewBonusFilter then
      Stream.WriteInt(ware.WareBrandID); // код бренда товара (MOTUL - cbrMotul in v_constants)

      pSelling:= 0;
      if ware.IsCatchMom then for ii:= 0 to olPrevPrices.Count-1 do begin
        tc:= TTwoCodes(olPrevPrices[ii]);
        if (ware.ID<>tc.ID1) then Continue;
        pSelling:= tc.Qty;
        break;
      end;
      Stream.WriteBool(ware.IsNews);     // признак акции "Новинки"
      Stream.WriteBool(ware.IsCatchMom); // признак акции "Лови момент"
      Stream.WriteDouble(pSelling);      // зачеркнутые бонусы ("Лови момент") или 0
      Stream.WriteInt(cq.ID2);           // семафор остатков

if flSpecRestSem then
      Stream.WriteStr(cq.Name);          // подсказка к семафору (пока только к 3)

{if flDebug then begin
  if ware.IsNews then
    prMessageLOGS(nmProc+': Ware.IsNews     - '+ware.Name, fLogDebug, false); // пишем в log
  if ware.IsCatchMom then
    prMessageLOGS(nmProc+': Ware.IsCatchMom - '+ware.Name+', now= '+FloatToStr(cq.Qty)+
                  ', prev= '+FloatToStr(pSelling), fLogDebug, false); // пишем в log
end; // if flDebug  }

//------------------------------------------------------ атрибуты подарка
if flBonusAttr then begin
      gr:= ware.PrizAttGroup; // код группы атрибутов
      attCount:= 0;
      lst:= ware.PrizAttLinks.ListLinks;
      Stream.WriteInt(gr);        // передаем код группы атрибутов
      AttvPos:= Stream.Position;
      Stream.WriteInt(0);         // место под кол-во значений атрибутов
      for ii:= 0 to lst.Count-1 do begin
        linkt:= TTwoLink(lst[ii]);
        kAtt:= TGBAttribute(linkt.LinkPtr).ID;   // код атрибута
        for j:= 0 to olExcludes.Count-1 do begin // проверяем исключения
          tc:= TTwoCodes(olExcludes[j]);
          if (tc.ID1=gr) and (tc.ID2=kAtt) then begin
            kAtt:= 0; //
            break;
          end;
        end;
        if (kAtt<1) then Continue;
        kAttv:= TBaseDirItem(linkt.LinkPtrTwo).ID; // код значения
        Stream.WriteInt(kAtt);   // передаем код атрибута
        Stream.WriteInt(kAttv);  // передаем код значения
        Inc(attCount);
      end;
      if (attCount>0) then begin
        Stream.Position:= AttvPos;
        Stream.WriteInt(attCount); // передаем кол-во значений атрибутов
        Stream.Position:= Stream.Size;
      end;
end; // if flBonusAttr
//------------------------------------------------------
      inc(wareCount);
    end; // for I:= 0 to olWares.Count-1
    if (wareCount>0) then begin
      Stream.Position:= Pos;
      Stream.WriteInt(wareCount);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(olWares);
  prFree(olExcludes);
  prFree(olPrevPrices);
  SetLength(StorageCodes, 0);
end;
//------------------------------------------------------------ vc

//========================================= просмотр параметров заголовка заказа
procedure prGetOrderHeaderParams(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetOrderHeaderParams'; // имя процедуры/функции
var ordIBD: TIBDatabase;
    ordIBS: TIBSQL;
    UserId, FirmID, DestID, ShipTableID, ShipMetID, ShipTimeID, DelivType,
      ContID, DprtID, accType, Status, i, MeetPerson: integer;
    OrderCode, sWarrNum, sWarrPers, sStoreComm, sDestName, sShipMet, sShipTime,
      sArrive, sDestAdr, err, sShipView, sSelfComm, sMeetText: string;
    WarrDate, ShipDate: double;
    Accounts, Invoices: TDocRecArr;
    GBdirection, flDontJoin: Boolean;
begin
  Stream.Position:= 0;
  ordIBS:= nil;
//  ordIBD:= nil;
  DestID:= 0;
  ShipDate:= 0;
  ShipTableID:= 0;
  ShipMetID:= 0;
  ShipTimeID:= 0;
  sShipMet:= '';
  sShipTime:= '';
  sArrive:= '';
  sDestName:= '';
  sDestAdr:= '';
  DelivType:= cDelivReserve;
  WarrDate:= 0;
  accType:= 0;
  contID:= 0;
  DprtID:= 0;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  flDontJoin:= False;
  MeetPerson:= 0;
  sMeetText:= '';
  try
//-------------------------- from CGI - begin
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    GBdirection:= Stream.ReadBool;
//-------------------------- from CGI - end

    prSetThLogParams(ThreadData, csGetOrderHeaderParams, UserID, FirmID, 'OrderId='+OrderCode); // логирование

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    if CheckNotValidUser(UserID, FirmID, err) then raise EBOBError.Create(err);

    ordIBD:= cntsORD.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, ThreadData.ID, tpWrite, True);
      ordIBS.SQL.Text:= 'Select ORDRSTATUS, ORDRWARRANT, ORDRWARRANTPERSON,'+ // ищем  заказ
        ' ORDRCONTRACT, ORDRWARRANTDATE, ORDRSTORAGECOMMENT, ORDRDESTPOINT,'+
        ' ORDRSHIPDATE, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID, ORDRSTORAGE,'+
        ' ORDRDELIVERYTYPE, ORDRACCOUNTINGTYPE, ORDRSELFCOMMENT, OrdrDontJoinAcc'+
        fnIfStr(flMeetPerson, ', ordrAccMeetPerson, ordrAccMeetText', '')+
        ' FROM ORDERSREESTR WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
      ordIBS.ExecQuery;
      if ordIBS.Bof and ordIBS.Eof then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

      sWarrNum:= ordIBS.FieldByName('ORDRWARRANT').AsString;
      sWarrPers:= ordIBS.FieldByName('ORDRWARRANTPERSON').AsString;
      WarrDate:= ordIBS.FieldByName('ORDRWARRANTDATE').AsDateTime;
      sStoreComm:= ordIBS.FieldByName('ORDRSTORAGECOMMENT').AsString;
      sSelfComm:= ordIBS.FieldByName('ORDRSELFCOMMENT').AsString;
      DelivType:= ordIBS.FieldByName('ORDRDELIVERYTYPE').AsInteger;
      accType:= ordIBS.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;
      Status:= ordIBS.FieldByName('ORDRSTATUS').AsInteger;
      contID:= ordIBS.FieldByName('ORDRCONTRACT').AsInteger;
      if Cache.arClientInfo[UserID].CheckContract(contID) then
        DprtID:= Cache.arClientInfo[UserID].GetCliContract(contID).MainStorage
      else DprtID:= ordIBS.FieldByName('ORDRSTORAGE').AsInteger;

if not flNewSaveAcc then flDontJoin:= True else
      flDontJoin:= GetBoolGB(ordIBS, 'OrdrDontJoinAcc');  // True - не объединять счета

if flMeetPerson then begin
      MeetPerson:= ordIBS.FieldByName('ordrAccMeetPerson').AsInteger;
      sMeetText := ordIBS.FieldByName('ordrAccMeetText').AsString;
end; // flMeetPerson

      if ((Status>orstProcessing) and (Status<orstAnnulated)) then begin
        err:= fnGetClosingDocsOrd(OrderCode, Accounts, Invoices, Status, ThreadData.ID);
        if (err<>'') then raise Exception.Create(err);
      end;

     case DelivType of
        cDelivTimeTable: begin //------------------------ Доставка по расписанию
          ShipDate:= ordIBS.FieldByName('ORDRSHIPDATE').AsDateTime;
          if (ShipDate<DateNull) then ShipDate:= 0;
          DestID:= ordIBS.FieldByName('ORDRDESTPOINT').AsInteger;
          ShipTableID:= ordIBS.FieldByName('ORDRTIMETIBLE').AsInteger;
          ShipMetID:= ordIBS.FieldByName('ORDRSHIPMETHOD').AsInteger;
          ShipTimeID:= ordIBS.FieldByName('ORDRSHIPTIMEID').AsInteger;
        end; // cDelivTimeTable

        cDelivReserve: begin // Резерв
        end; // cDelivReserve

        cDelivSelfGet: begin //--------------------------------------- Самовывоз
          ShipDate:= ordIBS.FieldByName('ORDRSHIPDATE').AsDateTime;
//          ShipMetID:= ordIBS.FieldByName('ORDRSHIPMETHOD').AsInteger;
          ShipMetID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
          ShipTimeID:= ordIBS.FieldByName('ORDRSHIPTIMEID').AsInteger;
        end; // cDelivSelfGet

      else DelivType:= cDelivReserve; //--------------------------------- резерв
      end; // case
      ordIBS.Close;
    finally
      prFreeIBSQL(ordIBS);
      cntsORD.SetFreeCnt(ordIBD);
    end;
    err:= fnGetShipParamsView(contID, DprtID, DestID, ShipTableID, ShipDate,
          DelivType, ShipMetID, ShipTimeID, sDestName, sDestAdr, sArrive,
          sShipMet, sShipTime, sShipView, GBdirection);
    if (err<>'') then raise Exception.Create(err);

    if (WarrDate<DateNull) then WarrDate:= 0;
    if (ShipDate<DateNull) then ShipDate:= 0;

    Stream.Clear;
//-------------------------- to CGI - begin
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteStr(sWarrNum);    // номер доверености
    Stream.WriteStr(sWarrPers);   // ФИО в доверености
    Stream.WriteDouble(WarrDate); // дата доверености
    Stream.WriteStr(sStoreComm);  // комментарий
    Stream.WriteStr(sSelfComm);   // личный комментарий
    Stream.WriteInt(DelivType);   // вид доставки
    Stream.WriteInt(accType);     // тип оплаты: 0- нал, 1- б/нал

    Stream.WriteInt(DestID);      // код торговой точки
    Stream.WriteStr(sDestName);   // название торговой точки
    Stream.WriteStr(sDestAdr);    // адрес торговой точки
    Stream.WriteDouble(ShipDate); // дата отгрузки
    Stream.WriteInt(ShipTableID); // код расписания
//    Stream.WriteInt(ShipMetID);   // код способа отгрузки
    Stream.WriteStr(sShipMet);    // название способа отгрузки
    Stream.WriteInt(ShipTimeID);  // код времени отгрузки
    Stream.WriteStr(sShipTime);   // текст времени отгрузки
    Stream.WriteStr(sArrive);     // текст даты/времени прибытия

    Stream.WriteInt(Length(Accounts)); // док-ты
    for i:= Low(Accounts) to High(Accounts) do begin
      Stream.WriteInt(Accounts[i].ID);
      if (Accounts[i].ID>0) then with Accounts[i] do begin
                  // если f -счет необр., если t-  обр., если ничего - накладная
        Stream.WriteByte(fnIfInt(Accounts[i].Processed, byte('t'), byte('f')));
        Stream.WriteStr(Cache.GetDprtMainName(DprtID));
        Stream.WriteStr(Number+cWebSpace+fnIfStr(Accounts[i].Processed, cWebProcessed, ''));
        Stream.WriteStr(Commentary);
        Stream.WriteDouble(Data);
        Stream.WriteDouble(Summa);
        Stream.WriteStr(CurrencyName);
      end;
      Stream.WriteInt(Invoices[i].ID);
      if (Invoices[i].ID>0) then with Invoices[i] do begin
        Stream.WriteStr(Cache.GetDprtMainName(DprtID));
        Stream.WriteStr(Number);
        Stream.WriteDouble(Data);
        Stream.WriteDouble(Summa);
        Stream.WriteStr(CurrencyName);
      end;
    end;

if flNewSaveAcc then
    Stream.WriteBool(flDontJoin); // True - не объединять счета

if flMeetPerson then begin
    Stream.WriteInt(MeetPerson);  // код встречающего
    Stream.WriteStr(sMeetText);   // текст встречающего
end; // flMeetPerson

//-------------------------- to CGI - end
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
end;
//============================================== редактирование заголовка заказа
procedure prEditOrderHeaderParams(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prEditOrderHeaderParams'; // имя процедуры/функции
      Mess1  = ' может содержать не более ';
      Mess2  = ' символов, лишних - ';
var ordIBD, grbIBD: TIBDatabase;
    ordIBS, grbIBS: TIBSQL;
    UserID, FirmID, DestID, stID, smID, ttID, deliv, ContID, DprtID, i, Curr,
      OrderID, WareCount, MeetPerson, lenMeetText: integer;
    OrderCode, sWarrNum, sWarrPers, sStoreComm, s, ss, ErrorPos, SResult, sMeetText: string;
    flWarrNum, flWarrPers, flStoreComm, flWarrDate, flShipDate, flRefreshPrice,
      flSendToProcessing, flSelfComm, flResLimit, flDontJoin, flMeetText, flCheckWareLimits: Boolean;
    WarrDate, d, sum, LineSum, OrderSum: double;
    firma: TFirmInfo;
    Contract: TContract;
    ShipDate: TDateTime;
//    ffp: TForFirmParams;
begin
  Stream.Position:= 0;
  ordIBS:= nil;
//  ordIBD:= nil;
  grbIBS:= nil;
  grbIBD:= nil;
//  ffp:= nil;
  flWarrNum:= False;
  flWarrPers:= False;
  flWarrDate:= False;
  flStoreComm:= False;
  flShipDate:= False;
  flSelfComm:= False;
  flMeetText:= False;
  ContID:= 0;
  smID:= 0;   // код способа отгрузки
  MeetPerson:= 0;
  sMeetText:= '';
  try
//-------------------------- from CGI - begin
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;   // код заказа в симв.виде
    sWarrNum:= Stream.ReadStr;    // номер доверености
    sWarrPers:= Stream.ReadStr;   // ФИО в доверености
    WarrDate:= Stream.ReadDouble; // дата доверености
    sStoreComm:= Stream.ReadStr;  // комментарий в счет
    deliv:= Stream.ReadInt;       // вид доставки: 0 - Доставка, 1 - Резерв, 2 - Самовывоз
    DestID:= Stream.ReadInt;      // код торговой точки
    ShipDate:= Stream.ReadDouble; // дата отгрузки
    ttID:= Stream.ReadInt;        // код расписания
    stID:= Stream.ReadInt;        // код времени отгрузки
    flSendToProcessing:= Stream.ReadBool; // True - отправлять на обработку

if flNewSaveAcc then begin
    flDontJoin:= Stream.ReadBool;  // True - не объединять счета
end else flDontJoin:= True;

if flMeetPerson then begin
    MeetPerson:= Stream.ReadInt; // код (телефона) встречающего (при резерве - 0)
    sMeetText := Stream.ReadStr; // текст встречающего
end; // flMeetPerson

if not flCheckLimits then flCheckWareLimits:= False else
    flCheckWareLimits:= Stream.ReadBool; // флаг проверки лимитов по кол-ву и весу

//-------------------------- from CGI - end

    if (WarrDate<DateNull) then WarrDate:= 0;
    if (ShipDate<DateNull) then ShipDate:= 0;

    prSetThLogParams(ThreadData, csEditOrderHeaderParams, UserID, FirmID, 'OrderId='+OrderCode+ // логирование
      #13#10'ORDRWARRANT='+sWarrNum+#13#10'ORDRWARRANTPERSON='+sWarrPers+
      #13#10'ORDRWARRANTDATE='+FormatDateTime(cDateFormatY2, WarrDate)+
      #13#10'ORDRSTORAGECOMMENT='+sStoreComm+#13#10'ORDRDELIVERYTYPE='+IntToStr(deliv)+
      #13#10'ORDRDESTPOINT='+IntToStr(DestID)+
      #13#10'ORDRSHIPDATE='+FormatDateTime(cDateFormatY2, ShipDate)+
      #13#10'ORDRTIMETIBLE='+IntToStr(ttID)+#13#10'ORDRSHIPTIMEID='+IntToStr(stID));

    OrderID:= StrToIntDef(OrderCode, 0);
    if (OrderID<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    i:= Length(sWarrNum)-Cache.OrdWarrNumLength; // проверяем длину текстовых значений
    if (i>0) then raise EBOBError.Create('Номер доверенности'+Mess1+
      IntToStr(Cache.OrdWarrNumLength)+Mess2+IntToStr(i));
    i:= Length(sWarrPers)-Cache.OrdWarrPersLength;
    if (i>0) then raise EBOBError.Create('ФИО'+Mess1+
      IntToStr(Cache.OrdWarrPersLength)+Mess2+IntToStr(i));
    i:= Length(sStoreComm)-Cache.OrdCommentLength;
    if (i>0) then raise EBOBError.Create('Комментарий'+Mess1+
      IntToStr(Cache.OrdCommentLength)+Mess2+IntToStr(i));

    if not (deliv in [cDelivTimeTable, cDelivReserve, cDelivSelfGet]) then
      raise EBOBError.Create('Неизвестный вид доставки - '+IntToStr(deliv));

    firma:= Cache.arFirmInfo[FirmId];

ErrorPos:= '1';
    ordIBD:= cntsORD.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, ThreadData.ID, tpRead, True);
      ordIBS.SQL.Text:= 'Select ORDRSTATUS, ORDRWARRANT, ORDRWARRANTPERSON,'+ // ищем  заказ
        ' ORDRCONTRACT, ORDRWARRANTDATE, ORDRSTORAGECOMMENT, ORDRDESTPOINT,'+
        ' ORDRDELIVERYTYPE, ORDRSTORAGE, ORDRSHIPDATE, ORDRTIMETIBLE, ORDRSUMORDER,'+
        ' ORDRSHIPMETHOD, ORDRSHIPTIMEID, ORDRFIRM, ORDRCURRENCY, ORDRSELFCOMMENT,'+
        ' OrdrWareLineCount, OrdrDontJoinAcc'+
        fnIfStr(flMeetPerson, ', ordrAccMeetPerson, ordrAccMeetText', '')+
        ' FROM ORDERSREESTR WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
      ordIBS.ExecQuery;
      if ordIBS.Bof and ordIBS.Eof then
        raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
                                      // проверяем, можно ли заказ редактировать
      if (ordIBS.FieldByName('ORDRSTATUS').AsInteger<>orstForming) then
        raise EBOBError.Create(MessText(mtkNotEditOrder));
                   // проверяем, имеет ли право этот человек редактировать заказ
      if ordIBS.FieldByName('ORDRFIRM').AsInteger<>FirmID then
        raise EBOBError.Create(MessText(mtkNotRightExists));

      sum:= ordIBS.FieldByName('ORDRSUMORDER').AsFloat;
      Curr:= ordIBS.FieldByName('ORDRCURRENCY').AsInteger;
      if (contID<1) then contID:= ordIBS.FieldByName('ORDRCONTRACT').AsInteger;

      Contract:= firma.GetContract(contID);
      if (Contract.Status=cstClosed) then   // проверка на доступность контракта
        raise EBOBError.Create('Контракт '+Contract.Name+' недоступен');

      DprtID:= Contract.MainStorage;
      case deliv of
        cDelivTimeTable: begin // Доставка по расписанию
          stID:= 0;
          if (ShipDate<1) or (DestID<1) or (DprtID<1) then ttID:= 0
          else if (ttID>0) then try
            grbIBD:= cntsGRB.GetFreeCnt;
            grbIBS:= fnCreateNewIBSQL(grbIBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, True);
            grbIBS.SQL.Text:= 'select rSMethodID, rSTimeID'+
              ' from Vlad_CSS_GetContDestTimeTables'+fnIfStr(flNewArrive, '1', '')+
              '('+IntToStr(contID)+', '+IntToStr(DestID)+', '+IntToStr(DprtID)+
              ', :pDate) where RttID='+IntToStr(ttID);
            grbIBS.ParamByName('pDate').AsDate:= ShipDate;
            grbIBS.ExecQuery;
            if not (grbIBS.Bof and grbIBS.Eof) then begin
              smID:= grbIBS.FieldByName('rSMethodID').AsInteger;
              stID:= grbIBS.FieldByName('rSTimeID').AsInteger;
            end else ttID:= 0;
          finally
            prFreeIBSQL(grbIBS);
            cntsGRB.SetFreeCnt(grbIBD);
          end;
        end; // cDelivTimeTable

        cDelivReserve: begin // Резерв
          DestID:= 0;
          ShipDate:= 0;
          ttID:= 0;
          stID:= 0;
        end; // cDelivReserve

        cDelivSelfGet: begin // Самовывоз
          DestID:= 0;
          ttID:= 0;
          smID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
        end; // cDelivSelfGet
      end; // case

      s:= '';
      if (sWarrNum<>ordIBS.FieldByName('ORDRWARRANT').AsString) then begin
        flWarrNum:= (sWarrNum<>'');
        if flWarrNum then ss:= ':ORDRWARRANT' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ORDRWARRANT='+ss;
      end;
      if (sWarrPers<>ordIBS.FieldByName('ORDRWARRANTPERSON').AsString) then begin
        flWarrPers:= (sWarrPers<>'');
        if flWarrPers then ss:= ':ORDRWARRANTPERSON' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ORDRWARRANTPERSON='+ss;
      end;
      d:= ordIBS.FieldByName('ORDRWARRANTDATE').AsDateTime;
      if (trunc(abs(WarrDate-d))>0) then begin
        flWarrDate:= (WarrDate>DateNull);
        if flWarrDate then ss:= ':ORDRWARRANTDATE' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ORDRWARRANTDATE='+ss;
      end;
      if (sStoreComm<>ordIBS.FieldByName('ORDRSTORAGECOMMENT').AsString) then begin
        flStoreComm:= (sStoreComm<>'');  // комментарий в счет
        if flStoreComm then ss:= ':ORDRSTORAGECOMMENT' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ORDRSTORAGECOMMENT='+ss;
      end;
      d:= ordIBS.FieldByName('ORDRSHIPDATE').AsDateTime;
      if (trunc(abs(ShipDate-d))>0) then begin
        flShipDate:= (ShipDate>DateNull);
        if flShipDate then ss:= ':ORDRSHIPDATE' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ORDRSHIPDATE='+ss;
      end;
      if (DestID<>ordIBS.FieldByName('ORDRDESTPOINT').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ORDRDESTPOINT='+
            fnIfStr(DestID>0, IntToStr(DestID), 'null');
      if (ttID<>ordIBS.FieldByName('ORDRTIMETIBLE').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ORDRTIMETIBLE='+
            fnIfStr(ttID>0, IntToStr(ttID), 'null');
      if (smID<>ordIBS.FieldByName('ORDRSHIPMETHOD').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ORDRSHIPMETHOD='+
            fnIfStr(smID>0, IntToStr(smID), 'null');
      if (stID<>ordIBS.FieldByName('ORDRSHIPTIMEID').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ORDRSHIPTIMEID='+
            fnIfStr(stID>0, IntToStr(stID), 'null');
      if (deliv<>ordIBS.FieldByName('ORDRDELIVERYTYPE').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ORDRDELIVERYTYPE='+IntToStr(deliv);

if flNewSaveAcc then begin
      if (flDontJoin<>GetBoolGB(ordIBS, 'OrdrDontJoinAcc')) then
        s:= s+fnIfStr(s='','',',')+'OrdrDontJoinAcc="'+fnIfStr(flDontJoin, 'T', 'F')+'"';
end; // flNewSaveAcc

if flMeetPerson then begin
      lenMeetText:= ordIBS.FieldByName('ordrAccMeetText').Size; // встречающий
      if not (deliv in [cDelivTimeTable, cDelivSelfGet]) then begin
        MeetPerson:= 0;
        sMeetText:= '';
      end else sMeetText:= copy(sMeetText, 1, lenMeetText);
      if (MeetPerson<>ordIBS.FieldByName('ordrAccMeetPerson').AsInteger) then
        s:= s+fnIfStr(s='','',',')+'ordrAccMeetPerson='+
            fnIfStr(MeetPerson>0, IntToStr(MeetPerson), 'null');
      if (sMeetText<>ordIBS.FieldByName('ordrAccMeetText').AsString) then begin
        flMeetText:= (sMeetText<>'');  //
        if flMeetText then ss:= ':ordrAccMeetText' else ss:= 'null';
        s:= s+fnIfStr(s='','',',')+'ordrAccMeetText='+ss;
      end;
end; // flMeetPerson
      ordIBS.Close;

      fnSetTransParams(ordIBS.Transaction, tpWrite, True); // готовим к записи

  ErrorPos:= '2';
      if (s<>'') then begin //--------- если надо - редактируем заголовок заказа
         ordIBS.SQL.Text:=  'Update ORDERSREESTR set '+s+
          ' WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
        if flWarrNum   then ordIBS.ParamByName('ORDRWARRANT').AsString       := sWarrNum;
        if flWarrPers  then ordIBS.ParamByName('ORDRWARRANTPERSON').AsString := sWarrPers;
        if flWarrDate  then ordIBS.ParamByName('ORDRWARRANTDATE').AsDateTime := WarrDate;
        if flStoreComm then ordIBS.ParamByName('ORDRSTORAGECOMMENT').AsString:= sStoreComm;
        if flShipDate  then ordIBS.ParamByName('ORDRSHIPDATE').AsDateTime    := ShipDate;
        if flMeetText  then ordIBS.ParamByName('ordrAccMeetText').AsString   := sMeetText;
        s:= RepeatExecuteIBSQL(ordIBS);
        if s<>'' then raise Exception.Create(s);

      end else if not flSendToProcessing then raise EBOBError.Create('Нет изменений');

//------------------------------------------ если надо - отправляем на обработку
      if flSendToProcessing then begin

      if flNotReserve and (deliv=cDelivReserve) then
        raise EBOBError.Create('Резервирование заблокировано');

if flMeetPerson then begin
        if (deliv in [cDelivTimeTable, cDelivSelfGet]) and (MeetPerson<1) then
          raise EBOBError.Create('Не указан встречающий');
end; // flMeetPerson
                                                 // флаг проверки лимита резерва
        flResLimit:= (firma.ResLimit>=0) and (Curr<>Cache.BonusCrncCode);
        if flResLimit and (firma.ResLimit=0) then
          raise EBOBError.Create('Резервирование заблокировано'); // ???

        //----------------- проверяем запрет отгрузки
        if (firma.SaleBlocked or Contract.SaleBlocked) then begin
          if (deliv=cDelivTimeTable) then s:= 'Доставка недоступна'
          else if (deliv=cDelivSelfGet) then s:= 'Самовывоз недоступен'
          else s:= '';
          if (s<>'') then raise EBOBError.Create(s);
        end;

        OrderSum:= 0;
        LineSum:= 0;
        flRefreshPrice:= (Curr<>Cache.BonusCrncCode) and (Curr<>Contract.DutyCurrency);
  ErrorPos:= '3';
        s:= CheckAccountShipParams(deliv, ContID, DprtID, ShipDate, DestID, ttID, smID, stID, True);
        if (s<>'') then raise EBOBError.Create(s);

        //----------------- проверяем наличие товаров, превышение лимита резерва
        if flResLimit then firma.CheckReserveLimit; // проверяем лимит резерва
        i:= fnIfInt(flRefreshPrice, Contract.DutyCurrency, Curr); // в какой валюте
        if not flResLimit then WareCount:= 2
        else WareCount:= OrdIBS.FieldByName('OrdrWareLineCount').AsInteger;
        s:= CheckOrdWaresExAndOverLimit(FirmID, UserID, ContID, OrderID, i, flResLimit, True, (WareCount<2));
        if s<>'' then raise EBOBError.Create(MessText(mtkNotProcOrder)+' '+s);

        if flRefreshPrice then begin
  ErrorPos:= '4';
          s:= fnRefreshPriceInOrderOrd(SResult, OrderCode, ThreadData);
          if (s<>'') then // если функция выполнилась с ошибкой - отправляем ошибку
            if copy(s, 1, 3)='EB:' then raise EBOBError.Create(copy(s, 4, length(s)))
            else raise Exception.Create(s);
        end;

        if flCheckWareLimits then begin // проверяем лимиты по кол-ву и весу
  ErrorPos:= '5';


          if ( false ) then begin
            Stream.Clear;
            Stream.WriteInt(erWareLimitOut); // превышение лимитов - требуется подтверждение


            Exit;
          end;
        end;

  ErrorPos:= '6';
        //-------------------------------------- для резерва комментарий очищаем
        if flSendToProcessing and (deliv=cDelivReserve) and (sStoreComm<>'') then
          sStoreComm:= ', ORDRSTORAGECOMMENT=""'
        else sStoreComm:= '';
                                               // все проверено - меняем статус
        with ordIBS.Transaction do if not InTransaction then StartTransaction;
        ordIBS.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstProcessing)+
          ', ORDRTOPROCESSPerson='+IntToStr(UserId)+', ORDRTOPROCESSDATE="NOW"'+sStoreComm+
          ' WHERE ORDRCODE='+OrderCode;
        s:= RepeatExecuteIBSQL(ordIBS);
        if s<>'' then raise Exception.Create(s);

        firma.SetContUnitOrd(0); // обнуляем контракт unit-заказа
      end; // if flSendToProcessing
//-------------------------------------------------------- if flSendToProcessing
    finally
      prFreeIBSQL(ordIBS);
      cntsORD.SetFreeCnt(ordIBD);
    end;

    Stream.Clear;
//-------------------------- to CGI - begin
    if flSendToProcessing and firma.SKIPPROCESSING then begin

//      if flNewSaveAcc then begin
        // записать товары в счет Grossbee с объединением счетов
        i:= fnOrderToGB(OrderID, False, True, ss, ThreadData);
        Stream.WriteInt(i);
        case i of
          aeCommonError  : Stream.WriteStr('Ошибка записи документа.');
          erWareToAccount: Stream.WriteStr(ss); // были ошибки при записи товаров
        end;

{      end else begin
        Stream.WriteInt(OrderID);
        Stream.WriteBool(False); // не проверять параметры отгрузки
        prOrderToGBn_Ord(Stream, ThreadData, True); // здесь ответ записывается внутри
      end;  }
      Firma.CheckReserveLimit; // уточняем лимит и резерв к/а

    end else Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
//-------------------------- to CGI - end
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, 'ErrorPos='+ErrorPos, True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, 'ErrorPos='+ErrorPos, False);
  end;
  Stream.Position:= 0;
end;
//======================================== редактирование комментария "для себя"
procedure prEditOrderSelfComment(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prEditOrderSelfComment'; // имя процедуры/функции
      Mess1 = ' может содержать не более ';
      Mess2 = ' символов';
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    UserId, FirmID, i: integer;
    OrderCode, SelfComm, s: string;
begin
  Stream.Position:= 0;
  OrdIBS:= nil;
  OrdIBD:= nil;
  try
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    OrderCode:= Stream.ReadStr;
    SelfComm:= Stream.ReadStr;

    prSetThLogParams(ThreadData, csEditOrderSelfComment, UserID, FirmID, 'OrderCode='+OrderCode+ // логирование
      #13#10'ORDRSELFCOMMENT='+SelfComm);

    i:= StrToIntDef(OrderCode, 0);
    if (i<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    i:= Length(SelfComm)-Cache.OrdSelfCommLength;
    if (i>0) then raise EBOBError.Create('Личный комментарий'+Mess1+
      IntToStr(Cache.OrdSelfCommLength)+Mess2+IntToStr(i));

    OrdIBD:= cntsORD.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpWrite, True);
// ищем  заказ
    OrdIBS.SQL.Text:= 'Select ORDRSTATUS, ORDRSELFCOMMENT'+
      ' FROM ORDERSREESTR WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
    OrdIBS.ExecQuery;
    if OrdIBS.Bof and OrdIBS.Eof then
      raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
// потом проверяем, можно ли заказ редактировать
    if (OrdIBS.FieldByName('ORDRSTATUS').AsInteger<>orstForming) then
      raise EBOBError.Create(MessText(mtkNotEditOrder));

    if (OrdIBS.FieldByName('ORDRSELFCOMMENT').AsString=SelfComm) then // нет изменений
      raise EBOBError.Create(MessText(mtkNotChanges));
    OrdIBS.Close;

    OrdIBS.SQL.Text:= 'Update ORDERSREESTR set ORDRSELFCOMMENT=:ORDRSELFCOMMENT'+
      ' WHERE ORDRCODE='+OrderCode+' and ORDRFIRM='+IntToStr(FirmID);
    OrdIBS.ParamByName('ORDRSELFCOMMENT').AsString:= SelfComm;
    s:= RepeatExecuteIBSQL(OrdIBS);
    if s<>'' then raise Exception.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(OrdIBD);
  Stream.Position:= 0;
end;
//==================================== просмотр бонусного неотправленного заказа
procedure prShowBonusFormingOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowBonusFormingOrder'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    UserId, FirmID, i, spos, LineCount, contID, MainStore,
      DestID, ShipTableID, DelivType, ShipMetID, ShipTimeID, OrderID: integer;
    OrderCode, err, s, sDestName, sDestAdr, sArrive, sShipMet, sShipTime, sShipView, CurrCode: string;
    Storages: TaSD;
    Ware: TWareInfo;
    GBdirection: Boolean;
    anw: Tai;
    qty, price, ShipDate, bonFormOrd, bonAccount, bonUnitAcc: Double;
    Contract: TContract;
    firma: TFirmInfo;
    Client: TClientInfo;
begin
  Stream.Position:= 0;
  IBS:= nil;
//  OrdIBD:= nil;
  contID:= 0;
  LineCount:= 0;            // счетчик - кол-во строк
  OrderCode:= '';
  bonFormOrd:= 0; // бонусы по неотправленным заказам
  bonAccount:= 0; // бонусы по счетам резерва
  bonUnitAcc:= 0; // бонусы по unit-счетам резерва
  try
//----------------------------------------------------------- read from stream +
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    GBdirection:= Stream.ReadBool;
//----------------------------------------------------------- read from stream -

    prSetThLogParams(ThreadData, csShowBonusFormingOrder, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    firma:= Cache.arFirmInfo[FirmId];
    if firma.IsFinalClient then raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

    Client:= Cache.arClientInfo[UserID];
    CurrCode:= IntToStr(Cache.BonusCrncCode);

    IBD:= cntsORD.GetFreeCnt;
    try
      IBS:= fnCreateNewIBSQL(IBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, True);
      s:= 'SELECT ORDRCODE, ORDRSUMORDER, ORDRNUM, ORDRDATE, ORDRSELFCOMMENT,'+  // , ORDRACCOUNTINGTYPE
        ' ORDRDELIVERYTYPE, ORDRCREATORPERSON, ORDRSTORAGECOMMENT, ORDRDESTPOINT,'+
        ' ORDRSHIPDATE, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID, ORDRCONTRACT'+
        ' from ORDERSREESTR';
      IBS.SQL.Text:= s+' where ORDRFIRM='+IntToStr(FirmId)+
        ' and ORDRSTATUS='+IntToStr(orstForming)+' and ORDRCURRENCY='+CurrCode;
      IBS.ExecQuery;
      if IBS.Bof and IBS.Eof then begin // если нет - создаем новый бонусный заказ
        IBS.Close;
        contID:= Client.LastContract;
{
        Contract:= firma.GetContract(contID);
        if (Contract.PayType>0) then begin
          Contract:= firma.GetAvailableContract; // найти действующий контракт фирмы (желательно наличный)
          if Assigned(Contract) then contID:= Contract.ID;
        end;
}
        prCreateNewOrderCommonOrd(UserId, FirmID, OrderID, ContID, err, ThreadData.ID, nil, Cache.BonusCrncCode);
        if (err<>'') then raise EBOBError.Create(err);
        OrderCode:= IntToStr(OrderID);
        IBS.SQL.Text:= s+' where ORDRCODE='+OrderCode;
        IBS.ExecQuery;
      end else begin
        contID:= IBS.FieldByName('ORDRCONTRACT').AsInteger;

        if (contID>0) and not Client.CheckContract(contID) then
          raise EBOBError.Create(MessText(mtkFuncNotAvailabl));

        OrderID:= IBS.FieldByName('ORDRCODE').AsInteger;
        OrderCode:= IBS.FieldByName('ORDRCODE').AsString;
      end;
      Contract:= firma.GetContract(contID);
      MainStore:= Contract.MainStorage;

      firma.SetContUnitOrd(contID); // проверяем контракт unit-заказа

      DelivType:= IBS.FieldByName('ORDRDELIVERYTYPE').AsInteger;
      DestID:= IBS.FieldByName('ORDRDESTPOINT').AsInteger;
      ShipTableID:= IBS.FieldByName('ORDRTIMETIBLE').AsInteger;
      ShipDate:= IBS.FieldByName('ORDRSHIPDATE').AsDateTime;
      ShipMetID:= IBS.FieldByName('ORDRSHIPMETHOD').AsInteger;
      ShipTimeID:= IBS.FieldByName('ORDRSHIPTIMEID').AsInteger;
      err:= fnGetShipParamsView(contID, MainStore, DestID, ShipTableID, ShipDate,
            DelivType, ShipMetID, ShipTimeID, sDestName, sDestAdr, sArrive,
            sShipMet, sShipTime, sShipView, GBdirection);
      if (err<>'') then sShipView:= '';
      i:= IBS.FieldByName('ORDRCREATORPERSON').AsInteger; // Передаем создателя заказа
      if (i=0) or not Cache.ClientExist(i) then s:= ''
      else s:= fnCutFIO(Cache.arClientInfo[i].Name);
      price:= IBS.FieldByName('ORDRSUMORDER').AsFloat;
//------------------------------------------------------------- save to stream +
      Stream.Clear;
      Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
      Stream.WriteInt(contID);                               // код контракта
      Stream.WriteStr(Contract.Name);                        // номер контракта
      Stream.WriteInt(OrderID);                              // код заказа
      Stream.WriteStr(IBS.FieldByName('ORDRNUM').AsString);  // номер заказа
      Stream.WriteStr(FormatDateTime(cDateFormatY2, IBS.FieldByName('ORDRDATE').AsDateTime)); // дата
      Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));       // сумма заказа = бонусы текущего unit-заказа (-)
      Stream.WriteInt(DelivType);                            // тип доставки
      Stream.WriteStr(sShipView);                            // строка параметров отгрузки
      Stream.WriteStr(IBS.FieldByName('ORDRSTORAGECOMMENT').AsString); // комментарий
      Stream.WriteStr(Cache.GetDprtColName(Contract.MainStorage));     // заголовок д/склада
      Stream.WriteStr(Cache.GetDprtMainName(Contract.MainStorage));    // подсказка д/склада
      Stream.WriteStr(IBS.FieldByName('ORDRSELFCOMMENT').AsString);    // личный комментарий
      Stream.WriteStr(IntToStr(Contract.MainStorage));                 // код склада

      sPos:= Stream.Position;
      Stream.WriteInt(0); //  место под кол-во строк
//------------------------------------------------------------- save to stream -
      IBS.Close;
      IBS.SQL.Text:= 'SELECT OL.ORDRLNWARE, OL.ORDRLNCODE, OL.ORDRLNCLIENTQTY, OL.ORDRLNPRICE'+
        ' from ORDERSLINES OL where ORDRLNORDER='+OrderCode;
      IBS.ExecQuery;
      while not IBS.EOF do begin
        i:= IBS.FieldByName('ORDRLNWARE').AsInteger;
        Ware:= Cache.GetWare(i);
        if not Assigned(Ware) or (Ware=NoWare) then
          raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(i)));

        qty:= IBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;
        price:= IBS.FieldByName('ORDRLNPRICE').AsFloat;
//------------------------------------------------------------- save to stream +
        Stream.WriteInt(IBS.FieldByName('ORDRLNCODE').AsInteger);
        Stream.WriteStr(IBS.FieldByName('ORDRLNWARE').AsString);
        Stream.WriteStr(Ware.WareBrandName);
        Stream.WriteStr(Ware.Name);
        Stream.WriteDouble(qty);
        Stream.WriteStr(Ware.MeasName);
        Stream.WriteStr(FloatToStr(RoundToHalfDown(price)));
        Stream.WriteStr(FloatToStr(RoundToHalfDown(price*qty)));
//------------------------------------------------------------- save to stream -
        inc(LineCount);
        TestCssStopException;
        IBS.Next;
      end; // while not OrdIBS.EOF
//------------------------------------------------------------- save to stream +
    Stream.Position:= sPos;
    Stream.WriteInt(LineCount);
    Stream.Position:= Stream.Size;
//------------------------------------------------------------- save to stream -

//--------------------------------------------- бонусы по неотправленным заказам
      IBS.Close;
      IBS.SQL.Text:= 'SELECT sum(ORDRSUMORDER) summa, ORDRCURRENCY'+
        ' from ORDERSREESTR where ORDRFIRM='+IntToStr(FirmId)+
        ' and ORDRCODE<>'+OrderCode+' and ORDRCURRENCY<>'+CurrCode+
        ' and ORDRSTATUS='+IntToStr(orstForming)+' group by ORDRCURRENCY';
      IBS.ExecQuery;
      while not IBS.EOF do begin
        i:= IBS.FieldByName('ORDRCURRENCY').AsInteger;                   // валюта
        price:= IBS.FieldByName('summa').AsFloat*Cache.GetPriceBonusCoeff(i); // кол-во бонусов
        bonFormOrd:= bonFormOrd+price;
        TestCssStopException;
        IBS.Next;
      end; // while not OrdIBS.EOF
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD);
    end;
//----------------------------------------------------- бонусы по счетам резерва
    IBD:= cntsGRB.GetFreeCnt;
    try
      IBS:= fnCreateNewIBSQL(IBD, 'gbIBS_'+nmProc, ThreadData.ID, tpRead, True);
      IBS.SQL.Text:= 'SELECT sum(rPInvSumm) summa, rPInvCrnc'+
        ' from Vlad_CSS_GetFirmReserveDocsN('+IntToStr(FirmID)+', '+'0)'+
        ' group by rPInvCrnc';
      IBS.ExecQuery;
      while not IBS.EOF do begin
        i:= IBS.FieldByName('rPInvCrnc').AsInteger;                   // валюта
        price:= IBS.FieldByName('summa').AsFloat;
        if (i=Cache.BonusCrncCode) then
          bonUnitAcc:= bonUnitAcc+price  // бонусы по unit-счетам резерва
        else begin
          price:= price*Cache.GetPriceBonusCoeff(i); // кол-во бонусов
          bonAccount:= bonAccount+price; // бонусы по обычным счетам резерва
        end;
        TestCssStopException;
        IBS.Next;
      end; // while not OrdIBS.EOF
    finally
      prFreeIBSQL(IBS);
      cntsGRB.SetFreeCnt(IBD);
    end;
    if fnNotZero(firma.BonusRes-bonUnitAcc) then try
      firma.CS_firm.Enter;
      firma.BonusRes:= bonUnitAcc;
    finally
      firma.CS_firm.Leave;
    end;

//------------------------------------------------------------- save to stream +
    Stream.WriteStr(FloatToStr(Trunc(bonFormOrd))); // кол-во бонусов по неотправленным заказам (+)
    Stream.WriteStr(FloatToStr(Trunc(bonAccount))); // бонусы по обычным счетам резерва         (+)
    Stream.WriteStr(FloatToStr(Trunc(firma.BonusRes))); // бонусы по unit-счетам резерва            (-)
//------------------------------------------------------------- save to stream -
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  SetLength(anw, 0);
  SetLength(Storages, 0);
end;
//================================================ список акций для "Информации"
procedure prGetWareActions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetWareActions'; // имя процедуры/функции
var i, iCount, FirmID, UserID, iPos: Integer;
    s: String;
    wa: TWareAction;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetWareActions, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    iPos:= Stream.Position;
    Stream.WriteInt(0);    // место под кол-во акций
    iCount:= 0;
    for i:= 0 to Cache.WareActions.ItemsList.Count-1 do begin
      wa:= Cache.WareActions.ItemsList[i];
      if not wa.IsAction then Continue;
      s:= wa.Comment;
      Stream.WriteInt(wa.ID);    // код акции
      Stream.WriteStr(wa.Name);  // заголовок
      Stream.WriteStr(s);        // текст
      Inc(iCount);
    end;
    if (iCount>0) then begin
      Stream.Position:= iPos;
      Stream.WriteInt(iCount);    // кол-во акций
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//================================== проверка проблем отгрузки товаров по заказу
procedure prCheckOrderWareRests(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCheckOrderWareRests'; // имя процедуры/функции
var UserID, FirmID, WareID, DprtID, Count, i, OrderID, compDate, deliv, limit: integer;
    s, OrderCode, s1, s2, ss: string;
    ordIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    Ware: TWareInfo;
    OrdQty, ShipDate: double;
    OList: TObjectList;
    flToday: Boolean;
  //---------------------------------------
  procedure AddWareName;
  begin
    ss:= ss+fnIfStr(ss='', '', '; ')+Ware.Name;
    Inc(Count);
  end;
  //---------------------------------------
  procedure SaveReportToStream;
  begin
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(s); // текст предупреждения
    Stream.Position:= 0;
  end;
  //---------------------------------------
begin
  Stream.Position:= 0;
  ordIBD:= nil;
  OrdIBS:= nil;
  OList:= nil;
  s:= '';
  ss:= '';
  DprtID:= 0;
  Count:= 0;
  limit:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    OrderID:= Stream.ReadInt;      // код заказа
    ShipDate:= Stream.ReadDouble;  // дата отгрузки
    deliv:= Stream.ReadInt;        // вид доставки

    OrderCode:= IntToStr(OrderID);
    prSetThLogParams(ThreadData, csCheckOrderWareRests, UserID, FirmID, 'OrderCode='+OrderCode); // логирование

    if (OrderID<1) then raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));
    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    if (ShipDate<=DateNull) then compDate:= -1
    else compDate:= CompareDate(ShipDate, Date);
    flToday:= (compDate=0); // пока проверяем остатки только сегодня
    s:= '';

    if not (deliv in [cDelivTimeTable, cDelivReserve, cDelivSelfGet]) then  // , cDelivClientNow
      deliv:= cDelivReserve; // резерв

    //------------------------------------------------ проверяем срок действия
    with fnSplit(',', Cache.GetConstItem(pcAccountStorageDays).StrValue) do try  // TStringList
      if (Count>deliv) then limit:= StrToIntDef(Strings[deliv], 0);
      if (limit>0) then begin
        s1:= 'ВНИМАНИЕ! Через '+Strings[deliv]+' дн. заявка ';
        s2:= ' будет аннулирована.';
        case deliv of
          cDelivTimeTable: // Доставка по расписанию
            if ((Date()+limit)<ShipDate) then s:= s+s1+'(доставка)'+s2;
          cDelivSelfGet  : // Самовывоз
            if ((Date()+limit)<ShipDate) then s:= s+s1+'(самовывоз)'+s2;
          cDelivReserve  : // Резерв
            s:= s+s1+'(резерв)'+s2;
        end;
      end; // if (limit>0)
    finally
      Free;
    end;

    if (compDate<0) or not flToday then begin  // дата <> сегодняшней - остатки не проверяем
      SaveReportToStream;
      Exit;
    end;

    try
      ordIBD:= CntsOrd.GetFreeCnt();
      OrdIBS:= fnCreateNewIBSQL(ordIBD,'OrdIBS_'+nmProc, ThreadData.ID, tpRead, true);
      OrdIBS.SQL.Text:= 'SELECT ORDRSTORAGE, ORDRLNWARE, ORDRLNCLIENTQTY'+
        ' FROM ORDERSREESTR left join ORDERSLINES on ORDRLNORDER=ORDRCODE'+
        ' WHERE ORDRCODE='+OrderCode;
      OrdIBS.ExecQuery;
      if (OrdIBS.EOF and OrdIBS.BOF) then
        raise EBOBError.Create(MessText(mtkNotFoundOrder, OrderCode));

      while not OrdIBS.EOF do begin
        if (DprtID<1) then  // на 1-й строке находим склад
          DprtID:= OrdIBS.FieldByName('ORDRSTORAGE').AsInteger;
        WareID:= OrdIBS.FieldByName('ORDRLNWARE').AsInteger;
        if (WareID<1) then Ware:= NoWare else Ware:= Cache.GetWare(WareID, True);
        if (Ware<>NoWare) then begin
          OrdQty:= OrdIBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;

          OList:= Cache.GetWareRestsByStores(WareID); // проверка остатков по товару
          try
            if (OList.Count<1) then AddWareName
            else for i:= 0 to OList.Count-1 do with TCodeAndQty(OList[i]) do
              if flToday and (ID=DprtID) and (OrdQty>Qty) then begin // если нашли склад на сегодня
                AddWareName;                                         // и заказано больше, чем есть
                break;
              end;
          finally
            prFree(OList);
          end;

        end; // if (Ware<>NoWare)
        cntsORD.TestSuspendException;
        OrdIBS.Next;
      end;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(ordIBD);
    end;

    if (Count>0) then begin
      s1:= 'ВНИМАНИЕ! На складе отгрузки ';
      s2:= ' заказанного количества товар'+fnIfStr(Count=1, 'а', 'ов');
      if flToday then s:= s+fnIfStr(s='', '', ' ')+s1+'сегодня нет в наличии'+s2+' '+ss+'.';
//      s:= s+' Предлагаем изменить дату отгрузки.';
    end;

    SaveReportToStream;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//============================= получить сообщение о превышении лимита по заказу
function GetOrderOverSummMess(currID: integer; OverSumm, OrderSum, LastLineSum: Double): String;
// если лимит превышен - возвращает сообщение о превышении
begin
  Result:= '';
  OrderSum:= RoundTo(OrderSum, -2);
  LastLineSum:= RoundTo(LastLineSum, -2);
  OverSumm:= OverSumm+OrderSum-LastLineSum; // проверяем без учета последней строки заказа
  if (OverSumm>0.0099) then // превышение - в сообщение (с учетом последней строки заказа)
    Result:= 'Сумма заказа превышает остаток лимита резерва на '+
      FormatFloat(cFloatFormatSumm, OverSumm+LastLineSum)+' '+Cache.GetCurrName(CurrID, True);
end;
//=============== проверка наличия товаров в заказе и остатка лимита резерва к/а
function CheckOrdWaresExAndOverLimit(FirmID, UserID, ContID, OrderID, CurrID: Integer;
                                    flResLimit, flExWares, flSingleLine: Boolean; ibs: TIBSQL=nil): String;
const nmProc = 'CheckOrdWaresExAndOverLimit'; // имя процедуры/функции
var IBD: TIBDatabase;
    s: String;
    i: Integer;
    OrderSum, LineSum, Qty, LineQty, OverSumm, price: Double;
    prices: TDoubleDynArray;
    Firma: TFirmInfo;
    flCreate: Boolean;
begin
  Result:= '';
  if not flExWares and not flResLimit then Exit; // нечего проверять
  ibd:= nil;
  s:= '';
  Qty:= 0;
  OrderSum:= 0;
  LineSum:= 0;
  OverSumm:= 0;
  flCreate:= False;
  try
    Firma:= Cache.arFirmInfo[FirmID];
    flResLimit:= flResLimit and (CurrID<>Cache.BonusCrncCode); // в бонусных заказах лимит не проверяем
//--------------------------------------------------- вычисляем общее превышение
    if flResLimit then begin
      s:= firma.GetOverSummAll(currID, OverSumm);
      if (s<>'') then raise EBOBError.Create(s);
      flResLimit:= (firma.ResLimit>0);   // в заказах с 1-й строкой не проверяем
      if flResLimit and not flExWares and flSingleLine then Exit;
    end;

//------------------ проверяем наличие товаров / считаем актуальную сумму заказа
    if flExWares or flResLimit then try
      flCreate:= not Assigned(ibs);
      if flCreate then begin
        IBD:= cntsORD.GetFreeCnt;
        IBS:= fnCreateNewIBSQL(IBD, 'ordIBS_'+nmProc, -1, tpRead, True);
      end;
      with IBS.Transaction do if not InTransaction then StartTransaction;
      if (IBS.SQL.Text='') then IBS.SQL.Text:= 'SELECT ORDRLNWARE, ORDRLNCLIENTQTY'+
        ', ORDRLNPRICE from ORDERSLINES where ORDRLNORDER=:ord order by ORDRLNCODE';
      IBS.ParamByName('ord').AsInteger:= OrderID;
      IBS.ExecQuery;
      if (IBS.Bof and IBS.Eof) then
        if flExWares then raise EBOBError.Create('нет товаров') else Exit;

      while not IBS.EOF do begin
        LineQty:= IBS.FieldByName('ORDRLNCLIENTQTY').AsFloat;
        LineSum:= 0;
        if fnNotZero(LineQty) then begin
          Qty:= Qty+LineQty;
          if flResLimit then begin
            i:= IBS.FieldByName('ORDRLNWARE').AsInteger;
            price:= Cache.GetWare(i).SellingPrice(FirmID, CurrID, contID);
            //--------------------------- вычисляем актуальную сумму по товару
            LineSum:= price*LineQty;
            OrderSum:= OrderSum+LineSum; // считаем актуальную сумму заказа
          end; // if flResLimit
        end; // if fnNotZero(LineQty)
        TestCssStopException;
        IBS.Next;
      end; // while not IBS.EOF
    finally
      IBS.Close;
      if flCreate then begin
        prFreeIBSQL(IBS);
        cntsORD.SetFreeCnt(IBD);
      end;
      SetLength(prices, 0);
    end; // if flExWares or flResLimit

    if not fnNotZero(Qty) then
      if flExWares then raise EBOBError.Create('Нет товаров') else Exit;
    if not flResLimit then Exit; // превышение лимита не надо проверять - выходим

//----------------------------------------------- вычисляем возможное превышение
    s:= GetOrderOverSummMess(currID, OverSumm, OrderSum, LineSum);
    if (s<>'') then raise EBOBError.Create(s);

  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//============================================= Получить список счетов на оплату
procedure prGetBankAccountsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetBankAccountsList'; // имя процедуры/функции
var UserID, FirmID, iCount, pos: integer;
    s, sFirm, sNum, sPname: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    fl: Boolean;
begin
  Stream.Position:= 0;
  IBD:= nil;
  IBS:= nil;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetBankAccountsList, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    sFirm:= Cache.arFirmInfo[FirmID].UPPERSHORTNAME;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    iCount:= 0;
    pos:= Stream.Position;
    Stream.WriteInt(iCount); //----- передаем кол-во счетов
    try
      IBD:= CntsGRB.GetFreeCnt();                      //
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpRead, true);
      IBS.SQL.Text:= 'SELECT BKATCODE, BKATNUMBER, BKATSUMM, cs.RHaveDuplicate,'+
        ' iif(BKATPERSONCODE is null, BKATPERSONNAME, p.prsnname) pname,'+
        ' iif(BKATPERSONPHONECODE is null, bkatpersonphone, pphphone) phone,'+
        ' gn.rNum contnumber FROM bankaccountreestr'+
        ' left join persons p on p.prsncode=BKATPERSONCODE'+
        ' left join personphones on pphcode=BKATPERSONPHONECODE'+
        ' left join contract on contcode=BKATCONTRACTCODE'+
        ' left join Vlad_CSS_GetFullContNum(contnumber, contnkeyyear, contpaytype) gn on 1=1'+
        ' left join SENDSMSFROMBANKACCOUNT(BKATCODE, 2) cs on 1=1'+ // 2- check insert
        ' WHERE BKATFIRMCODE='+IntToStr(FirmID)+
        '   and bkatdate>="today" and BKATPAYMENTCODE is null and BKATSUMM>0';
      IBS.ExecQuery;
      while not IBS.EOF do begin
        sNum:= IBS.FieldByName('BKATNUMBER').AsString;
        s:= IBS.FieldByName('phone').AsString;
        fl:= GetBoolGB(ibs, 'RHaveDuplicate') or (s='') or not CheckMobileNumber(s);

        Stream.WriteInt(IBS.FieldByName('BKATCODE').AsInteger);  //----- передаем код счета
        Stream.WriteStr(IBS.FieldByName('contnumber').AsString); //----- передаем контракт
        Stream.WriteStr(sNum);                                   //----- передаем № счета
        Stream.WriteDouble(IBS.FieldByName('BKATSUMM').AsFloat); //----- передаем сумму
        sPname:= fnReplaceQuotedForWeb(IBS.FieldByName('pname').AsString); // переводит кавычки ' и " в `
        Stream.WriteStr(sPname);      //----- передаем конт.лицо
        Stream.WriteStr('Счет: '+sNum+', код клиента: '+sFirm);  //----- передаем Реквизиты для КБ Приватбанк
        Stream.WriteBool(fl);                                    //----- передаем признак запрета отправки SMS

        inc(iCount);
        CntsGRB.TestSuspendException;
        IBS.Next;
      end;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;
    if (iCount>0) then begin
      Stream.Position:= pos;
      Stream.WriteInt(iCount); // кол-во счетов
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//============================================ Сформировать новый счет на оплату
procedure prNewBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prNewBankAccount'; // имя процедуры/функции
var UserID, FirmID, ii, iCount, i, j, pos: integer;
    s, sCliCodes: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    sum: double;
    Contract: TContract;
    Client: TClientInfo;
    firma: TFirmInfo;
    arLimits: TDoubleDynArray;
    lstCliCodes: TIntegerList;
//    lst: TStringList;
begin
  Stream.Position:= 0;
  IBD:= nil;
  IBS:= nil;
  SetLength(arLimits, 0);
  lstCliCodes:= TIntegerList.Create;
//  lst:= TStringList.Create;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csNewBankAccount, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    firma:= Cache.arFirmInfo[FirmID];
    Client:= Cache.arClientInfo[UserID];

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    //----------------------------------------- доступные контракты пользователя
    iCount:= 0;
    pos:= Stream.Position;
    Stream.WriteInt(iCount);          //----- передаем кол-во контрактов
    for i:= 0 to Client.CliContracts.Count-1 do begin
      ii:= Client.CliContracts[i];
      if not Cache.Contracts.ItemExists(ii) then Continue;

      Contract:= Cache.Contracts[ii];
      if (Contract.Status<cstBlocked) then Continue; // закрытые пропускаем   ???
      if (Contract.PayType>0) then Continue;         // безнал пропускаем

      Stream.WriteInt(Contract.ID);   //----- передаем код контракта
      Stream.WriteStr(Contract.Name); //----- передаем № контракта
      inc(iCount);
    end;
    if (iCount>0) then begin
      Stream.Position:= pos;
      Stream.WriteInt(iCount);
      Stream.Position:= Stream.Size;
    end else raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));

    //------------------------------------------------------ доступные конт.лица
    sCliCodes:= ''; // строка с кодами клиентов для SQL (при Cache.flCheckCliBankLim=True)
    for i:= 0 to High(Firma.FirmClients) do begin
      ii:= Firma.FirmClients[i];
      if not Cache.ClientExist(ii) then Continue;

      Client:= Cache.arClientInfo[ii];
      if Client.Arhived then Continue;             // архивных пропускаем
//      if (Client.CliMails.Count<1) then Continue;  // без Email-ов пропускаем
//      if (Client.CliPhones.Count<1) then Continue; // без телефонов пропускаем
//      s:= CheckClientFIO(Client.Name); // проверка соответствия ФИО шаблонам
//      if s<>'' then Continue;

      if not Client.CliPay then Continue; // Проверка спец.птички

      lstCliCodes.Add(ii);
      if Cache.flCheckCliBankLim then
        sCliCodes:= sCliCodes+fnIfStr(sCliCodes='', '', ', ')+IntToStr(ii);
    end;
    if (lstCliCodes.Count<1) then
      raise EBOBError.Create('Не найдены контактные лица для документа');

    //------------- вычисляем доступные суммы оплаты (в пределах лимита в сутки)
    SetLength(arLimits, lstCliCodes.Count); // массив доступных сумм клиентов
    try
      IBD:= CntsGRB.GetFreeCnt();
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpRead, true);

      if Cache.flCheckCliBankLim then begin //----- проверка лимита по конт.лицу
        for i:= 0 to High(arLimits) do
          arLimits[i]:= Cache.BankLimitSumm; // сначала проставляем всем лимит банка
        IBS.SQL.Text:= 'select sum(BKATSUMM) summa, BKATPERSONCODE'+
          ' from bankaccountreestr where bkatdate="today"'+
          '   and BKATPERSONCODE in ('+sCliCodes+') group by BKATPERSONCODE';
        IBS.ExecQuery; // вычисляем суммы уже существующих счетов клиентов
        while not IBS.EOF do begin
          ii:= IBS.FieldByName('BKATPERSONCODE').AsInteger;
          sum:= IBS.FieldByName('summa').AsFloat;
          j:= -1; // ищем индекс клиента в списке
          for i:= 0 to lstCliCodes.Count-1 do if (lstCliCodes[i]=ii) then begin
            j:= i;
            break;
          end;
          if (j>-1) then begin             // нашли индекс клиента -
            arLimits[j]:= arLimits[j]-sum; // корректируем его доступную сумму
            if (arLimits[j]<0) then arLimits[j]:= 0;
          end;
          TestCssStopException;
          IBS.Next;
        end;

      end else begin                       //------------ проверка лимита по к/а
        sum:= Cache.BankLimitSumm; // лимит банка
        IBS.SQL.Text:= 'select sum(BKATSUMM) summa from bankaccountreestr'+
          ' where bkatdate="today" and BKATFIRMCODE='+IntToStr(FirmID);
        IBS.ExecQuery;             // отнимаем сумму уже существующих счетов к/а
        if not (IBS.EOF and IBS.BOF) then sum:= sum-IBS.FieldByName('summa').AsFloat;
        if (sum<0.01) then raise EBOBError.Create('Исчерпан лимит суммы счетов за сутки'); // ???
        for i:= 0 to High(arLimits) do arLimits[i]:= sum; // всем проставляем доступную сумму к/а
      end;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;

    Stream.WriteInt(lstCliCodes.Count); //----- передаем кол-во конт.лиц
    for i:= 0 to lstCliCodes.Count-1 do begin
      Client:= Cache.arClientInfo[lstCliCodes[i]];
      Stream.WriteInt(Client.ID);       //----- передаем код конт.лица
      Stream.WriteStr(Client.Name);     //----- передаем ФИО конт.лица
      Stream.WriteDouble(arLimits[i]);  //----- передаем доступную сумму для конт.лица
{
      lst.Clear;
      for ii:= 0 to Client.CliPhones.Count-1 do
//        if CheckMobileNumber(trim(Client.CliPhones[ii])) then // проверяем телефоны конт.лица ???
        lst.Add(Client.CliPhones[ii]);
      Stream.WriteInt(lst.Count);              //----- передаем кол-во телефонов конт.лица
      for ii:= 0 to lst.Count-1 do
        Stream.WriteStr(lst[ii]);              //----- передаем телефоны конт.лица
}
      Stream.WriteInt(Client.CliPhones.Count); //----- передаем кол-во телефонов конт.лица
      for ii:= 0 to Client.CliPhones.Count-1 do
        Stream.WriteStr(Client.CliPhones[ii]); //----- передаем телефоны конт.лица

      Stream.WriteInt(Client.CliMails.Count);  //----- передаем кол-во Email-ов конт.лица
      for ii:= 0 to Client.CliMails.Count-1 do
        Stream.WriteStr(Client.CliMails[ii]);  //----- передаем Email-ы конт.лица
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  SetLength(arLimits, 0);
  prFree(lstCliCodes);
//  prFree(lst);
  Stream.Position:= 0;
end;
//====================================================== записать счет на оплату
procedure prSaveBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveBankAccount'; // имя процедуры/функции
var UserID, FirmID, ContID, persID, bkat, TryCount: integer;
    s, phone, email, sFirmID, sContID, sPersID, sNum: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    AvailSum, AccSum: double;
    Contract: TContract;
    Client: TClientInfo;
    firma: TFirmInfo;
    flPhone, flEmail, fl: Boolean;
begin
  Stream.Position:= 0;
  IBD:= nil;
  IBS:= nil;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    ContID:= Stream.ReadInt;    // код контракта
    persID:= Stream.ReadInt;    // код конт.лица
    phone := Stream.ReadStr;    // телефон
    email := Stream.ReadStr;    // Email
    AccSum:= Stream.ReadDouble; // сумма

    sFirmID:= IntToStr(FirmID);
    sContID:= IntToStr(ContID);
    sPersID:= IntToStr(persID);
    flPhone:= (trim(phone)<>'');
    flEmail:= (trim(email)<>'');

    prSetThLogParams(ThreadData, csSaveBankAccount, UserID, FirmID,
      'ContID='+sContID+#13#10'person='+sPersID+#13#10'phone='+phone+
      #13#10'email='+email+#13#10'AccSum='+FloatToStr(AccSum)); // логирование

    if (AccSum<0.01) then raise EBOBError.Create('Не задана сумма');

    if (AccSum<Cache.BankMinSumm) then // 26.10.2016 - письмо Трошина
      raise EBOBError.Create('Минимальная сумма оплаты '+
        FormatFloat(cFloatFormatSumm, Cache.BankMinSumm)+' грн.');

    if not flPhone then raise EBOBError.Create('Не задан номер телефона');
    if flPhone and not CheckMobileNumber(trim(phone)) then
      raise EBOBError.Create('Номер телефона '+phone+' не мобильный');
//    if not flEmail then raise EBOBError.Create('Не задан E-mail');    // ???
//    if flEmail and not fnCheckEmail(trim(email)) then
//      raise EBOBError.Create('Некорректный E-mail - '+email);

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
//    if CheckNotValidUser(persID, FirmID, s) then raise EBOBError.Create(s); // ??? Blocked
    if not Cache.ClientExist(persID) then
      raise EBOBError.Create(MessText(mtkNotClientExist));

    Client:= Cache.arClientInfo[persID];
    if Client.Arhived then raise EBOBError.Create(MessText(mtkNotClientExist));
    if (Client.FirmID<>FirmID) then raise EBOBError.Create(MessText(mtkNotClientOfFirm));

    if flPhone and (Client.CliPhones.IndexOf(phone)<0) then    // ???
      raise EBOBError.Create('Не найден номер телефона конт.лица '+phone);
//    if flEmail and (Client.CliMails.IndexOf(email)<0) then     // ???
//      raise EBOBError.Create('Не найден E-mail конт.лица '+email);

    firma:= Cache.arFirmInfo[FirmID]; // контракт проверяем у к/а !!!
    if not firma.CheckContract(ContID)then
      raise EBOBError.Create(MessText(mtkNotFoundFirmCont, sContID));

    Contract:= Cache.Contracts[ContID];
    if (Contract.Status<cstBlocked) then raise EBOBError.Create('Контракт закрыт');
    if (Contract.PayType>0) then raise EBOBError.Create('Контракт безналичный');

    //------------- вычисляем доступную сумму оплаты (в пределах лимита в сутки)
    AvailSum:= Cache.BankLimitSumm; // лимит банка
    s:= '';
    bkat:= 0;
    try
      IBD:= CntsGRB.GetFreeCnt();
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpRead, true);
      IBS.SQL.Text:= 'select sum(BKATSUMM) summa from bankaccountreestr'+
        ' where bkatdate="today" and '+fnIfStr(Cache.flCheckCliBankLim,
        'BKATPERSONCODE='+sPersID, 'BKATFIRMCODE='+sFirmID); // по конт.лицу или по к/а
      IBS.ExecQuery;
      if not (IBS.EOF and IBS.BOF) then // отнимаем сумму уже существующих счетов
        AvailSum:= AvailSum-IBS.FieldByName('summa').AsFloat;
      IBS.Close;
      if (AvailSum<0.01) then
        raise EBOBError.Create('Исчерпан лимит суммы счетов за сутки');
      if (AccSum>AvailSum) then
        raise EBOBError.Create('Превышен лимит суммы счетов за сутки,'+
          ' доступно '+FloatToStr(AvailSum)+' грн');

      fnSetTransParams(ibs.Transaction, tpWrite, True);
      IBS.SQL.Text:= 'insert into bankaccountreestr (BKATFIRMCODE, BKATNUMBER,'+
        ' BKATCONTRACTCODE, BKATHOUR, BKATSUMM, BKATCRNCCODE, BKATPERSONCODE'+
        fnIfStr(flPhone, ', BKATPERSONPHONECODE', '')+
        fnIfStr(flEmail, ', BKATPERSONEMAILCODE', '')+', BKATFIRSTPARTY) values ('+sFirmID+
        ', "< АВТО >",'+sContID+', EXTRACT(HOUR FROM CURRENT_TIMESTAMP), :sum, 1, '+sPersID+
        fnIfStr(flPhone, ', (select first 1 pphcode from personphones where'+
          ' PPHPersonCode='+sPersID+' and pphphone=:phone and ppharchivedkey="F")', '')+
        fnIfStr(flEmail, ', (select first 1 pecode from personemails where'+
          ' PEPERSONCODE='+sPersID+' and peemail=:email and pearchivedkey="F")', '')+
        ', (select userfirmcode from userpsevdonimreestr where usercode=1)'+
        ') returning BKATCODE, BKATNUMBER, BKATSUMM, BKATPERSONPHONECODE';  //, BKATPERSONEMAILCODE ???
      IBS.ParamByName('sum').AsFloat:= AccSum;
      if flPhone then IBS.ParamByName('phone').AsString:= phone;
      if flEmail then IBS.ParamByName('email').AsString:= email;

      for TryCount:= 1 to RepeatCount do try // RepeatCount попыток
        Application.ProcessMessages;
        with ibs.Transaction do if not InTransaction then StartTransaction;
        ibs.ExecQuery;
        if flPhone and ibs.FieldByName('BKATPERSONPHONECODE').IsNull then    // ???
          raise EBOBError.Create('Не найден номер телефона '+phone);
  //      if flEmail and ibs.FieldByName('BKATPERSONEMAILCODE').IsNull then    // ???
  //        raise EBOBError.Create('Не найден E-mail '+email);
        bkat:= IBS.FieldByName('BKATCODE').AsInteger;
        sNum:= ibs.FieldByName('BKATNUMBER').AsString;
        AccSum:= ibs.FieldByName('BKATSUMM').AsFloat;
        ibs.Transaction.Commit;
        break;
      except
        on E: EBOBError do raise EBOBError.Create(E.Message);
        on E: Exception do begin
          with ibs.Transaction do if InTransaction then RollbackRetaining;
          if (Pos('lock', E.Message)>0) and (TryCount<RepeatCount) then
            Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
          else raise Exception.Create(E.Message);
        end;
      end;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;
    s:= 'Счет: '+sNum+', код клиента: '+firma.UPPERSHORTNAME;
    fl:= not CheckMobileNumber(trim(phone));

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    Stream.WriteInt(bkat);          //----- передаем код счета
    Stream.WriteStr(Contract.Name); //----- передаем контракт
    Stream.WriteStr(sNum);          //----- передаем № счета
    Stream.WriteDouble(AccSum);     //----- передаем сумму
    Stream.WriteStr(Client.Name);   //----- передаем конт.лицо
    Stream.WriteStr(s);             //----- передаем Реквизиты для КБ Приватбанк
    Stream.WriteBool(fl);           //----- передаем признак запрета отправки SMS

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False, True);
  end;
  Stream.Position:= 0;
end;
//================================================ Получить файл счета на оплату
procedure prGetBankAccountFile(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetBankAccountFile'; // имя процедуры/функции
var UserID, FirmID, i, baccID: integer;
    ss, sNum, s, sPers, sDate, sSum, sSum0, sNds, nf, nfOut, sumstr, sShort: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    sum, nds: Double;
    lst: TStringList;
    firma: TFirmInfo;
begin
  Stream.Position:= 0;
  IBD:= nil;
  IBS:= nil;
  lst:= TStringList.Create;
  sum:= 0;
  nds:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    baccID:= Stream.ReadInt; // код счета

    prSetThLogParams(ThreadData, csGetBankAccountFile, UserID, FirmID, 'baccID='+IntToStr(baccID)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    firma:= Cache.arFirmInfo[FirmID];

    nf:= GetAppExePath+fnTestDirEnd(cShablonDir)+cShablon_bkat_xml; // файл шаблона счета
    if not FileExists(nf) then raise EBOBError.Create('Не найден файл-шаблон счета');

    try
      IBD:= CntsGRB.GetFreeCnt();
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpRead, true);
      IBS.SQL.Text:= 'SELECT BKATNUMBER, BKATDATE, BKATSUMM, SummOfNDS(BKATSUMM, 20,"0") nds,'+  //
        ' iif(BKATPERSONCODE is null, BKATPERSONNAME, p.prsnname) pname'+
        ' FROM bankaccountreestr left join persons p on p.prsncode=BKATPERSONCODE'+
        ' WHERE BKATCODE='+IntToStr(baccID)+' and BKATFIRMCODE='+IntToStr(FirmID);
      IBS.ExecQuery;
      if (IBS.EOF and IBS.BOF) then raise EBOBError.Create('Не найден счет');
      sNum:= IBS.FieldByName('BKATNUMBER').AsString; // № счета
      sPers:= IBS.FieldByName('pname').AsString;     // плательщик
      sDate:= FormatDateTime(cDateFormatY4, IBS.FieldByName('BKATDATE').AsDateTime); // строка даты
      sum:= IBS.FieldByName('BKATSUMM').AsFloat;     // сумма
      nds:= IBS.FieldByName('nds').AsFloat;          // НДС
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;
    sSum:= FormatFloat(cFloatFormatSumm, sum);      // строка суммы
    sNds:= FormatFloat(cFloatFormatSumm, nds);      // строка НДС
    sSum0:= FormatFloat(cFloatFormatSumm, sum-nds); // строка суммы б/НДС
    sumstr:= SumNumToFullUkr(sum);            // сумма прописью
    sShort:= firma.UPPERSHORTNAME;            // код к/а

    nfOut:= 'bkat_'+sNum+'_'+FormatDateTime('ddmmyyhhnnss', Now)+'.xml';
    try
      Cache.CScache.Enter;
      try
        lst.LoadFromFile(nf, TEncoding.UTF8);
      finally
        Cache.CScache.Leave;
      end;

      for i:= 0 to lst.Count-1 do begin
        ss:= lst[i];
        if (pos('@@', lst[i])>0) then begin
          if (pos('@@number@@', ss)>0) then
            ss:= StringReplace(ss, '@@number@@', sNum, [rfReplaceAll]);
          if (pos('@@date@@', ss)>0) then
            ss:= StringReplace(ss, '@@date@@',   sDate, [rfReplaceAll]);
          if (pos('@@person@@', ss)>0) then
            ss:= StringReplace(ss, '@@person@@', sPers, [rfReplaceAll]);
          if (pos('@@short@@', ss)>0) then
            ss:= StringReplace(ss, '@@short@@',  sShort, [rfReplaceAll]);
          if (pos('@@sum@@', ss)>0) then
            ss:= StringReplace(ss, '@@sum@@',    sSum0, [rfReplaceAll]);
          if (pos('@@nds@@', ss)>0) then
            ss:= StringReplace(ss, '@@nds@@',    sNds, [rfReplaceAll]);
          if (pos('@@sumall@@', ss)>0) then
            ss:= StringReplace(ss, '@@sumall@@', sSum, [rfReplaceAll]);
          if (pos('@@sumstr@@', ss)>0) then
            ss:= StringReplace(ss, '@@sumstr@@', sumstr, [rfReplaceAll]);
        end;
        lst[i]:= AnsiToUTF8(ss);
      end;

      Stream.Clear;
      Stream.WriteInt(aeSuccess);
      Stream.WriteStr(XMLContentType);
      Stream.WriteStr(nfOut);
      Stream.WriteLongStr(lst.Text);
    finally
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFree(lst);
  Stream.Position:= 0;
end;
//============================================= Отправить SMS из счета на оплату
procedure prSendSMSfromBankAccount(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSendSMSfromBankAccount'; // имя процедуры/функции
var UserID, FirmID, baccID: integer;
    sDup, s: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
begin
  Stream.Position:= 0;
//  IBD:= nil;
  IBS:= nil;
  try
    UserID:= Stream.ReadInt;               // 3854562
    FirmID:= Stream.ReadInt;               // 32751
    baccID:= Stream.ReadInt; // код счета  // 284288

    prSetThLogParams(ThreadData, csSendSMSfromBankAccount, UserID, FirmID, 'baccID='+IntToStr(baccID)); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    IBD:= CntsGRB.GetFreeCnt();
    try
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpWrite, true);
      IBS.ParamCheck:= False;
      IBS.SQL.Add('execute block returns (rDup varchar(1))');
      IBS.SQL.Add('as declare variable firmID integer='+IntToStr(FirmID)+';');
      IBS.SQL.Add(' declare variable baccID integer='+IntToStr(baccID)+';');
      IBS.SQL.Add('begin rDup=""; if (exists(select * from bankaccountreestr');
      IBS.SQL.Add(' WHERE BKATCODE=:baccID and BKATFIRMCODE=:firmID)) then begin'); // проверка телефона
      IBS.SQL.Add(' select iif((select RConvertedNumber from PhoneNumberConverter(Phone))="", "N",'); // на корректность
      IBS.SQL.Add('  iif((select RResult from TestMobilePhone(Phone))="F", "M", "")) from');          // на мобильность
      IBS.SQL.Add('   (select iif(BKATPERSONPHONECODE is null, bkatpersonphone, pphphone) phone');
      IBS.SQL.Add('   from bankaccountreestr left join personphones on pphcode=BKATPERSONPHONECODE');
      IBS.SQL.Add('   WHERE BKATCODE=:baccID and BKATFIRMCODE=:firmID) into rDup;');
      IBS.SQL.Add(' if (rDup<>"") then begin suspend; exit; end');
      IBS.SQL.Add(' SELECT RHaveDuplicate from SENDSMSFROMBANKACCOUNT(:baccID, 2) into rDup;');
      IBS.SQL.Add(' if (rDup<>"T") then SELECT RHaveDuplicate -- 2- check insert, 0- insert');
      IBS.SQL.Add('  from SENDSMSFROMBANKACCOUNT(:baccID, 0) into rDup; end suspend; end');
      IBS.ExecQuery;
      if (IBS.EOF and IBS.BOF) then raise EBOBError.Create('Не найден счет');
      sDup:= IBS.FieldByName('rDup').AsString; // результат
      if (sDup='') then raise EBOBError.Create('Не найден счет');
      if (sDup='N') then raise EBOBError.Create('Номер телефона некорректный');
      if (sDup='M') then raise EBOBError.Create('Номер телефона не мобильный');
      if (sDup='T') then raise EBOBError.Create('SMS сообщение с данными по счету уже отправлено');
      IBS.Transaction.Commit;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end;
//============================= отправить письмо о формировании счета в Grossbee
function prSendMessAboutCreateAccount(ORDRCODE, DCACCODE, FirmID,
         contID, storID, crnc, IDq: Integer; SumDoc, SumLines: Double;
         DCACNUMBER, ORDRNUM, sDate, ErrStr: string; accLines: TStringList): string;
const nmProc = 'prSendMessAboutCreateAccount'; // имя процедуры/функции
var i, j, FilID: integer;
    s, ss1, ss2, AccCode, attFile, SysAdr, sacc: string;
    Strings, Attachments: TStringList;
    arDprts: Tai;
    firma: TFirmInfo;
    Contract: TContract;
begin
  Result:= '';
  Strings:= nil;
  Attachments:= nil;
  setLength(arDprts, 0);
//  if flDebug and (ErrStr='') then ErrStr:= 'test/mail';
  with Cache do try try
    if not FirmExist(FirmID) then raise Exception.Create('Not correct FirmID');
    firma:= arFirmInfo[FirmID];

    Strings:= TStringList.Create;
    AccCode:= IntToStr(DCACCODE);
    attFile:= DirFileErr+'c'+ORDRNUM+'n'+DCACNUMBER+'.txt'; // имя файла строк счета
    if CurrExists(crnc) then s:= ' '+GetCurrName(crnc, True) else s:= '';
    sacc:= ' N '+DCACNUMBER+' от '+sDate;
    if (ErrStr>'') then ss2:= 'Ошибки записи счета'+sacc else ss2:= 'Создан счет'+sacc;

    Strings.Clear;
    Strings.Add('Системой автоматического приема заказов');
    Strings.Add('для контрагента '+firma.Name);
    Strings.Add('Создан счет'+sacc+' на сумму '+FormatFloat(cFloatFormatSumm, SumDoc)+s);
    if ORDRNUM<>'' then Strings.Add('( по заказу СВК N '+ORDRNUM+' )');
    // проверяем сумму счета
    if (abs(SumDoc-SumLines)>0.03) then begin // выводим в лог проблемные счета
      prMessageLOGS('---------- некорректный счет N '+DCACNUMBER+' от '+sDate, 'err_acc', false);
      prMessageLOGS('           контрагент= '+firma.Name, 'err_acc', false);
      prMessageLOGS('   сумма в реестре= '+FormatFloat(cFloatFormatSumm, SumDoc)+
        ', сумма по строкам= '+FormatFloat(cFloatFormatSumm, SumLines)+' ('+s+')', 'err_acc', false);
    end;

    FilID:= 0;
    if DprtExist(storID) then with arDprtInfo[storID] do begin  // склад резервирования
      FilID:= FilialID; // филиал резервирования
      Strings.Add(' склад резервирования: '+MainName);
    end;
    with firma do if (FilID>0) then begin
      Contract:= GetContract(contID);
      j:= 1;
      setLength(arDprts, j);
      arDprts[0]:= FilID; // филиал резервирования
      for i:= 0 to High(Contract.ContProcDprts) do begin // определяем доп.филиалы обработки счетов
        storID:= Contract.ContProcDprts[i];
        if not DprtExist(storID) then Continue;
        FilID:= arDprtInfo[storID].FilialID;
        if (fnInIntArray(FilID, arDprts)>-1) then Continue;
        setLength(arDprts, j+1);
        arDprts[j]:= FilID;
        inc(j);
      end;
    end;
    for i:= High(arDprts) downto 0 do begin // проверяем филиалы обработки счетов
      FilID:= arDprts[i];
      if DprtExist(FilID) then with arDprtInfo[FilID] do // филиал - отправлять только письма о счетах с ошибками
        if IsFilial and IsFilOnlyErr and (ErrStr='') then prDelItemFromArray(i, arDprts);
    end;

    if (Length(arDprts)<1) then Exit; // если некуда отправлять - выходим

    if (ErrStr>'') then Strings.Add(ErrStr); // ошибки записи товаров

    if (accLines.Count>0) then try
      s:= fnMakeAddCharStr('счет N '+DCACNUMBER+': товар', 40, True)+
        fnMakeAddCharStr('заказ', 10)+fnMakeAddCharStr('цена', 10);
      accLines.Insert(0, s);
      accLines.Insert(1, '');
      fnStringsLogToFile(accLines, attFile);
      Attachments:= TStringList.Create;
      Attachments.Add(attFile);
    except
      if Assigned(Attachments) then Attachments.Clear;
    end;

    SysAdr:= fnGetSysAdresVlad(caeOnlyWorkTime); // адрес для письма в случае сбоя
    for i:= 0 to High(arDprts) do begin // рассылаем по филиалам обработки счетов
      FilID:= arDprts[i];
      ss1:= fnGetManagerMail(FilID, SysAdr); // отсылаем письмо о создании счета
      s:= n_SysMailSend(ss1, ss2+' ('+fnGetComputerName+', create account)', Strings, Attachments, '', '', true);
      if s<>'' then Result:= 'Ошибка отправки письма: '+#13#10+ss2+#13#10+s;
    end;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
  finally
    prFree(Strings);
    if Assigned(Attachments) and FileExists(attFile) then DeleteFile(attFile);
    prFree(Attachments);
    setLength(arDprts, 0);
  end;
end;
//============================= отправить письмо о формировании счета в Grossbee
function prSendMessAboutCreateAccount(Ord: ROrderOpts; IDq: Integer; ErrStr: string): string;
const nmProc = 'prSendMessAboutCreateAccount'; // имя процедуры/функции
var i, j, FilID, storID: integer;
    s, ss1, ss2,  attFile, SysAdr: string;
    Strings, Attachments: TStringList;
    arDprts: Tai;
begin
  Result:= '';
  Strings:= nil;
  Attachments:= nil;
  setLength(arDprts, 0);
  with Cache do try try
//    if not FirmExist(Ord.Firma.ID) then raise Exception.Create('Not correct FirmID');
    Strings:= TStringList.Create;
    if (ord.accSing.ID>0) then ss1:= ord.accSing.Num
    else if (ord.accJoin.ID>0) then ss1:= ord.accJoin.Num
    else ss1:= '';
    attFile:= DirFileErr+'c'+Ord.ORDRNUM+'n'+ss1+'.txt'; // имя файла строк счета
    if CurrExists(Ord.currID) then s:= ' '+GetCurrName(Ord.currID, True) else s:= '';

    Strings.Clear;
    Strings.Add('Системой автоматического приема заказов');
    Strings.Add('для контрагента '+Ord.firma.Name);
    if (Ord.ORDRNUM<>'') then Strings.Add('   по заказу СВК N '+Ord.ORDRNUM);
    Strings.Add('');

    ss2:= '';
    if (ord.accJoin.ID>0) then begin
      ss2:= ord.accJoin.Num;
      Strings.Add('Добавлены товары в счет '+ord.accJoin.Num+' от '+ord.accJoin.sDate+
                  ' на сумму '+FormatFloat(cFloatFormatSumm, ord.accJoin.sumlines)+s);
    end;
    if (ord.accSing.ID>0) then begin
      ss2:= ss2+fnIfStr(ss2='', '', ', ')+ord.accSing.Num;
      Strings.Add('Создан счет '+ord.accSing.Num+' от '+ord.accSing.sDate+
                  ' на сумму '+FormatFloat(cFloatFormatSumm, ord.accSing.AccSumm)+s);
    end;
    if (ErrStr>'') then ss2:= 'Ошибки при формировании счета: '+ss2
    else ss2:= 'Добавлены товары в счет: '+ss2;

    // проверяем сумму счета                 // выводим в лог проблемные счета
    if (ord.accSing.ID>0) and (abs(ord.accSing.AccSumm-ord.accSing.SumLines)>0.03) then begin
      prMessageLOGS('---------- некорректный счет N '+ord.accSing.Num+' от '+ord.accSing.sDate, 'err_acc', false);
      prMessageLOGS('           контрагент= '+Ord.firma.Name, 'err_acc', false);
      prMessageLOGS('   сумма в реестре= '+FormatFloat(cFloatFormatSumm, ord.accSing.AccSumm)+
        ', сумма по строкам= '+FormatFloat(cFloatFormatSumm, ord.accSing.SumLines)+' ('+s+')', 'err_acc', false);
    end;

    FilID:= 0;
    if DprtExist(Ord.DprtID) then with arDprtInfo[Ord.DprtID] do begin  // склад резервирования
      FilID:= FilialID; // филиал резервирования
      Strings.Add('');
      Strings.Add(' склад резервирования: '+MainName);
    end;
    with Ord.firma do if (FilID>0) then begin
      j:= 1;
      setLength(arDprts, j);
      arDprts[0]:= FilID; // филиал резервирования
      for i:= 0 to High(Ord.Contract.ContProcDprts) do begin // определяем доп.филиалы обработки счетов
        storID:= Ord.Contract.ContProcDprts[i];
        if not DprtExist(storID) then Continue;
        FilID:= arDprtInfo[storID].FilialID;
        if (fnInIntArray(FilID, arDprts)>-1) then Continue;
        setLength(arDprts, j+1);
        arDprts[j]:= FilID;
        inc(j);
      end;
    end;
    for i:= High(arDprts) downto 0 do begin // проверяем филиалы обработки счетов
      FilID:= arDprts[i];
      if DprtExist(FilID) then with arDprtInfo[FilID] do // филиал - отправлять только письма о счетах с ошибками
        if IsFilial and IsFilOnlyErr and (ErrStr='') then prDelItemFromArray(i, arDprts);
    end;

    if (Length(arDprts)<1) then Exit; // если некуда отправлять - выходим

    if (ErrStr>'') then begin
      Strings.Add('');
      Strings.Add(ErrStr); // ошибки при формировании счета
    end;

    try
      if (ord.accJoin.accLines.Count>0) then begin
        s:= fnMakeAddCharStr('счет N '+ord.accJoin.Num+': товар', 40, True)+
          fnMakeAddCharStr('заказ', 10)+fnMakeAddCharStr('цена', 10);
        ord.accJoin.accLines.Insert(0, s);
        ord.accJoin.accLines.Insert(1, '');
      end;
      if (ord.accSing.accLines.Count>0) then begin
        s:= fnMakeAddCharStr('счет N '+ord.accSing.Num+': товар', 40, True)+
          fnMakeAddCharStr('заказ', 10)+fnMakeAddCharStr('цена', 10);
        if (ord.accJoin.accLines.Count>0) then ord.accJoin.accLines.Add('');
        ord.accJoin.accLines.Add(s);
        ord.accJoin.accLines.Add('');
        for i:= 0 to ord.accSing.accLines.Count-1 do
          ord.accJoin.accLines.Add(ord.accSing.accLines[i]);
      end;
      fnStringsLogToFile(ord.accJoin.accLines, attFile);
      Attachments:= TStringList.Create;
      Attachments.Add(attFile);
    except
      if Assigned(Attachments) then Attachments.Clear;
    end;

    SysAdr:= fnGetSysAdresVlad(caeOnlyWorkTime); // адрес для письма в случае сбоя
    for i:= 0 to High(arDprts) do begin // рассылаем по филиалам обработки счетов
      FilID:= arDprts[i];
      ss1:= fnGetManagerMail(FilID, SysAdr); // отсылаем письмо о создании счета
      s:= n_SysMailSend(ss1, ss2+' ('+fnGetComputerName+', create account)', Strings, Attachments, '', '', true);
      if s<>'' then Result:= 'Ошибка отправки письма: '+#13#10+ss2+#13#10+s;
    end;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
  finally
    prFree(Strings);
    if Assigned(Attachments) and FileExists(attFile) then DeleteFile(attFile);
    prFree(Attachments);
    setLength(arDprts, 0);
  end;
end;
//============================================================ список рекламаций
procedure prGetReclamationList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetReclamationList'; // имя процедуры/функции
var GBIBD: TIBDatabase;
    GBIBS: TIBSQL;
    iCount, UserID, FirmID, sPos, iState, iRes: integer;
    s: string;
begin
  Stream.Position:= 0;
  GBIBS:= nil;
  GBIBD:= nil;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetReclamationList, UserID, FirmID); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);

    GBIBD:= CntsGRB.GetFreeCnt();
    GBIBS:= fnCreateNewIBSQL(GBIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:= 'select RCNUMBER, RCDATE, RCSTATE,'+ // RCCODE, RCCONTRACTCODE, RCWARECODE,
      ' RCWARECOUNT, RCCOMMENT, RCRESOLUTION, WAREOFFICIALNAME,'+
      ' gn.rNum contnumber from RECLAMATIONREESTR'+
      ' left join Contract on contcode=RCCONTRACTCODE'+
      ' left join Vlad_CSS_GetFullContNum(contnumber, contnkeyyear, contpaytype) gn on 1=1'+
      ' left join Wares on warecode=RCWARECODE'+
      ' where RCFIRMCODE='+IntToStr(FirmID)+' order by RCDATE desc';

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    sPos:= Stream.Position;
    Stream.WriteInt(0); // забиваем место под кол-во
    iCount:= 0;

    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
//      Stream.WriteInt(GBIBS.FieldByName('RCCODE').AsInteger); // код док-та
      iState:= GBIBS.FieldByName('RCSTATE').AsInteger; // Состояние
      if not (iState in [crsPrepared..crsExecuted]) then iState:= crsUnknown;
      if GBIBS.FieldByName('RCRESOLUTION').IsNull then iRes:= crsUnknown
      else begin                                       // Итоговое решение
        iRes:= GBIBS.FieldByName('RCRESOLUTION').AsInteger;
        if not (iRes in [crsDefected..crsReturned]) then iRes:= crsUnknown;
      end;

      Stream.WriteStr(GBIBS.FieldByname('RCNUMBER').AsString);    // Номер документа
      Stream.WriteDouble(GBIBS.FieldByName('RCDATE').AsDateTime); // Дата поступления рекламации
      Stream.WriteStr(GBIBS.FieldByname('CONTNUMBER').AsString);  // Контракт
      Stream.WriteStr(GBIBS.FieldByname('WAREOFFICIALNAME').AsString); // Товар
      Stream.WriteDouble(GBIBS.FieldByName('RCWARECOUNT').AsFloat);    // Кол-во
      Stream.WriteStr(GBIBS.FieldByname('RCCOMMENT').AsString);   // Комментарий

      if (iState=crsUnknown) then begin
        Stream.WriteStr('');          // Состояние: название
        Stream.WriteStr('');         // Состояние: подсказка
      end else begin
        Stream.WriteStr(ReclStateNames[iState]);          // Состояние: название
        Stream.WriteStr(ReclStateTitles[iState]);         // Состояние: подсказка
      end;

      if (iRes=crsUnknown) then begin
        Stream.WriteStr('');          // решение: название
        Stream.WriteStr('');         // решение: подсказка
      end else begin
        Stream.WriteStr(ReclResNames[iRes]);              // решение: название
        Stream.WriteStr(ReclResTitles[iRes]);             // решение: подсказка
      end;

//      Stream.WriteInt(iState); // Состояние: название - ReclStateNames[i], подсказка - ReclStateTitles[i]
//      Stream.WriteInt(iRes);   // Итоговое решение: название - ReclResNames[i], подсказка - ReclResTitles[i]
      TestCssStopException;
      GBIBS.Next;
      Inc(iCount);
    end;
    GBIBS.Close;

    if (iCount>0) then begin
      Stream.Position:= sPos;
      Stream.WriteInt(iCount); // передаем кол-во
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(GBIBD);
  Stream.Position:= 0;
end;
//============================================== Получить список встречающих к/а
procedure prGetMeetPersonsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetMeetPersonsList'; // имя процедуры/функции
var UserID, FirmID, iCount, i: integer;
    s, ss: string;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    lst: TStringList;
begin
  Stream.Position:= 0;
  IBD:= nil;
  IBS:= nil;
  lst:= fnCreateStringList(True, dupIgnore); // сортированный список без дубликатов
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, csGetMeetPersonsList, UserID, FirmID, ''); // логирование

    if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
    try
      IBD:= CntsGRB.GetFreeCnt();
      IBS:= fnCreateNewIBSQL(IBD,'IBS_'+nmProc, ThreadData.ID, tpRead, true);
      IBS.SQL.Text:= 'SELECT pp.pphcode, pp.pphphone, p.prsnname'+
        '  from persons p left join personphones pp on pp.PPhPersonCode=p.prsncode'+
        '  left join TestMobilePhone(pp.PPhPhone) t on 1=1'+
        '  WHERE p.PrSnFirmCode='+IntToStr(FirmID)+' and t.RResult="T"'+
        '   and p.prsnarchivedkey="F" and pp.PPhArchivedKey="F" order by p.prsncode';
      IBS.ExecQuery;
      while not IBS.EOF do begin
        ss:= IBS.FieldByName('pphphone').AsString;
        if CheckMobileNumber(ss) then begin // проверка мобильного номера телефона
          i:= IBS.FieldByName('pphcode').AsInteger;
          s:= trim(fnReplaceQuotedForWeb(IBS.FieldByName('prsnname').AsString))+' ('+ss+')';
          if (lst.IndexOf(s)<0) then lst.AddObject(s, Pointer(i));
        end;
        CntsGRB.TestSuspendException;
        IBS.Next;
      end;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(lst.Count); //----- передаем кол-во
    for iCount:= 0 to lst.Count-1 do begin
      i:= Integer(lst.Objects[iCount]);
      Stream.WriteInt(i);           //----- передаем код встречающего (для счета)
      Stream.WriteStr(lst[iCount]); //----- передаем текст встречающего
    end;

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(lst);
end;



//******************************************************************************
end.

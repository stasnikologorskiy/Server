unit v_WebArmProcedures;
interface
uses Classes, SysUtils, Variants, IBQuery, IBDatabase, IBSQL, Windows,
     Registry, ComObj, ActiveX, Forms, Excel2000, Contnrs,
     n_free_functions, v_constants, v_DataTrans, v_Server_common,
     n_LogThreads, n_DataSetsManager, n_DataCacheInMemory;

procedure prWebArmAutenticate(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowWebArmUsers(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAEWebArmUser(Stream: TBoBMemoryStream; ThreadData: TThreadData);
//procedure prAnalystReport1(Stream: TBoBMemoryStream; ThreadData: TThreadData);
//procedure prAnalystReports(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSaveWebArmUsers(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prManageBrands(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prTNAManagePage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetFilialList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAutoModelInfoLists(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prLoadModelData(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prImportPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetBrandsGB(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetWareList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// добавляет единичный оригинальный номер к товару
procedure prProductAddOrigNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// Удаление привязки оригинального номера к товару
procedure prProductDelOrigNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);

procedure prLoadModelDataText(Stream: TBoBMemoryStream; ThreadData: TThreadData);

//отображает список моделей, в которых применяется товар
procedure prShowModelsWhereUsed(Stream: TBoBMemoryStream; ThreadData: TThreadData);

// Получение списка оригинальных номеров для товара с кодом источника
procedure prProductGetOrigNumsAndWares(Stream: TBoBMemoryStream; ThreadData: TThreadData);

// Управление отметкой об ошибочной связи товара и ОЕ
procedure prMarkOrNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);

// Получить оригинальные номера, общие для 2х товаров
procedure prShowCrossOE(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// Показать характеристики двигателя
procedure prShowEngineOptions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// "освежает" набор Top10 последних выбираемых моделей и возвращает данные для отображения строк
procedure prGetTop10Model(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// получить список двигателей по производителю
procedure prLoadEngines(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prNewsPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prWebArmResetPassword(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prTestLinksLoading(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetFilterValues(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowActionNews(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAEActionNews(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSaveImgForAction(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowSysOptionsPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prEditSysOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSaveSysOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowConstRoles(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prEditConstRoles(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// Управление отметкой об ошибочной связи товара c односторонним аналогом
procedure prMarkOneDirectAnalog(Stream: TBoBMemoryStream; ThreadData: TThreadData);
// Добавить односторонний аналог вручную
procedure prAddOneDirectAnalog(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prUiKPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
{
procedure prShowCurrentOperations(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prStopIEOperation(Stream: TBoBMemoryStream; ThreadData: TThreadData);
function  fnGetGBAndTecDocWareLinks(UserID: integer; var lstBodyMail: TStringList; var FName, Subj,
                                 ContentType:string; ThreadData: TThreadData; filter_data: string ):string;
}
{----------------------------------------------------------------------------------------}
{  Получить списки Брендов Grossbee, TecDoc и список связей брендов
{----------------------------------------------------------------------------------------}
procedure prGetLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAddLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData); // добавить связку брендов ГроссБии и производителей ТекДок
procedure prDelLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData); // удалить связку брендов ГроссБии и производителей ТекДок

procedure prAccountsGetFirmList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAccountsReestrPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
//procedure prAccountsGetAccountsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSendWareDescrErrorMes(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prCheckWareManager(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prModifyLink3(Stream: TBoBMemoryStream; ThreadData: TThreadData);
function fnGetCategoryList(RootCode:integer=221648):TStringList;

procedure prShowConditionPortions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prMarkPortions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowPortion(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prCOUPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetCateroryValues(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prSavePortion(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetDeliveriesList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prRestorePassword(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prBlockWebArmUser(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prCheckRestsInStorageForAcc(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prAEDNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prNotificationPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prShowNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prCheckContracts(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prWebarmContractList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prManageLogotypesPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prLogotypeEdit(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prLoadOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prLampSelect(Stream: TBoBMemoryStream; ThreadData: TThreadData);

function fnRep47(UserID: integer; var lstBodyMail: TStringList; var FName, Subj,
   ContentType:string; ThreadData: TThreadData; filter_data: string): string;



procedure prGetRadiatorList;
procedure prWebarmPlug1(Stream: TBoBMemoryStream; ThreadData: TThreadData);




implementation

uses v_Functions, n_DataCacheAddition, n_constants,
  n_server_common, n_DataCacheObjects, t_ImportChecking;

procedure prWebArmAutenticate(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebArmAutenticate'; // имя процедуры/функции
var
  sid, UserLogin, UserPsw: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBQuery: TIBQuery;
  UserId, i: integer;
  IP, Ident, ErrorPos: string;
  TimeNow: TDateTime;
  sParam: string;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBQuery:= nil;
  UserId:=-1;
  try
    UserLogin:= trim(Stream.ReadStr);
    UserPsw:= trim(Stream.ReadStr);
    sid:= trim(Stream.ReadStr);
    IP:= trim(Stream.ReadStr);
    Ident:= trim(Stream.ReadStr);

//---------------------------------------------------  //
//    prSetThLogParams(ThreadData,0,0,0,'Login='+UserLogin+#13#10'Password='+UserPsw+
//      #13#10'sid='+sid+#13#10'IP='+IP+#13#10'Browser='+Ident); // логирование
    sParam:= 'Login='+UserLogin+#13#10'Password='+UserPsw+#13#10'sid='+sid+#13#10'IP='+IP+#13#10'Browser='+Ident;
    try
//---------------------------------------------------  //

      if ((UserLogin+UserPsw+sid)='') then begin
        raise EBOBError.Create('Не заданы реквизиты аутентикации.');
      end;
      if (UserLogin<>'') then begin
        //если задан параметр логин, то предполагаем наличие и пароля
        // сначала проверяем, есть ли такой логин в системе
        UserId:=Cache.GetEmplIDbyLogin(UserLogin);

        if (UserId=-1) then begin
          raise EBOBError.Create('Не найден логин '+UserLogin);
        end;

        if (Cache.arEmplInfo[UserId].Arhived) then begin
          raise EBOBError.Create('Ваша учетная запись заблокирована администратором системы GrossBee.');
        end;

        if (Cache.arEmplInfo[UserId].Blocked) then begin
          raise EBOBError.Create('Ваша учетная запись заблокирована администратором werbarm.');
        end;

        if (UserPsw='') then begin
          raise EBOBError.Create('Вы не ввели пароль');
        end;

        if (Cache.arEmplInfo[UserId].USERPASSFORSERVER<>UserPsw) then begin
          raise EBOBError.Create('Пароль введен неверно');
        end;

        if (Cache.arEmplInfo[UserId].RESETPASSWORD) then begin
          raise EBoBAutenticationError.Create(IntToStr(aeResetPassword));
        end;

  ErrorPos:='0-2';

        sid:= IntToStr(UserID)+'|'+fnGetSessionID;


  ErrorPos:='0-3';

        OrdIBDatabase:=CntsOrd.GetFreeCnt();
  ErrorPos:='0-5';
        OrdIBQuery:=fnCreateNewIBQuery(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
  ErrorPos:='0-7';

        TimeNow:=Now();
        for i:= 1 to RepeatCount do try
          OrdIBQuery.SQL.Text:='UPDATE EMPLOYEES SET EMPLLASTACTION=:TimeNow, EMPLSESSIONID="'+sid+'" WHERE EMPLCODE='+IntToStr(UserId);
          OrdIBQuery.ParamByName('TimeNow').AsDateTime:=TimeNow;
          OrdIBQuery.ExecSQL;
          OrdIBQuery.Transaction.Commit;
          break;
        except
          on E: Exception do begin
            if (Pos('lock',E.Message)>0) and (i<RepeatCount) then
              Sleep(RepeatSaveInterval) // ждем немного
            else raise Exception.Create('try '+IntToStr(RepeatCount)+': '+E.Message);
          end;
        end;
  ErrorPos:='1-0';
        Cache.arEmplInfo[UserId].Session:=sid;
        Cache.arEmplInfo[UserId].LastActionTime:=TimeNow;

      end else begin // if (UserLogin<>'')
        if (sid='') then begin
          raise EBOBError.Create('Ошибка авторизации. Пустой идентификатор сесcии.');
        end;
        UserId:=Cache.GetEmplIDBySession(sid);
        if (UserId=-1) then begin
          raise EBOBError.Create('Ошибка авторизации. Идентификатор сесcии устарел или испорчен.');
        end;

        if (Copy(sid, 1, Pos('|', sid)-1)<>IntToStr(UserId)) then begin
          raise EBOBError.Create('Ошибка авторизации. Идентификатор сесcии не соответствует принятым соглашениям.');
        end;

        if (Cache.arEmplInfo[UserId].Arhived) then begin
          raise EBOBError.Create('Ваша учетная запись заблокирована администратором системы GrossBee.');
        end;

        if (Cache.arEmplInfo[UserId].Blocked) then begin
          raise EBOBError.Create('Ваша учетная запись заблокирована администратором werbarm.');
        end;

        if ((now-Cache.arEmplInfo[UserId].LastActionTime)>Cache.GetConstItem(pcClientTimeOutWebArm).IntValue/24/60) then begin
          raise EBOBError.Create('Время действительности Вашей сессии истекло. Пройдите заново процедуру авторизации используя Ваши логин и пароль.');
        end;
  ErrorPos:='1-5';

        OrdIBDatabase:=CntsOrd.GetFreeCnt();
        OrdIBQuery:=fnCreateNewIBQuery(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
  ErrorPos:='1-10';
        TimeNow:=Now();
        for i:= 1 to RepeatCount do try
          OrdIBQuery.SQL.Text:='UPDATE EMPLOYEES SET EMPLLASTACTION=:TimeNow WHERE EMPLCODE='+IntToStr(UserId);
          OrdIBQuery.ParamByName('TimeNow').AsDateTime:=TimeNow;
          OrdIBQuery.ExecSQL;
          OrdIBQuery.Transaction.Commit;
          break;
        except
          on E: Exception do begin
            if (Pos('lock',E.Message)>0) and (i<RepeatCount) then
              Sleep(RepeatSaveInterval) // ждем немного
            else raise Exception.Create('try '+IntToStr(RepeatCount)+': '+E.Message);
          end;
        end;
  ErrorPos:='1-15';
        Cache.arEmplInfo[UserId].LastActionTime:=TimeNow;
      end; //if (UserLogin<>'') else
  ErrorPos:='2-0';
    finally
      prSetThLogParams(ThreadData, 0, UserId, 0, sParam);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(UserID);
    Stream.WriteStr(sid);
    Stream.WriteDouble(Now());
ErrorPos:='2-5';
    Stream.WriteIntArray(Cache.arEmplInfo[UserId].UserRoles);
ErrorPos:='2-6';
//    Stream.WriteInt(Cache.GetEmplImportsCount(UserID));
//    Stream.WriteInt(Integer(Cache.GetEmplAllowRepImp(UserID)));
    Stream.WriteBool(Cache.GetEmplAllowRepImp(UserID)); // признак наличия разрешенных отчетов/импортов у сотрудника
ErrorPos:='2-7';
    Stream.WriteBool(Cache.WareCacheUnLocked);
ErrorPos:='2-8';
    Stream.WriteBool(Cache.GetEmplConstantsCount(UserID)>0);
ErrorPos:='2-9';
    Stream.WriteStr(Cache.arEmplInfo[UserId].EmplShortName);
ErrorPos:='2-10';
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: EBoBAutenticationError do begin
      i:=StrToIntDef(E.Message, -1);
      Stream.Clear;
      case i of
        aeResetPassword : begin
          Stream.WriteInt(i);
          Stream.WriteInt(UserID);
        end;
        else begin
          Stream.WriteInt(aeCommonError);
          Stream.WriteStr('Неизвестный код ошибки авторизации - '+E.Message);
          fnWriteToLog(ThreadData, lgmsUserError, nmProc, 'Неизвестный код ошибки авторизации', E.Message, '');
        end;
      end;
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prFreeIBQuery(OrdIBQuery);
  cntsORD.SetFreeCnt(OrdIBDatabase);
  Stream.Position:= 0;
end; //prWebArmAutenticate


procedure prShowWebArmUsers(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowWebArmUsers'; // имя процедуры/функции
var
  UserId: integer;
  i, Count, varTo, Pos: integer;
  Empl: TEmplInfoItem;
  list: TStringList;
  Roles: Tai;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolManageUsers, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(0); // место под кол-во
    Stream.WriteInt(0); // место под кол-во сотрудников

    varTo:=Length(Cache.arEmplInfo)-1;
    Count:=0;
    for i:=0 to varTo do if Cache.EmplExist(i) and not Cache.arEmplInfo[i].Arhived then begin
      Stream.WriteInt(i);
      Stream.WriteStr(Cache.arEmplInfo[i].EmplShortName);
      Inc(Count);
    end;
    Stream.Position:= 8;
    Stream.WriteInt(Count);
    Stream.Position:=Stream.Size;
    list:= TStringList.Create;

    varTo:=Length(Cache.arDprtInfo)-1;
    for i:=0 to varTo do if Cache.DprtExist(i) and Cache.arDprtInfo[i].IsFilial then begin
      list.AddObject(Cache.arDprtInfo[i].ShortName,Pointer(i));
    end;
    list.Sort;
    Stream.WriteStringList(list, true);
    list.Clear;

    Pos:=Stream.Position;
    Stream.WriteInt(0); // место под кол-во ролей
    Roles:=Cache.GetAllRoleCodes;
    varTo:=Length(Roles)-1;
    Count:=0;
    for i:=0 to varTo do begin
      Stream.WriteInt(Roles[i]);
      Stream.WriteStr(Cache.GetRoleName(Roles[i]));
      Inc(Count);
    end;
    Stream.Position:= Pos;
    Stream.WriteInt(Count);
    Stream.Position:=Stream.Size;

    Count:=0;
    for i:=0 to Length(Cache.arEmplInfo) do if (Cache.EmplExist(i) and (Cache.arEmplInfo[i].UserPassForServer<>'')) then begin
      Empl:=Cache.arEmplInfo[i];
      Stream.WriteInt(i);
      Stream.WriteStr(Empl.ServerLogin);
//      Stream.WriteInt(Empl.EmplID);
      Stream.WriteInt(Empl.EmplDprtID);
      Stream.WriteStr(Empl.GBLogin);
      Stream.WriteBool(Empl.Blocked);
      Inc(Count);
    end;
    Stream.Position:=4;
    Stream.WriteInt(Count);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  prFree(list);
  SetLength(Roles, 0);
  Stream.Position:= 0;
end; //prShowWebArmUsers


procedure prAEWebArmUser(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAEWebArmUser'; // имя процедуры/функции
var
  GBIBDatabase: TIBDatabase;
  GBIBSQL: TIBSQL;
//  OrdIBDatabase: TIBDatabase;
//  OrdIBQuery: TIBQuery;
  UserId, EmplId : integer;
  i: integer;
  Empl: TEmplInfoItem;
  list: TStringList;


begin
  Stream.Position:= 0;
  GBIBSQL:= nil;
  GBIBDatabase:= nil;
  list:=nil;
  Empl:=nil;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolManageUsers, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    EmplID:=Stream.ReadInt;

    if (EmplID>-1) and not Cache.EmplExist(EmplID)  then begin
      raise EBOBError.Create('Не найден пользователь для редактирования.');
    end;

    if (EmplID>-1) then begin
      Empl:=Cache.arEmplInfo[EmplID];
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    list:= TStringList.Create;

    for i:=Low(Cache.arEmplInfo) to High(Cache.arEmplInfo) do begin
      if (Cache.EmplExist(i) and not Cache.arEmplInfo[i].Arhived and ((EmplID=-1) and (Cache.arEmplInfo[i].ServerLogin='') or (i=EmplID))) then list.AddObject(Cache.arEmplInfo[i].EmplShortName,Pointer(i));
    end;
    list.Sort;
    Stream.WriteStringList(list, true);
    list.Clear;

    GBIBDatabase:=CntsGRB.GetFreeCnt();
    GBIBSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBQuery_'+nmProc,ThreadData.ID);
    GBIBSQL.Transaction.StartTransaction;

    GBIBSQL.SQL.Text:='Select USLSCODE, USLSUSERID from USERLIST ';
    GBIBSQL.ExecQuery;
    while not GBIBSQL.EOF do begin
      for i:=Low(Cache.arEmplInfo) to High(Cache.arEmplInfo) do if (i<>EmplID) and Cache.EmplExist(i) and ((AnsiSameText(Cache.arEmplInfo[i].GBReportLogin, GBIBSQL.Fields[1].AsString) or AnsiSameText(Cache.arEmplInfo[i].GBLogin, GBIBSQL.Fields[1].AsString))) then begin
        break;
//      end else prMessageLog(IntToStr(i)+'|'+Cache.arEmplInfo[i].GBLogin+'|'+Cache.arEmplInfo[i].GBReportLogin, );
      end;
      if i>High(Cache.arEmplInfo) then begin
        list.Add(GBIBSQL.Fields[1].AsString);
      end;
      GBIBSQL.Next;
    end;
    GBIBSQL.Close;

    list.Sort;
    Stream.WriteStringList(list, false);
    list.Clear;

    if (EmplID>-1) then begin
      Stream.WriteStr(Empl.ServerLogin);
      Stream.WriteStr(Empl.USERPASSFORSERVER);
      Stream.WriteStr(IntToStr(Empl.EmplDprtID));
      Stream.WriteStr(Empl.GBLogin);
      Stream.WriteStr(Empl.GBReportLogin);
      Stream.WriteIntArray(Empl.UserRoles);
    end;


    Stream.Position:= 0;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  prFree(list);
  prFreeIBSQL(GBIBSQL);
  CntsGRB.SetFreeCnt(GBIBDatabase, false);

end; //prAEWebArmUser


procedure prSaveWebArmUsers(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveWebArmUsers'; // имя процедуры/функции
var
  GBIBDatabase: TIBDatabase;
  GBIBSQL: TIBSQL;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
  UserId, EmplID, aEmplCodeID, GBID, GBID_o, DprtID: integer;
  i: integer;
  Empl: TEmplInfoItem;
  s, aLogin, aPass, aGBLogin, aGBLogin_O: string;
  NewRoles: Tai;
  Roles: Tai;

procedure prRoleToBase(CurRole: integer; flAdd: boolean; Empl: TEmplInfoItem; OrdIBSQL: TIBSQL);
var RolePresent: boolean;
begin
  RolePresent:=(fnInIntArray(CurRole, Empl.UserRoles)>-1);
  if RolePresent<>flAdd then begin
    if flAdd then  begin
      OrdIBSQL.SQL.Text:='INSERT INTO EMPLOYEESROLES (EMRLEMPLCODE, EMRLROLECODE) VALUES ('+IntToStr(Empl.EmplID)+', '+IntToStr(CurRole)+')';
    end else begin
      OrdIBSQL.SQL.Text:='DELETE FROM EMPLOYEESROLES where EMRLEMPLCODE='+IntToStr(Empl.EmplID)+' and EMRLROLECODE='+IntToStr(CurRole);
    end;
    try
      OrdIBSQL.ExecQuery;
    except
      on E: Exception do begin
        fnWriteToLog(ThreadData, lgmsUserError, 'prRoleToBase', '', E.Message, '');
      end;
    end;

  end;
end;

procedure prApplyRole(CurRole: integer; flAdd: boolean; Empl: TEmplInfoItem);
var index: integer;
begin
  index:=fnInIntArray(CurRole, Empl.UserRoles);
  if (index>-1)<>flAdd then begin
    if flAdd then  begin
      prAddItemToIntArray(CurRole, Empl.UserRoles);
    end else begin
      prDelItemFromArray(index, Empl.UserRoles);
    end;
  end;
end;//

begin
  Stream.Position:= 0;
  GBIBSQL:= nil;
  GBIBDatabase:= nil;
  OrdIBSQL:= nil;
  OrdIBDatabase:= nil;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolManageUsers, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;


    EmplID:=Stream.ReadInt;

    if ((EmplID>-1) and not Cache.EmplExist(EmplID)) then begin
      raise EBOBError.Create('Не найдена запись для редактирования.');
    end;

    aLogin:=Stream.ReadStr;
    aPass:=Stream.ReadStr;
    s:=Stream.ReadStr;

    aEmplCodeID:=-1;
    if (EmplID=-1) then try
      aEmplCodeID:=StrToInt(s);
    except
      raise EBOBError.Create('Неверный идентификатор привязываемого сотрудника  - '+s);
    end;
    
    if (EmplID=-1) and (aEmplCodeID>-1) and not Cache.EmplExist(aEmplCodeID) then begin
      raise EBOBError.Create('Не найдена привязываемая запись пользователя.');
    end;

    if (EmplID>-1) then begin
      Empl:=Cache.arEmplInfo[EmplID];
    end else
    if (aEmplCodeID>-1) then begin
      Empl:=Cache.arEmplInfo[aEmplCodeID];
    end else begin
      raise EBOBError.Create('Должен быть указан либо новый сотрудник для добавления либо старый для редактирования.');
    end;

    s:=Stream.ReadStr;
    try
      DprtID:=StrToInt(s);
    except
      raise EBOBError.Create('Неверный идентификатор филиала  - '+s);
    end;

    if (not Cache.DprtExist(DprtID) or not Cache.arDprtInfo[DprtID].IsFilial) then begin
      raise EBOBError.Create('Задано неверное подразделение или подразделение не является филиалом.');
    end;

    aGBLogin:=Stream.ReadStr;
    aGBLogin_O:=Stream.ReadStr;
    NewRoles:=Stream.ReadIntArray;

    if ((EmplID=-1) and not fnCheckOrderWebLogin(aLogin)) then begin
      raise EBOBError.Create('Логин не соответствует принятым соглашениям.');
    end;

    if (not fnCheckOrderWebPassword(aPass)) then begin
      raise EBOBError.Create('Пароль не соответствует принятым соглашениям.');
    end;

    if (EmplID=-1) and not Cache.EmplExist(aEmplCodeID) then begin
      raise EBOBError.Create('Не найден привязываемый сотрудник');
    end;


    if (aGBLogin<>'') then begin
      i:=Cache.GetEmplIDByGBLogin(aGBLogin);
      if (i>-1) and (i<>EmplID) then begin
        raise EBOBError.Create('Такой логин GrossBee уже используется');
      end;
    end;

    if (aGBLogin_O<>'') then begin
      i:=Cache.GetEmplIDByGBLogin(aGBLogin_O);
      if (i>-1) and (i<>EmplID) then begin
        raise EBOBError.Create('Такой логин GrossBee для отчетов уже используется');
      end;
    end;



    GBIBDatabase:=CntsGRB.GetFreeCnt(Cache.arEmplInfo[UserID].GBLogin, cDefPassword, 'ALLGBUSER');
    GBIBSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBQuery_'+nmProc,ThreadData.ID);
    GBIBSQL.Transaction.StartTransaction;

    GBID:=-1; GBID_o:=-1;

    if (aGBLogin<>'') then begin
      GBIBSQL.SQL.Text:='Select USLSCODE, USLSUSERID from USERLIST WHERE UPPERCASE(USLSUSERID)="'+UpperCase(aGBLogin)+'"';
      GBIBSQL.ExecQuery;
      if (GBIBSQL.BoF and GBIBSQL.EoF) then begin
        raise EBOBError.Create('Задан несуществующий логин GrossBee');
      end else begin
        GBID:=GBIBSQL.Fields[0].AsInteger;
      end;
      GBIBSQL.Close;
    end;

    if (aGBLogin_O<>'') then begin
      GBIBSQL.SQL.Text:='Select USLSCODE, USLSUSERID from USERLIST WHERE UPPERCASE(USLSUSERID)="'+UpperCase(aGBLogin_O)+'"';
      GBIBSQL.ExecQuery;
      if (GBIBSQL.BoF and GBIBSQL.EoF) then begin
        raise EBOBError.Create('Задан несуществующий логин GrossBee для отчетов');
      end else begin
        GBID_o:=GBIBSQL.Fields[0].AsInteger;
      end;
      GBIBSQL.Close;
    end;

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
    OrdIBSQL.Transaction.StartTransaction;

    s:='';
    if EmplID=-1 then begin
      s:=s+'INSERT INTO EMPLOYEES (EMPLCODE, EMPLDPRTCODE, EMPLLOGIN, EMPLPASS';
      if (GBID>-1) then  s:=s+', EMPLGBUSER';
      if (GBID_o>-1) then  s:=s+', EMPLGBREPORTUSER';
      s:=s+') VALUES ('+IntToStr(aEmplCodeID)+', '+IntToStr(DprtID)+', '+QuotedStr(aLogin)+', '+QuotedStr(aPass);
      if (GBID>-1) then  s:=s+', '+IntToStr(GBID);
      if (GBID_o>-1) then  s:=s+', '+IntToStr(GBID_o);
      s:=s+')';
    end else begin
      s:=s+fnIfStr(AnsiSameText(aPass, Empl.UserPassForServer), '', fnIfStr(s='','',', ')+'EMPLPASS='+QuotedStr(aPass));
      s:=s+fnIfStr(DprtID=Empl.EmplDprtID, '', fnIfStr(s='','',', ')+'EMPLDPRTCODE='+IntToStr(DprtID));
      s:=s+fnIfStr(AnsiSameText(aGBLogin, Empl.GBLogin), '', fnIfStr(s='','',', ')+'EMPLGBUSER='+fnIfStr(GBID=-1, 'NULL', IntToStr(GBID)));
      s:=s+fnIfStr(AnsiSameText(aGBLogin_O, Empl.GBReportLogin), '', fnIfStr(s='','',', ')+'EMPLGBREPORTUSER='+fnIfStr(GBID_o=-1, 'NULL', IntToStr(GBID_o)));
      if s<>'' then s:='UPDATE EMPLOYEES SET '+s+' WHERE EMPLCODE='+IntToStr(EmplID);
    end;

    if s<>'' then begin
      OrdIBSQL.SQL.Text:=s;
      OrdIBSQL.ExecQuery;
    end;

    if (EmplId=-1) then Empl.ServerLogin:=aLogin;
    if not AnsiSameText(aPass, Empl.UserPassForServer) then Empl.UserPassForServer:=aPass;
    if not (DprtID=Empl.EmplDprtID) then
       Empl.EmplDprtID:=DprtID;
    if not AnsiSameText(aGBLogin, Empl.GBLogin) then Empl.GBLogin:=aGBLogin;
    if not AnsiSameText(aGBLogin_O, Empl.GBReportLogin) then Empl.GBReportLogin:=aGBLogin_O;

    Roles:=Cache.GetAllRoleCodes;
    for i:=0 to Length(Roles)-1 do  begin
      prRoleToBase(Roles[i], fnInIntArray(Roles[i], NewRoles)>-1, Empl, OrdIBSQL);
    end;

    OrdIBSQL.Transaction.Commit;

    for i:=0 to Length(Roles)-1 do begin
      prApplyRole(Roles[i], fnInIntArray(Roles[i], NewRoles)>-1, Empl);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(Empl.EmplId);
    Stream.WriteInt(Empl.EmplDprtID);
    Stream.Position:= 0;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
      if (OrdIBSQL<>nil) then  OrdIBSQL.Transaction.Rollback;
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
      if (OrdIBSQL<>nil) then  OrdIBSQL.Transaction.Rollback;
    end;
  end;
  SetLength(NewRoles, 0);
  SetLength(Roles, 0);
  prFreeIBSQL(OrdIBSQL);
  CntsOrd.SetFreeCnt(OrdIBDatabase, false);
  prFreeIBSQL(GBIBSQL);
  CntsGRB.SetFreeCnt(GBIBDatabase, false);
end; //prSaveWebArmUsers
(*
procedure prAnalystReport1(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAnalystReport1'; // имя процедуры/функции
var
  GBIBDatabase: TIBDatabase;
  GBIBQuery: TIBQuery;
  UserId: integer;
  FileStream: TFileStream;
  regData : TRegistry;
  cls_ExcelObject, s : string;
  Excel, WorkBook, Sheet, Range, VarAr: Variant;
  DateStart, DateEnd: TDatetime;
  CurRow, CurCol: integer;
  RecCount: integer;
begin
  Stream.Position:= 0;
  GBIBQuery:= nil;
  GBIBDatabase:= nil;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolAnalyst, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    s:=Stream.ReadStr;
    if (Length(s)<8) or not TryEncodeDate(2000+StrToIntDef(Copy(s, 7, 2), 0), StrToIntDef(Copy(s, 4, 2), 0), StrToIntDef(Copy(s, 1, 2), 0), DateStart) then begin
      raise EBOBError.Create('Неправильная дата - '+s);
    end;

    s:=Stream.ReadStr;
    if (Length(s)<8) or not TryEncodeDate(2000+StrToIntDef(Copy(s, 7, 2), 0), StrToIntDef(Copy(s, 4, 2), 0), StrToIntDef(Copy(s, 1, 2), 0), DateEnd) then begin
      raise EBOBError.Create('Неправильная дата - '+s);
    end;


    GBIBDatabase:=CntsGRB.GetFreeCnt(Cache.arEmplInfo[UserID].GBLogin, cDefPassword, 'ALLGBUSER');
    GBIBQuery:=fnCreateNewIBQuery(GBIBDatabase,'GBIBQuery_'+nmProc,ThreadData.ID);

    GBIBQuery.SQL.Add('select count(WRRQDATETIME) ');
    GBIBQuery.SQL.Add(' from WareRequest_VLAD where WRRQDATETIME between :begintime and :endtime');
    GBIBQuery.ParamByName('begintime').AsDate:=DateStart;
    GBIBQuery.ParamByName('endtime').AsDate:=DateEnd+1;
    GBIBQuery.Open;
    RecCount:=GBIBQuery.Fields[0].AsInteger;
    GBIBQuery.Close;
    GBIBQuery.SQL.Strings[0]:='select WRRQDATETIME, WRRQPERSONCODE, WRRQWARECODE, WRRQFROMORDER, WRRQQTY, WRRQMAXINORDER, WRRQORDERQTY, WRRQORDERANALOGQTY,'
                     +'(select sum(WRRQDTFREEREST) from WareRequestDetails_VLAD where WRRQDTMASTERCODE=WRRQCODE) WRQTY ';
    cls_ExcelObject := 'Excel.Application';
    regData := TRegistry.Create;
    regData.RootKey := HKEY_CLASSES_ROOT;
    try
      if regData.OpenKey('\Excel.Application\CurVer', False) then begin
        cls_ExcelObject := regData.ReadString('');
        regData.CloseKey;
      end
    finally
      regData.Free;
    end;

    OleInitialize(nil);
    Excel := CreateOleObject(cls_ExcelObject);
    Excel.Visible := false;
    Excel.DisplayAlerts := False;
    WorkBook:=Excel.Workbooks.Add();
    Sheet:=Excel.Sheets.Add(EmptyParam, Excel.ActiveSheet);
    Sheet.Name:=FormatDateTime('dd.mm.yyyy', DateStart)+'-'+FormatDateTime('dd.mm.yyyy', DateEnd);
    CurRow:=1;
    CurCol:=0;
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Дата';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Контрагент';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Товар';
      Sheet.Cells[CurRow,CurCol].NoteText('Название GrossBee');
      Sheet.Cells[CurRow,CurCol].Comment.Shape.Width:= 250;
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Из заказа';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Первоначальный запрос';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Максимальное значение запроса';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Первоначального товара ушло в заказ';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Аналогов ушло в заказ';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Остаток товара по всем складам';
      Sheet.Cells[CurRow,CurCol].NoteText('По тем складам, которые пользователь определил для себя, как видимые');
      Sheet.Cells[CurRow,CurCol].Comment.Shape.Width:= 250;
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Контроль обращений';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Менеджер по закупкам';
    Sheet.Cells[CurRow,fnNextInt(CurCol)]:='Менеджер по продажам';
    GBIBQuery.Open;
    VarAr:= VarArrayCreate([1,RecCount,1,CurCol],varVariant); // массив значений для 1 листа
    while not GBIBQuery.EOF do begin
      Inc(CurRow);
      CurCol:=0;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQDATETIME').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=Cache.arFirmInfo[Cache.arClientInfo[GBIBQuery.FieldByName('WRRQPERSONCODE').AsInteger].FirmID].Name;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=Cache.GetWare(GBIBQuery.FieldByName('WRRQWARECODE').AsInteger).Name;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQFROMORDER').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQQTY').AsString;;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQMAXINORDER').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQORDERQTY').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRRQORDERANALOGQTY').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=GBIBQuery.FieldByName('WRQTY').AsString;
      VarAr[CurRow-1,fnNextInt(CurCol)]:='';
      VarAr[CurRow-1,fnNextInt(CurCol)]:=Cache.arEmplInfo[Cache.arWareInfo[GBIBQuery.FieldByName('WRRQWARECODE').AsInteger].ManagerID].EmplShortName;
      VarAr[CurRow-1,fnNextInt(CurCol)]:=Cache.arEmplInfo[Cache.arFirmInfo[Cache.arClientInfo[GBIBQuery.FieldByName('WRRQPERSONCODE').AsInteger].FirmID].Regional].EmplShortName;
      GBIBQuery.Next;
    end;
    GBIBQuery.Close;
    Sheet.Range['A2',Char(64+CurCol)+IntToStr(RecCount+1)].Value:= VarAr; // Загоняем в Excel все одним куском
    s:=fnIfStr(Pos('г', LongDateFormat)>0, 'ДД.ММ.ГГГГ', 'm/d/yyyy');

//    s:=Excel.International(xlDateSeparator);
    Sheet.Range['A2:A'+IntToStr(RecCount+1)].NumberFormat:=s; //
//    Sheet.Range['A2:A'+IntToStr(RecCount+1)].NumberFormat:=fnGetExcelDateFormat(Excel); //
    Sheet.Range['J2'].Formula:='=F2-G2-H2'; //
    Sheet.Range['J2'].Copy; //
    Sheet.Range['J3:J'+IntToStr(RecCount+1)].Select;
    Sheet.Paste;


    s:=ExtractFilePath(Application.ExeName)+'TMP\';
    if not DirectoryExists(s) then begin
      CreateDir(s);
    end;

    s:=s+Cache.arEmplInfo[UserID].ServerLogin+'\';
    if not DirectoryExists(s) then begin
      CreateDir(s);
    end;

    s:=s+'Report_001_'+fnDateGetText(DateStart)+'-'+fnDateGetText(DateEnd)+'.xls';
    if FileExists(s) then begin
      if not SysUtils.DeleteFile(s) then begin
        raise EBOBError.Create('Невозможно удалить предыдущий файл.');
      end;
    end;

    Range:=Sheet.Cells[1, 1];
    Range.AutoFilter;

    Sheet.Range['A2'].Select;
    Excel.ActiveWindow.FreezePanes:=true;

    Range:=Sheet.Range['A1:K1'];
//   With Selection
    Range.HorizontalAlignment:= xlCenter;
    Range.VerticalAlignment:= xlCenter;
    Range.WrapText:= True;


    Range:=Sheet.Columns['A:M'];
    Range.Columns.AutoFit;

    WorkBook.SaveAs(s);
    Excel.Workbooks.Close;
    Excel.Quit;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(ExtractFileName(s)+ExtractFileExt(s));

    FileStream:=TFileStream.Create(s, fmOpenRead);
    Stream.WriteInt(FileStream.Size);
    FileStream.Position:= 0;
    Stream.CopyFrom(FileStream, FileStream.Size);
    prFree(FileStream);
    SysUtils.DeleteFile(s);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Внутренняя ошибка');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  prFreeIBQuery(GBIBQuery);
  cntsGRB.SetFreeCnt(GBIBDatabase);
  Stream.Position:= 0;
  VarAr:= null;
  Excel.Workbooks.Close;
  Excel.Quit;
  Range:= null;
  Sheet:= null;
  WorkBook:= null;
  Excel:= null; 
end; //prAnalystReport1


procedure prAnalystReports(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAnalystReports'; // имя процедуры/функции
var
  UserId: integer;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolAnalyst, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prAnalystReports
*)

procedure prAccountsReestrPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAccountsReestrPage'; // имя процедуры/функции
var
  UserId: integer;
  LineCount, sPos, k: integer;
  SL: TStringList;
  Empl:  TEmplInfoItem;
  s: string;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if CheckNotValidUser(UserId, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    Empl:=Cache.arEmplInfo[UserId];

    if not Empl.UserRoleExists(rolOPRSK) then // проверяем право пользователя
      raise EBOBError.Create(MessText(mtkNotRightExists));

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    prSaveEmplStoresChoiceList(Stream, UserId, true);  // запись в Stream списка видимых сотруднику складов(+путей) для выбора

    prSaveEmplFirmsChoiceList(Stream, UserId);

    //-------------- передаем все валюты
    LineCount:= 0;       // счетчик
    sPos:= Stream.Position;
    Stream.WriteInt(0);  //  место под кол-во валют
    for k:= 0 to High(Cache.arCurrShortNames) do
      if not Cache.arCurrArhived[k] and (Cache.arCurrShortNames[k]<>'') then begin
        Stream.WriteInt(k);                         // код валюты
        Stream.WriteStr(Cache.arCurrShortNames[k]); // наименование валюты
        inc(LineCount);
      end;
    Stream.Position:= sPos;
    Stream.WriteInt(LineCount);
    Stream.Position:= Stream.Size;

    SL:=Cache.GetShipMethodsList();
    Stream.WriteInt(SL.Count-1);
    for k:=0 to SL.Count-1 do begin
      Stream.WriteInt(integer(SL.Objects[k]));
      Stream.WriteStr(SL[k]);
      Stream.WriteBool(Cache.GetShipMethodNotTime(integer(SL.Objects[k])));
      Stream.WriteBool(Cache.GetShipMethodNotLabel(integer(SL.Objects[k])));
    end;
    prFree(SL);

    SL:=Cache.GetShipTimesList();
    Stream.WriteStringList(SL, true);
    prFree(SL);

(*
    Stream.WriteInt(0); // место под кол-во валют
    arlen:=Length(Cache.arCurrShortNames)-1;
    j:=0;
    for i:=0 to arlen do begin
      if not Cache.arCurrArhived[i] and (Cache.arCurrShortNames[i]<>'') then begin
        Stream.WriteInt(i);
        Stream.WriteStr(Cache.arCurrShortNames[i]);
        Inc(j);
      end;
    end;
    Stream.Position:=4;
    Stream.WriteInt(j);
    Stream.Position:=Stream.Size;
    StreamPos:=Stream.Position;

    Stream.WriteInt(0); // место под кол-во подразделений
    arlen:=Length(Cache.arDprtInfo)-1;
    j:=0;
    for i:=0 to arlen do begin
      if (Cache.arDprtInfo[i]<>nil) {and (not Cache.arDprtInfo[i].Arhived)} and (Cache.arDprtInfo[i].IsStoreHouse) then begin
        Stream.WriteInt(i);
        Stream.WriteStr(Cache.arDprtInfo[i].MainName);
        Inc(j);
      end;
    end;
    Stream.Position:=StreamPos;
    Stream.WriteInt(j);
    Stream.Position:=Stream.Size;
    StreamPos:=Stream.Position;

    Stream.WriteInt(0); // место под кол-во менеджеров
    arlen:=Length(Cache.arEmplInfo)-1;
    j:=0;
    for i:=0 to arlen do begin
      if (Cache.arEmplInfo[i]<>nil) and (not Cache.arEmplInfo[i].Arhived) and (fnInIntArray(rolRegional, Cache.arEmplInfo[i].UserRoles)>-1) then begin
        Stream.WriteInt(i);
        Stream.WriteStr(Cache.arEmplInfo[i].EmplShortName);
        Inc(j);
      end;
    end;
    Stream.Position:=StreamPos;
    Stream.WriteInt(j);
    Stream.Position:=Stream.Size;
*)

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(SL);
end; //prAccountsReestrPage

procedure prAccountsGetFirmList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAccountsGetFirmList'; // имя процедуры/функции
var
  UserId: integer;
  i,j,arlen: integer;
  templ: string;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    templ:=UpperCase(trim(Stream.ReadStr));
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolOPRSK, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(0); // место под кол-во фирм
    if Length(templ)>3 then begin
      arlen:=Length(Cache.arFirmInfo)-1;
      j:=0;
      for i:=0 to arlen do begin
        if (Cache.arFirmInfo[i]<>nil ) and (not Cache.arFirmInfo[i].Arhived) and (pos(templ, UpperCase(Cache.arFirmInfo[i].Name))>0) then begin
          Stream.WriteInt(i);
          Stream.WriteStr(Cache.arFirmInfo[i].Name);
          Inc(j);
        end;
      end;
      Stream.Position:=4;
      Stream.WriteInt(j);
    end;


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prAccountsGetFirmList

//отображает список моделей, в которых применяется товар
procedure prShowModelsWhereUsed(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowModelsWhereUsed'; // имя процедуры/функции
var
  UserId, WareID, FirmID, WhatShow, i, ModelLineID, MFAID, arlen1, ManufID: integer;
  errmess: string;
  List: TList;
  Model: TModelAuto;
  Manufacturers: TObjectList;
begin
  Stream.Position:= 0;
  Manufacturers:=TObjectList.Create;
  List:=nil;
  try
    FirmID:= Stream.ReadInt;
    UserID:= Stream.ReadInt;
    WareID:= Stream.ReadInt;
    WhatShow:=Stream.ReadByte;
    ManufID:= Stream.ReadInt;

    prSetThLogParams(ThreadData,0,UserId,FirmID,'Wareid='+IntToStr(WareID)+#13#10+'WhatShow='+IntToStr(WhatShow)+#13#10+'ManufID='+IntToStr(ManufID)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
(*
    if CheckNotValidFirmSys(FirmID, WhatShow, errmess) then raise EBOBError.Create(errmess);

    if (FirmID<>isWe) then begin
      if (Cache.arFirmInfo[FirmID].IsMOTOFirm and (WhatShow<>constIsMoto)) then begin
        raise EBOBError.Create('Тип системы - '+IntToStr(WhatShow)+' не соответствует типу контрагента.');
      end;
      if (Cache.arFirmInfo[FirmID].IsAUTOFirm and (WhatShow<>constIsAuto)) then begin
        raise EBOBError.Create('Тип системы - '+IntToStr(WhatShow)+' не соответствует типу контрагента.');
      end;
    end;
*)

    if not (WhatShow in constAllSys) then begin
      raise EBOBError.Create('Неизвестный тип системы - '+IntToStr(WhatShow));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    List:=Cache.arWareInfo[WareID].GetSysModels(WhatShow, ManufID);
    arlen1:= List.Count-1;
    if (arlen1=-1) then begin
      raise EBOBError.Create('К этому товару не привязаны модели '+fnIfStr(WhatShow=constIsAuto, 'авто', 'мото')+'.');
    end;

    Stream.WriteInt(arlen1+1); // кол-во моделей
    for i:=0 to arlen1 do begin
      Model:=TModelAuto(List[i]);
      ModelLineID:=Model.ModelLineID;
      MFAID:=Cache.FDCA.ModelLines.GetModelLine(ModelLineID).MFAID;
      if (manufID<0) and (Cache.FDCA.ManufAutoExist(MFAID)) then prAddOrIncTwoCode(Manufacturers, MFAID);
      Stream.WriteInt(Model.ID); //
      Stream.WriteInt(Model.SubCode); //
      Stream.WriteInt(ModelLineID); //
      Stream.WriteInt(MFAID); //
      Stream.WriteStr(Cache.FDCA.Manufacturers[MFAID].Name);
      Stream.WriteStr(Cache.FDCA.ModelLines.GetModelLine(ModelLineID).Name);
      Stream.WriteStr(Model.Name); //
      Stream.WriteInt(Model.Params.pYStart); // Год начала выпуска
      Stream.WriteInt(Model.Params.pMStart); // Месяц начала выпуска
      Stream.WriteInt(Model.Params.pYEnd);   // Год окончания выпуска
      Stream.WriteInt(Model.Params.pMEnd);   // Месяц окончания выпуска
      Stream.WriteInt(Model.Params.pHP); //
      Stream.WriteStr(Model.MarksCommaText); //
    end;
    if (arlen1>cache.GetConstItem(pcSearchCountTypeAsk).IntValue) and (Manufacturers.Count>1) then begin
      Stream.Clear;
      Stream.WriteInt(aeSuccess);
      Manufacturers.Sort(@CompareManufacturerNamesForTwoCodes);
      Stream.WriteInt(-Manufacturers.Count);// кол-во производителей
      arlen1:= Manufacturers.Count-1;
      for i:=0 to arlen1 do begin
        Stream.WriteInt(TTwoCodes(Manufacturers[i]).ID1); //
        Stream.WriteStr(Cache.FDCA.Manufacturers[TTwoCodes(Manufacturers[i]).ID1].Name); //
        Stream.WriteInt(TTwoCodes(Manufacturers[i]).ID2); //
      end;

    end;


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(List);
  prFree(Manufacturers);
end; // prShowModelsWhereUsed


procedure prManageBrands(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prManageBrands'; // имя процедуры/функции
var
  UserId: integer;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolManageBrands, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prManageBrands


procedure prTNAManagePage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prTNAManagePage'; // имя процедуры/функции
var
  UserId: integer;
  PageType: byte;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    PageType:= Stream.ReadByte;
    if ((PageType=constIsAuto) and (fnInIntArray(rolTNAManageAuto, Cache.arEmplInfo[UserId].UserRoles)=-1))
      or ((PageType=constIsMoto) and (fnInIntArray(rolTNAManageMoto, Cache.arEmplInfo[UserId].UserRoles)=-1))
      then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prTNAManagePage

procedure prGetFilialList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFilialList'; // имя процедуры/функции
var
  UserId, VarTo, i: integer;
  list: TStringList;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    list:= TStringList.Create;

    varTo:=Length(Cache.arDprtInfo)-1;
    for i:=0 to varTo do if Cache.DprtExist(i) and Cache.arDprtInfo[i].IsFilial then begin
      list.AddObject(Cache.arDprtInfo[i].ShortName,Pointer(i));
    end;
    list.Sort;
    Stream.WriteStringList(list, true);
    list.Clear;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prGetFilialList


procedure prGetList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFilialList'; // имя процедуры/функции
var
  UserId, ListType: integer;
  list: TStringList;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    ListType:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId,0,'ListType='+IntToStr(ListType)); // логирование

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    if not ListType in [glFilials, glFirmTypes, glFirmCategories] then begin
      list:= TStringList.Create;
    end;

    case ListType of
      glFilials: begin
        List:=Cache.GetFilialList();
      end;
      glFirmTypes: begin
        List:=Cache.GetFirmTypesList();
      end;
      glFirmCategories: begin
        List:=Cache.GetFirmClassesList();
      end;
    end;

    list.Sort;
    Stream.WriteStringList(list, true);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prGetFilialList


procedure prAutoModelInfoLists(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAutoModelInfoLists'; // имя процедуры/функции
var
  UserId, FirmId, i: integer;
  list: TStringList;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;

    if FirmID=isWe then begin                    // проверки WebArm
      prSetThLogParams(ThreadData, 0, UserId, 0, '');
      if not Cache.EmplExist(UserID) then raise EBOBError.Create(MessText(mtkNotEmplExist));
    end else begin                               // проверки Web
      prSetThLogParams(ThreadData, 0, UserId, FirmID, '');
      if not Cache.ClientExist(UserID) then raise EBOBError.Create(MessText(mtkNotClientExist));
      if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));
      if Cache.arClientInfo[UserID].FirmID<>FirmID then raise EBOBError.Create(MessText(mtkNotClientOfFirm));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    for i:=1 to 9 do begin
      Stream.WriteStringList(Cache.FDCA.TypesInfoModel.InfoModelList[i] , true);
    end;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prAutoModelInfoLists


procedure prLoadModelData(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLoadModelData'; // имя процедуры/функции
var
  UserId, FirmId, i: integer;
  list: TStringList;
  Model : TModelAuto;
begin
  Stream.Position:= 0;
  List:=nil;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    i:= Stream.ReadInt;

    if FirmID=isWe then begin                    // проверки WebArm
      prSetThLogParams(ThreadData, 0, UserId, 0, '');
      if not Cache.EmplExist(UserID) then raise EBOBError.Create(MessText(mtkNotEmplExist));
    end else begin                               // проверки Web
      prSetThLogParams(ThreadData, 0, UserId, FirmID, '');
      if not Cache.ClientExist(UserID) then raise EBOBError.Create(MessText(mtkNotClientExist));
      if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));
      if Cache.arClientInfo[UserID].FirmID<>FirmID then raise EBOBError.Create(MessText(mtkNotClientOfFirm));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    if not Cache.FDCA.Models.ModelExists(i) then raise EBOBError.Create('Не найдена заданная модель');
    Model:= Cache.FDCA.Models.GetModel(i);

    Stream.WriteInt(Model.ID);                // Код модели
    Stream.WriteStr(Model.Name);              // Название модели
    Stream.WriteBool(Model.IsVisible);        // Видимость модель
    Stream.WriteBool(Model.IsTop);            // Топ модель
    Stream.WriteInt(Model.Params.pYStart);            // Год начала выпуска
    Stream.WriteInt(Model.Params.pMStart);            // Месяц начала выпуска
    Stream.WriteInt(Model.Params.pYEnd);              // Год окончания выпуска
    Stream.WriteInt(Model.Params.pMEnd);              // Месяц окончания выпуска

    Stream.WriteInt(Model.Params.pKW);                // Мощность кВт
    Stream.WriteInt(Model.Params.pHP);                // Мощность ЛС
    Stream.WriteInt(Model.Params.pCCM);               // Тех. обьем куб.см.
    Stream.WriteInt(Model.Params.pCylinders);         // Количество цилиндров
    Stream.WriteInt(Model.Params.pValves);            // Количество клапанов на одну камеру сгорания
    Stream.WriteInt(Model.Params.pBodyID);            // Код, тип кузова
    Stream.WriteInt(Model.Params.pDriveID);           // Код, тип привода
    Stream.WriteInt(Model.Params.pEngTypeID);         // Код, тип двигателя
    Stream.WriteInt(Model.Params.pFuelID);            // Код, тип топлива
    Stream.WriteInt(Model.Params.pFuelSupID);         // Код, система впрыска
    Stream.WriteInt(Model.Params.pBrakeID);           // Код, тип тормозной системы
    Stream.WriteInt(Model.Params.pBrakeSysID);        // Код, тип тормозная система
    Stream.WriteInt(Model.Params.pCatalID);           // Код, тип катализатора
    Stream.WriteInt(Model.Params.pTransID);           // Код, тип коробки передач
    Stream.WriteInt(Model.ModelOrderNum);             // Порядковый номер
    Stream.WriteStr(Model.MarksCommaText); // маркировки двигателей

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prLoadModelData


procedure prLoadModelDataText(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLoadModelDataText'; // имя процедуры/функции
var
  UserId, FirmId, i: integer;
  Model : TModelAuto;
  ErrorPos: string;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
    i:= Stream.ReadInt;
ErrorPos:='00';

    if FirmID=isWe then begin                    // проверки WebArm
      prSetThLogParams(ThreadData, 0, UserId, 0, '');
      if not Cache.EmplExist(UserID) then raise EBOBError.Create(MessText(mtkNotEmplExist));
    end else begin                               // проверки Web
      prSetThLogParams(ThreadData, 0, UserId, FirmID, '');
      if not Cache.ClientExist(UserID) then raise EBOBError.Create(MessText(mtkNotClientExist));
      if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));
      if Cache.arClientInfo[UserID].FirmID<>FirmID then raise EBOBError.Create(MessText(mtkNotClientOfFirm));
    end;
ErrorPos:='05';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    if not Cache.FDCA.Models.ModelExists(i) then raise EBOBError.Create('Не найдена заданная модель');
    Model:= Cache.FDCA.Models.GetModel(i);
ErrorPos:='10';

    Stream.WriteStr(Model.Name);                      // Название модели
    Stream.WriteInt(Model.Params.pYStart);            // Год начала выпуска
    Stream.WriteInt(Model.Params.pMStart);            // Месяц начала выпуска
    Stream.WriteInt(Model.Params.pYEnd);              // Год окончания выпуска
    Stream.WriteInt(Model.Params.pMEnd);              // Месяц окончания выпуска
ErrorPos:='15';

    Stream.WriteInt(Model.Params.pKW);                // Мощность кВт
    Stream.WriteInt(Model.Params.pHP);                // Мощность ЛС
    Stream.WriteInt(Model.Params.pCCM);               // Тех. обьем куб.см.
    Stream.WriteInt(Model.Params.pCylinders);         // Количество цилиндров
    Stream.WriteInt(Model.Params.pValves);            // Количество клапанов на одну камеру сгорания
ErrorPos:='20';

    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pBodyID].Name);            // Код, тип кузова
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pDriveID].Name);           // Код, тип привода
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pEngTypeID].Name);         // Код, тип двигателя
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pFuelID].Name);            // Код, тип топлива
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pFuelSupID].Name);         // Код, система впрыска
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pBrakeID].Name);           // Код, тип тормозной системы
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pBrakeSysID].Name);        // Код, тип тормозная система
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pCatalID].Name);           // Код, тип катализатора
    Stream.WriteStr(Cache.FDCA.TypesInfoModel.InfoItems[Model.Params.pTransID].Name);           // Код, тип коробки передач
    Stream.WriteStr(Model.MarksCommaText);                                                      // маркировки двигателей
ErrorPos:='25';

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prLoadModelDataText


procedure prSendWareDescrErrorMes(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSendWareDescrErrorMes'; // имя процедуры/функции
var
  UserId, FirmId, NodeId, ModelId, WareId, MesType, AnalogId, OrNumId: integer;
  ErrText, AtrErrText: string;
begin
  Stream.Position:= 0;
  FirmID:= Stream.ReadInt;
  UserID:= Stream.ReadInt;
  MesType:= Stream.ReadInt;
  WareId:= Stream.ReadInt;
  ModelId:= Stream.ReadInt;
  NodeId:= Stream.ReadInt;
  AnalogId:= Stream.ReadInt;
  OrNumId:= Stream.ReadInt;
  ErrText:= Stream.ReadStr;
  AtrErrText:= Stream.ReadStr;
  try
    prSetThLogParams(ThreadData, 0, UserId, FirmId); // логирование

    ErrText:= fnSendErrorMes(FirmID, UserID, MesType, WareId, AnalogId, OrNumId,
              ModelId, NodeId, ErrText, AtrErrText, ThreadData);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prSendWareDescrErrorMes


procedure prImportPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prImportPage'; // имя процедуры/функции
var
  UserId: integer;
  list: TStringList;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.GetEmplAllowRepImp(UserID) then begin // признак наличия разрешенных отчетов/импортов у сотрудника
//    if (Cache.GetEmplImportsCount(UserID)<1) then begin
      raise EBOBError.Create('У Вас нет прав для работы на этой странице.');
    end;

    if (Cache.arEmplInfo[UserID].Mail='') then raise EBOBError.Create('Отчеты и результат импорта отправляются на email пользователя.'#13#10+'Ваш email не внесен в базу данных сотрудников в Grossbee.<br>'+' В справочнике сотрудников GrossBee отсутствует Ваш email. Обратитесь в отдел УиК непосредственно или через Вашего руководителя с просьбой внести Ваш email в справочник для решения этой проблемы.');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
//    list:= Cache.GetEmplImports(UserID);
    list:= Cache.GetEmplAllowRepOrImpList(UserID); // список отчетов
    Stream.WriteStringList(list, true);
    list.Clear;
    list:= Cache.GetEmplAllowRepOrImpList(UserID, False); // список импортов
    Stream.WriteStringList(list, true);
    list.Clear;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prImportPage

procedure prCheckWareManager(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCheckWareManager'; // имя процедуры/функции
var
  UserId, WareId: integer;

begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    WareId:= Stream.ReadInt;

    prSetThLogParams(ThreadData,0,UserId,0,'Ware='+IntToStr(WareId)); // логирование

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create('Не найден заданный пользователь');
    end;

    if not Cache.WareExist(WareID) then begin
      raise EBOBError.Create('Не найден заданный товар');
    end;

    if (Cache.GetWare(WareID).ManagerID<>UserID) then begin
      raise EBOBError.Create('У Вас нет прав на редактирование этого товара');
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prCheckWareManager

procedure prModifyLink3(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prModifyLink3'; // имя процедуры/функции
var
  UserId, WareId, ModelId, NodeId, ResCode: integer;
  errmess: string;

begin
  Stream.Position:= 0;
  try
    UserID  := Stream.ReadInt;
    WareId  := Stream.ReadInt;
    ResCode := Stream.ReadInt;
    NodeId  := Stream.ReadInt;
    ModelId := Stream.ReadInt;

    prSetThLogParams(ThreadData,0,UserId,0,'Ware='+IntToStr(WareId)+#13#10'Act='+IntToStr(ResCode)+#13#10'NodeId='+IntToStr(NodeId)+#13#10'Model='+IntToStr(ModelId)); // логирование

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create('Не найден заданный пользователь');
    end;

    if not Cache.WareExist(WareID) then begin
      raise EBOBError.Create('Не найден заданный товар');
    end;

    if ((Cache.FDCA.GetModelTypeSys(ModelID)=constIsMoto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) or
    ((Cache.FDCA.GetModelTypeSys(ModelID)=constIsAuto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto)) then begin
      raise EBOBError.Create('У Вас нет прав на выполнение этой операции');
    end;

    if (ResCode<>resDeleted) and (ResCode<>resAdded) then begin
      raise EBOBError.Create('Неопознанный код операции - '+IntToStr(ResCode));
    end;

    errmess:=Cache.FDCA.CheckWareModelNodeLink(WareID, ModelID, NodeID, ResCode, soHand, UserID);

    if (ResCode=resError)then begin
      raise EBOBError.Create(errmess);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(errmess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prModifyLink3

procedure prShowConditionPortions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowConditionPortions'; // имя процедуры/функции
var
  WareId, ModelID, NodeID, UserId, i: integer;
  OL: TObjectList;
  List: TStringList;
  Model: TModelAuto;
begin
  Stream.Position:= 0;
  OL:=nil;
  try
    UserID:= Stream.ReadInt;
    ModelID:= Stream.ReadInt;
    NodeID:= Stream.ReadInt;
    WareID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) and not Cache.FDCA.AutoTreeNodesSys[constIsAuto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto) and not Cache.FDCA.AutoTreeNodesSys[constIsMoto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if not Cache.WareExist(WareID) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));

    if ((Cache.FDCA.Models[ModelID].TypeSys=constIsAuto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto)) or
       ((Cache.FDCA.Models[ModelID].TypeSys=constIsMoto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create('У Вас нет прав на редактирование данных этого бизнес-направления');
    end;

    OL:=GetModelNodeWareUsesAndTextsPartsView(ModelID, NodeID, WareID);
    OL.Sort(@CompareConditionPortions);


    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    Model:=Cache.FDCA.Models.GetModel(ModelId);
    Stream.WriteStr(Cache.GetWare(WareId).Name);
    Stream.WriteStr(Cache.FDCA.AutoTreeNodesSys[Model.TypeSys][NodeId].Name);
    Stream.WriteStr(Model.WebName);

    Stream.WriteInt(OL.Count);
    for i:=0 to OL.Count-1 do begin
      List:=TStringList(OL[i]);

      Stream.WriteInt(Ord(List.QuoteChar));
      Stream.WriteInt(Ord(List.Delimiter));
      Stream.WriteStr(List.Text);
    end;


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(OL);
end; //prShowConditionPortions


procedure prMarkPortions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prMarkPortions'; // имя процедуры/функции
var
  WareId, ModelID, NodeID, UserId, PortionID: integer;
  ss, Mark: string;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    ModelID:= Stream.ReadInt;
    NodeID:= Stream.ReadInt;
    WareID:= Stream.ReadInt;
    PortionID:= Stream.ReadInt;
    Mark:= Stream.ReadStr;
    prSetThLogParams(ThreadData,0,UserId, 0, 'ModelID='+IntToStr(ModelID)+#9'NodeID='+IntToStr(NodeID)+#9'WareID='+IntToStr(WareID)+#9'PortionID='+IntToStr(PortionID)+#9'Mark='+(Mark));

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) and not Cache.FDCA.AutoTreeNodesSys[constIsAuto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto) and not Cache.FDCA.AutoTreeNodesSys[constIsMoto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');

    if not Cache.WareExist(WareID) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));

    if ((Cache.FDCA.Models[ModelID].TypeSys=constIsAuto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto)) or
       ((Cache.FDCA.Models[ModelID].TypeSys=constIsMoto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create('У Вас нет прав на редактирование данных этого бизнес-направления');
    end;

    if (Mark<>'wrong') and (Mark<>'right') and (Mark<>'del') then raise EBOBError.Create('Неправильный маркер связки - '+Mark);

    if (Mark='del') then begin
      ss:=Cache.DelModelNodeWareUseListLinks(ModelID, NodeID, WareID, PortionID);
    end else begin
      ss:=SetUsageTextPartWrongMark(ModelID, NodeID, WareID, PortionID, UserID, Mark='wrong');
    end;


    if (ss<>'') then raise EBOBError.Create(ss);

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prMarkPortions

procedure prWebarmPlug1(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebarmPlug1'; // имя процедуры/функции
begin
  try
    try
      Stream.Clear;
      Stream.WriteInt(aeSuccess);
    except
      on E: EBOBError do begin
        Stream.Clear;
        Stream.WriteInt(aeCommonError);
        Stream.WriteStr(E.Message);
        fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
      end;

    end;
  finally
    Stream.Position := 0;
  end;
end;
(*
procedure prAccountsGetAccountsList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAccountsGetAccountsList'; // имя процедуры/функции
var
  UserId: integer;
  i,j: integer;
  templ: string;

  GBIBDatabase: TIBDatabase;
  GBIBQuery: TIBQuery;

begin
  Stream.Position:= 0;
  GBIBQuery:= nil;
  GBIBDatabase:= nil;
  try
    UserID:= Stream.ReadInt;
    templ:=UpperCase(trim(Stream.ReadStr));
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolOPRSK, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(0); // место под кол-во счетов


    GBIBDatabase:=CntsGRB.GetFreeCnt(Cache.arEmplInfo[UserID].GBLogin, cDefPassword, 'ALLGBUSER');
    GBIBQuery:=fnCreateNewIBQuery(GBIBDatabase,'GBIBQuery_'+nmProc,ThreadData.ID);

//-------------------------------------------------------------------------------------------------- //
    GBIBQuery.SQL.Text:= 'select PInvCode DCACCODE, PInvNumber DCACNUMBER,'+
      ' PInvDate DCACDATE, PInvSumm DCACSUMM, PINVPROCESSED DCACPROCESSED,'+
      ' PINVCLIENTCOMMENT DCACCLIENTCOMMENTS, PInvCrncCode DCACCRNCCODE,'+
      ' PInvSupplyDprtCode DCACDPRTCODE, PINVANNULKEY DCACANNULKEY,'+
      ' PInvRecipientCode DCACFIRMCODE, PINVCOMMENT DCACCOMMENTS,'+
      ' PINVWEBCOMMENT DCACWEBCOMMENT,'+
      ' nullif(iif(SbCnCode is null or INVCCODE is null or INVCEXECUTED=''F'', 0, SbCnCode), 0) DCACHIERCODE'+
      ' from PayInvoiceReestr'+
      ' left join SUBCONTRACT on SbCnDocmCode=PInvCode and SbCnDocmType=99'+
      ' left join INVOICEREESTR on INVCSUBCONTRACT=SbCnCode'+
      ' where PInvDate>:DCACDATE order by PInvDate desc';
//--------------------------------------------------------------------------------------------------- // 
//    GBIBQuery.SQL.Text:= 'select * from DCACCOUNTREESTR where DCACDATE>:DCACDATE order by DCACDATE desc';
    GBIBQuery.ParamByName('DCACDATE').AsDate:=Date()-60;
    GBIBQuery.Open;

    j:=0;
    while not GBIBQuery.EOF and (j<50) do begin
      Stream.WriteInt(GBIBQuery.FieldByName('DCACCODE').AsInteger);

      i:=fnIfInt(GBIBQuery.FieldByName('DCACANNULKEY').AsString='T', 0, fnIfInt(not GBIBQuery.FieldByName('DCACHIERCODE').IsNull, 1, 2));
      if i=2 then begin
        i:=fnIfInt(fnCheckKindOfStorage(GBIBQuery.FieldByName('DCACDPRTCODE').AsInteger, GBIBQuery.FieldByName('DCACFIRMCODE').AsInteger, constStorSale), 2, 3);
      end;
      Stream.WriteByte(i); // 0 - Аннулирован, 1 - Закрыт, 2- нормальный, 3 - не со своего склада

      Stream.WriteByte(byte(GBIBQuery.FieldByName('DCACPROCESSED').AsString='T'));
      Stream.WriteStr(GBIBQuery.FieldByName('DCACNUMBER').AsString);
      Stream.WriteStr(FormatDateTime('dd.mm.yy', GBIBQuery.FieldByName('DCACDATE').AsDateTime));
      Stream.WriteStr(Cache.arFirmInfo[GBIBQuery.FieldByName('DCACFIRMCODE').AsInteger].Name);
      Stream.WriteStr(Cache.arDprtInfo[GBIBQuery.FieldByName('DCACDPRTCODE').AsInteger].MainName);
      Stream.WriteStr(FormatFloat('# ##0.00', GBIBQuery.FieldByName('DCACSUMM').AsFloat));
      Stream.WriteStr(Cache.arCurrShortNames[GBIBQuery.FieldByName('DCACCRNCCODE').AsInteger]);
      Stream.WriteStr(GBIBQuery.FieldByName('DCACCOMMENTS').AsString);
      Stream.WriteStr(GBIBQuery.FieldByName('DCACWEBCOMMENT').AsString);
      Stream.WriteStr(GBIBQuery.FieldByName('DCACCLIENTCOMMENTS').AsString);
      Inc(j);
      GBIBQuery.Next;
    end;
    Stream.WriteStr(fnIfStr(GBIBQuery.EOF, '', 'Вывод был ограничен 50 счетами.'));
    Stream.Position:=4;
    Stream.WriteInt(j);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBQuery(GBIBQuery);
  cntsGRB.SetFreeCnt(GBIBDatabase);
end; //prAccountsGetAccountsList
*)

procedure prGetBrandsGB(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetBrandsGB'; // имя процедуры/функции
var
  UserId, VarTo, i: integer;
  list: TStringList;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    list:= TStringList.Create;

    varTo:=Cache.WareBrands.ItemsList.Count-1;
    for i:=0 to varTo do with TBrandItem(Cache.WareBrands.ItemsList[i]) do begin
      list.AddObject(Name,Pointer(ID));
    end;
    list.Sort;
    Stream.WriteStringList(list, true);
    list.Clear;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
end; //prGetBrandsGB


// централизованно возвращает товары по заданному условию
procedure prGetWareList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetWareList'; // имя процедуры/функции
var
  UserId, FirmID, VarTo, i, ListType, ID : integer;
  list: TStringList;
  conditions, StrPos: string;
  Ware, Analog: TWareInfo;
  pAr1, pAr2, aiWares: Tai;
  AnalogsCount: integer;
  anw: Tai;
  OL: TObjectList;
  IBDatabase: TIBDatabase;
  IBSQL: TIBSQL;
//  contID: integer;
begin
  Stream.Position:= 0;
  List:=nil;
  OL:=nil;
  IBDatabase:=nil;
  IBSQL:=nil;
  StrPos:='0';
  SetLength(anw, 0);
//  contID:= 0;
  try
    UserID:= Stream.ReadInt;
    FirmID:= Stream.ReadInt;
//    ContID:= Stream.ReadInt; // для контрактов   // nk
    ListType:= Stream.ReadInt;
    conditions:= Stream.ReadStr;

    prSetThLogParams(ThreadData, 0, UserId, FirmID, 'ListType='+IntToStr(ListType)+' conditions='+conditions);
    list:= TStringList.Create;

StrPos:='5';
    case ListType of
      gwlAnalogsGB: begin
StrPos:='10-1';
        try
          ID:=StrToInt(conditions)
        except
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;
        Ware:=Cache.GetWare(ID, true);
        if (Ware.PgrID=0) then begin
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;

        OL:=Ware.GetSrcAnalogs(ca_GR);
        VarTo:= OL.Count-1;
        for i := 0 to VarTo do begin
          Analog:= Cache.GetWare(TTwoCodes(OL[i]).ID1);
          list.AddObject(Analog.Name, pointer(Analog.ID));
        end;
      end;

      gwlAnalogsON: begin
StrPos:='10-2';
        try
          ID:=StrToInt(conditions)
        except
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;
        Ware:=Cache.GetWare(ID, true);
        if (Ware.PgrID=0) then begin
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;

        SetLength(pAr1, 0);
        SetLength(pAr2, 0);
        try
          i:=Cache.FDCA.fnGetListAnalogsWithManufacturer(ID, -1, pAr1, pAr2);
          case i of
            -1: begin
              raise EBOBError.Create('Товар с кодом '+conditions+' не найден в кеше');
            end;
            -3: begin
              raise EBOBError.Create('Ошибка выполнения в функции Cache.fnGetListAnalogsWithManufacturer' );
            end;
          end;

          VarTo:=Length(pAr2)-1;
          for i := 0 to VarTo do begin
            Analog:=Cache.GetWare(pAr2[i]);
            list.AddObject(Analog.Name, pointer(Analog.ID));
          end;

        finally
          SetLength(pAr1, 0);
          SetLength(pAr2, 0);
        end;
      end; //  gwlAnalogsON

      gwlAnalogsOneDirectWrong, gwlAnalogsOneDirect: begin
StrPos:='10-4';
        try
          ID:=StrToInt(conditions)
        except
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;
        Ware:=Cache.GetWare(ID, true);
        if (Ware.PgrID=0) then begin
          raise EBOBError.Create('Не найден товар с кодом '+conditions);
        end;

        OL:=TObjectList.Create;

        IBDatabase:=CntsGrb.GetFreeCnt();
        IBSQL:=fnCreateNewIBSQL(IBDatabase,'GBIBQuery_'+nmProc,ThreadData.ID, tpWrite);
        IBSQL.Transaction.StartTransaction;

        IBSQL.SQL.Text:='SELECT PmWAWareCode, PmWASourceCode FROM PMWareAnalogs WHERE PmWAWareAnalogCode='+IntToStr(Id)+' AND PmWAIsWrong="'+fnIfStr(ListType=gwlAnalogsOneDirect, 'F', 'T')+'"';
        IBSQL.ExecQuery;

        while not IBSQL.EOF do begin
          if (Cache.WareExist(IBSQL.FieldByName('PmWAWareCode').AsInteger)) then begin
            Analog:= Cache.GetWare(IBSQL.FieldByName('PmWAWareCode').AsInteger);
            list.AddObject(Analog.Name, pointer(Analog.ID));
            OL.Add(TTwoCodes.Create(IBSQL.FieldByName('PmWAWareCode').AsInteger, Cache.FDCA.GetSourceByGBcode(IBSQL.FieldByName('PmWASourceCode').AsInteger)));
          end;
          IBSQL.Next;
        end;
        IBSQL.Close;
      end;
      gwlWareByCode: begin
        i:=StrToIntDef(conditions, -1);
        if not Cache.WareExist(i) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(i)));
        list.AddObject('', pointer(i));
      end;
    else
      raise EBOBError.Create('Неизвестный тип списка - '+IntToStr(ListType));
    end;

StrPos:='15';
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    List.Sort;

    varTo:=List.Count-1;
    Stream.WriteInt(varTo+1);
    SetLength(aiWares, varTo+1);
    for i:=0 to varTo do begin
StrPos:='17, i='+intToStr(i)+', varTo='+intToStr(varTo);
      aiWares[i]:=integer(List.Objects[i]);
      AnalogsCount:=0;
      if (ListType in [gwlAnalogsOneDirect, gwlAnalogsOneDirectWrong]) then begin
        AnalogsCount:=fnGetID2byID1Def(OL, integer(List.Objects[i]), -1);
      end;
      if (ListType in [gwlWareByCode]) then begin
        pAr1:=Cache.arWareInfo[aiWares[i]].Analogs;
        AnalogsCount:=Length(pAr1);
      end;
      prSaveShortWareInfoToStream(Stream, integer(List.Objects[i]), FirmId, UserId, AnalogsCount);
    end;

    Stream.WriteBool(varTo<Cache.GetConstItem(pcOrderWareSemaforLimit).IntValue);          // нужно ли запрашивать остатки
    // блок отправки инфы о наличии привязанных моделей +++
    prSaveWaresModelsExists(Stream, 0, aiWares);


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(list);
  prFree(OL);
  SetLength(aiWares, 0);
  SetLength(anw, 0);
  SetLength(pAr1, 0);
  SetLength(pAr2, 0);
  prFreeIBSQL(IBSQL);
  cntsGRB.SetFreeCnt(IBDatabase);
end; //prGetWareList


// добавляет единичный оригинальный номер к товару
procedure prProductAddOrigNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prProductAddOrigNum'; // имя процедуры/функции
var
  UserId, WareID, ResCode, OrigId: integer;
  OrigNum, MsgStr: string;
  SourceLinkID: integer;
  MfAuID: integer;
begin
  Stream.Position:= 0;
  OrigId:=0;
  try
    UserID       := Stream.ReadInt;
    WareID       := Stream.ReadInt;  // Код товара
    SourceLinkID := soHand; //Код источника данных
    MfAuID       := Stream.ReadInt;   // Код производителя авто
    OrigNum      := Stream.ReadStr;   // Оригинальный номер
    OrigNum:= fnDelSpcAndSumb(OrigNum, StrSpecSumbs);

    prSetThLogParams(ThreadData, 0, UserId, 0, 'WareID='+IntToStr(WareID)+'SourceLinkID='+IntToStr(SourceLinkID)+' MfAuID='+IntToStr(MfAuID)+' OrigNum='+OrigNum);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolProduct) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    ResCode:= resAdded;
    MsgStr:= Cache.FDCA.CheckOrigNumLink(ResCode, WareID, MfAuID,
      OrigId, OrigNum, SourceLinkID, UserID);


    Case ResCode of
      resError: begin
        raise EBOBError.Create(MsgStr);
      end;
      resDoNothing: begin
        raise EBOBError.Create('Привязка данного оригинального номера уже существует.');
      end;
    end;// Case ResCode of

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
//    Stream.WriteInt(OrigId);
//    Stream.WriteStr(OrigNum);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prProductAddOrigNum


//* Удаление привязки оригинального номера к товару
procedure prProductDelOrigNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prProductDelOrigNum'; // имя процедуры/функции
var
  UserId, WareID, ResCode, OrigId: integer;
  OrigNum, MsgStr: string;
  SourceLinkID: integer;
  MfAuID: integer;
begin
  Stream.Position:= 0;
  OrigId:=0;
  SourceLinkID:=soHand;
  MfAuID:=0;
  try
    UserID       := Stream.ReadInt;
    WareID       := Stream.ReadInt;  // Код товара
    OrigId       := Stream.ReadInt;   // Код оригинального номера

    prSetThLogParams(ThreadData, 0, UserId, 0, 'WareID='+IntToStr(WareID)+' OrigId='+IntToStr(OrigId));

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolProduct) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    ResCode:= resDeleted;
    MsgStr:= Cache.FDCA.CheckOrigNumLink(ResCode, WareID, MfAuID,
      OrigId, OrigNum, SourceLinkID, UserID);


    Case ResCode of
      resError: begin
        raise EBOBError.Create('Не удалось удалить оригинальный номер - '+MsgStr);
      end;
      resDoNothing: begin
        raise EBOBError.Create('Привязка данного оригинального номера не существует.');
      end;
    end;// Case ResCode of

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prProductAddOrigNum


{
function SearchWareGBInTecDocBasic(plstSearch, plstBrandFromGB: TStringList;
         ThreadData: TThreadData): TStringList;
const nmProc='SearchWareGBInTecDoc';
var     i: Integer;
  IBQuery: TIBQuery;
      IBD: TIBDatabase;
begin

end;
}

//----- Поиск артикулов TecDoc, соответствующих товару Grossbee по имени(группе)
function SearchWareGBInTecDoc(pWareID: Integer; ThreadData: TThreadData): TStringList;
const nmProc='SearchWareGBInTecDocExtended';
var s, s1: String;
    lstWares, lstAddon: TStringList;
    i, j, Count: Integer;
    Ware: TWareInfo;
    IBQuery: TIBSQL;
    IBD: TIBDatabase;

  //=== Получение наименование товара с отбошеным префиксом Бренда и окончания с P
  function GetCutNameForSearchTD(pName: String): String;
  begin
    Result:= fnGetStrPart(' ', fnGetStrPart('   ', Trim(pName)), 1);
  end;

begin
  Result   := nil;
  lstAddon := nil;
  lstWares := nil;
  IBD      := nil;
  IBQuery  := nil;
  if not Cache.WareExist(pWareID) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(pWareID)));
  Ware:=Cache.GetWare(pWareID);
  try
    lstWares:= fnCreateStringList(True, dupIgnore);
    with Ware do begin
      lstWares.Append(GetCutNameForSearchTD(Name));  //GetCutNameForSearchTD - Получение наименование товара с отброшеным префиксом Бренда и окончания с P
      lstWares.Append(AnsiUpperCase(fnDelSpcAndSumb(WareSupName)));
    end;
    if not Assigned(lstWares) then exit;

    Result:= fnCreateStringList(True, dupIgnore);

    case Ware.WareBrandID of

      brandCONTITECH: begin   // CONTITECH
        lstAddon:= GetLstPrefixAddon(Ware.WareBrandID);  // Prefix
        Count:=lstWares.Count-1;
        for i:= 0 to lstAddon.Count-1 do
          for j:= 0 to Count do
            lstWares.Add(lstAddon[i]+lstWares[j]);
        prFree(lstAddon);

        lstAddon:= GetLstSufixAddon(Ware.WareBrandID);  // Sufix
        Count:=lstWares.Count-1;
        for i:= 0 to lstAddon.Count-1 do
          for j:= 0 to Count do
            lstWares.Add(lstWares[j]+lstAddon[i]);
      end;
{
      43394: begin   // HANS PRIES
        lstFound:= SearchWareGBInTecDocBasic(lstWares, lstBrands, ThreadData);;
        if lstFound.Count=0 then begin
          lstSearch.Clear;
//          s:= GetCutNameForSearchTD(Cache.GetWare(pWareID).Name);
          s1:= fnDelSpcAndSumb(s,'');
          if (Length(s1)=9) and (s[4]=' ') and (s[8]=' ') then System.Delete(s1, 7, MaxInt);
          lstSearch.Add(s1);
          prFree(lstFound);
          lstFound:= SearchWareGBInTecDocBasic(lstSearch, lstBrands, ThreadData);
        end;
        if lstFound.Count>1 then ChoiceFromMany(lstFound, plstTwice, lstWares);
        Result.Assign(lstFound);
      end;
}
    end; // case

    Result:= fnCreateStringList(True, dupIgnore);
    IBQuery:= nil;
    IBD:= cntsTDT.GetFreeCnt;
    IBQuery:= fnCreateNewIBSQL(IBD, 'IBQuery_'+nmProc, -1, tpRead, true);
    s:=fnGetDelimiterText(lstWares);
    s1:=fnArrOfIntToString(TBrandItem(Cache.WareBrands[Ware.WareBrandID]).TDMFcodes);
    IBQuery.SQL.Text:= 'SELECT DS_MF_ID, ART_NR '+
      'FROM ARTICLES, DATA_SUPPLIERS '#10+
      'WHERE (ART_NR in ('+s+')) and '#10+
            '(ART_SUP_ID=DS_ID) and DS_MF_ID IN ('+s1+')'#10+
      'ORDER BY DS_BRA, ART_NR';
    IBQuery.Prepare;
    IBQuery.ExecQuery;
    while not IBQuery.EOF do begin
      Result.AddObject(IBQuery.FieldByName('DS_MF_ID').AsString+'|'+IBQuery.FieldByName('ART_NR').asString, pointer(0));
      if cntsTDT.Suspend then raise Exception.Create(MessText(mtkExitBySuspend));
      IBQuery.Next;
    end;
    IBQuery.close;

  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  prFree(lstAddon);
  prFree(lstWares);
  prFreeIBSQL(IBQuery);
  cntsTDT.SetFreeCnt(IBD);
end;
{
function  fnGetGBAndTecDocWareLinks(UserID: integer; var lstBodyMail: TStringList; var FName, Subj,
                                 ContentType:string; ThreadData: TThreadData; filter_data: string):string;
const nmProc='fnGetGBAndTecDocWareLinks';
var
  WareList, List: TStringList;
  i, ii : integer;
  Position : integer;
  CurBrand, Content, s: string;
  Ware: TWareInfo;
  PathFile: String;
  CellStylesArray: TXmlCellStylesArray;
  CellStyle, TextStyle: TXmlReportStyle;
  FilterData: TStringList;
  TDWares: TStringList;
  AnalogInList: boolean;
  ManufID, Manuf, Article, SubContent: string;
  RowCount: integer;

  IBORDQuery: TIBSQL;
  IBORD: TIBDatabase;

begin
  Content:='';
  FilterData:=TStringList.Create;
  IBORDQuery:=nil;
  IBORD:=nil;
  try
    FilterData.Text:=filter_data;
    CurBrand:=FilterData.Values['dop_gbbrand']; // получаем код бренда

    try  // проверяю на целочисленность
      i:=StrToInt(CurBrand);
    except
      raise EBOBError.Create('Задан неверный код бренда - "'+CurBrand+'"');
    end;

    if (not Cache.WareBrands.ItemExists(i)) then begin
      raise EBOBError.Create('Не существует бренда с кодом '+CurBrand);
    end;

    if (Length(TBrandItem(Cache.WareBrands[i]).TDMFcodes)=0) then begin
      raise EBOBError.Create('Этому бренду не соответствует ни один бренд TecDoc');
    end;

    WareList:=fnGetWareListByBrand(i, constIsAuto, true);
    if WareList.Count=0 then begin
      raise EBOBError.Create('В этом бренде не найден ни один товар');
    end;



    CellStylesArray:= TXmlCellStylesArray.Create;
    TextStyle:= CellStylesArray.AddStyle(TXmlReportStyle.Create('#FFFFFF'));
    Content:=Content+fnOpenWorksheet(TBrandItem(Cache.WareBrands[i]).Name)+#10;  //открываем worksheet;

    IBORD:= cntsORD.GetFreeCnt;
    IBORDQuery:= fnCreateNewIBSQL(IBORD, 'Query_'+nmProc, -1, tpRead, true);
    IBORDQuery.SQL.Text:= 'SELECT * FROM WAREARTICLETD WHERE WATDWARECODE=:WATDWARECODE';
    IBORDQuery.Prepare;

 //    for i := 0 to 10 do begin
    for i := 0 to WareList.Count-1 do begin
      AnalogInList:=false; // флажок, был ли назначенный товару ГроссБии товар TecDoc в возвращенном списке
      Ware:=Cache.GetWare(integer(WareList.Objects[i]));

      // получаем список товаров из базы TecDoc
      TDWares:=SearchWareGBInTecDoc(integer(WareList.Objects[i]), ThreadData);

      try
        // теперь добавляем, что у нас есть по этому товару в gb_ord
        IBORDQuery.ParamByName('WATDWARECODE').AsInteger:=Ware.ID;
        IBORDQuery.ExecQuery;
        while not IBORDQuery.EOF do begin
          s:=IBORDQuery.FieldByName('WATDARTSUP').AsString+'|'+IBORDQuery.FieldByName('WATDARTICLE').asString;
          if TDWares.Find(s, Position) then begin
            TDWares.Objects[Position]:=pointer(fnIfInt(IBORDQuery.FieldByName('WATDWRONG').AsString='F', 1, -1));
          end else begin
            TDWares.AddObject(s, pointer(fnIfInt(IBORDQuery.FieldByName('WATDWRONG').AsString='F', 1, -1)));
          end;
          IBORDQuery.Next;
        end;
        IBORDQuery.Close;


        Content:= Content+'<Row>'#10;
        if (Ware.ArticleTD='') then begin
          Content:= Content+fnGenerateXMLcell(Ware.Name, TextStyle); // тут должен быть белый цвет, как сигнал, что нет товара TecDoc. либо как-то по другому выделить
        end else begin
          Content:= Content+fnGenerateXMLcell(Ware.Name, TextStyle); // // тут должен быть зеленый цвет
        end;

        RowCount:=TDWares.Count-1;
        for ii :=0  to RowCount do begin
          if ii>0 then begin
            Content:= Content+'</Row>'#10;
            Content:= Content+'<Row>'#10;
          end;
          s:=TDWares[ii];
          Position:=Pos('|', s);
          ManufID:=Copy(s, 1, Position-1);
          Article:=Copy(s, Position+1, length(s));
          Position:=Cache.BrandTDList.IndexOfObject(pointer(StrToInt(ManufID)));
          if Position=-1 then begin
            raise EBOBError.Create('Не найден бренд TecDoc с кодом "'+ManufID+'"'); // тут не должно быть raise, должна быть запись ошибки в лог импорта
          end;
          Manuf:=Cache.BrandTDList[Position];

          if (integer(TDWares.Objects[ii])=0) then begin
            CellStyle:=TextStyle; // тут должен быть белый цвет
          end else begin
            CellStyle:=TextStyle; // тут должен быть зеленый цвет
          end;

          Content:= Content+fnGenerateXMLcell(Manuf,CellStyle);
          Content:= Content+fnGenerateXMLcell(Article,CellStyle);
          Content:= Content+fnGenerateXMLcell(intToStr(integer(TDWares.Objects[ii])),CellStyle);
        end;
      finally
        prFree(TDWares);
      end;
      Content:= Content+'</Row>'#10;
    end;
    Content:=Content+fnCloseWorkSheet('')+#10;  //закрываем worksheet;

    List:=TStringList.Create;
    List.Add(cEX_Doc_Begin);
    List.Add(cEX_Workbook_Begin);

    List.Add(CellStylesArray.GetXmlStyles);

    List.Add(Content);

    List.Add(cEX_Workbook_End);

    PathFile:=ExtractFilePath(Application.ExeName)+'TMP\'+Cache.arEmplInfo[UserID].ServerLogin+'\';
    if not DirectoryExists(PathFile) then begin
      if not ForceDirectories(PathFile)then begin
        raise Exception.Create('Невозможно создать папку'+PathFile);
      end;
    end;

    FName:=PathFile+'WaresGBandTD_'+FormatDateTime('_dd.mm_(hh.nn)',Now)+'.xml';
    if FileExists(FName) then
      if not SysUtils.DeleteFile(FName) then
        raise Exception.Create('Невозможно удалить предыдущий файл.');

    List.SaveToFile(FName);

//    lstBodyMail:=TStringList.Create;
//    lstBodyMail.Add('Заглушка для письма - а вдруг поможет?');
    ContentType:='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';

  finally
    prFree(FilterData);
    prFree(WareList);
    prFree(List);
    prFree(CellStylesArray);
    prFree(TDWares);
    prFreeIBSQL(IBORDQuery);
    cntsORD.SetFreeCnt(IBORD);
  end;
end;
)


{----------------------------------------------------------------------------------------}
{  Получить списки Брендов Grossbee, TecDoc и список связей брендов
{----------------------------------------------------------------------------------------}
procedure prGetLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetLinkBrandsGBTD';
var
       UserID: Integer;
     Position: Integer;
//      TimeAll: TDateTime;
        VarTo: Integer;
     i, ii, j: integer;
         list: TStringList;

begin
  List:=nil;
  Stream.Position := 0;
//  TimeAll := Now;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolManageBrands) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Position:=Stream.Position;
    Stream.WriteInt(0); // место под кол-во

    list:= TStringList.Create;

    varTo:=Cache.WareBrands.ItemsList.Count-1;
    j:=0;
    for i:=0 to varTo do with TBrandItem(Cache.WareBrands.ItemsList[i]) do begin
      list.AddObject(Name,Cache.WareBrands.ItemsList[i]);
    end;
    varTo:=List.Count-1;
    list.Sort;
    for i:=0 to varTo do with TBrandItem(List.Objects[i]) do begin
      if (Length(TDMFcodes)>0) then begin
        for ii:=0  to Length(TDMFcodes)-1 do begin
          Stream.WriteInt(ID);
          Stream.WriteInt(TDMFcodes[ii]);
          Inc(j);
        end;
      end;
      list.AddObject(Name,Pointer(ID));
    end;
    Stream.Position := Position;
    Stream.WriteInt(j);

    Stream.Position := 0;
  except
    on E: Exception do
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
  end;
  prFree(list);
end; // prGetLinkBrandsGBTD

procedure prAddLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAddLinkBrandsGBTD';
var
     UserID: Integer;
//    TimeAll: TDateTime;
  idBrandGB: Integer;
  idBrandTD: Integer;
    ResCode: Integer;
    ErrText: string;
begin
  Stream.Position := 0;
//  TimeAll := Now;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolManageBrands) then
      raise EBOBError.Create(MessText(mtkNotRightExists));


    idBrandGB := Stream.ReadInt;
    idBrandTD := Stream.ReadInt;

    if (not Cache.WareBrands.ItemExists(idBrandGB)) then begin
      raise EBOBError.Create('Не существует бренда с кодом '+IntToStr(idBrandGB));
    end;

    ResCode:=resAdded;
    ErrText:=Cache.CheckWareBrandReplace(idBrandGB, idBrandTD, UserID, ResCode);
    if (ResCode=resDoNothing) then begin
      raise EBOBError.Create('Эти бренды уже связаны друг с другом');
    end else
    if (ResCode=resError) then begin
      raise EBOBError.Create(ErrText);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
  end;

  Stream.Position := 0;
end; // prAddLinkBrandsGBTD


procedure prDelLinkBrandsGBTD(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prDelLinkBrandsGBTD';
var
     UserID: Integer;
//    TimeAll: TDateTime;
  idBrandGB: Integer;
  idBrandTD: Integer;
    ResCode: Integer;
    ErrText: string;
begin
  Stream.Position := 0;
//  TimeAll := Now;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;


    idBrandGB := Stream.ReadInt;
    idBrandTD := Stream.ReadInt;

    if (not Cache.WareBrands.ItemExists(idBrandGB)) then begin
      raise EBOBError.Create('Не существует бренда с кодом '+IntToStr(idBrandGB));
    end;

    ResCode:=resDeleted;
    ErrText:=Cache.CheckWareBrandReplace(idBrandGB, idBrandTD, UserID, ResCode);
    if (ResCode=resDoNothing) then begin
      raise EBOBError.Create('Такой связки брендов не существует');
    end else
    if (ResCode=resError) then begin
      raise EBOBError.Create(ErrText);
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
  end;

  Stream.Position := 0;
end; // prDelLinkBrandsGBTD


{----------------------------------------------------------------------------------------}
{        Получение списка оригинальных номеров для товара с кодом источника
{----------------------------------------------------------------------------------------}
procedure prProductGetOrigNumsAndWares(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prProductGetOrigNumsAndWares'; // имя процедуры/функции
var
  UserID, WareID: integer;
  pos: int64;
  STai, SLTai: Tai;
  j: integer;
  WhatReturn: byte;
  IBQuery: TIBSQL;
  IBD: TIBDatabase;
  OrNum: TOriginalNumInfo;
  s: string;

begin
  Stream.Position:= 0;
  IBQuery:=nil;
  IBD:=nil;
  UserID:= Stream.ReadInt;
  WareID:= Stream.ReadInt;
  WhatReturn:= Stream.ReadByte;
  try
//    UserID:= Stream.ReadInt;
//    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolProduct, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    pos:= Stream.Position;
    Stream.WriteInt(0);
    j:=0;
    if WhatReturn=0 then s:= 'F' else s:= 'T';

    IBD:= cntsORD.GetFreeCnt;
    IBQuery:= fnCreateNewIBSQL(IBD, 'IBQuery_'+nmProc, -1, tpRead, true);
    IBQuery.SQL.Text:= 'select ORLKONUMCODE, ORLKSOURCECODE'+
                      ' from ORIGINALLINKWARE where ORLKCODEWARE='+IntToStr(WareID)+
                      ' AND ORLKWRONG="'+s+'" order by ORLKSOURCECODE';
    IBQuery.Prepare;
    IBQuery.ExecQuery;
    while not IBQuery.EOF do begin
      OrNum:= Cache.FDCA.GetOriginalNum(IBQuery.FieldByName('ORLKONUMCODE').AsInteger);
      if (OrNum<>nil) then begin
        Stream.WriteInt(OrNum.ID);      // Код оригинального номера
        Stream.WriteInt(OrNum.MfAutoID);     // код производителя авто
        Stream.WriteByte(IBQuery.FieldByName('ORLKSOURCECODE').AsInteger);    // Код источника связи
        Stream.WriteStr(OrNum.OriginalNum);  // оригинальный номер
        Stream.WriteStr(OrNum.ManufName);  // оригинальный номер
        Inc(j);
      end;
      IBQuery.Next;
    end;
    IBQuery.close;

    Stream.Position:= pos;
    Stream.WriteInt(j);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
  end;
  prFreeIBSQL(IBQuery);
  cntsORD.SetFreeCnt(IBD);
  Stream.Position:= 0;
  SetLength(STai, 0);
  SetLength(SLTai, 0);

end; // prProductGetOrigNumsAndWares


{----------------------------------------------------------------------------------------}
{                Управление отметкой об ошибочной связи товара и ОЕ
{----------------------------------------------------------------------------------------}
procedure prMarkOrNum(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prMarkOrNum'; // имя процедуры/функции
var
  UserId, WareID, ResCode, OrigId: integer;
  OrigNum, MsgStr: string;
  SourceLinkID: integer;
//  MfAuID: integer;
begin
  Stream.Position:= 0;
  SourceLinkID:=soHand;
  try
    UserID       := Stream.ReadInt;
    WareID       := Stream.ReadInt;  // Код товара
    OrigId       := Stream.ReadInt;  // Код ОЕ
    ResCode      := Stream.ReadByte; // Код операции

    if not (ResCode in [resWrong, resNotWrong]) then
      raise EBOBError.Create('Ошибочный код операции '+IntToStr(resCode)+' !');

    prSetThLogParams(ThreadData, 0, UserId, 0, 'WareID='+IntToStr(WareID)+'OrigId='+IntToStr(OrigId)+' Operation='+IntToStr(ResCode));

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolProduct) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    if (ResCode=resWrong) then begin
//      MfAuID:=Cache.FDCA.arOriginalNumInfo[OrigId].MfAutoID;
      OrigNum:=Cache.FDCA.arOriginalNumInfo[OrigId].OriginalNum;
    end;

    MsgStr:= Cache.FDCA.CheckOrigNumLink(ResCode, WareID, 0,
      OrigId, OrigNum, SourceLinkID, UserID);


    Case ResCode of
      resError, resDoNothing: begin
        raise EBOBError.Create(MsgStr);
      end;
    end;// Case ResCode of

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prMarkOrNum

{----------------------------------------------------------------------------------------}
{                Получить оригинальные номера, общие для 2х товаров
{----------------------------------------------------------------------------------------}
procedure prShowCrossOE(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowCrossOE'; // имя процедуры/функции
var
  UserId, FirmID, Ware1, Ware2: integer;
  errmess: string;
  i, Position, Count, arlen: integer;
  STai1, SLTai1, STai2, SLTai2: Tai;
  
begin
  Stream.Position:= 0;
  try
    UserID       := Stream.ReadInt;
    FirmID       := Stream.ReadInt;
    Ware1        := Stream.ReadInt;  // Код товара
    Ware2        := Stream.ReadInt;  // Код товара

    prSetThLogParams(ThreadData, 0, UserId, FirmID, ' Ware1='+IntToStr(Ware1)+' Ware2='+IntToStr(Ware2));

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if not Cache.WareExist(Ware1) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(Ware1)+' ] !');

    if not Cache.WareExist(Ware2) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(Ware2)+' ] !');

    Cache.arWareInfo[Ware1].SortOrigNumsWithSrc(STai1, SLTai1);
    Cache.arWareInfo[Ware2].SortOrigNumsWithSrc(STai2, SLTai2);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(Cache.arWareInfo[Ware1].Name);
    Stream.WriteStr(Cache.arWareInfo[Ware2].Name);

    arlen:=Length(STai2);
    Count:=0;
    Position:=Stream.Position;
    Stream.WriteInt(0);
    for i:= 0 to arlen-1 do begin
      if not Cache.FDCA.OrigNumExist(STai2[i]) then Continue;
      if (fnInIntArray(STai2[i], STai1)=-1) then Continue;
      inc(Count);
      with Cache.FDCA.arOriginalNumInfo[STai2[i]] do begin
        Stream.WriteInt(STai2[i]);      // Код оригинального номера
        Stream.WriteInt(MfAutoID);     // код производителя авто
        Stream.WriteByte(SLTai2[i]);    // Код источника связи
        Stream.WriteStr(OriginalNum);  // оригинальный номер
        Stream.WriteStr(ManufName);  //
      end;
    end;
    Stream.Position:=Position;
    Stream.WriteInt(Count);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  SetLength(STai1, 0);
  SetLength(SLTai1, 0);
  SetLength(STai2, 0);
  SetLength(SLTai2, 0);
end; // prShowCrossOE

procedure prShowCurrentOperations(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowCurrentOperations'; // имя процедуры/функции
var
  UserId, FirmID, UserOperID, i: integer;
  errmess: string;

begin
  Stream.Position:= 0;
  try
    UserID       := Stream.ReadInt;
    UserOperID   := Stream.ReadInt;
    FirmID:=isWe;

    prSetThLogParams(ThreadData, 0, UserId, FirmID, ' UserOperID='+IntToStr(UserOperID));

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if (UserOperID>-1) and CheckNotValidUser(UserOperID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(1); // кол-во передаваемых элементов
randomize();
    for i:= 0 to 0 do begin
      Stream.WriteDouble(Now()-3);   // дата/время начала операции
      if (random>0.5) then begin
        Stream.WriteInt(constOpExport);     // признак импорт/экспорт
      end else begin
        Stream.WriteInt(constOpImport);     // признак
      end;
      Stream.WriteInt(UserID);     // код хозяина процесса
      Stream.WriteInt(23);         // код импорта/экспорта
      Stream.WriteStr('Касторский Б.Б.');  // Фио хозяина процесса
      Stream.WriteStr('Крутой мега импорт №2765 по производителю Фольксваген');  // название операции
      Stream.WriteDouble(100*random);  // процент выполнения
    end;

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prShowCurrentOperations

procedure prShowEngineOptions(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowEngineOptions'; // имя процедуры/функции
var
  UserId, FirmID, ModelID, i, EngineID: integer;
  errmess, Engine: string;
  EngineData, List: TStringList;
  EngCodes: Tai;
  arlen: integer;

begin
  List:=nil;
  EngineData:=nil;
  Stream.Position:= 0;
  try
    FirmID       := Stream.ReadInt;
    UserID       := Stream.ReadInt;
    ModelID      := Stream.ReadInt;
    Engine       := Stream.ReadStr;
    EngineID     := Stream.ReadInt;

    prSetThLogParams(ThreadData, 0, UserId, FirmID, ' ModelID='+IntToStr(ModelID)+' Engine='+Engine); // дописать подробности!

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if (EngineID=-1) then begin
      if not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');

      EngCodes:=Cache.FDCA.Models[ModelID].EngLinks.GetLinkCodes;
    end else begin
      if not Cache.FDCA.Engines.ItemExists(EngineID) then raise EBOBError.Create('Не найден заданный двигатель');
      SetLength(EngCodes, 1);
      EngCodes[0]:=EngineID;
      Engine:=Cache.FDCA.Engines.GetEngine(EngineID).Mark;
    end;

    arlen:=Length(EngCodes)-1;
    EngineData:=TStringList.Create;

    for i:=0 to arlen do begin
      if Cache.FDCA.Engines.GetEngine(EngCodes[i]).Mark=Engine then begin
        if EngineData.Count>0 then begin
          EngineData.Add('==========</td><td> ==========');
        end;
        List:=Cache.FDCA.Engines.GetEngine(EngCodes[i]).GetViewList('</td><td> ');
        EngineData.Assign(List);
        prFree(List);
      end;
    end;

    arlen:=EngineData.Count-1;
    if arlen<0 then begin
      raise EBoBError.Create('Нет данных по этому двигателю.');
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(arlen);
    for i:=0 to arlen do begin
      Stream.WriteStr(EngineData[i]);
    end;
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  SetLength(EngCodes, 0);
  prFree(EngineData);
  prFree(List);
end; // prShowEngineOptions

// "освежает" набор Top10 последних выбираемых моделей и возвращает данные для отображения строк
procedure prGetTop10Model(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetTop10Model'; // имя процедуры/функции
var
  UserId, FirmID, ModelID, i, Sys, ModelLineID, MFAID, CurModel: integer;
  errmess, Codes: string;
  ModelCodesNew: Tai;
  ModelCodesOLD : Tas;
  arlen: integer;
  Model: TModelAuto;
  MayAdd: boolean;
  Engine: TEngine;
begin
  Stream.Position:= 0;
  try
    FirmID       := Stream.ReadInt;
    UserID       := Stream.ReadInt;
    Sys          := Stream.ReadInt;
    ModelID      := Stream.ReadInt;
    Codes        := Stream.ReadStr;

    prSetThLogParams(ThreadData, 0, UserId, FirmID, ' ModelID='+IntToStr(ModelID)+' Codes='+Codes); // дописать подробности!

    if not (Sys in constAllSys) and (Sys<>(constIsAuto+30)) then begin
      raise EBOBError.Create('Неизвестный тип системы - '+IntToStr(Sys));
    end;
    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if ((Sys in constAllSys)) then begin
      if (ModelID<>-1) and not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');
      if (ModelID<>-1) and (Sys<>(constIsAuto+30)) and (Cache.FDCA.Models[ModelID].TypeSys<>Sys) then raise EBOBError.Create('Модель не соответствует системе учета');
      if (ModelID<>-1) and not (Cache.FDCA.Models[ModelID].IsVisible) then raise EBOBError.Create('Нельзя добавить невидимую модель');
    end else begin
      if (ModelID<>-1) and not Cache.FDCA.Engines.ItemExists(ModelID) then raise EBOBError.Create('Не найден заданный двигатель');
    end;

    if (ModelID=-1) then begin
      SetLength(ModelCodesNew, 0);
    end else begin
      SetLength(ModelCodesNew, 1);
      ModelCodesNew[0]:=ModelID;
    end;

    ModelCodesOld:=fnSplitString(Codes, ',');
    arlen:=Length(ModelCodesOld)-1;
    for i:=0  to arlen do begin
      CurModel:=StrToIntDef(ModelCodesOld[i], -1);
      MayAdd:=(CurModel<>-1) and (CurModel<>ModelID);

      if ((Sys in constAllSys)) then begin
        MayAdd:=MayAdd and
         Cache.FDCA.Models.ModelExists(CurModel) and
        (Cache.FDCA.Models[CurModel].TypeSys=Sys) and
        (Cache.FDCA.Models[CurModel].IsVisible)
      end else begin
        MayAdd:=MayAdd and Cache.FDCA.Engines.ItemExists(CurModel);
      end;

      if MayAdd then begin
        SetLength(ModelCodesNew, Length(ModelCodesNew)+1);
        ModelCodesNew[Length(ModelCodesNew)-1]:=CurModel;
      end;
    end;

    if Length(ModelCodesNew)>10 then begin
      SetLength(ModelCodesNew, 10);
    end;

    arlen:=Length(ModelCodesNew)-1;
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(arlen);
    for i:=0 to arlen do begin
      if ((Sys in constAllSys)) then begin
        Model:=Cache.FDCA.Models[ModelCodesNew[i]];
        ModelLineID:=Model.ModelLineID;
        MFAID:=Cache.FDCA.ModelLines.GetModelLine(ModelLineID).MFAID;
        Stream.WriteInt(Model.ID); //
        Stream.WriteInt(Model.SubCode); //
        Stream.WriteInt(ModelLineID); //
        Stream.WriteInt(MFAID); //
        Stream.WriteStr(Cache.FDCA.Manufacturers[MFAID].Name);
        Stream.WriteStr(Cache.FDCA.ModelLines.GetModelLine(ModelLineID).Name);
        Stream.WriteStr(Model.Name); //
        Stream.WriteInt(Model.Params.pYStart); // Год начала выпуска
        Stream.WriteInt(Model.Params.pMStart); // Месяц начала выпуска
        Stream.WriteInt(Model.Params.pYEnd);   // Год окончания выпуска
        Stream.WriteInt(Model.Params.pMEnd);   // Месяц окончания выпуска
        Stream.WriteInt(Model.Params.pHP); //
        Stream.WriteStr(Model.MarksCommaText); //
      end else begin
        Engine:=Cache.FDCA.Engines[ModelCodesNew[i]];
        Stream.WriteInt(Engine.ID); // Code
        Stream.WriteStr(Engine.MfauName); //
        Stream.WriteStr(Engine.Name); //
        Stream.WriteStr(Engine.EngCCstr); //
        Stream.WriteStr(Engine.EngKWstr); //
        Stream.WriteStr(Engine.EngHPstr); //
        Stream.WriteStr(Engine.EngCYLstr); //
      end;
    end;
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  SetLength(ModelCodesOLD, 0);
  SetLength(ModelCodesNew, 0);
end; // prGetTop10Model

// получить список двигателей по производителю
procedure prLoadEngines(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLoadEngines'; // имя процедуры/функции
var
  UserId, FirmID, MFAUID, i, Count : integer;
  errmess: string;
//  ModelCodesNew: Tai;
  arlen: integer;
  Engine: TEngine;
  EngineList: TStringList;
begin
  EngineList:=nil;
  Stream.Position:= 0;
  try
    FirmID       := Stream.ReadInt;
    UserID       := Stream.ReadInt;
    MFAUID       := Stream.ReadInt;

    prSetThLogParams(ThreadData, 0, UserId, FirmID, ' MFAUID='+IntToStr(MFAUID)); // дописать подробности!
    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if not Cache.FDCA.Manufacturers.ManufExists(MFAUID) then raise EBOBError.Create(MessText(mtkNotFoundManuf, IntToStr(MFAUID)));

    EngineList:=Cache.FDCA.Engines.GetMfauEngList(MFAUID);

    arlen:=EngineList.Count-1;
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(arlen);
    Count:=0;
    for i:=0 to arlen do begin
      Engine:=TEngine(EngineList.Objects[i]);
      if (Engine.EngHasWares) then begin
  (*
        TEngine.EngKWstr  - строка - значение Мощность кВт
        TEngine.EngHPstr  - строка - значение Мощность ЛС
        TEngine.EngCCstr  - строка - значение Тех.обьем в куб.см.
        TEngine.EngCYLstr - строка - значение Количество цилиндров
  *)
        Stream.WriteInt(Engine.ID); //
        Stream.WriteStr(Engine.Name); //
        Stream.WriteStr(Engine.EngCCstr); //
        Stream.WriteStr(Engine.EngKWstr); //
        Stream.WriteStr(Engine.EngHPstr); //
        Stream.WriteStr(Engine.EngCYLstr); //
        Inc(Count);
      end;
    end;
    Stream.Position:=4;
    Stream.WriteInt(Count);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(EngineList);
end; // prLoadEngines


procedure prNewsPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prNewsPage'; // имя процедуры/функции
var
  UserId: integer;
  Count: integer;
  OrdIBDatabase: TIBDatabase;
  GBIBSQL: TIBSQL;
  Employees: TEmplInfoItem;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  GBIBSQL:= nil;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if (fnInIntArray(rolNewsManage, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    GBIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'GBIBSQL_'+nmProc,ThreadData.ID, tpRead, true);

    GBIBSQL.SQL.Text:='Select * from infoboxviews i order by i.ibvdateto desc, i.ibvdatefrom desc, i.ibvtitle';
    GBIBSQL.ExecQuery;
    Count:=0;
    Stream.WriteInt(Count);
    while not GBIBSQL.EOF do begin
      Stream.WriteInt(GBIBSQL.FieldByName('IBVCODE').AsInteger);
      Stream.WriteBool(GBIBSQL.FieldByName('IBVVISIBLE').AsString='T');
      Stream.WriteBool(GBIBSQL.FieldByName('IBVVISAUTO').AsString='T');
      Stream.WriteBool(GBIBSQL.FieldByName('IBVVISMOTO').AsString='T');
      Stream.WriteStr(FormatDateTime('dd.mm.yyyy', GBIBSQL.FieldByName('IBVDATEFROM').AsDate));
      Stream.WriteStr(FormatDateTime('dd.mm.yyyy', GBIBSQL.FieldByName('IBVDATETO').AsDate));
      Stream.WriteStr(GBIBSQL.FieldByName('IBVTITLE').AsString);
      Stream.WriteStr(GBIBSQL.FieldByName('IBVLINKTOPICT').AsString);
      Stream.WriteStr(GBIBSQL.FieldByName('IBVLINKTOSITE').AsString);

      if Cache.EmplExist(GBIBSQL.FieldByName('IBVUSERID').AsInteger) then begin
        Employees:=Cache.arEmplInfo[GBIBSQL.FieldByName('IBVUSERID').AsInteger];
        Stream.WriteStr(fnCutFio(Employees.Surname, Employees.Name, Employees.Patronymic));
      end else begin
        Stream.WriteStr('Неизвестный');
      end;

      Stream.WriteStr(FormatDateTime('dd.mm.yyyy hh:nn', GBIBSQL.FieldByName('IBVTIMEADD').AsDateTime));
      Stream.Writeint(GBIBSQL.FieldByName('IBVCLICKCOUNT').AsInteger);
      GBIBSQL.Next;
      Inc(Count);
    end;

    Stream.Position:=4;
    Stream.WriteInt(Count);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBSQL(GBIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prNewsPage

procedure prWebArmResetPassword(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebArmResetPassword'; // имя процедуры/функции
var
  UserId, FirmID: integer;
  errmess: string;
  pass1, pass2: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBQuery: TIBQuery;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBQuery:= nil;
  FirmID:=isWe;
  try
    UserID       := Stream.ReadInt;
    pass1        := trim(Stream.ReadStr);
    pass2        := trim(Stream.ReadStr);


    prSetThLogParams(ThreadData, 0, UserId, isWe, ' newpass1='+pass1+' newpass2='+pass2); // дописать подробности!
    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if (not Cache.arEmplInfo[UserId].RESETPASSWORD) then begin
      raise EBoBAutenticationError.Create('В Вашей учетной записи нет пометки об обязательной смене пароля.');
    end;

    if (not fnCheckOrderWebPassword(pass1)) then begin
      raise EBOBError.Create('Пароль не соответствует принятым соглашениям.');
    end;

    if (pass1<>pass2) then begin
      raise EBOBError.Create('Введенные пароли не совпадают.');
    end;

    if (pass1=Cache.arEmplInfo[UserId].USERPASSFORSERVER) then begin
      raise EBOBError.Create('Новый пароль не должен совпадать со старым');
    end;

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBQuery:=fnCreateNewIBQuery(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);

    OrdIBQuery.SQL.Text:='UPDATE EMPLOYEES SET EMPLPASS=:pass, EMPLRESETPASWORD=''F'' WHERE EMPLCODE='+IntToStr(UserId);
    OrdIBQuery.ParamByName('pass').AsString:=pass1;
    OrdIBQuery.ExecSQL;
    OrdIBQuery.Transaction.Commit;
    Cache.arEmplInfo[UserId].RESETPASSWORD:=false;
    Cache.arEmplInfo[UserId].USERPASSFORSERVER:=pass1;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBQuery(OrdIBQuery);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; // prWebArmResetPassword

procedure prTestLinksLoading(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prTestLinksLoading'; // имя процедуры/функции
begin
  try
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteBool(Cache.WareCacheUnLocked);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
//      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
//      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prTestLinksLoading


procedure prGetFilterValues(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFilterValues'; // имя процедуры/функции
var
  UserId, NodeId, ModelId, FirmId: integer;
  i: integer;
  IsEngine: boolean;
  aiWares: Tai;
  errmess, StrPos: string;
  List: TStringList;
begin
  Stream.Position:= 0;
  List:=nil;
  try
    FirmId:=Stream.ReadInt;
    UserID:= Stream.ReadInt;
    NodeId:= Stream.ReadInt;
    ModelId:= Stream.ReadInt;
    IsEngine:= Stream.ReadBool;
StrPos:='0';
    prSetThLogParams(ThreadData, 0, UserId, FirmId,
     'Node='+IntToStr(NodeId)+#13#10+'Model='+IntToStr(ModelId)+'isEngine='+fnIfStr(IsEngine, '1', '0')+#13#10); // логирование
StrPos:='1';

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
StrPos:='1-1';

StrPos:='2';

    if not IsEngine and not Cache.FDCA.Models.ModelExists(ModelId) then begin
      raise EBOBError.Create('Неверно указана модель');
    end;

    if IsEngine and not Cache.FDCA.Engines.ItemExists(ModelId) then begin
      raise EBOBError.Create('Неверно указан двигатель');
    end;
StrPos:='3';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    List:= Cache.FDCA.GetModelOrEngNodeFiltersList(NodeID, ModelID, IsEngine);
    Stream.WriteStr('Место установки');
    Stream.WriteInt(List.Count); // кол-во значений в категории
    for i:= 0 to List.Count-1 do begin
      Stream.WriteInt(integer(List.Objects[i])); //
      Stream.WriteStr(List[i]);
    end;
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
  end;
StrPos:='30';
  Stream.Position:= 0;
  SetLength(aiWares, 0);
  prFree(List);
end; // prGetFilterValues

procedure prShowActionNews(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowActionNews'; // имя процедуры/функции
var
  UserId, FirmId, NewsId: integer;
  errmess, StrPos: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    FirmId:=isWe;
    UserId:= Stream.ReadInt;
    NewsId:= Stream.ReadInt;
StrPos:='0';
    prSetThLogParams(ThreadData,0,UserId,0,'Newsid='+IntToStr(NewsId)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolNewsManage) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
StrPos:='2';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'GBIBSQL_'+nmProc,ThreadData.ID, tpRead, true);
    OrdIBSQL.SQL.Text:='Select * from infoboxviews where ibvcode='+IntToStr(NewsId);
    OrdIBSQL.ExecQuery;
    if OrdIBSQL.EOF then begin
      raise EBOBError.Create('Указанная новость не найдена');
    end;

    Stream.WriteInt(OrdIBSQL.FieldByName('IBVCODE').Asinteger);
    Stream.WriteBool(OrdIBSQL.FieldByName('IBVVISAUTO').AsString='T');
    Stream.WriteBool(OrdIBSQL.FieldByName('IBVVISMOTO').AsString='T');
    Stream.WriteBool(OrdIBSQL.FieldByName('IBVVISIBLE').AsString='T');
    Stream.WriteDouble(OrdIBSQL.FieldByName('IBVDATEFROM').AsDate);
    Stream.WriteDouble(OrdIBSQL.FieldByName('IBVDATETO').AsDate);
    Stream.WriteInt(OrdIBSQL.FieldByName('IBVPRIORITY').Asinteger);
    Stream.WriteStr(OrdIBSQL.FieldByName('IBVTITLE').AsString);
    Stream.WriteStr(OrdIBSQL.FieldByName('IBVLINKTOSITE').AsString);
    Stream.WriteStr(OrdIBSQL.FieldByName('IBVLINKTOPICT').AsString);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
  end;
StrPos:='30';
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; // prShowActionNews

procedure prAEActionNews(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAEActionNews'; // имя процедуры/функции
var
  UserId, FirmId: integer;
  errmess, StrPos: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;

  Auto, Moto, InFrame: boolean;
  Link, title: string;
  DateTo, DateFrom: TDateTime;
  NewsId, Priority: integer;


begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    FirmId:= isWe;
    UserId:= Stream.ReadInt;
StrPos:='0';
    NewsId:= Stream.ReadInt;
    prSetThLogParams(ThreadData, 0, UserId, 0, 'Newsid='+IntToStr(NewsId)); // логирование

    Auto  := Stream.ReadBool;
    Moto  := Stream.ReadBool;
    InFrame:= Stream.ReadBool;
    Link:= Stream.ReadStr;
    title:= trim(Stream.ReadStr);
    DateTo:= Stream.ReadDouble;
    DateFrom:= Stream.ReadDouble;
    Priority:= Stream.ReadInt;

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolNewsManage) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if (title='') then raise EBOBError.Create('Название не может быть пустым');

    if (DateFrom>DateTo) then raise EBOBError.Create('Дата окончания периода отображения не может быть меньше даты начала.');

    if (Priority<0) then begin
      Priority:=0;
    end;

StrPos:='2';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBSQL_'+nmProc,ThreadData.ID, tpWrite, true);

    if (NewsId<0) then begin
      OrdIBSQL.SQL.Text:='Insert into infoboxviews (IBVVISAUTO, IBVVISMOTO, IBVVISIBLE, IBVDATEFROM, IBVDATETO, IBVPRIORITY, IBVTITLE, IBVLINKTOSITE, IBVLINKTOPICT, IBVUSERID) values '+
                         ' (:IBVVISAUTO, :IBVVISMOTO, :IBVVISIBLE, :IBVDATEFROM, :IBVDATETO, :IBVPRIORITY, :IBVTITLE, :IBVLINKTOSITE, :IBVLINKTOPICT, :IBVUSERID) returning ibvcode';
      OrdIBSQL.ParamByName('IBVLINKTOPICT').AsString:='addimage.jpg';
    end else begin
      OrdIBSQL.SQL.Text:='Update infoboxviews set IBVVISAUTO=:IBVVISAUTO, IBVVISMOTO=:IBVVISMOTO, IBVVISIBLE=:IBVVISIBLE, IBVDATEFROM=:IBVDATEFROM, '+
                         'IBVDATETO=:IBVDATETO, IBVPRIORITY=:IBVPRIORITY, IBVTITLE=:IBVTITLE, IBVLINKTOSITE=:IBVLINKTOSITE, IBVUSERID=:IBVUSERID where ibvcode='+IntToStr(NewsId);
    end;

    OrdIBSQL.ParamByName('IBVVISAUTO').AsString:=fnIfStr(Auto, 'T', 'F');
    OrdIBSQL.ParamByName('IBVVISMOTO').AsString:=fnIfStr(Moto, 'T', 'F');
    OrdIBSQL.ParamByName('IBVVISIBLE').AsString:=fnIfStr(InFrame, 'T', 'F');
    OrdIBSQL.ParamByName('IBVDATEFROM').AsDateTime:=DateFrom;
    OrdIBSQL.ParamByName('IBVDATETO').AsDateTime:=DateTo;
    OrdIBSQL.ParamByName('IBVPRIORITY').AsInteger:=Priority;
    OrdIBSQL.ParamByName('IBVTITLE').AsString:=title;
    OrdIBSQL.ParamByName('IBVLINKTOSITE').AsString:=Link;
    OrdIBSQL.ParamByName('IBVUSERID').AsInteger:=UserID;

    OrdIBSQL.ExecQuery;

    if (NewsId<0) then begin
      NewsID:=OrdIBSQL.FieldByName('IBVCODE').Asinteger;
    end;
    OrdIBSQL.Transaction.Commit;

    Stream.WriteInt(NewsId);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
  end;
StrPos:='30';
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; // prAEActionNews

procedure prSaveImgForAction(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveImgForAction'; // имя процедуры/функции
var
  UserId, FirmId, NewsId: integer;
  errmess, StrPos: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;

  Link, oldimage: string;


begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    FirmId:=isWe;
    UserId:= Stream.ReadInt;
StrPos:='0';

    NewsId:= Stream.ReadInt;
    Link:= Stream.ReadStr;
    prSetThLogParams(ThreadData,0,UserId,0,'Newsid='+IntToStr(NewsId)); // логирование

    if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolNewsManage) then
      raise EBOBError.Create(MessText(mtkNotRightExists));


StrPos:='2';

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBSQL_'+nmProc,ThreadData.ID, tpWrite, true);
    oldimage:='';
    OrdIBSQL.SQL.Text:='Select IBVLINKTOPICT from INFOBOXVIEWS where ibvcode='+IntToStr(NewsId);
    OrdIBSQL.ExecQuery;
    if (not OrdIBSQL.EOF) then begin
      oldimage:=OrdIBSQL.FieldByName('IBVLINKTOPICT').AsString;
    end;
    OrdIBSQL.Close;

    OrdIBSQL.SQL.Text:='Update infoboxviews set IBVLINKTOPICT=:IBVLINKTOPICT where ibvcode='+IntToStr(NewsId);
    OrdIBSQL.ParamByName('IBVLINKTOPICT').AsString:=Link;
    OrdIBSQL.ExecQuery;
    OrdIBSQL.Transaction.Commit;
    Stream.WriteStr(oldimage);
 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка сервера.');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message+#13#10+StrPos, '');
    end;
  end;
StrPos:='30';
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; // prSaveImgForAction

procedure prShowSysOptionsPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowSysOptionsPage'; // имя процедуры/функции
var EmplID, FirmID, i, Count: integer;
    errmess: String;
    List: TStringList;
    Item: TConstItem;
    Employee: TEmplInfoItem;
begin
  Stream.Position:= 0;
  List:=nil;
  try
    EmplID:= Stream.ReadInt;
    FirmID:=isWe;
    prSetThLogParams(ThreadData, 0, EmplID);

    if CheckNotValidUser(EmplID, FirmID, errmess) then raise EBOBError.Create(errmess);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    Stream.WriteBool(Cache.arEmplInfo[EmplID].UserRoleExists(rolManageSprav)); // может ли редактировать привязки ролей к константам

    List:=Cache.GetEmplConstants(EmplID);
    Count:=List.Count-1;
    Stream.WriteInt(Count);
    for i:=0 to Count do begin
      Item:=Cache.GetConstItem(integer(List.Objects[i]));
      Stream.WriteInt(Item.ID);
      Stream.WriteStr(Item.Grouping);
      Stream.WriteStr(Item.Name);
      Stream.WriteInt(Item.ItemType);
      Stream.WriteBool(Cache.CheckEmplConstant(EmplID, Item.ID, errmess, true));
      Stream.WriteStr(fnGetAdaptedConstValue(integer(List.Objects[i])));
      if Cache.EmplExist(Item.LastUser) then begin
        Employee:=Cache.arEmplInfo[Item.LastUser];
        Stream.WriteStr(fnCutFio(Employee.Surname, Employee.Name, Employee.Patronymic));
      end else begin
        Stream.WriteStr('Неизвестный');
      end;
      Stream.WriteDouble(Item.LastTime);
    end;

 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(fnReplaceQuotedForWeb(E.Message));
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(MessText(mtkErrProcess));
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(List);
end; // prShowSysOptionsPage


procedure prSaveSysOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSaveSysOption'; // имя процедуры/функции
var EmplID, FirmID, ConstId: integer;
    errmess, Value: String;
    Item: TConstItem;
    Employee: TEmplInfoItem;
    sParam: String;
begin
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;
    FirmID:=isWe;
    ConstID:= Stream.ReadInt;
    value:= Stream.ReadStr;
    sParam:= 'ConstID='+IntToStr(ConstID);
    try

      if CheckNotValidUser(EmplID, FirmID, errmess) then raise EBOBError.Create(errmess);
      if  not Cache.CheckEmplConstant(EmplID, ConstID, errmess, true) then raise EBOBError.Create(errmess);

      Stream.Clear;
      Stream.WriteInt(aeSuccess);
      errmess:= Cache.SaveNewConstValue(ConstID, EmplID, Value); // проверяем значение по смыслу внутри
      if (errmess<>'') then begin
        raise EBOBError.Create(errmess);
      end;
      sParam:= sParam+#13#10'Value='+Value; // дописываем значение
    finally
      prSetThLogParams(ThreadData, 0, EmplID, 0, sParam);
    end;


    Item:=Cache.GetConstItem(ConstID);
    Stream.WriteStr(fnGetAdaptedConstValue(ConstID));
    if Cache.EmplExist(Item.LastUser) then begin
      Employee:=Cache.arEmplInfo[Item.LastUser];
      Stream.WriteStr(fnCutFio(Employee.Surname, Employee.Name, Employee.Patronymic));
    end else begin
      Stream.WriteStr('Неизвестный');
    end;
    Stream.WriteDouble(Item.LastTime);



 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(fnReplaceQuotedForWeb(E.Message));
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(MessText(mtkErrProcess));
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prSaveSysOption

procedure prEditSysOption(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prEditSysOption'; // имя процедуры/функции
var EmplID, FirmID, ConstId: integer;
    errmess: String;
    List: TStringList;
    Employee: TEmplInfoItem;
    i, j, Count: integer;
    aos: Tas;
    Item: TConstItem;
begin
  List:=nil;
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;
    FirmID:=isWe;
    ConstID:= Stream.ReadInt;
    prSetThLogParams(ThreadData, 0, EmplID, 0, 'ConstID='+IntToStr(ConstID));

    if CheckNotValidUser(EmplID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if not Cache.ConstExists(ConstID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - код='+IntToStr(ConstID));
    if not Cache.CheckEmplConstant(EmplID, ConstID, errmess, true) then raise EBOBError.Create(errmess);

    Item:=Cache.GetConstItem(ConstID);

    Stream.Clear;
    Stream.WriteInt(aeSuccess);
    case ConstID of
      pcEmplID_list_Rep30, pcTestingSending1, pcTestingSending2, pcTestingSending3,
      pcEmpl_list_UnBlock, pcEmpl_list_TmpBlock, pcEmpl_list_FinalBlock,
      pcVINmailEmpl_list
      : begin
        List:=TStringList.Create;
        aos:=fnSplitString(Item.StrValue, ',');
        j:=0;
        Stream.WriteInt(j);
        Count:=Length(Cache.arEmplInfo)-1;
        for i:=0 to Count do begin
          if Cache.EmplExist(i) and (Cache.arEmplInfo[i].Mail<>'') then begin
            Employee:=Cache.arEmplInfo[i];
            list.AddObject(fnCutFio(Employee.Surname, Employee.Name, Employee.Patronymic), Pointer(i));
            Inc(j);
          end;
        end;
        List.Sort;
        for i:=1 to Length(ceNames) do begin
          list.AddObject(ceNames[-i], Pointer(-i));
          Inc(j);
        end;

        j:=j-1;
        for i:=0 to j do begin
          Stream.WriteInt(integer(List.Objects[i]));
          Stream.WriteBool(fnInStrArrayBool(IntToStr(integer(List.Objects[i])), aos));
          Stream.WriteStr(List[i]);
        end;
        Stream.Position:= 4;
        Stream.WriteInt(j);
      end;  //pcEmplID_list_Rep30

      pcVINmailFilial_list, pcVINmailFirmClass_list, pcVINmailFirmTypes_list, pcPriceLoadFirmClasses: begin
        aos:=fnSplitString(Item.StrValue, ',');
        case ConstID of
          pcVINmailFilial_list: begin
            List:=Cache.GetFilialList();
          end;
          pcVINmailFirmClass_list, pcPriceLoadFirmClasses: begin
            List:=Cache.GetFirmClassesList();
          end;
          pcVINmailFirmTypes_list: begin
            List:=Cache.GetFirmTypesList();
          end;
        end;
        Stream.WriteInt(List.Count);
        for i:=0 to List.Count-1 do begin
          j:=integer(List.Objects[i]);
          Stream.WriteInt(j);
          Stream.WriteBool(fnInStrArrayBool(IntToStr(j), aos));
          Stream.WriteStr(List[i]);
        end;
      end;


      pcEmplSaleDirectorAuto, pcEmplSaleDirectorMoto : begin
        Stream.WriteInt(StrToInt(Item.StrValue));
        List:=TStringList.Create;
        j:=0;
        Stream.WriteInt(j);
        Count:=Length(Cache.arEmplInfo)-1;
        for i:=0 to Count do begin
          if Cache.EmplExist(i) then begin
            Employee:=Cache.arEmplInfo[i];
            list.AddObject(fnCutFio(Employee.Surname, Employee.Name, Employee.Patronymic), Pointer(i));
            Inc(j);
          end;
        end;
        List.Sort;
        j:=j-1;
        for i:=0 to j do begin
          Stream.WriteInt(integer(List.Objects[i]));
          Stream.WriteStr(List[i]);
        end;
        Stream.Position:= 8;
        Stream.WriteInt(j);
      end;  // pcEmplSaleDirectorAuto, pcEmplSaleDirectorMoto

    else
      raise EBOBError.Create('Не знаю, как обработать значение.');
    end;


 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(fnReplaceQuotedForWeb(nmProc+': '+E.Message));
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(MessText(mtkErrProcess));
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(List);
  SetLength(aos, 0);
end; // prEditSysOption

procedure prShowConstRoles(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowConstRoles'; // имя процедуры/функции

var EmplID, FirmID, ConstId: integer;
    errmess: String;
    i, varTo: integer;
    Roles: Tai;
    Item: TConstItem;
begin
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;
    FirmID:=isWe;
    ConstID:= Stream.ReadInt;
    prSetThLogParams(ThreadData, 0, EmplID, 0, 'ConstID='+IntToStr(ConstID));


    if CheckNotValidUser(EmplID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if not Cache.arEmplInfo[EmplID].UserRoleExists(rolManageSprav) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.ConstExists(ConstID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - код='+IntToStr(ConstID));


    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    Roles:=Cache.GetAllRoleCodes;
    varTo:=Length(Roles)-1;
    Stream.WriteInt(varTo); // место под кол-во ролей
    for i:=0 to varTo do begin
      Stream.WriteInt(Roles[i]);
      Stream.WriteStr(Cache.GetRoleName(Roles[i]));
      Item:=Cache.GetConstItem(ConstID);
      if Item.Links.LinkExists(Roles[i]) then begin
        Stream.WriteInt(TLink(Item.Links[Roles[i]]).SrcId+100);
      end else begin
        Stream.WriteInt(0);
      end;
    end;

 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(fnReplaceQuotedForWeb(nmProc+': '+E.Message));
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(MessText(mtkErrProcess));
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  SetLength(Roles, 0);
end; // prShowConstRoles


procedure prEditConstRoles(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prEditConstRoles'; // имя процедуры/функции

var EmplID, FirmID, ConstId, ResCode: integer;
    errmess, s: String;
    List: TStringList;
    i, varTo: integer;
    Item: TConstItem;
    RoleCode, Rights: integer;

begin
  List:=nil;
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;
    FirmID:=isWe;
    ConstID:= Stream.ReadInt;
    errmess:=Stream.ReadStr;
    errmess:=StringReplace(errmess, '-', '=', [rfReplaceAll]);
    errmess:=StringReplace(errmess, '|', #13#10, [rfReplaceAll]);
    List:=TStringList.Create;
    List.Text:=errmess;
    prSetThLogParams(ThreadData, 0, EmplID, 0, 'ConstID='+IntToStr(ConstID));


    if CheckNotValidUser(EmplID, FirmID, errmess) then raise EBOBError.Create(errmess);
    if not Cache.arEmplInfo[EmplID].UserRoleExists(rolManageSprav) then
      raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.ConstExists(ConstID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - код='+IntToStr(ConstID));

    Stream.Clear;
    Stream.WriteInt(aeSuccess);

    Item:=Cache.GetConstItem(ConstID);
    varTo:=List.Count-1;
    errmess:='';
    for i:=0 to varTo do begin
      RoleCode:=StrToIntDef(List.Names[i], -1);
      Rights:=StrToIntDef(List.Values[List.Names[i]], -1);
      if (Cache.RoleExists(RoleCode) and (Rights in [0..2])) then begin
        if (Rights=0) then begin //удаляем
          if Item.Links.LinkExists(RoleCode) then begin
            ResCode:=resDeleted;
            s:=Cache.CheckRoleConstLink(ConstID, RoleCode, EmplID, false, ResCode);
            if ResCode=resError then begin
              errmess:=errmess+s+#13#10;
            end;
          end;
        end else begin
          if Item.Links.LinkExists(RoleCode) then begin
            ResCode:=resEdited;
          end else begin
            ResCode:=resAdded;
          end;
          s:=Cache.CheckRoleConstLink(ConstID, RoleCode, EmplID, Rights=2, ResCode);
          if ResCode=resError then begin
            errmess:=errmess+s+#13#10;
          end;
        end;
      end;
    end;
    if errmess<>'' then begin
      EBOBError.Create('Во время выполнения операции возникли следующие ошибки: '#13#10+errmess);
    end;

 except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(fnReplaceQuotedForWeb(nmProc+': '+E.Message));
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(MessText(mtkErrProcess));
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(List);
end; // prEditConstRoles

// Управление отметкой об ошибочной связи товара c односторонним аналогом
procedure prMarkOneDirectAnalog(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prMarkOneDirectAnalog'; // имя процедуры/функции
var
  UserId, WareID, ResCode, AnalogId, SrcID: integer;
  MsgStr: string;
  Ware: TWareInfo;
//  MfAuID: integer;
begin
  Stream.Position:= 0;
  try
    UserID       := Stream.ReadInt;
    WareID       := Stream.ReadInt;    // Код товара
    AnalogId     := Stream.ReadInt;    // Код аналога
    ResCode      := Stream.ReadByte;   // Код операции
    SrcID        := Stream.ReadInt;    // Код источника

    prSetThLogParams(ThreadData, 0, UserId, isWe, 'WareID='+IntToStr(WareID)+#13#10'AnalogId='+IntToStr(AnalogId)+#13#10'Operation='+IntToStr(ResCode));

    if not (ResCode in [resWrong, resNotWrong, resDeleted]) then
      raise EBOBError.Create('Ошибочный код операции '+IntToStr(resCode)+' !');

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.arEmplInfo[UserID].UserRoleExists(rolProduct) then
      raise EBOBError.Create(MessText(mtkNotRightExists));

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    if not Cache.WareExist(AnalogId) then
      raise EBOBError.Create('Товар-аналог не найден [ ID = '+IntToStr(AnalogId)+' ] !');

    Ware:=Cache.GetWare(WareId);

    if Ware.ManagerID<>UserId then
      raise EBOBError.Create('У Вас нет прав на работу с товаром '+Ware.Name);


    MsgStr:= Cache.CheckWareCrossLink(AnalogId, WareID, ResCode, SrcID, UserID);

    Case ResCode of
      resError, resDoNothing: begin
        raise EBOBError.Create(MsgStr);
      end;
    end;// Case ResCode of

//    prSetThLogParams(ThreadData, 0, UserId, isWe, ' Success=true');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; // prMarkOneDirectAnalog


// Добавить односторонний аналог вручную
procedure prAddOneDirectAnalog(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAddOneDirectAnalog'; // имя процедуры/функции
var
  UserId, WareID, ResCode: integer;
  AnalogName, MsgStr: string;
  Ware: TWareInfo;
  Wares, Plug: Tai;
begin
  Stream.Position:= 0;
  Plug:=nil;
  try
    UserID       := Stream.ReadInt;
    WareID       := Stream.ReadInt;    // Код товара
    AnalogName   := Stream.ReadStr;    // Наименование аналога

    prSetThLogParams(ThreadData, 0, UserId, isWe, 'WareID='+IntToStr(WareID)+#13#10'AnalogName='+AnalogName);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not Cache.WareExist(WareID) then
      raise EBOBError.Create('Товар не найден [ ID = '+IntToStr(WareID)+' ] !');

    Ware:=Cache.GetWare(WareId);
    if Ware.ManagerID<>UserId then
      raise EBOBError.Create('У Вас нет прав на работу с товаром '+Ware.Name);


    Wares:=SearchWareNames(AnalogName, 3);

    if (Length(Wares)=0) then
      raise EBOBError.Create('Товар-аналог не найден [ '+(AnalogName)+' ] !');

    ResCode:=resAdded;
    MsgStr:= Cache.CheckWareCrossLink(Wares[0], WareID, ResCode, soHand, UserID);

    Case ResCode of
      resError, resDoNothing: begin
        raise EBOBError.Create(MsgStr);
      end;
    end;// Case ResCode of

//    prSetThLogParams(ThreadData, 0, UserId, isWe, ' Success=true');

    Stream.Clear;
    Stream.WriteInt(aeSuccess);


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  SetLength(Wares, 0);
end; // prAddOneDirectAnalog


procedure prUiKPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prUiKPage'; // имя процедуры/функции
var
  UserId: integer;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create('Не найден пользователь.');
    end;

    if (fnInIntArray(rolUiK, Cache.arEmplInfo[UserId].UserRoles)=-1) then begin
      raise EBOBError.Create('У Вас нет прав для выполнения этой операции.');
    end;
    Stream.Clear;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
end; //prUiKPage

function fnGetCategoryList(RootCode:integer=221648):TStringList;
const nmProc = 'fnGetCategoryList'; // имя процедуры/функции
var
  GBIBDatabase: TIBDatabase;
  GBIBSQL: TIBSQL;
  Codes: Tai;
  CodesCount, CurrentCode: integer;

begin
  GBIBSQL:= nil;
//  GBIBDatabase:= nil;
  Result:=TStringList.Create;
  SetLength(Codes, 100);
  CodesCount:=1;
  CurrentCode:=0;
  Codes[CurrentCode]:=RootCode;
  try
    GBIBDatabase:=CntsGRB.GetFreeCnt();
    GBIBSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBQuery_'+nmProc); //  !!!! Передать THREADDATA
    GBIBSQL.Transaction.StartTransaction;
    GBIBSQL.SQL.Text:='Select WARECODE, WAREOFFICIALNAME, WARECHILDCOUNT from WARES where WAREMASTERCODE=:WARECODE';
    while CurrentCode<CodesCount do begin
      GBIBSQL.ParamByName('WARECODE').AsInteger:=Codes[CurrentCode];
      GBIBSQL.ExecQuery;
      while not GBIBSQL.EOF do begin
        if (GBIBSQL.FieldByName('WARECHILDCOUNT').AsInteger>0) then begin
          if CodesCount=Length(Codes) then SetLength(Codes, CodesCount+100);
          Codes[CodesCount]:=GBIBSQL.FieldByName('WARECODE').AsInteger;
          Inc(CodesCount);
        end else begin
          Result.AddObject(GBIBSQL.FieldByName('WAREOFFICIALNAME').AsString, pointer(GBIBSQL.FieldByName('WARECODE').AsInteger));
        end;
        GBIBSQL.Next;
      end;
      GBIBSQL.Close;
      Inc(CurrentCode);
    end;

  except
    on E:Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  SetLength(Codes, 0);
  prFreeIBSQL(GBIBSQL);
  CntsGRB.SetFreeCnt(GBIBDatabase, false);
end;  // fnGetCategoryList


procedure prShowPortion(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowPortion'; // имя процедуры/функции
var
  WareId, ModelID, NodeID, UserId, PortionID, i: integer;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    UserID:= Stream.ReadInt;
    ModelID:= Stream.ReadInt;
    NodeID:= Stream.ReadInt;
    WareID:= Stream.ReadInt;
    PortionID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId, 0, 'ModelID='+IntToStr(ModelID)+#9'NodeID='+IntToStr(NodeID)+#9'WareID='+IntToStr(WareID)+#9'PortionID='+IntToStr(PortionID));

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) and not Cache.FDCA.AutoTreeNodesSys[constIsAuto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto) and not Cache.FDCA.AutoTreeNodesSys[constIsMoto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if not Cache.WareExist(WareID) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));

    if ((Cache.FDCA.Models[ModelID].TypeSys=constIsAuto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto)) or
       ((Cache.FDCA.Models[ModelID].TypeSys=constIsMoto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create('У Вас нет прав на редактирование данных этого бизнес-направления');
    end;

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
    OrdIBSQL.Transaction.StartTransaction;

    OrdIBSQL.SQl.Clear;

    OrdIBSQL.SQL.Add('select c.wcridescr, v.wcvsvalue from GetModelNodeWareLinkCode('+IntToStr(ModelID)+
                     ', '+IntToStr(NodeID)+', '+IntToStr(WareID)+') l3 ');
    OrdIBSQL.SQL.Add('left join linkwaremodelnodeusage u on u.lwmnuldmwcode=l3.rLDMWCODE and u.lwmnupart='+IntToStr(PortionID)+' ');
    OrdIBSQL.SQL.Add('left join warecrivalues v on v.wcvscode=u.lwmnuwcvscode ');
    OrdIBSQL.SQL.Add('left join warecriteries c on c.wcricode=v.wcvswcricode ');
    OrdIBSQL.SQL.Add('order by c.wcridescr, v.wcvsvalue ');
    OrdIBSQL.ExecQuery;
    Stream.WriteInt(0); // место под кол-во
    i:=0;
    while not OrdIBSQL.EOF do begin
      Stream.WriteStr(OrdIBSQL.fieldByName('wcridescr').AsString);
      Stream.WriteStr(OrdIBSQL.fieldByName('wcvsvalue').AsString);
      Inc(i);
      OrdIBSQL.Next;
    end;
    Stream.Position:=4;
    Stream.WriteInt(i);




  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prShowPortion



procedure prGetRadiatorList;
const nmProc = 'prGetRadiatorList'; // имя процедуры/функции

var
  TDIBDatabase: TIBDatabase;
  TDIBQuery: TIBSQL;
  OrdIBDatabase: TIBDatabase;
  OrdIBQuery: TIBSQL;
  arFirst, arSecond: Tai;
  OL, OL1: TObjectList;
  CurrentModel, i, j, k: integer;
  Founded: boolean;
  TwoCodes: TTwoCodes;
  SL, SLTemp: TStringList;
  Articles, Models: Tas;
  ArticlesMin: integer;

function ComparePairs(Item1, Item2: Pointer): Integer;
var
  TwoCode1, TwoCode2: TTwoCodes;
begin
  TwoCode1:=TTwoCodes(TObjectList(Item1)[0]);
  TwoCode2:=TTwoCodes(TObjectList(Item2)[0]);
  if (TwoCode1.ID1<TwoCode2.ID1) then Result:=-1
  else if (TwoCode1.ID1>TwoCode2.ID1) then Result:=1
  else if (TwoCode1.ID2<TwoCode2.ID2) then Result:=-1
  else if (TwoCode1.ID2>TwoCode2.ID2) then Result:=1
  else Result:=0;
end;

begin

  TDIBDatabase:=nil;
  TDIBQuery:= nil;
  ORDIBDatabase:=nil;
  OrdIBQuery:= nil;
  SetLength(arFirst, 0);
  SetLength(arSecond, 0);
  CurrentModel:=-1;
  OL1:=nil;
  OL:=TObjectList.Create;
  try

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBQuery:=fnCreateNewIBSql(OrdIBDatabase,'OrdIBQuery_'+nmProc, 0, tpWrite);

    TDIBDatabase:=CntsTDT.GetFreeCnt();
    TDIBQuery:=fnCreateNewIBSQL(TDIBDatabase,'OrdIBQuery_'+nmProc,0, tpWrite);
    TDIBQuery.Transaction.StartTransaction;

    // создаем массив моделей в виде, пригодном для вставки в csv файл +++
    TDIBQuery.SQl.Clear;
    TDIBQuery.SQL.Add('select Max(m.mt_id) max_ from model_types m');
    TDIBQuery.ExecQuery;
    SetLength(Models, TDIBQuery.FieldByName('max_').AsInteger+1);
    TDIBQuery.Close;

    // инициализируем массив
    for i:=0 to Length(Models)-1 do begin
      Models[i]:='';
    end;

    TDIBQuery.SQl.Clear;
    TDIBQuery.SQL.Add('select m.mt_id, mf.mf_descr, s.ms_descr, m.mt_descr, m.mt_from, m.mt_to, m.mt_hp, e.eng_mark from model_types m');
    TDIBQuery.SQL.Add('left join model_series s on s.ms_id=m.mt_ms_id');
    TDIBQuery.SQL.Add('left join manufacturers mf on mf.mf_id=s.ms_mf_id');
    TDIBQuery.SQL.Add('left outer join link_eng_model_types le on le.lemt_mt_id=m.mt_id');
    TDIBQuery.SQL.Add('left join engines e on e.eng_id=le.lemt_eng_id');
    TDIBQuery.SQL.Add('order by m.mt_id, e.eng_mark');
    TDIBQuery.ExecQuery;
    while not TDIBQuery.Eof do begin
      if Models[TDIBQuery.FieldByName('mt_id').AsInteger]='' then
        Models[TDIBQuery.FieldByName('mt_id').AsInteger]:=TDIBQuery.FieldByName('mf_descr').AsString
        +';" '+TDIBQuery.FieldByName('ms_descr').AsString+' "'
        +';" '+TDIBQuery.FieldByName('mt_descr').AsString+' "'
        +';'+TDIBQuery.FieldByName('mt_from').AsString+'-'+fnIfStr(TDIBQuery.FieldByName('mt_to').AsInteger>0, TDIBQuery.FieldByName('mt_to').AsString, '')
        +';'+TDIBQuery.FieldByName('mt_hp').AsString
        +';'+TDIBQuery.FieldByName('mt_id').AsString
        +';'+TDIBQuery.FieldByName('eng_mark').AsString
      else Models[TDIBQuery.FieldByName('mt_id').AsInteger]:=Models[TDIBQuery.FieldByName('mt_id').AsInteger]+', '+TDIBQuery.FieldByName('eng_mark').AsString;
      TDIBQuery.Next;
    end;
    TDIBQuery.Close;
    // создаем массив моделей в виде, пригодном для вставки в csv файл ---


// выбираю все артикулы, которые должны участвовать в выборке вместе с моделями, к которым они привязаны
// причем сортирую по коду модели
    TDIBQuery.SQl.Clear;
    TDIBQuery.SQL.Add('select ');
//    TDIBQuery.SQL.Add('first 100 ');
    TDIBQuery.SQL.Add('l.*, a.art_nr ');
    TDIBQuery.SQL.Add('from link_art_ga_type l');
    TDIBQuery.SQL.Add('left join articles a on a.art_id=l.lagt_art_id ');
    TDIBQuery.SQL.Add('where l.lagt_ga_id in (447, 448, 2842, 2843)');
    TDIBQuery.SQL.Add('and a.art_sup_id in (66, 123)');
    TDIBQuery.SQL.Add('order by l.lagt_mt_id');
    TDIBQuery.ExecQuery;

    while not TDIBQuery.Eof do begin
// если эта модель встретилась не первый раз, то код артикула добавляется в массив arFirst или arSecond
// (см строки кода перед TDIBQuery.Next;)
// Проверки, в какой массив вставлять, основаны на данных заказчика, а именно, принадлежности ариткула группе и бренду(производителю)
      if (TDIBQuery.FieldByName('lagt_mt_id').AsInteger<>CurrentModel) then begin
// если модель встретилась первый раз, то это знак, что предыдущая закончилась (так как сортировка выборки идет по коду модели)
// и самое время подбить итоги
// OL - это ObjectList, в котором лежат объекты типа тоже ТObjectList
// во внутреннем ObjectList по два объекта. Первый типа TTwoCodes, который содержит коды пар товаров первой и второй группы
// Второй типа TStringList, который содержит строки с моделями.
{ TODO : Это неправильно, что я использую StringList для хранения полных строк моделей, это занимает лишнюю память. Заменить на Tlist }
// перебираем все возможные сочетания элементов массивов arFirst и arSecond
        for i:=0 to Length(arFirst)-1 do for j:=0 to Length(arSecond)-1 do begin
          Founded:=false;
          for k:=0 to OL.Count-1 do begin
            OL1:=TObjectList(OL[k]);
            TwoCodes:=TTwoCodes(OL1[0]);
            if (TwoCodes.ID1=arFirst[i]) and (TwoCodes.ID2=arSecond[j]) then begin
              Founded:=true;
              break;
            end;
          end;
// если нашли, то в OL1 ссылка на новый
          if not Founded then begin
            OL1:=TObjectList.Create;
            OL1.Add(TTWoCodes.Create(arFirst[i], arSecond[j]));
            OL.Add(OL1);
            SLTemp:=TStringList.Create;
            OL1.Add(SLTemp);
          end;
          SLTemp:=TStringList(OL1[1]);
          SLTemp.Add(Models[CurrentModel]);
        end;
        SetLength(arFirst, 0);
        SetLength(arSecond, 0);
        CurrentModel:=TDIBQuery.FieldByName('lagt_mt_id').AsInteger;
      end;

      if (TDIBQuery.FieldByName('lagt_ga_id').AsInteger=447) or (TDIBQuery.FieldByName('lagt_ga_id').AsInteger=2842) then begin
        prAddItemToIntArray(TDIBQuery.FieldByName('lagt_art_id').AsInteger, arFirst);
      end;
      if (TDIBQuery.FieldByName('lagt_ga_id').AsInteger=448) or (TDIBQuery.FieldByName('lagt_ga_id').AsInteger=2843) then begin
        prAddItemToIntArray(TDIBQuery.FieldByName('lagt_art_id').AsInteger, arSecond);
      end;
      TDIBQuery.Next;
    end;
    TDIBQuery.Close;

    TDIBQuery.SQl.Clear;
    TDIBQuery.SQL.Add('select Min(a.art_id) min_, Max(a.art_id) max_ from articles a');
    TDIBQuery.SQL.Add('where a.art_sup_id in (66, 123)');
    TDIBQuery.SQL.Add('and a.art_id in (select l.lagt_art_id from link_art_ga_type l where l.lagt_ga_id in (447, 448, 2842, 2843))');
    TDIBQuery.ExecQuery;
    ArticlesMin:=TDIBQuery.FieldByName('min_').AsInteger;
    SetLength(Articles, TDIBQuery.FieldByName('max_').AsInteger-ArticlesMin+1);
    TDIBQuery.Close;

    TDIBQuery.SQl.Clear;
    TDIBQuery.SQL.Add('select a.art_id, a.art_nr, d.ds_bra, a.art_warecode from articles a, data_suppliers d');
    TDIBQuery.SQL.Add('where');
    TDIBQuery.SQL.Add('a.art_sup_id in (66, 123)');
    TDIBQuery.SQL.Add('and a.art_id in (select l.lagt_art_id from link_art_ga_type l where l.lagt_ga_id in (447, 448, 2842, 2843))');
    TDIBQuery.SQL.Add('and d.ds_id=a.art_sup_id');
    TDIBQuery.ExecQuery;
    while not TDIBQuery.Eof do begin
      Articles[TDIBQuery.FieldByName('art_id').AsInteger-ArticlesMin]:=TDIBQuery.FieldByName('art_warecode').AsString+TDIBQuery.FieldByName('ds_bra').AsString+' '+TDIBQuery.FieldByName('art_nr').AsString;
      TDIBQuery.Next;
    end;
    TDIBQuery.Close;

    OL.Sort(@ComparePairs);
    SL:=TStringList.Create;
    SL.Add('Производитель;Модельный ряд;Модель;Даты выпуска;Мощность;Код;Двигатели');
    for k:=0 to OL.Count-1 do begin
      OL1:=TObjectList(OL[k]);
      TwoCodes:=TTwoCodes(OL1[0]);
      SLTemp:=TStringList(OL1[1]);
      SL.Add('');
      SL.Add(Copy(Articles[-ArticlesMin+TwoCodes.ID1], 2, 10000)+';'+Copy(Articles[-ArticlesMin+TwoCodes.ID2], 2, 10000));
      SL.Add(Copy(Articles[-ArticlesMin+TwoCodes.ID1], 1, 1)+';'+Copy(Articles[-ArticlesMin+TwoCodes.ID2], 1, 1));
      SL.AddStrings(SLTemp);
    end;

    SL.SaveToFile('111.csv');

      ShowMessage('I did it!');

  except
    on E: Exception do begin
      ShowMessage(E.Message);
    end;
  end;

  prFreeIBSQL(OrdIBQuery);
  cntsORD.SetFreeCnt(OrdIBDatabase);

  prFreeIBSQL(TDIBQuery);
  cntsTDT.SetFreeCnt(TDIBDatabase);

  SetLength(arFirst, 0);
  SetLength(arSecond, 0);
  SetLength(Articles, 0);
  SetLength(Models, 0);

//  prFree(OL);
end; //prGetRadiatorList

procedure prCOUPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCOUPage'; // имя процедуры/функции
var
  UserId, i: integer;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    UserID:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto) and Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then begin
      raise EBOBError.Create('Невозможно определить бизнес-направление для выбора соответствующих критериев.');
    end;

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
    OrdIBSQL.Transaction.StartTransaction;

    OrdIBSQL.SQl.Clear;
    OrdIBSQL.SQL.Add('select wc.wcridescr from warecriteries wc');
    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto)) then OrdIBSQL.SQL.Add('where wc.wcriedituseauto="T"');
    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then OrdIBSQL.SQL.Add('where wc.wcrieditusemoto="T"');
    OrdIBSQL.SQL.Add('group by wc.wcridescr');
    OrdIBSQL.SQL.Add('order by wc.wcridescr');

    OrdIBSQL.ExecQuery;
    Stream.WriteInt(0); // место под кол-во
    i:=0;
    while not OrdIBSQL.EOF do begin
      Stream.WriteStr(OrdIBSQL.fieldByName('wcridescr').AsString);
      Inc(i);
      OrdIBSQL.Next;
    end;
    OrdIBSQL.Close;
    Stream.Position:=4;
    Stream.WriteInt(i);

  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prCOUPage


procedure prGetCateroryValues(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetCateroryValues'; // имя процедуры/функции
var
  UserId, i, Position: integer;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
  ss, Criteria: string;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    UserID:=Stream.ReadInt;
    Criteria:=Stream.ReadStr;
    prSetThLogParams(ThreadData,0,UserId,isWe);

    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto) and Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then begin
      raise EBOBError.Create('Невозможно определить бизнес-направление для выбора соответствующих критериев.');
    end;

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(0); // место под кол-во
    Stream.WriteInt(0); // место под кол-во

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
    OrdIBSQL.Transaction.StartTransaction;

    OrdIBSQL.SQl.Clear;
    OrdIBSQL.SQL.Add('select first 1 wc.* from warecriteries wc ');
    OrdIBSQL.SQL.Add('where wc.wcridescr='''+Criteria+''' and ');
    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageAuto)) then OrdIBSQL.SQL.Add('wc.wcriedituseauto="T"');
    if (Cache.arEmplInfo[UserId].UserRoleExists(rolTNAManageMoto)) then OrdIBSQL.SQL.Add('wc.wcrieditusemoto="T"');
    OrdIBSQL.SQL.Add('order by wc.wcricode');
    OrdIBSQL.ExecQuery;
    if OrdIBSQL.EOF then raise EBOBError.Create('Не найден критерий "'+Criteria+'"');
    if OrdIBSQL.fieldByName('WCRICHOICE').AsString='T' then begin
      ss:=OrdIBSQL.fieldByName('wcricode').AsString;
      OrdIBSQL.Close;
//      Position:=Stream.Position;
      i:=0;
      Stream.Position:=8;
      if Cache.GetConstItem(pcStartLastCriValues).IntValue>0 then begin
        OrdIBSQL.SQl.Clear;
        OrdIBSQL.SQL.Add('  select first '+Cache.GetConstItem(pcStartLastCriValues).StrValue+' lwmnuwcvscode, wcvsvalue, ftime from ');
        OrdIBSQL.SQL.Add('  (select l.lwmnuwcvscode, v.wcvsvalue, max(l.lwmnutimeadd) ftime ');
        OrdIBSQL.SQL.Add('  from LINKWAREMODELNODEUSAGE l ');
        OrdIBSQL.SQL.Add('  left join warecrivalues v on l.lwmnuwcvscode=v.wcvscode ');
        OrdIBSQL.SQL.Add('  where ');
        OrdIBSQL.SQL.Add('  v.wcvswcricode='+ss+' and ');
        OrdIBSQL.SQL.Add('  l.lwmnuuserid='+IntToStr(UserId)+' and l.lwmnusrclecode='+IntToStr(soHand)+' ');
        OrdIBSQL.SQL.Add('  group by l.lwmnuwcvscode, v.wcvsvalue) ');
        OrdIBSQL.SQL.Add('  order by ftime desc ');
        OrdIBSQL.ExecQuery;
        while not OrdIBSQL.EOF do begin
          Stream.WriteStr(OrdIBSQL.fieldByName('wcvsvalue').AsString);
          Inc(i);
          OrdIBSQL.Next;
        end;
        OrdIBSQL.Close;
        Position:=Stream.Position;
        Stream.Position:=4;
        Stream.WriteInt(i);
        Stream.Position:=Position;
      end;

      OrdIBSQL.SQL.Text:='select wcvsvalue from warecrivalues wcv where wcv.wcvswcricode='+ss+' order by wcv.wcvsvalue';
      OrdIBSQL.ExecQuery;
      Position:=Stream.Position;
      i:=0;
      Stream.WriteInt(0); // место под кол-во
      while not OrdIBSQL.EOF do begin
        Stream.WriteStr(OrdIBSQL.fieldByName('wcvsvalue').AsString);
        Inc(i);
        OrdIBSQL.Next;
      end;
      OrdIBSQL.Close;
      Stream.Position:=Position;
      Stream.WriteInt(i);
    end;
    OrdIBSQL.Close;


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prGetCateroryValues


procedure prSavePortion(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prSavePortion'; // имя процедуры/функции
var
  WareId, ModelID, NodeID, UserId, PortionID, i, qty: integer;
  ss: string;
  SL: TStringList;
begin
  Stream.Position:= 0;
  try
    UserID:= Stream.ReadInt;
    ModelID:= Stream.ReadInt;
    NodeID:= Stream.ReadInt;
    WareID:= Stream.ReadInt;
    PortionID:= Stream.ReadInt;
    qty:= Stream.ReadInt;
    prSetThLogParams(ThreadData,0,UserId, 0, 'ModelID='+IntToStr(ModelID)+#9'NodeID='+IntToStr(NodeID)+#9'WareID='+IntToStr(WareID)+#9'PortionID='+IntToStr(PortionID)+#9'qty='+IntToStr(qty));
    if qty=0 then raise EBOBError.Create('Нельзя сохранить блок без содержимого');
    SL:=TStringList.Create;
    for i:=0 to qty-1 do begin
      SL.Add(Stream.ReadStr+cStrValueDelim+Stream.ReadStr);
    end;


    if not Cache.EmplExist(UserID) then begin
      raise EBOBError.Create(MessText(mtkNotClientExist));
    end;

    if not (Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) or Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create(MessText(mtkNotRightExists));
    end;

    if not Cache.FDCA.Models.ModelExists(ModelID) then raise EBOBError.Create('Не найдена заданная модель');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto) and not Cache.FDCA.AutoTreeNodesSys[constIsAuto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto) and not Cache.FDCA.AutoTreeNodesSys[constIsMoto].NodeExists(NodeId) then raise EBOBError.Create('Неверно указан узел');
    if not Cache.WareExist(WareID) then raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));

    if ((Cache.FDCA.Models[ModelID].TypeSys=constIsAuto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageAuto)) or
       ((Cache.FDCA.Models[ModelID].TypeSys=constIsMoto) and not Cache.arEmplInfo[UserId].UserRoleExists(rolModelManageMoto)) then begin
      raise EBOBError.Create('У Вас нет прав на редактирование данных этого бизнес-направления');
    end;

    if PortionId=-1 then  begin
      ss:=Cache.AddModelNodeWareUseListLinks(ModelID, NodeID, WareID, UserID, soHand, SL, PortionID);
    end else begin
      ss:=Cache.ChangeModelNodeWareUsesPart(ModelID, NodeID, WareID, UserID, soHand, SL, PortionID);
    end;


    if (ss<>'') then raise EBOBError.Create(ss);

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);


  except
    on E: EBOBError do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr(E.Message);
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', E.Message, '');
    end;
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка выполнения .');
      fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', E.Message, '');
    end;
  end;
  Stream.Position:= 0;
  prFree(SL);
end; //prSavePortion


procedure prGetDeliveriesList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetDeliveriesList'; // имя процедуры/функции
var EmplID, StoreId, i: integer;
    s: string;
begin
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;
    StoreId:= Stream.ReadInt;
    prSetThLogParams(ThreadData, 0, EmplID, 0, 'StoreId='+IntToStr(StoreId)); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    with Cache.GetShipMethodsList(StoreId) do try                      // список методов отгрузки по складу
      Stream.WriteInt(Count);
      for i:= 0 to Count-1 do begin
        Stream.WriteInt(Integer(Objects[i]));
        Stream.WriteStr(Strings[i]);
      end;
    finally
      Free;
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prGetDeliveriesList


procedure prRestorePassword(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prRestorePassword'; // имя процедуры/функции
var s, s1: string;
    empl: TEmplInfoItem;
    EmplID, i: integer;
    Body: TStringList;
    IP: string;
begin
  Body:=nil;
  Stream.Position:= 0;
  try
    S:= Stream.ReadStr;
    IP:= Stream.ReadStr;
    prSetThLogParams(ThreadData, 0, 0, 0, 'login='+s+#13#10'IP='+IP); // логирование

    EmplID:=Cache.GetEmplIDbyLogin(s);

    if (EmplID=-1) then begin
      raise EBOBError.Create('Не найден логин "'+s+'"');
    end;

    Empl:=Cache.arEmplInfo[EmplID];

    if (Empl.Arhived) then begin
      raise EBOBError.Create('Ваша учетная запись заблокирована администратором системы GrossBee.');
    end;

    if (Empl.Blocked) then begin
      raise EBOBError.Create('Ваша учетная запись заблокирована администратором werbarm.');
    end;

    i:=Pos('@', Empl.Mail);
    if (i=0) then begin
      raise EBOBError.Create('В справочнике сотрудников GrossBee отсутствует Ваш email. Обратитесь в отдел УиК непосредственно или через Вашего руководителя с просьбой внести Ваш email в справочник.');
    end;

    s:='172.20.10.';
    s1:='192.168.2.';
    if ((Copy(IP, 1, Length(s))<>s) and (Copy(IP, 1, Length(s1))<>s1)) then begin
      raise EBOBError.Create('Ваш IP '+IP+' не относится к числу разрешенных для восстановления пароля.');
    end;


    Body:=TStringList.Create;
    Body.Add('По запросу, выполненному с IP '+IP+', Вам направлены учетные данные для входа в webarm:');
    Body.Add('Адрес:  http://webarm.vladislav.ua/app/webarm.cgi');
    Body.Add('Логин: '+Empl.ServerLogin);
    Body.Add('Пароль: '+Empl.USERPASSFORSERVER);

    s:=n_SysMailSend(Empl.Mail, 'Восстановление пароля webarm', Body);

    if (s<>'') then begin
      raise EBOBError.Create('Не могу отправить почту. Ошибка "'+s+'"');
    end;

    raise EBOBError.Create('Пароль отправлен на адрес "'+Empl.Mail+'"');
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(Body);
end; //prRestorePassword

procedure prBlockWebArmUser(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prBlockWebArmUser'; // имя процедуры/функции
var
    OrdIBDatabase: TIBDatabase;
    OrdIBSQL: TIBSQL;
    EmplID, VictimID: integer;
    command, s: string;
    Victim: TEmplInfoItem;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    EmplID:= Stream.ReadInt;
    VictimID:= Stream.ReadInt;
    command:= Stream.ReadStr;

    prSetThLogParams(ThreadData, 0, EmplID, 0, 'VictimID='+IntToStr(VictimID)+#13#10'command='+command); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolManageUsers)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    if CheckNotValidUser(VictimID, isWe, s) then raise EBOBError.Create(s); // проверка жертвы
    Victim:=Cache.arEmplInfo[VictimId];

    if ((command<>'block') and (command<>'unblock')) then
        raise EBOBError.Create('Неизвестная подкоманда - "'+command+'"');

    if ((command='block') and Victim.Blocked) then
        raise EBOBError.Create('Пользователь уже заблокирован');

    if ((command<>'block') and not Victim.Blocked) then
        raise EBOBError.Create('Пользователь не заблокирован');

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite);
    OrdIBSQL.Transaction.StartTransaction;

    OrdIBSQL.SQl.Clear;
    OrdIBSQL.SQL.Add('UPDATE EMPLOYEES SET EMPLBLOCK="'+fnIfStr(command='block', '1', '0')+'" where EMPLCODE="'+IntToStr(VictimID)+'"');
    OrdIBSQL.ExecQuery;
    OrdIBSQL.Transaction.Commit;

    Victim.Blocked:=(command='block');

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prBlockWebArmUser

procedure prCheckRestsInStorageForAcc(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCheckRestsInStorageForAcc'; // имя процедуры/функции
var
  EmplID, i, StorageId, Pos, Count: integer;
  s, waress: string;
  wares: Tai;
  link: TQtyLink;
  rest: Double;
begin
  Stream.Position:= 0;
  SetLength(wares, 0);
  try
    EmplID:= Stream.ReadInt;
    StorageId:= Stream.ReadInt;
    waress:= Stream.ReadStr;

    prSetThLogParams(ThreadData, 0, EmplID, 0, 'Storage='+IntToStr(StorageId)+#13#10'wares='+s); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolOPRSK)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.DprtExist(StorageId) then
        raise EBOBError.Create('Не найден склад с кодом '+IntToStr(StorageId));

    wares:=fnArrOfCodesFromString(waress);
    if (Length(wares)=0) then
        raise EBOBError.Create('Нет данных для сравнения');

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    Pos:=Stream.Position;
    Stream.WriteInt(0);
    Count:=0;
    for i := 0 to Length(wares) do begin
      if Cache.WareExist(wares[i]) then begin
        link:= Cache.GetWare(wares[i]).RestLinks[StorageID];
        if Assigned(link) then Rest:=link.Qty  else Rest:=0;
        Stream.WriteInt(wares[i]);
        Stream.WriteDouble(Rest);
        Inc(Count);
      end;
    end;
    Stream.Position:=Pos;
    Stream.WriteInt(Count);
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  SetLength(wares, 0);
end; //prCheckRestsInStorageForAcc



function fnRep47(UserID: integer; var lstBodyMail: TStringList; var FName, Subj,
   ContentType:string; ThreadData: TThreadData; filter_data: string): string;
const
 nmProc = 'fnRep47'; // имя процедуры/функции
var
//  Percent: real;
//  OrdIBDatabase: TIBDatabase;
//  OrdIBSQL: TIBSQL;
  GBIBDatabase: TIBDatabase;
  GBIBSelectSQL: TIBSQL;
  GBIBInsertSQL: TIBSQL;
  ErrorMessage, PathFile:string;
//  total,
  added, skipped, addeddelta, skippeddelta, startid: integer;
  StartTime: TDateTime;
  Ware, Analog: TWareInfo;
  i, j: Integer;
  Analogs: Tai;
//  ShosBulo: boolean;
begin
//  ORDIBDatabase:=nil;
//  OrdIBSQL:= nil;
  GBIBDatabase:=nil;
  GBIBSelectSQL:= nil;
  GBIBInsertSQL:= nil;
  ErrorMessage:='';
  added:=0;
  skipped:=0;
//  Percent:=0;
  StartTime:=Now();
  lstBodyMail:=TStringList.Create;
  try

//    OrdIBDatabase:=CntsOrd.GetFreeCnt();
//    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBSQL_'+nmProc,ThreadData.ID, tpRead, true);
    GBIBDatabase:=CntsGrb.GetFreeCnt();

    GBIBSelectSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBSelectSQL_'+nmProc,ThreadData.ID, tpRead, true);
    GBIBSelectSQL.SQL.Text:='SELECT * FROM PMWAREANALOGS WHERE PMWAWARECODE=:PMWAWARECODE and PMWAWAREANALOGCODE=:PMWAWAREANALOGCODE';
    GBIBSelectSQL.Prepare;

    GBIBInsertSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBInsertSQL_'+nmProc,ThreadData.ID, tpWrite, true);
    GBIBInsertSQL.SQL.Text:='INSERT INTO PMWAREANALOGS (PMWAWARECODE, PMWAWAREANALOGCODE, PMWASOURCECODE, PMWAISWRONG, PMWAUSERCODE) '
                     +'VALUES (:PMWAWARECODE, :PMWAWAREANALOGCODE, :PMWASOURCECODE, :PMWAISWRONG, :PMWAUSERCODE)';
    GBIBInsertSQL.Prepare;

    startid:=Cache.GetConstItem(pcLastAddLoadWare).IntValue;

    for I := StartID+1 to High(Cache.arWareInfo) do begin
      addeddelta:=0;
      skippeddelta:=0;
      if Cache.WareExist(i) then begin
        Ware:=Cache.GetWare(i);
//        if Ware.IsWare and not Ware.IsArchive then begin
        if Ware.IsWare and not Ware.IsArchive and (Ware.ArticleTD<>'') then begin
          Analogs:=Ware.Analogs;
          if (length(Analogs)>0) and not GBIBInsertSQL.Transaction.Active then GBIBInsertSQL.Transaction.StartTransaction;
          for j:=0 to Length(Analogs)-1 do begin
            if not Cache.WareExist(Analogs[j]) then begin Inc(skippeddelta); continue; end;
            Analog:=Cache.GetWare(Analogs[j]);
            if not Analog.isWare then begin Inc(skippeddelta); continue; end;
            if Analog.IsArchive then begin Inc(skippeddelta); continue; end;
            if Analog.IsINFOgr then begin Inc(skippeddelta); continue; end;
            if (Analog.ArticleTD='') then begin Inc(skippeddelta); continue; end;
//            if ((Ware.ArticleTD<>'') and (Analog.ArticleTD<>'')) then begin Inc(skippeddelta); continue; end;
            GBIBSelectSQL.ParamByname('PMWAWARECODE').Asinteger:=Ware.ID;
            GBIBSelectSQL.ParamByname('PMWAWAREANALOGCODE').Asinteger:=Analog.ID;
            GBIBSelectSQL.ExecQuery;
            if GBIBSelectSQL.EOF then begin
              GBIBInsertSQL.ParamByname('PMWAWARECODE').Asinteger:=Ware.ID;
              GBIBInsertSQL.ParamByname('PMWAWAREANALOGCODE').Asinteger:=Analog.ID;
              GBIBInsertSQL.ParamByname('PMWASOURCECODE').Asinteger:=Cache.FDCA.GetSourceGBcode(soGrossBee);
              GBIBInsertSQL.ParamByname('PMWAISWRONG').AsString:='F';
              GBIBInsertSQL.ParamByname('PMWAUSERCODE').Asinteger:=UserID;
              GBIBInsertSQL.ExecQuery;
              Inc(addeddelta);
            end else begin
              Inc(skippeddelta);
            end;
            GBIBSelectSQL.Close;
          end;
          SetLength(Analogs, 0);
        end;
      end;
      if addeddelta>0 then begin
        GBIBInsertSQL.Transaction.Commit;
        added:=added+addeddelta;
        skipped:=skipped+skippeddelta;
      end;
      Cache.SaveNewConstValue(pcLastAddLoadWare, UserId, IntToStr(i));
      prStopProcess(UserID, ThreadData.ID);
      ImpCheck.SetProcessPercent(UserId,ThreadData.ID, (i-StartID)/(High(Cache.arWareInfo)-StartID));
//if (((i-startid)>100) and (added>0)) then break;

    end;







(* старая процедура - перекачка аналогов из базы ORD

    GBIBSelectSQL.SQL.Text:='SELECT * FROM PMWAREANALOGS WHERE PMWAWARECODE=:PMWAWARECODE and PMWAWAREANALOGCODE=:PMWAWAREANALOGCODE';
    GBIBSelectSQL.Prepare;
    GBIBInsertSQL:=fnCreateNewIBSQL(GBIBDatabase,'GBIBInsertSQL_'+nmProc,ThreadData.ID, tpWrite, true);
    GBIBInsertSQL.SQL.Text:='INSERT INTO PMWAREANALOGS (PMWAWARECODE, PMWAWAREANALOGCODE, PMWASOURCECODE, PMWAISWRONG, PMWAUSERCODE, PMWALASTEDITDATE) '
                     +'VALUES (:PMWAWARECODE, :PMWAWAREANALOGCODE, :PMWASOURCECODE, :PMWAISWRONG, :PMWAUSERCODE, :PMWALASTEDITDATE)';
    GBIBInsertSQL.Prepare;

    OrdIBSQL.SQL.Text:='Select count(LWACODE) from LINKWAREANALOGS where LWACODE>'+Cache.GetConstItem(pcLastAddLoadWare).StrValue;
    OrdIBSQL.ExecQuery;
    total:=OrdIBSQL.Fields[0].AsInteger;
    OrdIBSQL.Close;

    OrdIBSQL.SQL.Text:='Select FIRST 1000 * from LINKWAREANALOGS where LWACODE>:lastcode order by LWACODE';
    while true do begin
      addeddelta:=0;
      skippeddelta:=0;
      OrdIBSQL.ParamByname('lastcode').Asinteger:=Cache.GetConstItem(pcLastAddLoadWare).IntValue;
      OrdIBSQL.ExecQuery;
      if OrdIBSQL.EOF then break;
      if not GBIBInsertSQL.Transaction.Active then GBIBInsertSQL.Transaction.StartTransaction;
      while not OrdIBSQL.EOF do begin
        GBIBSelectSQL.ParamByname('PMWAWARECODE').Asinteger:=OrdIBSQL.FieldByName('LWAWARECODE').Asinteger;
        GBIBSelectSQL.ParamByname('PMWAWAREANALOGCODE').Asinteger:=OrdIBSQL.FieldByName('LWAANALOG').Asinteger;
        GBIBSelectSQL.ExecQuery;
        if GBIBSelectSQL.EOF then begin
          GBIBInsertSQL.ParamByname('PMWAWARECODE').Asinteger:=OrdIBSQL.FieldByName('LWAWARECODE').Asinteger;
          GBIBInsertSQL.ParamByname('PMWAWAREANALOGCODE').Asinteger:=OrdIBSQL.FieldByName('LWAANALOG').Asinteger;
          GBIBInsertSQL.ParamByname('PMWASOURCECODE').Asinteger:=Cache.FDCA.GetSourceGBcode(OrdIBSQL.FieldByName('LWASRCCODE').AsInteger);
          GBIBInsertSQL.ParamByname('PMWAISWRONG').AsString:=OrdIBSQL.FieldByName('LWAWRONG').AsString;
          GBIBInsertSQL.ParamByname('PMWAUSERCODE').Asinteger:=OrdIBSQL.FieldByName('LWAUSERID').Asinteger;
          GBIBInsertSQL.ParamByname('PMWALASTEDITDATE').AsDateTime:=OrdIBSQL.FieldByName('LWATIME').AsDateTime;
          GBIBInsertSQL.ExecQuery;
          Inc(addeddelta);
        end else begin
          Inc(skippeddelta);
        end;
        GBIBSelectSQL.Close;
        OrdIBSQL.Next;
      end;
      GBIBInsertSQL.Transaction.Commit;
      Cache.SaveNewConstValue(pcLastAddLoadWare, UserId, OrdIBSQL.FieldByName('LWACODE').AsString);
      OrdIBSQL.Close;
      added:=added+addeddelta;
      skipped:=skipped+skippeddelta;
      prStopProcess(UserID, ThreadData.ID);
      ImpCheck.SetProcessPercent(UserId,ThreadData.ID,(added+skipped)*100/total);
//break;
    end;
*)

  except
    on E: Exception do begin
      ErrorMessage:='Ошибка в процедуре '+nmProc+' '+ E.Message;
      prMessageLOGS(ErrorMessage, 'import', false) ;
    end;
  end;

  if (ErrorMessage='') then begin
    lstBodyMail.Add('Импорт односторонних аналогов прошел успешно.');
  end else begin
    lstBodyMail.Add('Импорт односторонних аналогов завершен с ошибкой '+ErrorMessage);
  end;
  lstBodyMail.Add('Импортировано '+IntToStr(added)+' аналогов.');
  lstBodyMail.Add('Пропущено '+IntToStr(skipped)+' аналогов.');
  lstBodyMail.Add('Время выполнения - '+FormatDateTime('hh:nn:ss.zzz', Now-StartTime));
  Subj:='Отчет 47 (импорт товаров в GrossBee) от '+FormatDateTime('dd.mm.yyyn hh:nn:ss', Now);
  try
    if not GetEmplTmpFilePath(UserID, PathFile, ErrorMessage) then raise EBOBError.Create(ErrorMessage);
    FName:= PathFile+fnFormRepFileName('47_', '.txt', ImpCheck.GetCheckKind(UserID, ThreadData.ID));
    lstBodyMail.SaveToFile(FName);
  finally
    SetLength(Analogs, 0);
    if ((GBIBSelectSQL<>nil) and GBIBSelectSQL.Transaction.Active) then GBIBSelectSQL.Transaction.Rollback;
    prFreeIBSQL(GBIBSelectSQL);
    prFreeIBSQL(GBIBInsertSQL);
    cntsGRB.SetFreeCnt(GBIBDatabase);
//    prFreeIBSQL(OrdIBSQL);
//    cntsORD.SetFreeCnt(OrdIBDatabase);
  end;

end; // fnRep47


procedure prNotificationPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prNotificationPage'; // имя процедуры/функции
var
  EmplID, i, j: integer;
  s: string;
  List: TStringList;
begin
  Stream.Position:= 0;
  try
    EmplID:= Stream.ReadInt;

    prSetThLogParams(ThreadData, 0, EmplID); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolNewsManage)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    List:=Cache.GetFirmTypesList();
    List.Sort;
    Stream.WriteStringList(List, true);
    prFree(List);

    List:=Cache.GetFirmClassesList();
    List.Sort;
    Stream.WriteStringList(List, true);
    prFree(List);

    List:=Cache.GetFilialList();
    List.Sort;
    Stream.WriteStringList(List, true);
    prFree(List);

    List:=TStringList.Create;
    for i:=Low(Cache.arFirmInfo) to High(Cache.arFirmInfo) do begin
      if (Cache.arFirmInfo[i]<>nil ) and (not Cache.arFirmInfo[i].Arhived) then begin
        List.AddObject(Cache.arFirmInfo[i].Name,Pointer(i));
      end;
    end;
    List.Sort;
    Stream.WriteInt(List.Count); // место под кол-во фирм
    for i:=0 to List.Count-1 do begin
      j:=integer(List.Objects[i]);
      Stream.WriteInt(j);
      Stream.WriteStr(Cache.arFirmInfo[j].UPPERSHORTNAME);
      Stream.WriteStr(Cache.arFirmInfo[j].Name);
    end;
    prFree(List);

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prNotificationPage


procedure prAEDNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prAEDNotification'; // имя процедуры/функции
var
  EmplID: integer;
  s: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;

  NotifyCode: integer;
  DateFrom, DateTo: double;
  NotifyText, ClientType, ClientCategory, ClientFilial, Firms: string;
  AddFlag, Auto, Moto: boolean;
begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    EmplID:=Stream.ReadInt;
    NotifyCode:=Stream.ReadInt;
    DateFrom:=Stream.ReadDouble;
    DateTo:=Stream.ReadDouble;
    NotifyText:=Stream.ReadStr;
    ClientType:=Stream.ReadStr;
    ClientCategory:=Stream.ReadStr;
    ClientFilial:=Stream.ReadStr;
    Firms:=Stream.ReadStr;
    AddFlag:=Stream.ReadBool;
    Auto:=Stream.ReadBool;
    Moto:=Stream.ReadBool;

    prSetThLogParams(ThreadData,0,EmplID,0,'NotifyCode='+IntToStr(NotifyCode)+#13#10); // логирование

    if (not (Auto or Moto)) then raise EBOBError.Create('Хотя бы один из признаков Auto или Moto должен быть задан');


    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolNewsManage)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite, true);

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    if NotifyCode<0 then begin
      OrdIBSQL.SQL.Text:='SELECT * FROM NOTIFIEDCLIENTS WHERE NOCLNOTE='+IntToStr(-NotifyCode);
      OrdIBSQL.ExecQuery;
      if OrdIBSQL.EOF then begin // если нет связок - удаляем
        OrdIBSQL.SQL.Text:='DELETE FROM NOTIFICATIONS WHERE NOTECODE='+IntToStr(-NotifyCode);
      end else begin  // если есть - в архив
        OrdIBSQL.SQL.Text:='UPDATE NOTIFICATIONS SET NOTEARCHIVED="T" WHERE NOTECODE='+IntToStr(-NotifyCode);
      end;
      OrdIBSQL.Close;
    end else begin
      if NotifyCode=0 then begin
        OrdIBSQL.SQL.Text:='INSERT INTO NOTIFICATIONS (NOTETEXT, NOTEBEGDATE, NOTEENDDATE, NOTEFILIALS, NOTECLASSES, NOTETYPES, '+
                          'NOTEFIRMS, NOTEUSERID, NOTEFIRMSADDFLAG, NOTEAUTO, NOTEMOTO) VALUES (:NOTETEXT, :NOTEBEGDATE, :NOTEENDDATE, :NOTEFILIALS, '+
                          ':NOTECLASSES, :NOTETYPES, :NOTEFIRMS, '+IntToStr(EmplID)+', :NOTEFIRMSADDFLAG, :NOTEAUTO, :NOTEMOTO) RETURNING NOTECODE';

      end else begin
        OrdIBSQL.SQL.Text:='UPDATE NOTIFICATIONS SET NOTETEXT=:NOTETEXT, NOTEBEGDATE=:NOTEBEGDATE, NOTEENDDATE=:NOTEENDDATE,'+
                          'NOTEFILIALS=:NOTEFILIALS, NOTECLASSES=:NOTECLASSES, NOTETYPES=:NOTETYPES, NOTEFIRMS=:NOTEFIRMS,'+
                          'NOTEUSERID='+IntToStr(EmplID)+', NOTEFIRMSADDFLAG=:NOTEFIRMSADDFLAG, NOTEAUTO=:NOTEAUTO, NOTEMOTO=:NOTEMOTO WHERE NOTECODE='+IntToStr(NotifyCode)+
                          ' RETURNING NOTECODE';
      end;
      OrdIBSQL.ParamByName('NOTETEXT').AsString:=NotifyText;
      OrdIBSQL.ParamByName('NOTEBEGDATE').AsDateTime:=DateFrom;
      OrdIBSQL.ParamByName('NOTEENDDATE').AsDateTime:=DateTo;
      OrdIBSQL.ParamByName('NOTEFILIALS').AsString:=ClientFilial;
      OrdIBSQL.ParamByName('NOTECLASSES').AsString:=ClientCategory;
      OrdIBSQL.ParamByName('NOTETYPES').AsString:= ClientType;
      OrdIBSQL.ParamByName('NOTEFIRMS').AsString:=Firms;
      OrdIBSQL.ParamByName('NOTEFIRMSADDFLAG').AsString:=fnIfStr(AddFlag, 'T', 'F');
      OrdIBSQL.ParamByName('NOTEAUTO').AsString:=fnIfStr(Auto, 'T', 'F');
      OrdIBSQL.ParamByName('NOTEMOTO').AsString:=fnIfStr(Moto, 'T', 'F');
      OrdIBSQL.Prepare;
    end;
    OrdIBSQL.ExecQuery;
    if (NotifyCode=0) then begin
      NotifyCode:=OrdIBSQL.FieldByName('NOTECODE').AsInteger;
    end;
    OrdIBSQL.Transaction.Commit;
    Stream.WriteInt(NotifyCode);

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prAEDNotification


procedure prShowNotification(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prShowNotification'; // имя процедуры/функции
var
  EmplID, i, NotifyCode: integer;
  s: string;
  List: TStringList;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
  firms: tai;

begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  List:=nil;
  SetLength(firms, 0);
  try
    EmplID:=Stream.ReadInt;
    NotifyCode:=Stream.ReadInt;

    prSetThLogParams(ThreadData,0,EmplID,0,'NotifyCode='+IntToStr(NotifyCode)+#13#10); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolNewsManage)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpWrite, true);

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    OrdIBSQL.SQL.Text:='SELECT * FROM NOTIFICATIONS WHERE NOTEARCHIVED="F" and NOTECODE='+IntToStr(NotifyCode);
    OrdIBSQL.ExecQuery;
    if OrdIBSQL.EOF then raise EBOBError.Create('Не найдено уведомление с кодом '+IntToStr(NotifyCode));

    Stream.WriteDouble(OrdIBSQL.FieldByName('NOTEBEGDATE').AsDateTime);
    Stream.WriteDouble(OrdIBSQL.FieldByName('NOTEENDDATE').AsDateTime);
    Stream.WriteStr(OrdIBSQL.FieldByName('NOTETEXT').AsString);
    Stream.WriteStr(OrdIBSQL.FieldByName('NOTETYPES').AsString);
    Stream.WriteStr(OrdIBSQL.FieldByName('NOTECLASSES').AsString);
    Stream.WriteStr(OrdIBSQL.FieldByName('NOTEFILIALS').AsString);
    Stream.WriteBool(OrdIBSQL.FieldByName('NOTEFIRMSADDFLAG').AsString='T');
    Stream.WriteBool(OrdIBSQL.FieldByName('NOTEAUTO').AsString='T');
    Stream.WriteBool(OrdIBSQL.FieldByName('NOTEMOTO').AsString='T');

    firms:=fnArrOfCodesFromString(OrdIBSQL.FieldByName('NOTEFIRMS').AsString);
    OrdIBSQL.Transaction.Commit;

    List:=TStringList.Create;
    for i:=0 to Length(firms)-1 do begin
      if not Cache.FirmExist(firms[i]) then continue;
      if Cache.arFirmInfo[firms[i]].Arhived then continue;
      List.AddObject(Cache.arFirmInfo[firms[i]].Name, Cache.arFirmInfo[firms[i]]);
    end;
    List.Sort;
    Stream.WriteInt(List.Count);
    for i:=0 to List.Count-1 do begin
      Stream.WriteInt(TFirmInfo(List.Objects[i]).ID);
      Stream.WriteStr(TFirmInfo(List.Objects[i]).UPPERSHORTNAME+'||'+List[i]);
    end;

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFree(List);
  SetLength(firms, 0);
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prShowNotification


procedure prCheckContracts(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prCheckContracts'; // имя процедуры/функции
var
  EmplID, FirmID, ContIdAsk, ContIdGet: integer;
  Contract: TContract;
  s: string;
begin
  Stream.Position:= 0;
  try
    EmplID:=Stream.ReadInt;
    FirmID:=Stream.ReadInt;
    ContIdAsk:=Stream.ReadInt;
    ContIdGet:=ContIdAsk;

    prSetThLogParams(ThreadData,0,EmplID,0,'FirmID='+IntToStr(FirmID)+#13#10); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolOPRSK)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    Contract:= Cache.arFirmInfo[FirmID].GetContract(ContIdGet);
    if (ContIdAsk<>0) and (ContIdGet<>0) then EBOBError.Create('Не найден контракт с кодом '+IntToStr(ContIdAsk));

    if ((Cache.arFirmInfo[FirmID].FirmContracts.Count>1) and (ContIdAsk=0)) then begin
      Stream.WriteInt(0);
      Stream.WriteInt(Cache.arFirmInfo[FirmID].FirmContracts.Count);
    end else begin
      Stream.WriteInt(ContIdGet);
      Stream.WriteInt(Cache.arFirmInfo[FirmID].FirmContracts.Count);
      Stream.WriteStr(Contract.Name);

      Stream.WriteDouble(Contract.CredLimit);
      Stream.WriteDouble(Contract.DebtSum);
      Stream.WriteDouble(Contract.OrderSum);
      Stream.WriteDouble(Contract.PlanOutSum);
      Stream.WriteInt(Contract.CredCurrency);
      Stream.WriteStr(Cache.GetCurrName(Contract.CredCurrency));
      Stream.WriteStr(Contract.WarnMessage);
      Stream.WriteBool(Contract.SaleBlocked);
      Stream.WriteInt(Contract.CredDelay);
      if not Contract.SaleBlocked then
        Stream.WriteInt(Contract.WhenBlocked); // если отгрузка не блокирована
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prCheckContracts



procedure prWebarmContractList(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prWebarmContractList'; // имя процедуры/функции
var
  EmplID, FirmID, i, ContId: integer;
  Contract: TContract;
  s: string;
  Firm: TFirmInfo;
begin
  Stream.Position:= 0;
  try
    EmplID:=Stream.ReadInt;
    FirmID:=Stream.ReadInt;

    prSetThLogParams(ThreadData,0,EmplID,0,'FirmID='+IntToStr(FirmID)+#13#10); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolOPRSK)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));
    if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));

    Firm:=Cache.arFirmInfo[FirmID];
    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);

    Stream.WriteInt(Firm.FirmContracts.Count);
    for i:=0 to Firm.FirmContracts.Count-1 do begin
      ContId:=Firm.FirmContracts[i];
      Contract:= Firm.GetContract(ContId);
      Stream.WriteInt(Contract.ID);
      Stream.WriteStr(Contract.Name);
      Stream.WriteStr(Contract.SysName);
      Stream.WriteDouble(Contract.CredLimit);
      Stream.WriteStr(Cache.GetCurrName(Contract.CredCurrency));
      Stream.WriteInt(Contract.CredDelay);
      Stream.WriteDouble(Contract.DebtSum);
      Stream.WriteBool(Contract.SaleBlocked);
      Stream.WriteStr(Contract.WarnMessage);
    end;



  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prWebarmContractList

procedure prManageLogotypesPage(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prManageLogotypesPage'; // имя процедуры/функции
var
  EmplID, i: integer;
  s: string;
  Brand: TBrandItem;
begin
  Stream.Position:= 0;
  try
    EmplID:=Stream.ReadInt;
    prSetThLogParams(ThreadData,0,EmplID,0,''); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolNewsManage)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    Stream.WriteInt(Cache.WareBrands.ItemsList.Count);
    for i:= 0 to Cache.WareBrands.ItemsList.Count-1 do begin
      Brand:= Cache.WareBrands.ItemsList[i];
      Stream.WriteInt(Brand.ID);
      Stream.WriteStr(Brand.Name);
      Stream.WriteStr(Brand.NameWWW);
      Stream.WriteStr(Brand.WarePrefix);
      Stream.WriteStr(Brand.adressWWW);
      Stream.WriteBool(Brand.DownLoadExclude);
    end;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prManageLogotypesPage

procedure prLogotypeEdit(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLogotypeEdit'; // имя процедуры/функции
var
  EmplID, BrandID: integer;
  s: string;
//  Firm: TFirmInfo;
  NameWWW, Prefix, AdressWWW: string;
  DownLoadExclude: boolean;
begin
  Stream.Position:= 0;
  try
    EmplID:=Stream.ReadInt;

    prSetThLogParams(ThreadData,0,EmplID,0,''); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolNewsManage)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    BrandID:=Stream.ReadInt;
    NameWWW:=Stream.ReadStr;
    Prefix:=Stream.ReadStr;
    AdressWWW:=Stream.ReadStr;
    DownLoadExclude:=Stream.ReadBool;

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    Cache.CheckBrandAdditionData(BrandID, EmplID, NameWWW, Prefix, AdressWWW, DownLoadExclude);

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; //prLogotypeEdit


procedure prLoadOrder(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLoadOrder'; // имя процедуры/функции
var
  EmplID, fid, cid, Pos, Count: integer;
  s, ORDRNUM: string;
  OrdIBDatabase: TIBDatabase;
  OrdIBSQL: TIBSQL;
  Firm: TFirmInfo;
  Contract: TContract;
  Ware: TWareInfo;

begin
  Stream.Position:= 0;
  ORDIBDatabase:=nil;
  OrdIBSQL:= nil;
  try
    EmplID:=Stream.ReadInt;
    ORDRNUM:=UpperCase(Stream.ReadStr);

    prSetThLogParams(ThreadData,0,EmplID,0,''); // логирование

    if CheckNotValidUser(EmplID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    if not (Cache.arEmplInfo[EmplId].UserRoleExists(rolOPRSK)) then
        raise EBOBError.Create(MessText(mtkNotRightExists));

    OrdIBDatabase:=CntsOrd.GetFreeCnt();
    OrdIBSQL:=fnCreateNewIBSQL(OrdIBDatabase,'OrdIBQuery_'+nmProc,ThreadData.ID, tpRead, true);

    OrdIBSQL.SQL.Text:='SELECT * FROM ORDERSREESTR WHERE ORDRNUM=:ORDRNUM and ORDRSTATUS>'+IntToStr(orstForming);
    OrdIBSQL.ParamByName('ORDRNUM').AsString:=ORDRNUM;
    OrdIBSQL.ExecQuery;
    if OrdIBSQL.EOF then raise EBOBError.Create('Не найден заказ с указанным номером');

    fid:= OrdIBSQL.FieldByName('ORDRFIRM').AsInteger;  // проверяем к/а
    if not Cache.FirmExist(fid) or not Cache.CheckEmplVisFirm(EmplID, fid) then raise EBOBError.Create('Не найден или недоступен контрагент заказа');
    Firm:=CAche.arFirmInfo[fid];
    cid:=OrdIBSQL.FieldByName('ORDRCONTRACT').AsInteger;
    Contract:= Firm.GetContract(cid);

    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess);
    Stream.WriteStr(OrdIBSQL.FieldByName('ORDRNUM').AsString);
    Stream.WriteStr(FormatDateTime('dd.mm.yyyy', OrdIBSQL.FieldByName('ORDRDATE').AsDate));
    Stream.WriteStr(arOrderStatusNames[OrdIBSQL.FieldByName('ORDRSTATUS').AsInteger]);
    Stream.WriteStr(Firm.Name+' ('+Firm.UPPERSHORTNAME+')');
    Stream.WriteStr(fnIfStr(OrdIBSQL.FieldByName('ORDRACCOUNTINGTYPE').AsInteger=0, 'нал', 'безнал'));
    Stream.WriteStr(fnIfStr(OrdIBSQL.FieldByName('ORDRDELIVERYTYPE').AsInteger=0, 'Стандартная доставка', 'Резервировать товар'));
    Stream.WriteStr(OrdIBSQL.FieldByName('ORDRSTORAGECOMMENT').AsString);
    Stream.WriteStr(Cache.arCurrShortNames[OrdIBSQL.FieldByName('ORDRCURRENCY').AsInteger]);
    Stream.WriteStr(Contract.Name);

    Pos:=Stream.Position;
    Count:=0;
    Stream.WriteInt(0); // заглушка под колво

    OrdIBSQL.Close;
    OrdIBSQL.SQL.Text:='SELECT * FROM ORDERSLINES WHERE ORDRLNORDER='+OrdIBSQL.FieldByName('ORDRCODE').AsString+'';
    OrdIBSQL.ExecQuery;

    while not OrdIBSQL.EOF do begin
      Ware:=Cache.GetWare(OrdIBSQL.FieldByName('ORDRLNWARE').AsInteger);
      Stream.WriteStr(Ware.Name);
      Stream.WriteStr(Ware.MeasName);
      Stream.WriteDouble(OrdIBSQL.FieldByName('ORDRLNCLIENTQTY').AsFloat);
      Stream.WriteDouble(OrdIBSQL.FieldByName('ORDRLNPRICE').AsFloat);

      Inc(Count);
      OrdIBSQL.Next;
    end;
    Stream.Position:=Pos;
    Stream.WriteInt(Count);
    OrdIBSQL.Close;

  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBSQL);
  cntsORD.SetFreeCnt(OrdIBDatabase);
end; //prLoadOrder


//================================================= поиск ламп по напряжению и цоколю
procedure prLampSelect(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prLampSelect'; // имя процедуры/функции
var Template, s, InnerErrorPos: string;
    UserId, FirmID, i, iWare, contID: integer;
//    PriceInUah,
    fl: boolean;
    arAnalogs: Tai;
    ware: TWareInfo;
    Wares: TStringList;
begin
  Stream.Position:= 0;
//  FirmSys:= 0;
  try
InnerErrorPos:='0';
    UserId:= Stream.ReadInt;
    FirmId:= Stream.ReadInt;
    ContID:= Stream.ReadInt;
//    PriceInUah:=
    Stream.ReadBool;
    Template:= Stream.ReadStr;
    Wares:=TStringList.Create;

    Template:= trim(Template);
    if Length(Template)<1 then raise EBOBError.Create('Не задан шаблон поиска');

    prSetThLogParams(ThreadData, 0, UserID, FirmID, 'Template='+Template+
      #13#10+'ContID='+IntToStr(ContID));

    s:= AnsiUpperCase(Template);
    for iWare:= 1 to High(Cache.arWareInfo) do begin
      if not Cache.WareExist(iWare) then Continue;
      ware:= Cache.GetWare(iWare, True);
      if (ware=NoWare) or ware.IsArchive or (ware.PgrID<1) then Continue; // отсев по архивности
      if (ware.PgrID=Cache.pgrDeliv) then Continue;                       // пропускаем доставки
      //-------------------------------------------------- отсев по ключу поиска
      fl:=pos(s, ware.CommentUP )>0;
      if not fl then Continue;

      SetLength(arAnalogs, 0);
      arAnalogs:= fnGetAllAnalogs(iWare, -1);
      //------------------------------------- отсев по наличию цены или аналогов или сопут.товаров
      if not fnNotZero(ware.RetailPrice)
        and (Length(arAnalogs)<1) and not ware.SatelliteExists(0) then Continue;


      if Wares.Capacity=Wares.Count then Wares.Capacity:= Wares.Count+100;
      Wares.AddObject(Ware.Name, pointer(Ware.ID));

    end;
    if Wares.Count>1 then Wares.Sort;
    Stream.WriteInt(Wares.Count);   // Передаем товары
    for i:=0 to Wares.Count-1 do begin
//      prSaveShortWareInfoToStream(Stream, WareAndAnalogs.WareID, FirmId, UserId, 0, currID, ForFirmID, arlen1, contID);

    end;


  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do
      prSaveCommonError(Stream, ThreadData, nmProc, E.Message, 'InnerErrorPos='+InnerErrorPos, False);
  end;
  Stream.Position:= 0;
  prFree(Wares);
end; //prLampSelect

end.


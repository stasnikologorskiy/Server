unit n_server_common; // общие функции

interface
uses Windows, Classes, SysUtils, IniFiles, System.DateUtils, Math, DB, Forms, Contnrs,
     IBDatabase, IBSQL, IdSMTP, IdMessage, IdAttachmentFile, IdCharsets, IdText,
     Controls, IdGlobal, IdContext, IdTCPServer, ShellAPI, Types,
     n_free_functions, v_constants, v_DataTrans, v_Functions, n_DataCacheObjects,
     n_constants, n_functions, n_DataSetsManager, n_LogThreads, n_DataCacheAddition;

type
//------------------------------------------------------------ vc
  TMyClass = class
    procedure ServerExecute(AContext: TIdContext);
    procedure ServerWEBConnect(AContext: TIdContext);
    procedure ServerWEBArmConnect(AContext: TIdContext);
    procedure ServerManageConnect(AContext: TIdContext);
  public
  end;
//------------------------------------------------------------ vc

  TVSMail = class // Vladislav Software Mail
  public
    Xstring: String;
    constructor Create;
    procedure CheckXstring(section: String=''; value: String='');
    procedure OnInitISO(var VHeaderEncoding: Char; var VCharSet: String);
  end;

  //----------------------------------------------------------
  TSearchWareOrOnum = class // рез-т поиска: код товара/ОН, аналоги, сопут.товары
  public
    ID, RestSem, SatCount: Integer; // код товара/ОН, семафор наличия, кол-во сопут.товаров
    IsWare: Boolean;      // признак товара
    AddComment, SemTitle : String; //условия применимости, подсказка к семафору (пока только к 3)
    OLAnalogs: TObjectList; // (TTwoCodes - ID, sem) аналоги, сопут.товары
    constructor Create(pID, pSatCount: Integer; pIsWare, pIsMarket: Boolean; parAnalogs: Tai=nil);
    destructor Destroy; override;
  end;

  //----------------------------------------------------------
  TForFirmParams = class
  public
    FirmID, UserID, ForFirmID, currID, contID, StoreMain: integer;
    rate: double;
    arSys, StoreCodes: Tai; // коды систем учета, коды доступных складов контракта
    ForClient, HideZeroRests: Boolean;
    constructor Create(pFirmID, pUserID: Integer; pForFirmID: Integer=0;
                       pCurrID: Integer=0; pContID: Integer=0);
    destructor Destroy; override;
    procedure FillStores;
    function NeedSemafores: Boolean;
  end;

  //----------------------------------------------------------
  TFirmPhoneParams = class
  public
    Names: String;
    arSMSind: Tai; //
    constructor Create(pNames: String; pSMScount: Integer);
    destructor Destroy; override;
  end;

//--------------------- для вывода остатков по колонкам пополнения
  TWareRestsByArrive = Class
  public
    arWares: Tai;             // 0- код товара, 1... - коды аналогов
    Storages: TaSD;           // набор колонок (складов)
//    WareTotals: TDoubleDynArray; //
    WareTotal: Double; // кол-во товара по всем складам
    arRestLists: TASL; // строковые остатки по пополнениям
    constructor Create;
    destructor Destroy; override;
  end;

var
  VSMail: TVSMail;
  nmIniFileBOB, cNoReplayEmail, cFictiveEmail: string;  // , TodayFillDprts
  RepeatSaveInterval: Integer; // интервал задержки попыток записи в мсек
  RepeatStopInterval: Integer; // интервал задержки ожидания остановки в сек
  accRepeatCount    : Integer; // кол-во попыток посадки счета
  SleepFillLinksInt : Integer; // интервал задержки заполнения связок
  FormingOrdersLimit: Integer; // лимит строк в списке незакрытых заказов
  OrderListLimit: Integer;     // лимит строк в списке заказов
  LimitShowAnalogs: Integer;   // лимит товаров по наличиею для показа аналогов (5)
  SaveToLog: set of Byte;      // набор видов записи в LOG
  flCSSnew, flDebug, flTest, flTestDocs, flMargins, flmyDebug, flSkipTestWares,
    flTmpRecodeCSS, flTmpRecodeORD, flTmpRecodeGRB, flWareForSearch, // flNewComplMode,
    flLogTestWares, flLogTestClients, flShowWareByState, flCheckLimits, flTradePoint,
    flContCurrPrice, flBonusAttr, flShowAttrImage, flNewModeCGI, flMeetPerson,
    flNewSaveAcc, flDisableOut, flNotReserve, flCredProfile, flNewBonusFilter,
    flSpecRestSem, flMotulTree, flOrderImport, flNewRestCols, flPictNotShow,flNewOrdersMode,flGetExcelWareList: boolean;

  PhoneSupport: String; // телефон службы поддержки
  CheckDocsList: TStringList;
  dLastCheckDocTime, dLastCheckCliEmails: TDateTime;
  brcWebDelim, brcWebBoldBlackBegin, brcWebBoldEnd,
    brcWebColorRedBegin, brcWebColorBlueBegin, brcWebColorEnd: string;
//  brcWebItalBegin, brcWebItalEnd: string;
//------------------------------------------------------------ vc
  AppStatus: integer; //Статус приложения
  StopList: Tas;
  ManageCommandsLock: boolean = false;
  GBWork: boolean; // признаки работоспособности GB
  thCheckStoppedOrders: TThread;
  thCheckDBConnectThread: TThread;
  thManageThread: TThread;

  thCheckSMSThread: TThread;
  thControlPayThread: TThread;
  thControlSMSThread: TThread;

  ServerWeb, ServerWebArm, ServerManage: TIDTCPServer;
  MyClass: TMyClass;
  ImageList: TImageList;
  DescrDir: string; // папка, родительская для рисунков и описаний
  DirFileErr: String; // папка д/сбойных и врем. файлов

 function fnGetNumOrder(Prefix, NumOrd: String; Source: Integer=5): String; // формируем номер заказа для сервера
 function fnCheckOrderWebLogin(S: string): boolean;
 function fnCheckOrderWebPassword(S: string): boolean;
 function fnGenWebPass: string;  // Генерирует пароль
 function fnGetThreadsCount(Server: TIdTCPServer): integer;
procedure SetAppCaption;                 // заголовок формы
 function GetAppImageList: TImageList;   // иконка
procedure SetAppStatus(Status: integer); // устанавливает атрибутику статусов приложения
 function fnWareCompareByBrand(List: TStringList; Index1, Index2: Integer): Integer; // сортировка товаров в StringList с учетом бренда
 function fnGetWareListByBrand(Brand: integer; Sys: byte = 255; Sort: boolean = false): TStringList; // получить товары по заданному бренду
 function fnGetAdaptedConstValue(ConstID: integer): string; // выдает значение системной настройки, адаптированное под вывод пользователю
 function CheckShipmentDateTime(Data: TDate; TimeCode: integer): boolean; // проверяет, просрочено ли время доставки
 function TypeNamesSortCompare(List: TStringList; Index1, Index2: Integer): Integer; // сортировка списка типов товаров в результатах поиска
 function SortCompareManufNamesForTwoCodes(Item1, Item2: Pointer): Integer; // сортировка объектов типа TTwoCodes в TObjectList при выводе списка производителей авто/мото
 function SortCompareConditionPortions(Item1, Item2: Pointer): Integer; // сортировка StringList в TObjectList при выводе порций условий применимости
//------------------------------------------------------------ vc
//----------------------------------------- v_CSSServerManageProcs
procedure prGetFullStatus(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prExecuteServerCommand(Stream: TBoBMemoryStream; ThreadData: TThreadData; ACommand: integer; AIP: string);
procedure prUpdateCacheSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetActionsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetActionIconsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData); // сформировать иконки акций
procedure prGetMediaBloksSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);  // сформировать файлы медиа-блоков
//----------------------------------------- v_CSSServerManageProcs

//                    функции по работе с заказами и т.п.
 function fnGetClosingDocsOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
          var Status: integer; id: Integer=-1): string; // Уточняет статус заказа и возвращает данные по закрывающим документам (Grossbee/Order)
 function fnGetClosingDocsFromOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
          var Status: integer; id: Integer=-1): string; // Уточняет статус заказа и возвращает данные по закрывающим документам из Order
//procedure prOrderToGBn_Ord(Stream: TBoBMemoryStream; ThreadData: TThreadData; CreateMail: boolean=false); // сформировать счета в Grossbee
 function fnOrderToGB(OrderID: Integer; flCheckShipParams, CreateMail: Boolean; // записать товары в счет Grossbee с объединением счетов
          var WaresErrMess: String; ThreadData: TThreadData): Integer;
 function GetRateCurr(crnc: Integer=cDefCurrency; crncTo: Integer=1): Double; // получить текущий курс валюты (def - EUR->UAH)
 function fnNotLockingLogin(Login: String): Boolean;                          // проверяем, не относится ли логин к запрещенным

procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;               // запись в Stream инфо о товаре
          WareID, FirmID, UserID: integer; AnalogsCount: integer=0;
          currID: Integer=0; ForFirmID: integer=0; SatellsCount: integer=0;
          contID: integer=0; RestSem: integer=-1; RestTitle: String=''; ModelsEx: Boolean=True); overload;
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;              // запись в Stream инфо о товаре
          ffp: TForFirmParams; WareID: integer; AnalogsCount: integer=0;
          SatellsCount: integer=0; RestSem: integer=-1; RestTitle: String=''; ModelsEx: Boolean=True); overload;
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; ffp: TForFirmParams; wCodes: Tai); // запись в Stream блока семафоров наличия товаров (вызов только в Web)
 function fnGetContMainStoreAndStoreCodes(FirmID, ContID: Integer; var StorageCodes: Tai): Integer; // получить коды складов контракта и код главного склада
procedure prCheckWareRestsExists(ffp: TForFirmParams; var OLmarkets: TObjectList; var RestCount: Integer);

 function GetContWareRestsByCols(wareID, ContID, StorageCount: Integer): TDoubleDynArray; // остатки товара для контракта по колонкам (сегодня, завтра, >1 дня)
 function GetContWareRestsSem(wareID: Integer; ffp: TForFirmParams; var sArrive: String): Integer;

procedure prSaveEmplFirmsChoiceList(Stream: TBoBMemoryStream; EmplID: Integer);             // запись в Stream списка видимых сотруднику к/а для выбора (WebArm)
procedure prSaveEmplStoresChoiceList(Stream: TBoBMemoryStream; EmplID: Integer; flWithRoad: Boolean=False); // запись в Stream списка видимых сотруднику складов(+путей) для выбора (WebArm)

procedure CheckDocSum;                                                        // проверка сумм док-тов
procedure CheckClientsEmails;                                                 // проверка адресов

procedure prHideTreeNodes(var ListNodes, listParCodes: TList; flOnlySameName, flOnlyOneLevel: boolean); // свернуть ноды дерева узлов с 1 ребенком, в TreeList[i] - Pointer(TSecondLink)
 function fnRepClientRequests(UserID: integer; StartTime, EndTime: TDateTime; var FName: string): string; // формирование отчета по запросам клиента за период
 function SaveClientBlockType(BlockType, UserID: Integer;                     // блокировка/разблокировка клиента в базе
          var BlockTime: TDateTime; EmplID: Integer=0): Boolean;
// function SetSemMarkForClients(pSysID: Integer; SemMark: String='T'): String; // простановка признака WareSemafor всем клиентам системы

 function GetModelNodeWareUsesAndTextsPartsView(ModelID, NodeID, WareID: Integer): TObjectList; // must Free, список порций текстов и условий к связке 3 для просмотра
 function SetUsageTextPartWrongMark(pModelID, pNodeID, pWareID, pPart, // установить/убрать признак WRONG порции условий и текстов
          pUserID: Integer; flWrong: Boolean): String;
//function CheckTextFirstUpAndSpaces(txt: String): String; // проверка заглавной буквы и пробелов текста

//                       функции сообщений
 function fnGetManagerMail(code: Integer; Mailelse: String): String; // Email филиала
 function fnGetSysAdresVlad(kind: integer=caeOnlyDay): string;       // адреса для сист.сообщений
 function GetMessageFromSelf: String;                                // строка "сообщение от" CSS-сервера
 function n_SysMailSend(ToAdres, Subj: String; Body: TStrings=nil; Attachments: TStrings=nil;
          From: string =''; nmIniFile: string =''; flSaveToFile: boolean=False): string; // отправить системное сообщение
procedure TestOldErrMailFiles;                                                           // проверка незабранных файлов отчетов
 function MessText(kind: TMessTextKind; str: string=''): String;                         // текст сообщения пользователю
 function CutEMess(Emess: String): String;  overload;                                    // обрезка сообщений от exception ORD
 function CutEMess(Emess: String; var ResCode: Integer): String;  overload;              // обрезка сообщений от exception ORD + resDoNothing
 function CutLockMess(mess: String): String;                                             // обрезка сообщений deadlock и т.п.
 function CutPRSmess(mess: String): String;                                              // обрезать сообщение PRS.
 function fnFormRepFileName(pSubName, pNameOrExt: string; pOpKind: integer): string;     // формируем имя файла отчета
 function fnSendErrorMes(FirmID, UserID, MesType, WareId, AnalogId, OrNumId, ModelId, NodeId: Integer;
          SenderMess, AttrMess: String; ThreadData: TThreadData): String;      // отправляет сообщение пользователя об ошибке, Exception передает наружу, возвращает сообщение для пользователя
// function fnSendClientMes(FirmID, UserID, Source: Integer; SenderMess: String; // отправляет сообщение пользователя менеджеру
//          ThreadData: TThreadData; var Response: String; ContID: Integer=0): Boolean;
 function prSendMailWithClientPassw(Kind: TKindCliMail; Login, Password, Mail: String; // отправить письмо с паролем клиенту
          ThreadData: TThreadData; FirmName: String=''; lst: TStringList=nil): string;
//              функции отправки сообщений из файлов
 function fnSaveMailStringsToFile(ToAdres, Subj, From: String;
          Body, Attachments: TStrings; var FileName: String): Boolean; // запись набора строк письма в файл
 function fnGetMailFilesPath: String;                                  // путь к файлам писем
 function fnGetErrMailFilesDir: String;                                // папка с неотправленными файлами
 function fnGetLockFileName(FileName: String): String;                 // имя файла блокировки
 function ExtractFictiveEmail(emails: String): String; overload;           // исключение фиктивного адреса из строки
 function ExtractFictiveEmail(emails: TStringList): TStringList; overload; // must Free, исключение фиктивного адреса из списка

//              функции проверок
 function CheckNotValidUser(pUserID, pFirmID: Integer; var errmess: string): boolean;     // Проверить валидность пользователя
// function CheckNotValidFirmSys(FirmID, SysID: Integer; var errmess: string): boolean;     // Проверить систему фирмы
 function CheckNotValidModelManage(UserID, SysID: Integer; var errmess: string): boolean; // Проверить права сотрудника на работу с моделями системы
 function CheckNotValidTNAManage(UserID, SysID: Integer; var errmess: string): boolean;   // Проверить права сотрудника на работу с деревом узлов системы
 function CheckNotValidManuf(ManufID: Integer; SysID: Integer;             // Получить производителя и проверить доступность
          var Manuf: TManufacturer; var errmess: string): boolean;
 function CheckNotValidModelLine(ModelLineID: Integer; var SysID: Integer; // Получить модельный ряд, систему и проверить доступность
          var ModelLine: TModelLine; var errmess: string): boolean;
 function CheckNotValidModel(ModelID: Integer; var SysID: Integer;          // Получить модель, систему и проверить доступность
          var Model: TModelAuto; var errmess: string): boolean;
procedure TestCssStopException;         // проверка для остановки длит.процесса при остановке системы
 function SetLongProcessFlag(cdlpKind: Integer; NotCheck: Boolean=False): Boolean; // установить флаг длительного процесса (тестирования кеша и т.п)
 function SetNotLongProcessFlag(cdlpKind: Integer): Boolean; // снять флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
//procedure prCheckUserForFirmAndGetSysCurr(UserID, FirmID: Integer; // проверить UserID, FirmID, ForFirmID и получить систему, валюту
//          var ForFirmID, Sys, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);
procedure prCheckUserForFirmAndGetCurr(UserID, FirmID: Integer; // проверить UserID, FirmID, ForFirmID и получить валюту
          var ForFirmID, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);
 function CheckMobileNumber(num: String): Boolean;   // проверка номера мобильного телефона
 function CheckClientFIO(CliName: String): String;   // проверка соответствия ФИО пользователя шаблону
 function CheckFirmFilterConditions(FirmID: Integer; // проверка соответствия к/а условиям фильтрации (Web & WebArm)
          flFirmsAdd, flAuto, flMoto: Boolean; Filials, Classes, Types, Firms: TIntegerList): Boolean;

//              функции для спец.процессов
procedure CheckGAMainNodesLinks(LogFile: String='');                            // сверка TD->GA и TreeNodesAuto->MainNode
procedure CheckArticleWareMarks(LogFile: String=''; maxStrLen: Integer = 3000); // проверить наличие товаров у артикулов в TDT
procedure TestLastFirms(DecHour: Integer=1);                                    // проверка фирм, активных последние DecHour часов
procedure TestLogFirmNames;                                                     // проверка наименований фирм в базе логирования
procedure CheckClosingDocsAll(CompareTime: boolean=True);                       // пакетная проверка закрывающие док-тов заказов
//procedure CheckClosingDocsByPeriod(tbegin, tend: TDateTime;                     // проверка закрывающие док-тов заказов за период изменений
//          flSaveTime: boolean=True; flalter: boolean=True);
procedure CheckClosingDocsByPeriod_new(tbegin, tend: TDateTime; flSaveTime: boolean=True); // проверка закрывающие док-тов заказов за период изменений
procedure CheckWorkLogins(userID: Integer; Login: String);                      // проверка логина в списке поиска логинов
procedure CheckClonedOrBlockedClients(LogFile: String='');                      // проверка клонов/блоков клиентов
//procedure FillOrdersClosingDocs(FirstRecs: Integer=0); // заполнить таблицу закр.док-тов и проставить коды заказов закр.док-там
//procedure TestFile;
procedure TmpRecodeCSS;   // фоновая перкодировка в базе логирования
procedure TmpCheckRecode; // регулярная проверка в базе логирования, запускается при старте в Webarm
procedure TmpRecodeORD;   // фоновая перекодировка в базе ORD
procedure TmpRecodeGRB;   // фоновая перекодировка/чистка таблиц в базе Grossbee

//             разные функции
 function ToLog(vid: Integer): Boolean; // признак записи в LOG в зав-ти от вида
procedure GetLogKinds;                  // виды логирования
 function RepeatExecuteIBSQL(IBS: TIBSQL; repeats: Integer=RepeatCount): string; overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var StrValue: string; repeats: Integer=RepeatCount): string; overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var IntValue: Integer; repeats: Integer=RepeatCount): string; overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; var FnamesValues: Tas; repeats: Integer=RepeatCount): string;  overload;
 function GetEmplTmpFilePath(EmplID: Integer; var pFilePath, errmess: string): boolean;  // путь к рабочим файлам сотрудника
 function GetBoolGB(ibsql: TIBSQL; Fname: string): boolean;                              // Перевести значение поля Fname ibsql в boolean
 function GetLstPrefixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // Формирование списка префиксов для доавления к артикулу при поиске
 function GetLstSufixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList;  // Формирование списка префиксов для доавления к артикулу при поиске, not Object
 function ObjWareNameSortCompare(List: TStringList; Index1, Index2: Integer): Integer; // сортировка TStringList по наименованию товара, если ID в Objects
 function fnGetActionTimeEnable(kind: integer=caeOnlyDay): Boolean;           // допустимое время для операций
procedure prSaveCommonError(Stream: TBoBMemoryStream; ThreadData: TThreadData; // запись в Stream сообщения об ошибке
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
procedure prSaveCommonErrorStr(var errStr:String; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);  //запись в строку сообщения об ошибке
 function RenameErrFile(nf, dirold, dirnew: string; flPutOff: Boolean=False): string; // перемещаем файл nf из dirold в dirnew
procedure CheckStopExecute(pUserID: Integer; ThreadData: TThreadData); // проверка остановки процесса или системы
procedure SetExecutePercent(pUserID: Integer; ThreadData: TThreadData; Percent: Double); // отображение процентов выполнения
 function GetMobileNumber10(num: String): String;  // номер мобильного телефона без +38
 function GetYearFromLoadModels: String;
 function SetMainUserToGB(FirmID, UserID: Integer; pDate: TDateTime; ibsGBw: TIBSQL=nil): String; // запись глав.пользователя в Grossbee

//             функции поиска
 function SearchWareNames(Template: string; IgnoreSpec: Integer=0; // must Free, поиск товаров по наименованию (описанию) в кэше
          ManagID: Integer=-1; ByComments: boolean=False): Tai;
 function fnGetAllAnalogs(WareID: integer; ManufID: integer=-1): Tai; // must Free, возвращает массив кодов всех аналогов товара WareID
 function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer=0; // must Free, поиск товаров (с типами и аналогами) по наименованию в кэше
          ManagID: Integer=-1; ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
          flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList;

 function SearchWaresTypesAnalogs_new(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer; // must Free, поиск товаров (с типами и аналогами) по наименованию в кэше
          ByComments, flSale, flCutPrice, flSemafores: boolean; ffp: TForFirmParams): TObjectList;
 function SearchWareOrigNums_new(Template: String; IgnoreSpec: Integer; // must Free, Поиск оригинального номера по вхождению
          var TypeCodes: Tai; flSemafores: boolean; ffp: TForFirmParams): TObjectList;

//              функции для доставок
 function GetAvailableSelfGetTimesList(DprtID: Integer; pDate: TDateTime;                     // список доступных времен самовывоза по складу, дате
          var stID: Integer; var SL: TStringList; flWithSVKDelay: Boolean=False): String;
 function GetAvailableShipDatesList(DprtID, iDate: Integer; var SL: TStringList): String;     // список доступных дат отгрузки по складу
// function GetAvailableShipDatesList(DprtID, iDate: Integer;                                   // список доступных дат отгрузки по складу
//         var SL: TStringList; flWithSVKDelay: Boolean=False): String;
 function CheckAccountShipParams(delivType, ContID, DprtID: Integer; var pShipDate: TDateTime; // проверка параметров отгрузки для счета
          var DestID, ttID, smID, stID: Integer; WithSVKDelay: Boolean): String;
 function fnGetShipParamsView(contID, DprtID, DestID, ShipTableID: Integer; ShipDate: double; // параметры отгрузки для просмотра
          var DelivType, ShipMetID, ShipTimeID: Integer; var sDestName, sDestAdr, sArrive: String;
          var sShipMet, sShipTime, sView: String; GBdirection: Boolean=False): String;
//==================================== проверяем возможность поставки на сегодня
//===== есть - возвращает текст для подсказки времени доступности (спец.семафор)
 function CheckDprtTodayFill(dprtID: Integer; RestList: TObjectList): String;
 function GetDprtWareRestsByArrive(dprtID: Integer; WareQty: Double; // колонки остатков по прибытию
                                   var wrba: TWareRestsByArrive): String;

//******************************************************************************
implementation
uses n_IBCntsPool, n_DataCacheInMemory,
     t_ImportChecking, t_WebArmProcedures, n_WebArmProcedures,
     n_server_main, n_CSSservice, n_OnlinePocedures, n_CSSThreads,
     s_OnlineProcedures, s_WebArmProcedures;

//----------------------------------------- vc
//============================================================
function fnGetThreadsCount(Server: TIdTCPServer): integer;
var aList: TList;
begin
  aList:= Server.Contexts.LockList;
  try
    Result:= aList.Count;
  except
    Result:= 0;
  end;
  Server.Contexts.UnlockList;
end;
//=========================================== формируем номер заказа для сервера
function fnGetNumOrder(Prefix, NumOrd: String; Source: Integer=5): String;
// FirmCod - код фирмы, NumOrd - № заказа клиента, Source - источник (по умолчанию: 5-Vlad)
var s: String;
begin
  if pos('_',NumOrd)>0 then begin
    Result:= NumOrd;
    Exit;
  end;
  case Source of
    5: s:= '_V_'; // разделитель для Автомат.заказа через программу "vlad"
    6: s:= '_W_'; // разделитель для Автомат.заказа через Интернет
  else s:= '_';   // разделитель для других источников
  end; // case
  Result:= Prefix+s+NumOrd; // номер заказа: FirmShortName(FirmCod)_V(Source)_NumOrd
end;
//================= проверяет валидность логина Web-пользователя системы заказов
function fnCheckOrderWebLogin(S: string): boolean;
var i, j: integer;
    c:  Char;
begin
  Result:= false;
  j:= Length(s);
  if (j<5) or (j>Cache.CliLoginLength) then exit;
  for i:= 1 to j do begin
    c:= s[i];
    if not (SysUtils.CharInSet(c, ['a'..'z', 'A'..'Z', '0'..'9', '_'])) then exit;
  end;
  Result:= true;
end;
//================= проверяет валидность пароля Web-пользователя системы заказов
function fnCheckOrderWebPassword(S: string): boolean;
var i, j: integer;
    c:  Char;
begin
  Result:= false;
  j:= Length(s);
  if (j<5) or (j>Cache.CliPasswLength) then exit;
  for i:= 1 to j do begin
    c:= s[i];
    if not (SysUtils.CharInSet(c, ['a'..'z', 'A'..'Z', '0'..'9', '_'])) then exit;
  end;
  Result:= true;
end;
//============================================================ Генерирует пароль
function fnGenWebPass: string;
var len: integer;
    c: char;
begin
  Result:= '';
  Randomize;
  len:= 5+Random(4);
  while Length(Result)<(len+1) do begin
    c:= char(48+Random(123-48));
    if (SysUtils.CharInSet(c, ['a'..'z', '0'..'9'])) then Result:= Result+c;
  end;
end;
//========================================================= определяем ImageList
function GetAppImageList: TImageList;
var i: integer;
    nImageList: string;
begin
  Result:= Form1.ilDefault;                 // читаем имя ImageList из ini-файла
  nImageList:= GetIniParam(nmIniFileBOB,'service','ImageList','');
  if nImageList='' then Exit;
  for i:= 0 to Form1.ComponentCount-1 do
    if (Form1.Components[i] is TImageList) and
      (Form1.Components[i].Name=nImageList) then begin
      Result:= (Form1.Components[i] as TImageList);
      Exit;
    end;
end;
//============================================================== заголовок формы
procedure SetAppCaption;
begin
  Form1.lbAliases.Caption:= 'CSS-server,  GrossBee: '+cntsGRB.dbPath;
end;
//================================= устанавливает атрибутику статусов приложения
procedure SetAppStatus(Status: integer);
begin
  AppStatus:= Status;
  Form1.Caption:= Application.Title+': '+
    fnIfStr(IsServiceCSS, 'Служба ', 'Приложение ')+arCSSServerStatusNames[Status];
  if not IsServiceCSS and (Form1.Caption[length(Form1.Caption)]='а') then
    Form1.Caption:= Copy(Form1.Caption, 1, length(Form1.Caption)-1)+'о';
  ImageList.GetIcon(AppStatus,Application.Icon); // меняем Application.Icon
  Form1.btSuspend.Enabled:= (AppStatus=stWork);
  Form1.btResume.Enabled:= (AppStatus=stSuspended);
  Form1.bbFillarWares.Enabled:= (AppStatus=stWork);
  if not IsServiceCSS and fIconExist then begin
    SetTrayIconData;
    Shell_NotifyIcon(NIM_MODIFY, @TrayIconData);
    Application.ProcessMessages;
  end;
end;
//==========================================================  TMyClass
procedure TMyClass.ServerExecute(AContext: TIdContext);
begin
;
end;
//==============================================================================
procedure TMyClass.ServerWebConnect(AContext: TIdContext);
var Stream: TBOBMemoryStream;
    i: integer;
    AThread: TIdContext;
    Command: word;
    ThreadData: TThreadData;
    ErrorPos: string;
begin
  ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  try
{
ErrorPos:= '8-7';
ErrorPos:= '1';
    i:= AThread.Connection.IOHandler.ReadLongInt;
ErrorPos:= '3';
    if (i=csOnlineOrder) then begin // если это запрос от Web-пользователя системы онлайн-заказов
ErrorPos:= '8';
      try
        Stream:= TBOBMemoryStream.Create;
        if not (GetAllBasesConnected and (AppStatus=stWork))
          then raise EBOBError.Create(GetMessageNotCanWorks);
        if (fnGetThreadsCount(ServerWeb)>Cache.GetConstItem(pcMaxServerWebConnect).IntValue)
          then raise EBOBError.Create('Сервер перегружен, повторите запрос через несколько секунд');

  ErrorPos:= '8-8-1';
        AThread.Connection.IOHandler.ReadLongInt;                // принимаем SessionID, который в данном случае не нужен
  ErrorPos:= '8-2';
        Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
  ErrorPos:= '8-3';
        i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
  ErrorPos:= '8-6';
        AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
ErrorPos:= '8-8-2';

        ThreadData:= fnCreateThread(fnSignatureToThreadType(csOnlineOrder), Integer(Command));  // логирование в ib_css
  ErrorPos:= '8-8';
}
ErrorPos:= '1';
    i:= AThread.Connection.IOHandler.ReadLongInt;
ErrorPos:= '3';
    if (i=csOnlineOrder) then begin // если это запрос от Web-пользователя системы онлайн-заказов
ErrorPos:= '8';
      AThread.Connection.IOHandler.ReadLongInt;                // принимаем SessionID, который в данном случае не нужен
ErrorPos:= '8-2';
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));  // логирование в ib_css
ErrorPos:= '8-3';
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
ErrorPos:= '8-6';
      Stream:= TBOBMemoryStream.Create;
ErrorPos:= '8-7';
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
ErrorPos:= '8-8';
      try
        if not (GetAllBasesConnected and (AppStatus=stWork))
          then raise EBOBError.Create(GetMessageNotCanWorks);
ErrorPos:= '8-8-1';
        if (fnGetThreadsCount(ServerWeb)>Cache.GetConstItem(pcMaxServerWebConnect).IntValue)
          then raise EBOBError.Create('Сервер перегружен, повторите запрос через несколько секунд');
ErrorPos:= '8-8-2';
        case Command of
          csWebAutentication            : prAutenticateOrd(Stream, ThreadData);
          csGetAllUsersInfo             : prGetAllUsersInfo(Stream, ThreadData);
          csSearchWithOrNums            : prCommonWareSearch_new(Stream, ThreadData);
          csWebArmGetAnalogs            : prGetWareAnalogs_new(Stream, ThreadData);
          csCreateNewOrder              : prCreateNewOrderOrd(Stream, ThreadData);
          csGetOrderList                : prGetOrderListOrd(Stream, ThreadData);
          csShowOrder                   : prShowOrderOrd(Stream, ThreadData);
          csShowACOrder                 : prShowACOrderOrd(Stream, ThreadData);
          csDelLineFromOrder            : prDelLineFromOrderOrd(Stream, ThreadData);
          csChangeQtyInOrderLine        : prChangeQtyInOrderLineOrd(Stream, ThreadData);
          csRefreshPrices               : prRefreshPricesOrd(Stream, ThreadData);
          csCreateOrderByMarked         : prCreateOrderByMarkedOrd(Stream, ThreadData);
          csJoinMarkedOrders            : prJoinMarkedOrdersOrd(Stream, ThreadData);
          csGetAccountList              : prGetAccountListOrd(Stream, ThreadData);
          csGetWaresFromAccountList     : prGetWaresFromAccountList(Stream, ThreadData);
          csShowGBAccount               : prShowGBAccountOrd(Stream, ThreadData);         // просмотр счета
          csShowGBOutInvoice            : prShowGBOutInvoice(Stream, ThreadData);         // просмотр накладной
          csGetUnpayedDocs              : prGetUnpayedDocs(Stream, ThreadData);
          csDeleteOrderByMark           : prDeleteOrderByMarkOrd(Stream, ThreadData);
          csRefreshPricesInFormingOrders: prRefreshPricesInFormingOrdersOrd(Stream, ThreadData);
          csSetReservValue              : prSetReservValueOrd(Stream, ThreadData);
//          csSetOrderPayType             : prSetOrderPayTypeOrd(Stream, ThreadData);
          csGetOptions                  : prGetOptionsOrd(Stream, ThreadData);
          csSetOrderDefault             : prSetOrderDefaultOrd(Stream, ThreadData);
          csChangePassword              : prChangePasswordOrd(Stream, ThreadData);    // ???
          csWebSetMainUser              : prWebSetMainUserOrd(Stream, ThreadData);
          csWebResetPassword            : prWebResetPasswordOrd(Stream, ThreadData);
          csWebCreateUser               : prWebCreateUserOrd(Stream, ThreadData);
          csChangePass                  : prChangePasswordOrd(Stream, ThreadData);    // ???
          csGetRegisterTable            : prGetRegisterTableOrd(Stream, ThreadData);  // список регионов для формы регистрации фирмы
          csSaveRegOrder                : prSaveRegOrderOrd(Stream, ThreadData);      // запись заявки на регистрацию фирмы в системе СВК
          csGetRegisterUberTowns        : prGetRegisterUberTowns(Stream, ThreadData); // список городов для формы регистрации UBER
          csSaveRegOrderUber            : prSaveRegOrderUber(Stream, ThreadData);     // запись заявки на регистрацию UBER в системе СВК
          csCheckLogin                  : prCheckLoginOrd(Stream, ThreadData);
          csGetCheck                    : prGetCheck(Stream, ThreadData);             // сверка
          csShowGBBack                  : prShowGBBack(Stream, ThreadData);
          csSendMessage2Manager         : prSendMessage2Manager(Stream, ThreadData);
          csAddLinesToOrder             : prAddLinesToOrderOrd(Stream, ThreadData);
          csAddLineFromSearchResToOrder : prAddLineFromSearchResToOrderOrd(Stream, ThreadData);
          csChangeVisibilityOfStorage   : prChangeVisibilityOfStorage(Stream, ThreadData);
          csClientsStoreMove            : prClientsStoreMove(Stream, ThreadData);
          csGetManufacturerList         : prGetManufacturerList(Stream, ThreadData);

          csOrdGetListAttrGroupNames    : prGetListAttrGroupNames(Stream, ThreadData);
          csOrdGetListGroupAttrs        : prGetListGroupAttrs(Stream, ThreadData);
          csSearchWaresByAttrValues     : prCommonSearchWaresByAttr_new(Stream, ThreadData);
          csGetCompareWaresInfo         : prGetCompareWaresInfo(Stream, ThreadData);
          csOrdGetWareInfo              : prGetWareInfoView(Stream, ThreadData);
          csGetFilteredGBGroupAttValues : prGetFilteredGBGroupAttValues(Stream, ThreadData); // Фильтрованные списки значений атрибутов Grossbee по группе

          csOrdGetModelLineList         : prGetModelLineList(Stream, ThreadData);
          csGetModelLineModels          : prGetModelLineModels(Stream, ThreadData);
          csGetModelTree                : prGetModelTree(Stream, ThreadData);
          csGetNodeWares                : prCommonGetNodeWares_new(Stream, ThreadData);
          csOrdSendWareDescrErrorMes    : prSendWareDescrErrorMes(Stream, ThreadData);
          csShowModelsWhereUsed         : prShowModelsWhereUsed(Stream, ThreadData);
          csGetRestsOfWares             : prCommonGetRestsOfWares(Stream, ThreadData);
          csGetActions                  : prGetActions(Stream, ThreadData);
          csGetTop10Model               : prGetTop10Model(Stream, ThreadData);
          csClickOnNewsCounting         : prClickOnNewsCounting(Stream, ThreadData);
          csLoadEngines                 : prLoadEngines(Stream, ThreadData);
          csGetEngineTree               : prGetEngineTree(Stream, ThreadData);
          csShowEngineOptions           : prShowEngineOptions(Stream, ThreadData);
          csLoadModelDataText           : prLoadModelDataText(Stream, ThreadData);
          csTestLinksLoading            : prTestLinksLoading(Stream, ThreadData);
          csGetFilterValues             : prGetFilterValues(Stream, ThreadData);
          csBackJobAutentication        : prAutenticateOrd(Stream, ThreadData);
          csSaveOption                  : prSaveOption(Stream, ThreadData);
          csGetSatellites               : prGetWareSatellites(Stream, ThreadData);
          csSendVINOrder                : prSendVINOrder(Stream, ThreadData);
          csGetWaresByOE                : prCommonGetWaresByOE(Stream, ThreadData);
          csHideEmptyOE                 : prHideEmptyOE(Stream, ThreadData);
          csDownloadPrice               : prDownloadPrice(Stream, ThreadData);
          csShowNotification            : prShowNotificationOrd(Stream, ThreadData);
          csConfirmNotification         : prConfirmNotification(Stream, ThreadData);
          csWaresByOE                   : prSearchWaresByOE_new(Stream, ThreadData);
          csContractList                : prContractList(Stream, ThreadData);
          csChangeContract              : prChangeClientLastContract(Stream, ThreadData);
          csChangeContractAccess        : prChangeContractAccess(Stream, ThreadData);
          csSendOrderForChangePersonData: prSendOrderForChangeData(resEdited, Stream, ThreadData);  // отправить заявку на изменение персональных данных
          csSendOrderForAddContactPerson: prSendOrderForChangeData(resAdded, Stream, ThreadData);   // отправить заявку на добавление контактного лица
          csSendOrderForDelContactPerson: prSendOrderForChangeData(resDeleted, Stream, ThreadData); // отправить заявку на удаление контактного лица
//          csSetCliContMargins           : prSetCliContMargins(Stream, ThreadData);
          csRemindPass                  : prRemindPass(Stream, ThreadData);
          csGetContracts                : prGetContracts(Stream, ThreadData);
          csGetBonusWares               : prGetBonusWares(Stream, ThreadData);
          csGetTimeListSelfDelivery     : prGetTimeListSelfDelivery(Stream, ThreadData);    // список доступных времен самовывоза
          csGetContractDestPointsList   : prGetContractDestPointsList(Stream, ThreadData);  // список торговых точек контракта
          csGetAvailableTimeTablesList  : prGetAvailableTimeTablesList(Stream, ThreadData); // список доступных расписаний по контракту
          csGetOrderHeaderParams        : prGetOrderHeaderParams(Stream, ThreadData);       // просмотр параметров заголовка заказа
          csEditOrderHeaderParams       : prEditOrderHeaderParams(Stream, ThreadData);      // редактирование параметров заголовка заказа
          csShowBonusFormingOrder       : prShowBonusFormingOrder(Stream, ThreadData);      // просмотр бонусного неотправленного заказа
          csGetQtyByAnalogsAndStorages  : prGetQtyByAnalogsAndStoragesOrd(Stream, ThreadData);
          csEditOrderSelfComment        : prEditOrderSelfComment(Stream, ThreadData);       // редактирование комментария "для себя"
          csCheckOrderWareRests         : prCheckOrderWareRests(Stream, ThreadData);        // проверка проблем отгрузки товаров по заказу
          csGetDprtAvailableShipDates   : prGetDprtAvailableShipDates(Stream, ThreadData);  // список доступных дат отгрузки по складу
          csGetMainStoreLocation        : prGetMainStoreLocation(Stream, ThreadData);       // адрес и координаты главного склада
          csGetCheckBonus               : prGetCheckBonus(Stream, ThreadData);              // unit-движение
          csShowGBManual                : prShowGBManual(Stream, ThreadData);               // просмотр корректировок
          csGeneralNewSystemProcOrder   : prGeneralNewSystemProcOrder(Stream, ThreadData);  // общая процедура по новой схеме работы Ордер
          csGetOutInvoiceXml            : prGetOutInvoiceXml(Stream, ThreadData);           // получить накладную в виде xml-файла
          csGetFormingOrdersList        : prGetFormingOrdersList(Stream, ThreadData);       // Получить список неотправленных заказов
          csGetWareActions              : prGetWareActions(Stream, ThreadData);             // Получить список акций для "Информации"

          csGetBankAccountsList         : prGetBankAccountsList(Stream, ThreadData);        // Получить список счетов на оплату
          csNewBankAccount              : prNewBankAccount(Stream, ThreadData);             // Сформировать новый счет на оплату
          csSaveBankAccount             : prSaveBankAccount(Stream, ThreadData);            // Записать счет на оплату
          csGetBankAccountFile          : prGetBankAccountFile(Stream, ThreadData);         // Получить файл счета на оплату
          csSendSMSfromBankAccount      : prSendSMSfromBankAccount(Stream, ThreadData);     // Отправить SMS из счета на оплату
          csGetReclamationList          : prGetReclamationList(Stream, ThreadData);         // Получить список рекламаций
          csGetMeetPersonsList          : prGetMeetPersonsList(Stream, ThreadData);         // Получить список встречающих к/а
          csGetNodeWaresMotul           : prCommonGetNodeWares_Motul(Stream, ThreadData);   // Получить список товаров Motul по узлам модели
          csOrderImport                 : prOrderImport(Stream, ThreadData);                // импорт товаров в заказ
          csGetDestPointParams          : prGetDestPointParams(Stream, ThreadData);         // список параметров для управления торговыми точками

          else raise EBOBError.Create('Не опознана Web-команда - '+IntToStr(Command));
        end; // case Command of
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          if (Command<>csTestLinksLoading) and (AppStatus=stWork) then
            fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebConnect', 'Command='+IntToStr(Command), E.Message, 'ErrorPos='+ErrorPos);
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
ErrorPos:= '8-9';
      If Stream.Size>0 then begin
        i:= Stream.Size;
ErrorPos:= '8-10: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(i);              //
ErrorPos:= '8-11: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
ErrorPos:= '8-12';
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);

    end else begin // если неизвестная сигнатура
ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end;
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebConnect', 'Ошибка общего плана ', E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerWebConnect', 'Аварийно завершен поток ', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerWebConnect');
  if Assigned(AThread) and AThread.Connection.Connected then AThread.Connection.Disconnect;
  prFree(Stream);
end; //ServerWebConnect
//==============================================================================
procedure TMyClass.ServerWebArmConnect(AContext: TIdContext);
var Stream : TBOBMemoryStream;
    i : integer;
    AThread: TIdContext;
    Command: word;
    ThreadData: TThreadData;
    ErrorPos: string;
begin
  ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  try
ErrorPos:= '1';
ErrorPos:= '2';
    i:= AThread.Connection.IOHandler.ReadLongInt;
ErrorPos:= '3';
    if (i=csWebArm) then begin // если это запрос от WebArm-пользователя
ErrorPos:= '8';

      AThread.Connection.IOHandler.ReadLongInt;                // принимаем SessionID, который в данном случае не нужен
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
      Stream:= TBOBMemoryStream.Create;
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
      try
        if not (GetAllBasesConnected and (AppStatus=stWork))
          then raise EBOBError.Create(GetMessageNotCanWorks);
        case Command of
          csWebArmAutentication            : prWebArmAutenticate(Stream, ThreadData);
          csShowWebArmUsers                : prShowWebArmUsers(Stream, ThreadData);
          csAEWebArmUser                   : prAEWebArmUser(Stream, ThreadData);
          csProductPage                    : prProductPage(Stream, ThreadData);
          csProductWareSearch              : prProductWareSearch(Stream, ThreadData);
          csProductGetOrigNumsAndWares     : prProductGetOrigNumsAndWares(Stream, ThreadData);
          csProductAddOrigNum              : prProductAddOrigNum(Stream, ThreadData);
          csProductDelOrigNum              : prProductDelOrigNum(Stream, ThreadData);
          csAccountsReestrPage             : prAccountsReestrPage(Stream, ThreadData);
          csAccountsGetFirmList            : prAccountsGetFirmList(Stream, ThreadData);
          csSearchWithOrNums               : prCommonWareSearch(Stream, ThreadData);
          csGetManufacturerList            : prGetManufacturerList(Stream, ThreadData);
          csWebArmGetAnalogs               : prGetWareAnalogs(Stream, ThreadData);
          csSaveWebArmUsers                : prSaveWebArmUsers(Stream, ThreadData);
          csManageBrands                   : prManageBrands(Stream, ThreadData);
          csGetBrandsGB                    : prGetBrandsGB(Stream, ThreadData);
          csGetBrandsTD                    : prGetBrandsTD(Stream, ThreadData);
          csGetLinkBrandsGBTD              : prGetLinkBrandsGBTD(Stream, ThreadData);
          csAddLinkBrandsGBTD              : prAddLinkBrandsGBTD(Stream, ThreadData);
          csDelLinkBrandsGBTD              : prDelLinkBrandsGBTD(Stream, ThreadData);
          csUiKPage                        : prUiKPage(Stream, ThreadData);
          csTNAGet                         : prTNAGet(Stream, ThreadData);
          csTNANodeAdd                     : prTNANodeAdd(Stream, ThreadData);
          csTNANodeDel                     : prTNANodeDel(Stream, ThreadData);
          csTNANodeEdit                    : prTNANodeEdit(Stream, ThreadData);
          csTNAManagePage                  : prTNAManagePage(Stream, ThreadData);
          csManufacturerAdd                : prManufacturerAdd(Stream, ThreadData);
          csManufacturerEdit               : prManufacturerEdit(Stream, ThreadData);
          csManufacturerDel                : prManufacturerDel(Stream, ThreadData);
          csGetModelLineList               : prGetModelLineList(Stream, ThreadData);
          csModelLineAdd                   : prModelLineAdd(Stream, ThreadData);
          csModelLineEdit                  : prModelLineEdit(Stream, ThreadData);
          csModelLineDel                   : prModelLineDel(Stream, ThreadData);
          csWebArmGetRegionalFirms         : prWebArmGetRegionalFirms(Stream, ThreadData);
          csWebArmGetFirmUsers             : prWebArmGetFirmUsers(Stream, ThreadData);
          csWebArmResetUserPassword        : prWebArmResetUserPassword(Stream, ThreadData);
          csWebArmSetFirmMainUser          : prWebArmSetFirmMainUser(Stream, ThreadData);
          csWebArmGetOrdersToRegister      : prWebArmGetOrdersToRegister(Stream, ThreadData);
          csWebArmAnnulateOrderToRegister  : prWebArmAnnulateOrderToRegister(Stream, ThreadData);
          csWebArmRegisterOrderToRegister  : prWebArmRegisterOrderToRegister(Stream, ThreadData);
          csGetFilialList                  : prGetFilialList(Stream, ThreadData);
          csWebArmGetRegionalZones         : prWebArmGetRegionalZones(Stream, ThreadData);
          csWebArmInsertRegionalZone       : prWebArmInsertRegionalZone(Stream, ThreadData);
          csWebArmDeleteRegionalZone       : prWebArmDeleteRegionalZone(Stream, ThreadData);
          csWebArmUpdateRegionalZone       : prWebArmUpdateRegionalZone(Stream, ThreadData);
          csGetModelLineModels             : prGetModelLineModels(Stream, ThreadData);
          csGetModelTree                   : prGetModelTree(Stream, ThreadData);
          csGetNodeWares                   : prCommonGetNodeWares(Stream, ThreadData);
          csModelAddToModelLine            : prModelAddToModelLine(Stream, ThreadData);
          csModelEdit                      : prModelEdit(Stream, ThreadData);
          csModelDel                       : prModelDel(Stream, ThreadData);
          csModelSetVisible                : prModelSetVisible(Stream, ThreadData);
          csAutoModelInfoLists             : prAutoModelInfoLists(Stream, ThreadData);
          csLoadModelData                  : prLoadModelData(Stream, ThreadData);

          csGetListAttrGroupNames          : prGetListAttrGroupNames(Stream, ThreadData);
          csGetListGroupAttrs              : prGetListGroupAttrs(Stream, ThreadData);
          csSearchWaresByAttrValues        : prCommonSearchWaresByAttr(Stream, ThreadData);
          csGetCompareWaresInfo            : prGetCompareWaresInfo(Stream, ThreadData);
          csGetWareInfoView                : prGetWareInfoView(Stream, ThreadData);
          csGetFilteredGBGroupAttValues    : prGetFilteredGBGroupAttValues(Stream, ThreadData); // Фильтрованные списки значений атрибутов Grossbee по группе

          csSendWareDescrErrorMes          : prSendWareDescrErrorMes(Stream, ThreadData);
          csImportPage                     : prImportPage(Stream, ThreadData);
          csGetBaseStamp                   : prGetBaseStamp(Stream, ThreadData);
          csCommonImport                   : prCommonImport(Stream, ThreadData);
          csCheckWareManager               : prCheckWareManager(Stream, ThreadData);
          csModifyLink3                    : prModifyLink3(Stream, ThreadData);
          csGetWareList                    : prGetWareList(Stream, ThreadData);
          csLoadModelDataText              : prLoadModelDataText(Stream, ThreadData);
          csShowModelsWhereUsed            : prShowModelsWhereUsed(Stream, ThreadData);
          csMarkOrNum                      : prMarkOrNum(Stream, ThreadData);
          csShowCrossOE                    : prShowCrossOE(Stream, ThreadData);
          csShowCurrentOperations          : prShowCurrentOperations(Stream, ThreadData);
          csStopIEOperation                : prStopIEOperation(Stream, ThreadData);
          csShowEngineOptions              : prShowEngineOptions(Stream, ThreadData);
          csGetTop10Model                  : prGetTop10Model(Stream, ThreadData);
          csLoadEngines                    : prLoadEngines(Stream, ThreadData);
          csGetEngineTree                  : prGetEngineTree(Stream, ThreadData);
          csNewsPage                       : prNewsPage(Stream, ThreadData);
          csTestLinksLoading               : prTestLinksLoading(Stream, ThreadData);
          csGetFilterValues                : prGetFilterValues(Stream, ThreadData);
          csShowActionNews                 : prShowActionNews(Stream, ThreadData);
          csAEActionNews                   : prAEActionNews(Stream, ThreadData);
          csSaveImgForAction               : prSaveImgForAction(Stream, ThreadData);
          csUnblockWebUser                 : prUnblockWebUser(Stream, ThreadData);
          csDelActionNews                  : prDelActionNews(Stream, ThreadData);
          csShowSysOptionsPage             : prShowSysOptionsPage(Stream, ThreadData);
          csEditSysOption                  : prEditSysOption(Stream, ThreadData);
          csSaveSysOption                  : prSaveSysOption(Stream, ThreadData);
          csShowConstRoles                 : prShowConstRoles(Stream, ThreadData);
          csEditConstRoles                 : prEditConstRoles(Stream, ThreadData);
          csMarkOneDirectAnalog            : prMarkOneDirectAnalog(Stream, ThreadData);
          csAddOneDirectAnalog             : prAddOneDirectAnalog(Stream, ThreadData);
          csShowConditionPortions          : prShowConditionPortions(Stream, ThreadData);
          csGetWaresByOE                   : prCommonGetWaresByOE(Stream, ThreadData);
          csHideEmptyOE                    : prHideEmptyOE(Stream, ThreadData);
          csMarkPortions                   : prMarkPortions(Stream, ThreadData);
          csShowPortion                    : prShowPortion(Stream, ThreadData);
          csCOUPage                        : prCOUPage(Stream, ThreadData);
          csGetCateroryValues              : prGetCateroryValues(Stream, ThreadData);
          csSavePortion                    : prSavePortion(Stream, ThreadData);
          csGetSatellites                  : prGetWareSatellites(Stream, ThreadData);
//          csGetClientData                  : prWebArmGetFirmInfo(Stream, ThreadData);
          csGetRestsOfWares                : prCommonGetRestsOfWares(Stream, ThreadData);
          csLoadAccountList                : prWebArmGetFilteredAccountList(Stream, ThreadData);
          csWebArmShowAccount              : prWebArmShowAccount(Stream, ThreadData);
          csWebArmShowFirmWareRests        : prWebArmShowFirmWareRests(Stream, ThreadData);
          csWebArmEditAccountHeader        : prWebArmEditAccountHeader(Stream, ThreadData);
          csWebArmEditAccountLine          : prWebArmEditAccountLine(Stream, ThreadData);
          csWebArmGetWaresDescrView        : prWebArmGetWaresDescrView(Stream, ThreadData);
          csWebArmGetDeliviriesList        : prWebarmGetDeliveries(Stream, ThreadData);
          csCreateSubAcc                   : prWebArmMakeSecondAccount(Stream, ThreadData);
          csGetDeliveriesList              : prGetDeliveriesList(Stream, ThreadData);
          csRestorePassword                : prRestorePassword(Stream, ThreadData);
          csBlockWebArmUser                : prBlockWebArmUser(Stream, ThreadData);
          csWebArmMakeInvoiceFromAccount   : prWebArmMakeInvoiceFromAccount(Stream, ThreadData);
          csShowTransferInvoices           : prWebArmGetTransInvoicesList(Stream, ThreadData);
          csShowTransferInvoice            : prWebArmGetTransInvoice(Stream, ThreadData);
          csWebArmAddWaresFromAccToTransInv: prWebArmAddWaresFromAccToTransInv(Stream, ThreadData);
          csCheckRestsInStorageForAcc      : prCheckRestsInStorageForAcc(Stream, ThreadData);
          csAEDNotification                : prAEDNotification(Stream, ThreadData);
          csNotificationPage               : prNotificationPage(Stream, ThreadData);
          csWebArmGetNotificationsParams   : prWebArmGetNotificationsParams(Stream, ThreadData);
          csShowNotification               : prShowNotificationOrd(Stream, ThreadData);
          csShowNotificationWA             : prShowNotification(Stream, ThreadData);
          csWaresByOE                      : prSearchWaresByOE(Stream, ThreadData);
          csCheckContracts                 : prCheckContracts(Stream, ThreadData);
          csWebarmContractList             : prWebArmContractList(Stream, ThreadData);
          csManageLogotypesPage            : prManageLogotypesPage(Stream, ThreadData);
          csLogotypeEdit                   : prLogotypeEdit(Stream, ThreadData);
          csLoadOrder                      : prLoadOrder(Stream, ThreadData);
          csLampSelect                     : prGetActionsSrvMng(Stream, ThreadData);        // ???
          csGetTimeListSelfDelivery        : prGetTimeListSelfDelivery(Stream, ThreadData);    // список доступных времен самовывоза
          csGetContractDestPointsList      : prGetContractDestPointsList(Stream, ThreadData);  // список торговых точек контракта
          csGetAvailableTimeTablesList     : prGetAvailableTimeTablesList(Stream, ThreadData); // список доступных расписаний по контракту
          csGetAccountShipParams           : prGetAccountShipParams(Stream, ThreadData);       // просмотр параметров отгрузки счета
          csSetAccountShipParams           : prSetAccountShipParams(Stream, ThreadData);       // редактирование параметров отгрузки счета
          csGetDprtAvailableShipDates      : prGetDprtAvailableShipDates(Stream, ThreadData);  // список доступных дат отгрузки по складу
          csWebArmResetPassword            : prWebArmResetPassword(Stream, ThreadData);
          csMPBIReportsPage                : prMPBIRep(Stream, ThreadData);
          csMPBIReportsFiles               : prMPBIFiles(Stream, ThreadData);
          csLoadFirmAccountList            : prWebArmGetFirmAccountList(Stream, ThreadData);   // список счетов к/а для МП
          csShowGBAccount                  : prShowGBAccountOrd(Stream, ThreadData);           // просмотр счета для МП
          csShowGBOutInvoice               : prShowGBOutInvoice(Stream, ThreadData);           // просмотр накладной для МП

          csGeneralNewSystemProcWebArm     : prGeneralNewSystemProcWebArm(Stream, ThreadData);  // общая процедура по новой схеме работы

          csMotulSitePage                  : prMotulSitePage(Stream, ThreadData);   // Cписки для страницы "motul.vladislav.ua"
          csMotulSiteManage                : prMotulSiteManage(Stream, ThreadData); // Операции на странице "motul.vladislav.ua"

          else raise EBOBError.Create('Не опознана WebArm-команда - '+IntToStr(Command));
        end; //  case Command of
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          if (Command<>csTestLinksLoading) and (AppStatus=stWork) then
            fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebArmConnect',
              'Command='+IntToStr(Command), E.Message, 'ErrorPos='+ErrorPos);
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
      if Stream.Size>0 then begin
        i:= Stream.Size;
        AThread.Connection.IOHandler.Write(i);              //
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);
    end else begin // если неизвестная сигнатура
  ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end; // if i=csWebArm
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebArmConnect', 'Ошибка общего плана', E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerWebArmConnect', 'Аварийно завершен поток', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerWebConnect');
  prFree(Stream);
  if Assigned(AThread) and AThread.Connection.Connected then AThread.Connection.Disconnect;
end; //ServerWebArmConnect
//==============================================================================
procedure TMyClass.ServerManageConnect(AContext: TIdContext);
var i: integer;
    ThreadData: TThreadData;
    Command: word;
    ErrorPos: string;
    AThread: TIdContext;
    Stream: TBOBMemoryStream;
begin
ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  Command:= 0;
  try
    AThread.Connection.IOHandler.ReadTimeout:=5000;
ErrorPos:= '1';
    i:= AThread.Connection.IOHandler.ReadLongInt;    // принимаем сигнатуру
    AThread.Connection.IOHandler.ReadLongInt;   // пропускаем идентификатор сессии
ErrorPos:= '3';
    if (i=csServerManage) then begin // если это запрос управления сервером
ErrorPos:= '8';
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));
ErrorPos:= '8-3';
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
ErrorPos:= '8-6';
      Stream:= TBOBMemoryStream.Create;
ErrorPos:= '8-7';
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
ErrorPos:= '8-8';
      try
        case Command of
          scGetStatus     : prGetFullStatus(Stream, ThreadData);       // вернуть статус приложения
          scUpdateCache   : prUpdateCacheSrvMng(Stream, ThreadData);   // Обновить кэш
          scGetActions    : prGetActionsSrvMng(Stream, ThreadData);    // Обновить акции
          scSuspend, scResume, scExit:                                 // "Усыпить", "Разбудить", завершить приложение
            prExecuteServerCommand(Stream, ThreadData, Command, AThread.Connection.Socket.Binding.PeerIP);
          scGetKAPhones   : prGetKAPhones(Stream, ThreadData);         // обновить телефоны конт. лиц для Инфинити
          scGetMediaBlocks: prGetMediaBloksSrvMng(Stream, ThreadData); // Обновить медиа-блоки
          scGetActionIcons: prGetActionIconsSrvMng(Stream, ThreadData); // Обновить иконки акций
          else raise EBOBError.Create('Не опознана управляющая команда - '+IntToStr(Command));
        end;
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerManageConnect', '', E.Message, '');
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
ErrorPos:= '8-9';
      If Stream.Size>0 then begin
        i:= Stream.Size;
ErrorPos:= '8-10: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(i);              //
ErrorPos:= '8-11: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
ErrorPos:= '8-12';
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);

    end else begin // если неизвестная сигнатура
ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end;
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerManageConnect', 'Ошибка общего плана, Command='+IntToStr(Command), E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerManageConnect', 'Аварийно завершен поток', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prFree(Stream);
  if (AThread<>nil) and AThread.Connection.Connected then AThread.Connection.Disconnect;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerManageConnect');
end; //ServerManageConnect
//==========================================================  TMyClass

//= Функция для пользовательской сортировки товаров в StringList с учетом бренда
function fnWareCompareByBrand(List: TStringList; Index1, Index2: Integer): Integer;
var Ware1, Ware2: TWareInfo;
begin
  Ware1:= TWareInfo(Cache.arWareInfo[integer(List.Objects[Index1])]);
  Ware2:= TWareInfo(Cache.arWareInfo[integer(List.Objects[Index2])]);
  if (Ware1.WareBrandName<Ware2.WareBrandName) then Result:= -1
  else if (Ware1.WareBrandName>Ware2.WareBrandName) then Result:= 1
  else if (Ware1.Name<Ware2.Name) then Result:= -1
  else if (Ware1.Name>Ware2.Name) then Result:= 1
  else Result:= 0;
end;
//================================ Функция получения товаров по заданному бренду
function fnGetWareListByBrand(Brand: integer; Sys: byte = 255; Sort: boolean = false): TStringList;
var i, recs: integer;
    ware: TWareInfo;
begin
  Result:= TStringList.Create;
  try
    if (not Cache.WareBrands.ItemExists(Brand)) then
      raise EBOBError.Create('Не найден бренд с кодом '+IntToStr(Brand));
    recs:= Length(Cache.arWareInfo)-1;
    for i:= 0 to recs do if Cache.WareExist(i) then begin
      ware:= Cache.arWareInfo[i];
      if not (ware.WareBrandID=Brand) then Continue;
//      if not ware.CheckWareTypeSys(Sys) then Continue;
      Result.AddObject(ware.Name, pointer(ware.ID));
    end;
    if Sort then Result.Sort;
  except
    on E:Exception do raise Exception.Create('fnGetWareListByBrand: '+E.Message);
  end;
end;
//==============================================================================
function fnGetAdaptedConstValue(ConstID: integer): string;
const nmProc = 'fnGetAdaptedConstValue'; // имя процедуры/функции
var aos: Tas;
    s, ss: string;
    j, EmplCode, Code: integer;
    Item: TConstItem;
begin
  Result:= '';
  try
    if not Cache.ConstExists(ConstID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - код='+IntToStr(ConstID));

    Item:= Cache.GetConstItem(ConstID);
    s:= '';
    case ConstID of
      pcEmplID_list_Rep30, pcTestingSending1, pcTestingSending2, pcTestingSending3,
        pcEmpl_list_UnBlock, pcEmpl_list_TmpBlock, pcEmpl_list_FinalBlock, pcVINmailEmpl_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:= 0 to High(aos) do begin
          EmplCode:= StrToIntDef(aos[j], 0);
          ss:= '';
          if (EmplCode<0) then begin
            if (EmplCode>=Low(ceNames)) and (EmplCode<=High(ceNames)) then
              ss:= ceNames[EmplCode];
          end else if Cache.EmplExist(EmplCode) then
            ss:= Cache.arEmplInfo[EmplCode].EmplShortName;
          if ss<>'' then s:= s+fnIfStr(s<>'', ', ', '')+ss;
        end;
        Result:= s;
      end; // pcEmplID_list_Rep30 ...

      pcVINmailFilial_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:= 0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], 0);
          if Cache.DprtExist(Code) and Cache.arDprtInfo[Code].IsFilial then
            if s<>'' then s:=s+fnIfStr(s<>'', ', ', '')+Cache.arDprtInfo[Code].Name;
        end;
        Result:= s;
      end; // pcVINmailFilial_list

      pcVINmailFirmClass_list, pcPriceLoadFirmClasses: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:=0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], 0);
          ss:= Cache.GetFirmClassName(Code);
          if ss<>'' then begin
            if s<>'' then s:= s+', ';
            s:= s+ss;
          end;
        end;
        Result:= s;
      end; // pcVINmailFirmClass_list, pcPriceLoadFirmClasses

      pcVINmailFirmTypes_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:=0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], -1);
          ss:= Cache.GetFirmTypeName(Code);
          if ss<>'' then begin
            if s<>'' then s:=s+', ';
            s:= s+ss;
          end;
        end;
        Result:= s;
      end; // pcVINmailFirmTypes_list

      pcEmplSaleDirectorAuto, pcEmplSaleDirectorMoto: begin
        Code:= StrToIntDef(Item.StrValue, 0);
        if Cache.EmplExist(Code) then
          Result:= Cache.arEmplInfo[Code].EmplShortName
        else Result:= 'Неизвестный';
      end; // pcEmplSaleDirectorAuto, pcEmplSaleDirectorAuto

    else Result:= Item.StrValue;
    end; // case
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'for constID='+IntToStr(ConstID)+': '+E.Message);
    on E: Exception do raise Exception.Create(nmProc+'for constID='+IntToStr(ConstID)+': '+E.Message);
  end;
  SetLength(aos, 0);
end;  // fnGetAdaptedConstValue
//======== используется для сортировки списка типов товаров в результатах поиска
function TypeNamesSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var i1, i2: Integer;
begin
  try
    i1:= Integer(List.Objects[Index1]);
    i2:= Integer(List.Objects[Index2]);
    if (i1=i2) then Result:= 0
    else if (i1=0) then Result:= 1
    else if (i2=0) then Result:= -1
    else Result:= AnsiCompareText(List[Index1], List[Index2]);
  except
    Result:= 0;
  end;
end;
//============ используется для сортировки объектов типа TTwoCodes в TObjectList
//====================================при выводе списка производителей авто/мото
function SortCompareManufNamesForTwoCodes(Item1, Item2: Pointer): Integer;
begin
  Result:= CompareText(Cache.FDCA.Manufacturers[TTwoCodes(Item1).ID1].Name,
    Cache.FDCA.Manufacturers[TTwoCodes(Item2).ID1].Name);
end;
//========================= используется для сортировки StringList в TObjectList
//======================================= при выводе порций условий применимости
function SortCompareConditionPortions(Item1, Item2: Pointer): Integer;
begin
  Result:= CompareText(TStringList(Item1).QuoteChar, TStringList(Item2).QuoteChar);
end;
//================= проверяет, просрочено ли время доставки, true - не просрочен
function CheckShipmentDateTime(Data: TDate; TimeCode: integer): boolean;
var Hour, Minute: double;
    st: TShipTimeItem;
begin
  Result:= not fnNotZero(Data);
  if Result then Exit;
  if TimeCode=0 then begin
    Hour:= 23;
    Minute:= 59.9999999;
  end else begin
    st:= Cache.ShipTimes[TimeCode];
    Hour:= st.Hour;
    Minute:= st.Minute;
  end;
  Result:=(Data+Hour/24+Minute/60/24)>Now();
end; // CheckShipmentDateTime
//----------------------------------------- vc

//----------------------------------------- v_CSSServerManageProcs
procedure CheckManagePassw(passw: String);
const ManageDefPassw = 'sdihhhsdohsdohsovhovhsodvhsdohsdohSDObhSDObhsdohsdohbhSbuo';
begin
  if (passw<>GetIniParam(nmIniFileBOB, 'Manage', 'ManagePass', ManageDefPassw)) then
    raise Exception.Create('Неправильный пароль');
end;
//==============================================================================
procedure prGetFullStatus(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFullStatus'; // имя процедуры/функции
var i, Count, iState: integer;
    s, s1: string;
//    Pools: array of TIBCntsPool;
    pool: TIBCntsPool;
begin
  pool:= nil;
  try
    Stream.Position:= 0;
    s1:= Stream.ReadStr;
    CheckManagePassw(s1);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteInt(AppStatus);
    if AppStatus in [stSuspending, stSuspended] then begin  // если приложение спит, то отправляем список усыпивших его серверов
      s:= '';
      for i:= 0 to High(StopList) do s:= StopList[i]+', ';
      Stream.WriteStr(Copy(s, 1, length(s)-2));
    end;

    Stream.WriteByte(1);
    Stream.WriteByte(1);

    if (ServerWeb=nil) then iState:= sttcpsrvNone
    else if ServerWeb.Active then iState:= sttcpsrvActive
    else iState:= sttcpsrvSuspended;
    Stream.WriteInt(iState);

    if (ServerWebArm=nil) then iState:= sttcpsrvNone
    else if ServerWebArm.Active then iState:= sttcpsrvActive
    else iState:= sttcpsrvSuspended;
    Stream.WriteInt(iState);

    Stream.WriteInt(stthrdNone); // RespThread
    Stream.WriteInt(stthrdNone); // MailThread
    Stream.WriteInt(stthrdNone); // TestThread

    if (thCheckStoppedOrders=nil) then Stream.WriteInt(stthrdNone)
    else begin
      Stream.WriteInt(TCSSCyclicThread(thCheckStoppedOrders).Status);
      Stream.WriteDouble(TCSSCyclicThread(thCheckStoppedOrders).LastTime);
    end;

    if (thCheckDBConnectThread=nil) then Stream.WriteInt(stthrdNone)
    else begin
      Stream.WriteInt(TCSSCyclicThread(thCheckDBConnectThread).Status);
      Stream.WriteDouble(TCSSCyclicThread(thCheckDBConnectThread).LastTime);
    end;
    Stream.WriteInt(Cache.GetTestCacheIndication);
    Stream.WriteDouble(Cache.GetLastTimeCache);

    Count:= 4;
{    SetLength(Pools, Count+1);
    Pools[0]:= cntsGRB;
    Pools[1]:= cntsORD;
    Pools[2]:= cntsLOG;
    Pools[3]:= cntsSUF;
    Pools[4]:= cntsTDT;  }
    Stream.WriteInt(Count+1);
    for i:= 0 to Count do begin
      case i of
        0: Pool:= cntsGRB;
        1: Pool:= cntsORD;
        2: Pool:= cntsLOG;
        3: Pool:= cntsSUF;
        4: Pool:= cntsTDT;
      end;
      Stream.WriteStr(Pool.CntsComment);
      Stream.WriteStr(Pool.dbPath);
      Stream.WriteBool(Pool.BaseConnected);

{      Stream.WriteStr(Pools[i].CntsComment);
      Stream.WriteStr(Pools[i].dbPath);
      Stream.WriteBool(Pools[i].BaseConnected); }
    end;
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
//  SetLength(Pools, 0);
  Stream.Position:= 0;
end; // prGetFullStatus
//==============================================================================
procedure prExecuteServerCommand(Stream: TBoBMemoryStream; ThreadData: TThreadData; ACommand: integer; AIP: string);
const nmProc = 'prExecuteServerCommand'; // имя процедуры/функции
var s: string;
begin
  try
    Stream.Position:= 0;
    s:= Stream.ReadStr;
    CheckManagePassw(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    while ManageCommandsLock do sleep(50);
    try
      ManageCommandsLock:= true;
      if ACommand=scExit then SetLength(arManageCommands, 1)
      else SetLength(arManageCommands, Length(arManageCommands)+1);
      arManageCommands[Length(arManageCommands)-1].Command:= ACommand;
      arManageCommands[Length(arManageCommands)-1].IP:= AIP;
    finally
      ManageCommandsLock:= false;
    end;
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; // prExecuteServerCommand
//==============================================================================
procedure prUpdateCacheSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prUpdateCacheSrvMng'; // имя процедуры/функции
var s: string;
begin
  try
    Stream.Position:= 0;
    s:= Stream.ReadStr;
    CheckManagePassw(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    with TCSSCyclicThread(thCheckDBConnectThread) do
    if ExpressFlag or Cache.WareCacheTested then
      raise EBoBError.Create('Выполняется '+fnIfStr(ExpressFlag, 'срочная', 'штатная')+' проверка кеша')
    else ExpressFlag:= True;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; // prExecuteServerCommandprUpdateCacheSrvMng
//==============================================================================
procedure prGetActionsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetActionsSrvMng'; // имя процедуры/функции
var Count, Pos: integer;
    ordIBD: TIBDatabase;
    OrdIBS: TIBSQL;
begin
  ordIBD:= nil;
  OrdIBS:= nil;
  try
    Stream.Position:= 0;
    ordIBD:= CntsOrd.GetFreeCnt();
    OrdIBS:= fnCreateNewIBSQL(ordIBD, 'OrdIBS_'+nmProc, ThreadData.ID, tpRead, true);
    OrdIBS.SQL.Text:= 'Select * from infoboxviews'+
      ' where "TODAY" between IBVDATEFROM and IBVDATETO and (IBVVISAUTO="T" or IBVVISMOTO="T")'+
      ' order by IBVPRIORITY desc, IBVDATEFROM desc';
    OrdIBS.ExecQuery;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Pos:= Stream.Position;
    Stream.WriteInt(0); // заглушка под кол-во
    Count:= 0;
    while not OrdIBS.EOF do begin
      Stream.WriteInt(OrdIBS.FieldByName('IBVCODE').Asinteger);
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISAUTO'));
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISMOTO'));
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISIBLE'));
      Stream.WriteInt(OrdIBS.FieldByName('IBVPRIORITY').Asinteger);
      Stream.WriteStr(OrdIBS.FieldByName('IBVTITLE').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('IBVLINKTOSITE').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('IBVLINKTOPICT').AsString);
      inc(Count);
      TestCssStopException;
      OrdIBS.Next;
    end;
    if (Count>0) then begin
      Stream.Position:= Pos;
      Stream.WriteInt(Count);
    end;
    Stream.SaveToFile('actions.raw');
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(ordIBD);
end;
//======================================================== Обновить иконки акций
procedure prGetActionIconsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetActionIconsSrvMng'; // имя процедуры/функции
var Count, Pos, fsize, i: integer;
    s, ImageFname, mbPath: String;
    IBD: TIBDatabase;
    IBS: TIBSQL;
    msp: TMemoryStream;
begin
  IBD:= nil;
  IBS:= nil;
  msp:= nil;
  Count:= 0;
  try try
    Stream.Clear;
    Stream.Position:= 0;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Pos:= Stream.Position;
    Stream.WriteInt(0); // заглушка под кол-во

    if not TestRDB(CntsGRB, trkField, 'WareActionReestr', 'WrAcPhoto') then Exit; // флаг наличия поля иконки

    try
      msp:= TMemoryStream.Create;
      IBD:= CntsGRB.GetFreeCnt();
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, ThreadData.ID, tpRead, true);
      ibs.SQL.Text:= 'SELECT WrAcCode, WrAcExtn, WrAcPhoto from WareActionReestr'+
        ' where WrAcSubFirmCode=1 and WrAcDocmState=1'+
        '   and WrAcStartDate<="today" and WrAcStopDate>("today"-'+
        Cache.GetConstItem(pcClosedActionShowDays).StrValue+')';
      ibs.ExecQuery;
      while not ibs.Eof do begin
        s:= IBS.FieldByName('WrAcExtn').AsString;
        if (s<>'') then begin
          msp.Clear;
          IBS.FieldByName('WrAcPhoto').SaveToStream(msp);
          fsize:= msp.Size;
          if (fsize>0) then begin
            ImageFname:= ibs.fieldByName('WrAcCode').AsString+'.'+s;
            Stream.WriteStr(ImageFname); // имя файла картинки в папке actionicons
            Stream.WriteInt(fsize);     // размер иконки
            msp.Position:= 0;
            Stream.CopyFrom(msp, fsize); // иконка
            inc(Count);
          end;
        end;
        cntsGRB.TestSuspendException;
        ibs.Next;
      end;
      ibs.Close;
      if (Count>0) then begin
        Stream.Position:= Pos;
        Stream.WriteInt(Count);
      end;
    finally
      prFreeIBSQL(IBS);
      CntsGRB.SetFreeCnt(IBD);
      prFree(msp);
    end;
    mbPath:= fnTestDirEnd(fnCreateTmpDir('', 'actionicons'));

//---------------------------------- проверяем разборку файла (для Csscommander)
    prDeleteAllFiles('*.*', mbPath); // удаление всех файлов в папке mbPath = ...\order\app\actionicons\
//    Stream.Position:= 0;
//    Stream.SaveToFile(mbPath+'actionicons.raw');
    try
      msp:= TMemoryStream.Create;
      Stream.Position:= 0;
      Stream.ReadInt;     // aeSuccess

      Count:= Stream.ReadInt; // кол-во
      for i:= 1 to Count do begin
        ImageFname:= Stream.ReadStr; // имя файла иконки
        fsize:= Stream.ReadInt;  // размер иконки
        if (fsize>0) then begin
          msp.Clear;
          msp.CopyFrom(Stream, fsize); // иконка
          msp.Position:= 0;
          msp.SaveToFile(mbPath+ImageFname); // пишем иконку в файл
        end;
      end;  // for i:= 1
    finally
      prFree(msp);
    end;
//---------------------------------------------------- для Csscommander
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  finally
    Stream.Position:= 0;
  end;
end;
//============================================================ файл медиа-блоков
procedure prGetMediaBloksSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetMediaBloksSrvMng'; // имя процедуры/функции
var GBIBD: TIBDatabase;
    GBIBS: TIBSQL;
    iType, mbLast, fsize, i, j, ShowInt: integer;
    s, mbPath, mbFile, sHint, sWEBLink, MBnum, ss: String;
    arMBnums: Tas;
    arMedia: array of array of Rmedia;
    mBibb: Rmedia;
    ware: TWareInfo;
    pIniFile: TIniFile;
    msp: TMemoryStream;
    Strings: TStrings;
//    LocalStart: TDateTime;
begin
//  LocalStart:= now();
  GBIBS:= nil;
  GBIBD:= nil;
  SetLength(arMBnums, 0);
  SetLength(arMedia, 0, 0);
  Stream.Position:= 0;
  try
    mbLast:= -1;
    with mBibb do begin // готовим заглушку
      InfoType:= cmbBibb;
      WareCode:= 0;
      WareName:= '';
      ShowInterval:= 0;
      actID:= 0;
      actName:= '';
      ms:= TMemoryStream.Create;
    end; // with mBibb

    GBIBD:= CntsGRB.GetFreeCnt();
    GBIBS:= fnCreateNewIBSQL(GBIBD, 'GBIBS_'+nmProc, ThreadData.ID, tpRead, True);
    GBIBS.SQL.Text:=
      'select * from (select num.andtname BlockNum, mr1.MdBlInformationType InfoType,'+
      '    mr1.MdBlShowInterval ShowInterval, mr1.MdBlHint Hint, mr1.MdBlWEBLink WEBLink,'+
      '    mr1.MdBlImage Image, mr1.MdBlImageExtn ImageExt, 0 wCode, 0 WareCode, mr1.mdblcode'+
      '  from MediaBlockReestr mr1'+
      '  left join AnalitDict Num on AndtCode = mr1.MdBlBlockCode'+
      '  where mr1.MdBlDocmState = 1 and (mr1.MdBlInformationType = 2'+
      '    or (mr1.MdBlInformationType = 0'+
      '    and "today" between mr1.MdBlStartdate and mr1.MdBlStopdate))'+
      '  union select num.andtname BlockNum, mr2.MdBlInformationType InfoType,'+
      '    mr2.MdBlShowInterval ShowInterval, mr2.MdBlHint Hint, mr2.MdBlWEBLink WEBLink,'+
      '    null Image, null ImageExt, MdBlWrCode wCode, MdBlWrWareCode WareCode, mr2.mdblcode'+
      '  from MediaBlockReestr mr2'+
      '  left join AnalitDict Num on AndtCode = mr2.MdBlBlockCode'+
      '  left join MediaBlockWares on MdBlWrDocmCode = MdBlCode'+
      '  where mr2.MdBlDocmState = 1 and mr2.MdBlInformationType = 1'+
      '    and "today" between mr2.MdBlStartdate and mr2.MdBlStopdate)'+
      '  order by BlockNum, InfoType, mdblcode, wCode';
    // сортировка - блок, тип, код док-та, код строк док-та (для товаров)
    GBIBS.ExecQuery;
    while not GBIBS.EOF do begin
      s:= GBIBS.FieldByName('BlockNum').AsString; // Номер блока
      if (Length(arMBnums)>0) then mbLast:= High(arMBnums); // текущий индекс
//------------------------------------------------------------- новый медиа-блок
      if (mbLast<0) or (s<>arMBnums[mbLast]) then begin
        mbLast:= mbLast+1;
        SetLength(arMBnums, mbLast+1);
        arMBnums[mbLast]:= s;
        SetLength(arMedia, mbLast+1);
        SetLength(arMedia[mbLast], 1);
        with mBibb do begin // чистим заглушку
          Hint:= '';
          WEBLink:= '';
          ImageFname:= '';
          fsize:= 0;
          ShowInterval:= 0;
          actID:= 0;
          actName:= '';
          ms.Clear;
        end; // with mBibb
      end; // смена медиа-блока
//----------------------------------------------------------------- 1 медиа-блок
      j:= 0;
      while not GBIBS.EOF and (arMBnums[mbLast]=GBIBS.FieldByName('BlockNum').AsString) do begin
        iType:= GBIBS.FieldByName('InfoType').AsInteger;
        // обрабатываем только Тип информации: 0 - Картинка, 1 - Товар, 2 - Заглушка
        if not (iType in [cmbPict, cmbWare, cmbBibb]) then begin
          GBIBS.Next;
          Continue;
        end;
        sHint:= GBIBS.FieldByName('Hint').AsString;       // Всплывающая подсказка
        sHint:= fnChangeEndOfStrBySpace(sHint);
        sWEBLink:= GBIBS.FieldByName('WEBLink').AsString; // Ссылка на ресурс
        sWEBLink:= fnChangeEndOfStrBySpace(sWEBLink);
        ShowInt:= GBIBS.FieldByName('ShowInterval').AsInteger;

        if (iType<>cmbWare) then   // не товар - формируем имя файла картинки
          mbFile:= 'm_pic_'+arMBnums[mbLast]+'_'+IntToStr(j+1)+GBIBS.FieldByName('ImageExt').AsString;

        if (iType<>cmbBibb) then begin // Картинка, Товар (не заглушка)
          if (j>High(arMedia[mbLast])) then SetLength(arMedia[mbLast], j+10);
          with arMedia[mbLast][j] do begin
            InfoType:= iType;
            Hint:= sHint;
            WEBLink:= sWEBLink;
            ShowInterval:= ShowInt;   // ???
            ms:= TMemoryStream.Create;
            if (iType=cmbWare) then begin // товар
              WareCode:= GBIBS.FieldByName('WareCode').AsInteger;
              ware:= Cache.GetWare(WareCode);
              WareName:= ware.Name;
              if ware.IsPrize then begin
                InfoType:= cmbPriz;       // Тип информации: 3 - Товар-подарок
                if ware.IsNews then actID:= -1 else
                if ware.IsCatchMom then actID:= -2 else actID:= 0;
                actName:= '';
              end else actID:= ware.GetActionParams(actName, ss);

              if (Hint='') then Hint:= Ware.Name+' '+Ware.Comment;
              ImageFname:= '';
              fsize:= 0;
                                        // для товара - ищем 1-ю картинку TD
              if (iType=cmbWare) then ImageFname:= Ware.GetFirstTDPictName;

            end else begin
              WareCode:= 0;
              WareName:= '';
              actID:= 0;
              actName:= '';
              ImageFname:= mbFile;
              GBIBS.FieldByName('Image').SaveToStream(ms);
              fsize:= ms.Size;
            end;
          end; // with arMedia[mbLast][iCount]
          inc(j);

        end else with mBibb do begin  // заглушка - берем последнюю
          Hint:= sHint;
          WEBLink:= sWEBLink;
          ShowInterval:= ShowInt;   // ???
          ImageFname:= mbFile;
          ms.Clear; // если несколько заглушек, переписываем
          GBIBS.FieldByName('Image').SaveToStream(ms);
          fsize:= ms.Size;
        end; // with mBibb

        TestCssStopException;
        GBIBS.Next;
      end; // while not GBIBS.EOF and (s=GBIBS.FieldByName('BlockNum').AsString)

      if (Length(arMedia[mbLast])>j) then SetLength(arMedia[mbLast], j);
                                          // если список пустой и есть заглушка
      if (Length(arMedia[mbLast])<1) and (mBibb.ImageFname<>'') then begin
        SetLength(arMedia[mbLast], 1);
        with arMedia[mbLast][0] do begin
          InfoType:= mBibb.InfoType;
          Hint:= mBibb.Hint;
          WEBLink:= mBibb.WEBLink;
          ShowInterval:= mBibb.ShowInterval;   // ???
          WareCode:= 0;
          WareName:= '';
          actID:= 0;
          actName:= '';
          ImageFname:= mBibb.ImageFname;
          ms:= TMemoryStream.Create;
          fsize:= mBibb.ms.Size;
          mBibb.ms.Position:= 0;
          ms.CopyFrom(mBibb.ms, fsize); // картинка
        end;
      end; // если список пустой и есть заглушка

    end; // while not GBIBS.EOF
    GBIBS.Close;

    Stream.Clear;
    Stream.WriteInt(aeSuccess);         // знак того, что запрос обработан корректно
    Stream.WriteInt(Length(arMBnums));  // кол-во блоков
    for i:= 0 to High(arMBnums) do begin
      Stream.WriteStr(arMBnums[i]);        // наименование блока (1, 2, 3)
      Stream.WriteInt(Length(arMedia[i])); // кол-во элементов блока
      for j:= 0 to High(arMedia[i]) do with arMedia[i][j] do begin
        s:= IntToStr(InfoType)+'|'+ // тип: 0 - картинка, 1 - обычный товар, 2 - заглушка, 3 - подарок
            IntToStr(ShowInterval)+'|'+ // интервал отображения
            WEBLink+'|'+            // ссылка, куда идти по щелчку на картинке, если пусто - для InfoType in [1,3] открываем окно просмотра товара
            Hint+'|'+               // текст всплывающей подсказки
            IntToStr(WareCode)+'|'+ // код товара (InfoType in [1,3]), рисунок подтягивается по обычной схеме и вставляется в блок слева
            WareName+'|'+           // наименование товара (InfoType in [1,3]) - выводить в свободной области блока
            IntToStr(actID)+'|'+    // код акции товара (InfoType=1)
            actName+'|';            // наименование акции товара (InfoType=1) - подсказка на иконке акции
        Stream.WriteStr(s);
        Stream.WriteStr(ImageFname); // имя файла картинки в папке media для InfoType in [0,2] или имя файла для товара в tdfiles для InfoType=1
        Stream.WriteInt(fsize);     // размер картинки
        if (fsize>0) then begin
          ms.Position:= 0;
          Stream.CopyFrom(ms, fsize); // картинка
        end;
      end; // for j:= 0 to
    end; // for i:= 0 to

//if flDebug then begin
    mbPath:= fnTestDirEnd(fnCreateTmpDir('', 'media'));  // ???

//---------------------------------- проверяем разборку файла (для Csscommander)
    prDeleteAllFiles('*.*', mbPath); // удаление всех файлов в папке mbPath = ...\order\app\media\
  //  Stream.SaveToFile(mbPath+'media.raw');
    s:= mbPath+'media.ini';          // ini-файл в папке mbPath = ...\order\app\media\
    fnTestFileCreate(s);             // проверяет существование Ini-файла, если нет - создает
    pIniFile:= TINIFile.Create(s);
    msp:= TMemoryStream.Create;
    try
      Stream.Position:= 0;
      Stream.ReadInt;     // aeSuccess

      iType:= Stream.ReadInt; // кол-во блоков
      for i:= 1 to iType do begin
        MBnum:= Stream.ReadStr;  // наименование блока (1, 2, 3) - секция для ini-файла
        mbLast:= Stream.ReadInt; // кол-во элементов блока
        for j:= 1 to mbLast do begin
          s:= Stream.ReadStr;      // строка для ini-файла без имени файла картинки
          mbFile:= Stream.ReadStr; // имя файла картинки
          fsize:= Stream.ReadInt;  // размер картинки
          if (fsize>0) then begin
            msp.Clear;
            msp.CopyFrom(Stream, fsize); // картинка
            msp.Position:= 0;
            msp.SaveToFile(mbPath+mbFile); // пишем картинку в файл
          end;
          pIniFile.WriteString(MBnum, 'm'+IntToStr(j), s+mbFile); // строка в ini-файл
        end; // for j:= 1
      end;  // for i:= 1
    finally
      prFree(msp);
      prFree(pIniFile);
    end;
//---------------------------------------------------- для Csscommander

//----------------------------------------- если не хватает блоков - письмо в СП
    if (Length(arMBnums)<3) and fnGetActionTimeEnable(caeOnlyWorkTime) then try
      Strings:= TStringList.Create;
      s:= '';
      for i:= 0 to High(arMBnums) do s:= s+fnIfStr(s='', '', ', ')+arMBnums[i];
      Strings.Add('ВНИМАНИЕ!');
      Strings.Add(' ');
      if (s='') then
        Strings.Add('Нет данных для медиа-блоков СВК на текущую дату')
      else begin
        Strings.Add('В СВК обновлены медиа-блоки: '+s+',');
        Strings.Add(' ');
        Strings.Add('по другим нет данных на текущую дату');
      end;
      sHint:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // отправляем в УиК
      s:= n_SysMailSend(sHint, 'Нет данных по медиа-блокам', Strings, nil, cNoReplayEmail, '', true);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then // если не записали в файл для отправки
        fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', s, '');
    finally
      prFree(Strings);
    end;

//  prMessageLOGS(nmProc+': - '+GetLogTimeStr(LocalStart), fLogDebug, false);
//end; // if flDebug
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(GBIBS);
  cntsGRB.SetFreeCnt(GBIBD);
  for i:= 0 to High(arMedia) do for j:= 0 to High(arMedia[i]) do prFree(arMedia[i][j].ms);
  SetLength(arMedia, 0, 0);
  SetLength(arMBnums, 0);
end;

//----------------------------------------- v_CSSServerManageProcs

//******************************************************************************
//                     TVSMail - Vladislav Software Mail
//******************************************************************************
constructor TVSMail.Create;
begin
  inherited Create;
  CheckXstring; // def строка для вставки в заголовок письма (SysMailSend)
end;
//========================== строка для вставки в заголовок письма (SysMailSend)
procedure TVSMail.CheckXstring(section: String=''; value: String='');
var s: String;
begin
  if section<>'' then s:= section+': ' else s:= 'X-From-Prg: ';
  if value<>'' then s:= s+value else s:= s+'Vladislav Software';
  s:= s+' ('+GetAppExeName+', '+fnGetComputerName+')';
  if Xstring<>s then Xstring:= s;
end;
//===========================================
procedure TVSMail.OnInitISO(var VHeaderEncoding: Char; var VCharSet: String);
begin
  VCharSet:= IdCharsetNames[FindCharset(cCharSetWin)];
//  VHeaderEncoding:= 'B';     { base64 / quoted-printable }
end;

//******************************************************************************
//                          TSearchWareOrOnum
//******************************************************************************
constructor TSearchWareOrOnum.Create(pID, pSatCount: Integer; pIsWare, pIsMarket: Boolean; parAnalogs: Tai=nil);
var i: Integer;
begin
  ID:= pID;
  if pIsMarket then RestSem:= 0 else RestSem:= -1;
  IsWare:= pIsWare;
  SatCount:= pSatCount;
  OLAnalogs:= TObjectList.Create; // (TTwoCodes - ID, sem)
  if Assigned(parAnalogs) and (Length(parAnalogs)>0) then
    for i:= 0 to High(parAnalogs) do OLAnalogs.Add(TTwoCodes.Create(parAnalogs[i], -1));
  AddComment:= '';
  SemTitle:= '';
end;
//==============================================================================
destructor TSearchWareOrOnum.Destroy;
begin
  prFree(OLAnalogs);
  inherited;
end;

//******************************************************************************
//=================================================== проверка остановки системы
procedure TestCssStopException;
begin
  if AppStatus in [stSuspending, stSuspended, stExiting] then
    raise EBOBError.Create('процесс прерван из-за остановки системы');
end;
//================================ Перевести значение поля Fname ibsql в boolean
function GetBoolGB(ibsql: TIBSQL; Fname: string): boolean;
begin
  Result:= False;
  if not Assigned(ibsql) or (Fname='') or (ibsql.FieldIndex[Fname]<0) then Exit;
  Result:= ibsql.fieldByName(Fname).AsString='T';
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; repeats: Integer=RepeatCount): string;
// выполняет IBSQL RepeatCount попыток
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 1 to repeats do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<repeats) then
        Sleep(RepeatSaveInterval) // ждем немного
      else begin
        Result:= E.Message;
        break;
      end;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var StrValue: string; repeats: Integer=RepeatCount): string;
// выполняет IBSQL RepeatCount попыток, возвращает символьное значение заданного поля
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 1 to repeats do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if (Fname<>'') and not (IBS.Bof and IBS.Eof) then
      StrValue:= IBS.FieldByName(Fname).AsString;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<repeats) then
        Sleep(RepeatSaveInterval) // ждем немного
      else begin
        Result:= E.Message;
        break;
      end;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; var FnamesValues: Tas; repeats: Integer=RepeatCount): string;
// FnamesValues на входе - имена полей,
// FnamesValues на выходе - символьные значениz соответствующих полей
// выполняет IBSQL RepeatCount попыток
var i, j: integer;
    s: string;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 1 to repeats do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if not (IBS.Bof and IBS.Eof) and (length(FnamesValues)>0) then
      for j:= 0 to High(FnamesValues) do begin
        s:= FnamesValues[j];
        if (s='') then Continue;
        if (IBS.FieldIndex[s]<0) then s:= '' else s:= IBS.FieldByName(s).AsString;
        FnamesValues[j]:= s;
      end; // for
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<repeats) then
        Sleep(RepeatSaveInterval) // ждем немного
      else begin
        Result:= E.Message;
        break;
      end;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var IntValue: Integer; repeats: Integer=RepeatCount): string;
// выполняет IBSQL RepeatCount попыток, возвращает числовое значение заданного поля
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 1 to repeats do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if (Fname<>'') and not (IBS.Bof and IBS.Eof) then
      IntValue:= IBS.FieldByName(Fname).AsInteger;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<repeats) then
        Sleep(RepeatSaveInterval) // ждем немного
      else begin
        Result:= E.Message;
        break;
      end;
    end;
  end;
  IBS.Close;
end;
//============================================= путь к рабочим файлам сотрудника
function GetEmplTmpFilePath(EmplID: Integer; var pFilePath, errmess: string): boolean;
begin
  errmess:= '';
  pFilePath:= '';
  with Cache do if not EmplExist(EmplID) then errmess:= MessText(mtkNotEmplExist)
  else begin
    pFilePath:= GetAppExePath+'TMP';
    if DirectoryExists(pFilePath) or ForceDirectories(pFilePath) then begin
      pFilePath:= fnTestDirEnd(pFilePath)+arEmplInfo[EmplID].ServerLogin;
      if not DirectoryExists(pFilePath) and not ForceDirectories(pFilePath) then
        errmess:= MessText(mtkNotCreateDir, pFilePath);
    end else errmess:= MessText(mtkNotCreateDir, pFilePath);
  end;
  Result:= errmess='';
  if Result then pFilePath:= fnTestDirEnd(pFilePath);
end;
{//====================================================== Проверить систему фирмы
function CheckNotValidFirmSys(FirmID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  if (FirmID<>isWe) and not Cache.arFirmInfo[FirmID].CheckSysType(SysID) then
    errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;     }
//====================== Проверить права сотрудника на работу с моделями системы
function CheckNotValidModelManage(UserID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  with Cache do if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else if not EmplExist(UserID) then errmess:= MessText(mtkNotEmplExist)
  else with arEmplInfo[UserId] do
    if ((SysID=constIsAuto) and not UserRoleExists(rolModelManageAuto)) or
      ((SysID=constIsMoto) and not UserRoleExists(rolModelManageMoto)) then
      errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;
//================= Проверить права сотрудника на работу с деревом узлов системы
function CheckNotValidTNAManage(UserID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  with Cache do if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else if not EmplExist(UserID) then errmess:= MessText(mtkNotEmplExist)
  else with arEmplInfo[UserId] do
    if ((SysID=constIsAuto) and not UserRoleExists(rolTNAManageAuto))
      or ((SysID=constIsMoto) and not UserRoleExists(rolTNAManageMoto))
      or ((SysID=constIsCV) and not UserRoleExists(rolTNAManageCV)) then
      errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;
//=============================== Получить производителя и проверить доступность
function CheckNotValidManuf(ManufID: Integer; SysID: Integer;
         var Manuf: TManufacturer; var errmess: string): boolean;
begin
  errmess:= '';
  if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else with Cache.FDCA do
    if not Manufacturers.ManufExists(ManufID) then
      errmess:= MessText(mtkNotFoundManuf, IntToStr(ManufID))
    else begin
      Manuf:= Manufacturers[ManufID];
      if not Manuf.CheckIsTypeSys(SysID) then
        errmess:= MessText(mtkNotSysManuf, IntToStr(SysID));
    end;
  Result:= errmess<>'';
end;
//====================== Получить модельный ряд, систему и проверить доступность
function CheckNotValidModelLine(ModelLineID: Integer; var SysID: Integer;
         var ModelLine: TModelLine; var errmess: string): boolean;
begin
  errmess:= '';
  if not Cache.FDCA.ModelLines.ModelLineExists(ModelLineID) then
    errmess:= MessText(mtkNotFoundModLine, IntToStr(ModelLineID))
  else begin
    ModelLine:= Cache.FDCA.ModelLines[ModelLineID];
    SysID:= ModelLine.TypeSys;
    if not CheckTypeSys(SysID) then
      errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID));
  end;
  Result:= errmess<>'';
end;
//============================= Получить модель, систему и проверить доступность
function CheckNotValidModel(ModelID: Integer; var SysID: Integer;
         var Model: TModelAuto; var errmess: string): boolean;
begin
  errmess:= '';
  if not Cache.FDCA.Models.ModelExists(ModelID) then
    errmess:= MessText(mtkNotFoundModel, IntToStr(ModelID))
  else begin
    Model:= Cache.FDCA.Models.GetModel(ModelID);
    SysID:= Model.TypeSys;
    if not CheckTypeSys(SysID) then
      errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID));
  end;
  Result:= errmess<>'';
end;

//******************************************************************************
//                    функции по работе с заказами и т.п.
//******************************************************************************
//==========Уточняет статус заказа и возвращает данные по закрывающим документам
function fnGetClosingDocsOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
         var Status: integer; id: Integer=-1): string;
const nmProc = 'fnGetClosingDocsOrd'; // имя процедуры/функции
var ibsGB, ibsOrd: TIBSQL;
    ibGB, ibOrd: TIBDatabase;
    Closed, Annulated: boolean;
    i, accCode: integer;
    sid: string;
begin
  if (Cache.GetConstItem(pcClosingDocsFromOrd).IntValue=1) then begin // док-ты из Order
    Result:= fnGetClosingDocsFromOrd(ORDRCODE, Accounts, Invoices, Status, id);
    Exit;
  end;

  Result:= '';                                              // из Grossbee
  sid:= '_GCD'+fnIfStr(id<0, '', '_'+IntToStr(id))+'_'+ORDRCODE;
  ibsOrd:= nil;
  ibOrd:= nil;
  ibsGB:= nil;
  ibsGB:= nil;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  Closed:= true;
  try try
    ibOrd:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+sid, -1, tpRead, True);
    ibsOrd.SQL.Text:= 'SELECT ORDRSTATUS, ORDRGBACCCODE'+
                      ' FROM ORDERSREESTR WHERE ORDRCODE='+ORDRCODE;
    ibsOrd.ExecQuery;
    if (ibsOrd.Bof and ibsOrd.Eof) then Exit;

    Status:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger;
    accCode:= ibsOrd.FieldByName('ORDRGBACCCODE').AsInteger;
    ibsOrd.Transaction.Rollback;
    ibsOrd.Close;
    if not (Status in [orstAccepted..orstClosed]) or (accCode<1) then Exit;

    ibGB:= cntsGRB.GetFreeCnt;
    try
      ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+sid, -1, tpRead, True);
      ibsGB.SQL.Text:= 'Select d.* from Vlad_CSS_GetAllClosingDocs('+IntToStr(accCode)+
                       ') d where d.PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
      ibsGB.ExecQuery;
      i:= 0;
      while not ibsGB.Eof do begin
        SetLength(Accounts, i+1);
        SetLength(Invoices, i+1);
        with Accounts[i] do begin // заносим данные счета в структуру
          ID          := ibsGB.FieldByName('PInvCode').AsInteger;
          Number      := ibsGB.FieldByName('PInvNumber').AsString;
          Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
          Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
          CurrencyCode:= ibsGB.FieldByName('PInvCrnc').AsInteger;
          CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
          Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
          Commentary  := ibsGB.FieldByName('PINVCOMMENT').AsString;
          DprtID      := ibsGB.FieldByName('PInvDprt').AsInteger;
        end;
        with Invoices[i] do begin // заносим данные накладной в структуру
          ID:= ibsGB.FieldByName('INVCODE').AsInteger;
          if ID>0 then begin        // проверяем, закрыт ли счет
            Number      := ibsGB.FieldByName('INVNUMBER').AsString;
            Data        := ibsGB.FieldByName('INVDATE').AsDateTime;
            Summa       := ibsGB.FieldByName('INVSUMM').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('INVCRNC').AsInteger;
            CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
            DprtID      := ibsGB.FieldByName('INVDPRT').AsInteger;
          end else Number:= '';
          Closed:= Closed and (ID>0);
        end;
        inc(i);
        cntsGRB.TestSuspendException;
        ibsGB.Next;
      end;
    finally
      prFreeIBSQL(ibsGB);
      cntsGRB.SetFreeCnt(ibGB);
    end;

    Annulated:= i<1; // если не найдены счета - аннулируем заказ
    if Annulated then Closed:= False;
    i:= 0;
    if (Annulated and (Status<>orstAnnulated)) then i:= orstAnnulated   // если все счета аннулированы, аннулируем заказ
    else if (Closed and (Status<>orstClosed)) then i:= orstClosed       // если все счета закрыты, закрываем заказ
    else if (not Closed and (Status=orstClosed)) then i:= orstAccepted; // если не все счета закрыты, открываем заказ

    if i>0 then begin
      fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
      if i=orstAnnulated then begin
        ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+','+
          ' ORDRANNULATEREASON=:ORDRANNULATEREASON, ORDRANNULATEDATE="NOW" where ORDRCODE='+ORDRCODE;
        ibsOrd.ParamByName('ORDRANNULATEREASON').AsString:= 'Все '+fnGetGBDocName(docAccount, 1, 1)+' по заказу аннулированы.';
      end else
        ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+' where ORDRCODE='+ORDRCODE;

      Result:= RepeatExecuteIBSQL(ibsOrd);
      if Result='' then Status:= i;
    end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//==========Уточняет статус заказа и возвращает данные по закрывающим документам
function fnGetClosingDocsFromOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
         var Status: integer; id: Integer=-1): string;
const nmProc = 'fnGetClosingDocsFromOrd'; // имя процедуры/функции
var ibsOrd: TIBSQL;
    ibOrd: TIBDatabase;
    Closed, Annulated: boolean;
    i: integer;
    sid: string;
begin
  Result:= '';
  sid:= '_GCD'+fnIfStr(id<0, '', '_'+IntToStr(id))+'_'+ORDRCODE;
  ibsOrd:= nil;
  ibOrd:= nil;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  Closed:= true;
  try try
    ibOrd:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+sid, -1, tpRead, True);
//    ibsOrd.SQL.Text:= 'SELECT ORDRSTATUS FROM ORDERSREESTR WHERE ORDRCODE='+ORDRCODE;
//    ibsOrd.ExecQuery;
//    if (ibsOrd.Bof and ibsOrd.Eof) then Exit;
//    Status:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger;
//    ibsOrd.Close;
    if not (Status in [orstAccepted..orstClosed]) then Exit;
    i:= 0;
    ibsOrd.SQL.Text:= 'select * from OrdersClosingDocs where OCDOrderCode='+
                      ORDRCODE+' order by OCDOrderCode, OCDACCCODE';
    ibsOrd.ExecQuery;
    while not ibsOrd.Eof do begin
      SetLength(Accounts, i+1);
      SetLength(Invoices, i+1);
      with Accounts[i] do begin // заносим данные счета в структуру
        ID          := ibsOrd.FieldByName('OCDAccCode').AsInteger;
        Number      := ibsOrd.FieldByName('OCDAccNumber').AsString;
        Data        := ibsOrd.FieldByName('OCDAccDate').AsDateTime;
        Summa       := ibsOrd.FieldByName('OCDAccSumm').AsFloat;
        CurrencyCode:= ibsOrd.FieldByName('OCDAccCrnc').AsInteger;
        CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
        Processed   := GetBoolGB(ibsOrd, 'OCDAccPROCESSED');
        Commentary  := ibsOrd.FieldByName('OCDAccCOMMENT').AsString;
        DprtID      := ibsOrd.FieldByName('OCDAccDprt').AsInteger;
      end;
      with Invoices[i] do begin // заносим данные накладной в структуру
        ID:= ibsOrd.FieldByName('OCDInvCODE').AsInteger;
        if ID>0 then begin        // проверяем, закрыт ли счет
          Number      := ibsOrd.FieldByName('OCDInvNUMBER').AsString;
          Data        := ibsOrd.FieldByName('OCDInvDATE').AsDateTime;
          Summa       := ibsOrd.FieldByName('OCDInvSUMM').AsFloat;
          CurrencyCode:= ibsOrd.FieldByName('OCDInvCRNC').AsInteger;
          CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
          DprtID      := ibsOrd.FieldByName('OCDInvDPRT').AsInteger;
        end else Number:= '';
        Closed:= Closed and (ID>0);
      end;
      inc(i);
      cntsORD.TestSuspendException;
      ibsOrd.Next;
    end;

    Annulated:= i<1; // если не найдены счета - аннулируем заказ
    if Annulated then Closed:= False;
    i:= 0;
    if (Annulated and (Status<>orstAnnulated)) then i:= orstAnnulated   // если все счета аннулированы, аннулируем заказ
    else if (Closed and (Status<>orstClosed)) then i:= orstClosed       // если все счета закрыты, закрываем заказ
    else if (not Closed and (Status=orstClosed)) then i:= orstAccepted; // если не все счета закрыты, открываем заказ

    if i>0 then begin
      fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
      ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+
        fnIfStr(i=orstAnnulated, ', ORDRANNULATEDATE="NOW",'+
          ' ORDRANNULATEREASON="Все '+fnGetGBDocName(docAccount, 1, 1)+' по заказу аннулированы."', '')+
        ' where ORDRCODE='+ORDRCODE;
      Result:= RepeatExecuteIBSQL(ibsOrd);
      if Result='' then Status:= i;
    end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//================================ пакетная проверка закрывающие док-тов заказов
procedure CheckClosingDocsAll(CompareTime: boolean=True);
const nmProc = 'CheckClosingDocsAll'; // имя процедуры/функции
var tbegin, tend, tt: TDateTime;
    i: Integer;
begin
  if not Cache.flCheckClosingDocs then Exit;
//  tt:= StrToDate('01.01.2017');
  tt:= IncMonth(Date, -2);
           // время последней сверки закрывающих документов заказов
  tbegin:= Cache.GetConstItem(pcCheckClosingDocsTime).DateValue;
  if (tbegin<1) then tbegin:= IncMonth(Date, -2);
  tend:= Now;

  if CompareTime then begin // интервал сверки закрывающих документов заказов в мин
    i:= Cache.GetConstItem(pcCheckClosDocsInterval).IntValue;
    if IncMinute(tbegin, i)>tend then Exit; // рано проверять
  end;

  if (tbegin>tt) then tbegin:= IncMinute(tbegin, -2); // запас 2 мин.
  CheckClosingDocsByPeriod_new(tbegin, tend);
end;
(*//===================== проверка закрывающие док-тов заказов за период изменений
procedure CheckClosingDocsByPeriod(tbegin, tend: TDateTime; flSaveTime: boolean=True; flalter: boolean=True);
const nmProc = 'CheckClosingDocsByPeriod'; // имя процедуры/функции
var ibGB, ibOrd, ibOrdw: TIBDatabase;
    ibsGB, ibsOrd, ibsOrdw, ibsOrda: TIBSQL;
    LocalStart: TDateTime;
    i, OrdCount, accCount, OrdCode, accCode, invCode, accInd, j, jj, EditCount,
      Status, iOrd: Integer;
    Accounts, Invoices: TDocRecArr;
    lstBlock, lstBlockG, errmess: TStringList;
    sCode, ss, s: String;
    OrdCodes, OrdStats, OrdAccs: Tai;
begin
  ibGB:= nil;
  ibsGB:= nil;
  ibsOrd:= nil;
  ibsOrdw:= nil;
  ibsOrda:= nil;
  ibOrd:= nil;
  ibOrdw:= nil;
  LocalStart:= now();
  OrdCount:= 0;
  EditCount:= 0;
  SetLength(Accounts, 10);
  SetLength(Invoices, 10);
  SetLength(OrdCodes, 1000);
  SetLength(OrdStats, Length(OrdCodes));
  SetLength(OrdAccs, Length(OrdCodes));
  lstBlock:= TStringList.Create;
  errmess:= TStringList.Create;
  lstBlockG:= TStringList.Create;
  try try
    ibGB:= cntsGRB.GetFreeCnt;
    ibOrd:= cntsORD.GetFreeCnt;
    ibOrdw:= cntsORD.GetFreeCnt;
    ibsOrda:= fnCreateNewIBSQL(ibOrd, 'ibsOrda_'+nmProc, -1, tpRead);
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, -1, tpRead, True);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpRead, True);

    if ((Date-tbegin)>1) then begin // новый день - проверяем "зависшие" счета
      ibsOrd.SQL.Text:= 'SELECT min(ORDRGBACCTIME) FROM ORDERSREESTR'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+
        ' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2016"'+
        ' and ORDRGBACCTIME<:tbegin';
      ibsOrd.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsOrd.ExecQuery;
      if not ibsOrd.Fields[0].IsNull and (ibsOrd.Fields[0].AsDateTime>0) then
        tbegin:= ibsOrd.Fields[0].AsDateTime;
      ibsOrd.Close;
    end;

    if flalter then begin //---------- коды заказов по альтер-таблице в Grossbee
      // вынимаем список кодов заказов с изменениями за период из Grossbee
      ibsGB.SQL.Text:= 'Select rOrderCode from'+
        ' Vlad_CSS_GetChangedOrderCodes(:tbegin, :tend)'; // order by rOrderCode
      ibsGB.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsGB.ParamByName('tend').AsDateTime  := tend;
      ibsGB.ExecQuery;
      jj:= 0;
      while not ibsGB.Eof do begin
        if High(OrdCodes)<jj then SetLength(OrdCodes, jj+1000);
        OrdCodes[jj]:= ibsGB.FieldByName('rOrderCode').AsInteger; // код заказа
        inc(jj);
        TestCssStopException;
        ibsGB.Next;
      end;
      ibsGB.Close;
      if Length(OrdCodes)>jj then SetLength(OrdCodes, jj);
      SetLength(OrdStats, Length(OrdCodes));
      SetLength(OrdAccs, Length(OrdCodes));

      ibsOrda.SQL.Text:= 'select ORDRGBACCCODE, ORDRSTATUS FROM ORDERSREESTR WHERE ORDRCODE=:ord';
      ibsOrda.Prepare;

    end else begin  // коды заказов из Order за период ORDRGBACCTIME
      ibsOrd.SQL.Text:= 'SELECT ORDRCODE, ORDRGBACCCODE, ORDRSTATUS FROM ORDERSREESTR'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2016"'+
        ' and ORDRGBACCTIME between :tbegin and :tend';  //  order by ORDRCODE
      ibsOrd.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsOrd.ParamByName('tend').AsDateTime  := tend;
      ibsOrd.ExecQuery;
      jj:= 0;
      while not ibsOrd.Eof do begin
        if High(OrdCodes)<jj then begin
          SetLength(OrdCodes, jj+1000);
          SetLength(OrdStats, Length(OrdCodes));
          SetLength(OrdAccs, Length(OrdCodes));
        end;
        OrdCodes[jj]:= ibsOrd.FieldByName('ORDRCODE').AsInteger; // код заказа
        OrdStats[jj]:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger; // статус заказа
        OrdAccs[jj]:= ibsOrd.FieldByName('ORDRGBACCCODE').AsInteger; // код счета
        inc(jj);
        TestCssStopException;
        ibsOrd.Next;
      end;
      ibsOrd.Close;
      if Length(OrdCodes)>jj then begin
        SetLength(OrdCodes, jj);
        SetLength(OrdStats, Length(OrdCodes));
        SetLength(OrdAccs, Length(OrdCodes));
      end;
    end;
    TestCssStopException;
    OrdCount:= Length(OrdCodes);

    if OrdCount>0 then begin //------------------- если есть заказы для проверки
      ibsOrd.SQL.Text:= 'select * from OrdersClosingDocs'+
                        ' where OCDOrderCode=:ord order by OCDOrderCode, OCDACCCODE';
      ibsOrd.Prepare;
      ibsGB.SQL.Text:= 'select d.*, PIAVORDCODE from Vlad_CSS_GetAllClosingDocs(:acc) d'+
        ' left join PAYINVALTER_VLAD on PIAVACCCODE=d.PInvCode'+
        ' where d.PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
      ibsGB.Prepare;

      jj:= 0;
      for iOrd:= 0 to High(OrdCodes) do begin
        OrdCode:= OrdCodes[iOrd]; // код заказа

        if flalter then begin
          TestCssStopException;
          ibsOrda.ParamByName('ord').AsInteger:= OrdCode; // код 1-го счета по заказу
          ibsOrda.ExecQuery;
          accCode:= ibsOrda.FieldByName('ORDRGBACCCODE').AsInteger;
          Status:= ibsOrda.FieldByName('ORDRSTATUS').AsInteger;
          ibsOrda.Close;
        end else begin
          accCode:= OrdAccs[iOrd];
          Status:= OrdStats[iOrd];
        end;

        TestCssStopException;
        ibsGB.ParamByName('acc').AsInteger:= accCode;
        ibsGB.ExecQuery;
        accCount:= 0; //------------------------- док-ты по 1 заказу из Grossbee
        while not ibsGB.Eof do begin
          if High(Accounts)<accCount then begin
            SetLength(Accounts, accCount+10);
            SetLength(Invoices, accCount+10);
          end;
          with Accounts[accCount] do begin // заносим данные счета в структуру
            ID          := ibsGB.FieldByName('PInvCode').AsInteger;
            Number      := ibsGB.FieldByName('PInvNumber').AsString;
            Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
            Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('PInvCrnc').AsInteger;
            Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
            Commentary  := CheckSpecSumbs(ibsGB.FieldByName('PINVCOMMENT').AsString);
            DprtID      := ibsGB.FieldByName('PInvDprt').AsInteger;
          end;
          with Invoices[accCount] do begin // заносим данные накладной в структуру
            ID          := ibsGB.FieldByName('INVCODE').AsInteger;
            if (ID>0) then begin
              Number      := ibsGB.FieldByName('INVNUMBER').AsString;
              Data        := ibsGB.FieldByName('INVDATE').AsDateTime;
              Summa       := ibsGB.FieldByName('INVSUMM').AsFloat;
              CurrencyCode:= ibsGB.FieldByName('INVCRNC').AsInteger;
              DprtID      := ibsGB.FieldByName('INVDPRT').AsInteger;
            end;
          end;

          if (ibsGB.FieldByName('PIAVORDCODE').AsInteger<1) then // список для записи кода заказа
            lstBlockG.Add('execute procedure Vlad_CSS_SetAlterAccount('+
              ibsGB.FieldByName('PInvCode').AsString+', 0, '+IntToStr(OrdCode)+', 2);');

          Inc(accCount);
          TestCssStopException;
          ibsGB.Next;
        end; //--------------------------- док-ты по 1 заказу из Grossbee
        ibsGB.Close;

        lstBlock.Clear;  // строки изменений по 1 заказу для execute block
        ibsOrd.Close;
        ibsOrd.ParamByName('ord').AsInteger:= OrdCode;
        ibsOrd.ExecQuery;
        while not ibsOrd.Eof do begin //---- проверяем док-ты по 1 заказу из Order
          accCode:= ibsOrd.FieldByName('OCDAccCode').AsInteger;
          invCode:= ibsOrd.FieldByName('OCDInvCODE').AsInteger;
          sCode:= ' where OCDCODE='+ibsOrd.FieldByName('OCDCODE').AsString+';';
          accInd:= -1;
          if invCode>0 then for i:= 0 to accCount-1 do // сначала ищем строку с такой накладной
            if (Accounts[i].ID=accCode) and (Invoices[i].ID=invCode) then begin
              accInd:= i;
              break;
            end;
          if (accInd<0) then for i:= 0 to accCount-1 do // потом ищем строку без накладной
            if (Accounts[i].ID=accCode) and (Invoices[i].ID=0) then begin
              accInd:= i;
              break;
            end;

          if (accInd<0) then // если счета (с накладной/без накладной) в Grossbee нет
            lstBlock.Add('delete from OrdersClosingDocs'+sCode) // - удаляем строку

          else begin    // если строку нашли - сравниваем
            ss:= ''; // строка изменений по 1 счету
            with Accounts[accInd] do begin
              if (Number<>ibsOrd.FieldByName('OCDAccNumber').AsString) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccNumber='+fnStrQuoted(Number);
              if (Data<>ibsOrd.FieldByName('OCDAccDate').AsDateTime) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDate='+
                     fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDAccSumm').AsFloat) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccSumm='+fnSetDecSep(FloatToStr(Summa), 3);
              if (CurrencyCode<>ibsOrd.FieldByName('OCDAccCrnc').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCrnc='+IntToStr(CurrencyCode);
              if (Processed<>GetBoolGB(ibsOrd, 'OCDAccPROCESSED')) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccPROCESSED='+
                     fnStrQuoted(fnIfStr(Processed, 'T', 'F'));
              if (DprtID<>ibsOrd.FieldByName('OCDAccDprt').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDprt='+IntToStr(DprtID);
              if (Commentary<>CheckSpecSumbs(ibsOrd.FieldByName('OCDAccCOMMENT').AsString)) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCOMMENT='+fnStrQuoted(Commentary);
              ID:= 0; // счет из Grossbee проверен - обнуляем код
            end;

            with Invoices[accInd] do if (ID>0) then begin // есть есть накладная - проверяем
              if (ID<>invCode) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE='+IntToStr(ID);
              if (Number<>ibsOrd.FieldByName('OCDInvNUMBER').AsString) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER='+fnStrQuoted(Number);
              if (Data<>ibsOrd.FieldByName('OCDInvDATE').AsDateTime) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE='+
                     fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM='+fnSetDecSep(FloatToStr(Summa), 3);
              if (CurrencyCode<>ibsOrd.FieldByName('OCDInvCRNC').AsInteger) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC='+IntToStr(CurrencyCode);
              if (DprtID<>ibsOrd.FieldByName('OCDInvDPRT').AsInteger) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT='+IntToStr(DprtID);

            end else if (invCode>0) then begin // если нет и была накладная в Order - убираем
              ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE=0';
              if (ibsOrd.FieldByName('OCDInvNUMBER').AsString<>'') then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER=""';
              if not ibsOrd.FieldByName('OCDInvDATE').IsNull then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE=null';
              if fnNotZero(ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM=0';
              if (ibsOrd.FieldByName('OCDInvCRNC').AsInteger>0) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC=0';
              if (ibsOrd.FieldByName('OCDInvDPRT').AsInteger>0) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT=0';
            end;
            if (ss<>'') then
              lstBlock.Add(' if (exists(select * from ordersreestr where ordrcode='+
                IntToStr(OrdCode)+')) then update OrdersClosingDocs set '+ss+sCode);
          end;
          TestCssStopException;
          ibsOrd.Next;
        end; //--------------------- док-ты по 1 заказу из Order
        ibsOrd.Close;
{
        if (accCount<1) and (Status<orstAnnulated) then // если не найдены счета - аннулируем заказ
          lstBlock.Add('update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstAnnulated)+','+
            ' ORDRANNULATEREASON="Все счета по заказу аннулированы.",'+
            ' ORDRANNULATEDATE="NOW" where ORDRCODE='+IntToStr(OrdCode)+';')

         else if (accCount>0) and (Status=orstAnnulated) then // если найдены счета - восстанавливаем заказ
          lstBlock.Add('update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstClosed)+','+
            ' ORDRANNULATEREASON="", ORDRANNULATEDATE=null where ORDRCODE='+IntToStr(OrdCode)+';');
}
        for i:= 0 to accCount-1 do if Accounts[i].ID>0 then begin // ищем счета, кот.не хватает
          ss:= ' insert into OrdersClosingDocs (OCDOrderCode, OCDAccCode, OCDAccNumber,'+
            ' OCDAccDate, OCDAccCrnc, OCDAccSumm, OCDAccPROCESSED, OCDAccDprt, OCDAccCOMMENT'+
            fnIfStr(Invoices[i].ID<1, '', ', OCDInvCODE, OCDInvNUMBER,'+
              ' OCDInvDPRT, OCDInvCRNC, OCDInvSUMM, OCDInvDATE')+
            ') values ('+IntToStr(OrdCode)+', ';

          with Accounts[i] do ss:= ss+IntToStr(ID)+', '+fnStrQuoted(Number)+', '+
            fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data))+', '+
            IntToStr(CurrencyCode)+', '+fnSetDecSep(FloatToStr(Summa), 3)+', '+
            fnStrQuoted(fnIfStr(Processed, 'T', 'F'))+', '+
            IntToStr(DprtID)+', '+fnStrQuoted(Commentary);

          if (Invoices[i].ID>0) then with Invoices[i] do ss:= ss+', '+IntToStr(ID)+', '+
            fnStrQuoted(Number)+', '+IntToStr(DprtID)+', '+IntToStr(CurrencyCode)+', '+
            fnSetDecSep(FloatToStr(Summa), 3)+', '+
            fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
          ss:= ss+');';
          lstBlock.Add(' if (exists(select * from ordersreestr where ordrcode='+IntToStr(OrdCode)+')) then');
          lstBlock.Add(ss);
        end;
        TestCssStopException;

        if (lstBlock.Count>0) then try  // вносим изменения в таблицу OrdersClosingDocs
          if not Assigned(ibsOrdw) then  // создаем только при необходимости
            ibsOrdw:= fnCreateNewIBSQL(ibOrdw, 'ibsOrdw_'+nmProc, -1, tpWrite); // для записи
          lstBlock.Insert(0, 'execute block as begin ');
          lstBlock.Add(' end');
          with ibsOrdw.Transaction do if not InTransaction then StartTransaction;
          ibsOrdw.SQL.Clear;
          ibsOrdw.SQL.AddStrings(lstBlock);
          ibsOrdw.ExecQuery;
          ibsOrdw.Transaction.Commit;
          Inc(EditCount);
        except
          on E: Exception do begin
            ibsOrdw.Transaction.Rollback;
            flSaveTime:= False;
            prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogCache, false);
            if flTestDocs then for j:= 0 to lstBlock.Count-1 do errmess.Add(lstBlock[j]);
          end;
        end;
        if Assigned(ibsOrdw) then ibsOrdw.Close;

        if (jj>100) then begin // вывод процесса в лог
          jj:= 0;
          if flTestDocs then prMessageLOGS(nmProc+': '+IntToStr(iOrd+1)+
            ' зак., изм - '+IntToStr(EditCount), fLogDebug, false);
          Application.ProcessMessages;
        end else inc(jj);

        TestCssStopException;
      end; // for iOrd

      jj:= lstBlockG.Count;
      if lstBlockG.Count>0 then fnSetTransParams(ibsGB.Transaction, tpWrite, True);
      ibsGB.SQL.Clear;
      for i:= lstBlockG.Count-1 downto 0 do begin
        ibsGB.SQL.Add(lstBlockG[i]);
        lstBlockG.Delete(i);
        if (i=0) or (ibsGB.SQL.Count>99) then begin
          try  // вносим изменения в таблицу PAYINVALTER_VLAD
            if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
            ibsGB.SQL.Insert(0, 'execute block as begin ');
            ibsGB.SQL.Add(' end');
            ibsGB.ExecQuery;
            ibsGB.Transaction.Commit;
          except
            on E: Exception do begin
              ibsGB.Transaction.Rollback;
              flSaveTime:= False;
              prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogCache, false);
              if flTestDocs then for j:= 0 to lstBlockG.Count-1 do errmess.Add(lstBlockG[j]);
            end;
          end;
          ibsGB.SQL.Clear;
        end; // if (i=0) or
        TestCssStopException;
      end; // for i:= lstBlockG.Count
      if flTestDocs then
        prMessageLOGS(nmProc+': кодов зак. в Gr - '+IntToStr(jj), fLogDebug, false);

    end else  // if OrdCount>0
    if flTestDocs then
      prMessageLOGS(nmProc+': '+MessText(mtkNotFoundOrders)+' для сверки док-тов', fLogDebug, false);
  except
    on E: Exception do begin
      flSaveTime:= False;
      if flTestDocs then prMessageLOGS(nmProc+': '+E.Message, fLogDebug, false);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
    prFreeIBSQL(ibsOrdw);
    prFreeIBSQL(ibsOrda);
    cntsOrd.SetFreeCnt(ibOrdw);
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    SetLength(Accounts, 0);
    SetLength(Invoices, 0);
    SetLength(OrdCodes, 0);
    SetLength(OrdStats, 0);
    SetLength(OrdAccs, 0);
    prFree(lstBlock);
    prFree(lstBlockG);
    if flSaveTime then begin // пишем время сверки закрывающих документов
      i:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
      s:= FormatDateTime(cDateTimeFormatY4S, tend);
      Cache.SaveNewConstValue(pcCheckClosingDocsTime, i, s);
    end;
    prMessageLOGS(nmProc+': '+IntToStr(OrdCount)+
      ' зак, '+IntToStr(EditCount)+' изм - '+GetLogTimeStr(LocalStart), fLogCache, false);
    if flTestDocs then                  // если были ошибки - пишем в лог
      for j:= 0 to errmess.Count-1 do prMessageLOGS(errmess[j], fLogDebug, false);
    prFree(errmess);
  end;
  TestCssStopException;
end; *)
//-----------------------------------------------------
type TCheckData = class
  OrderID: Integer;
  OrdCodes:  TIntegerList;   // коды заказов к счету
  Account, Invoice: TDocRec; // параметры счета, накладной
  constructor Create;
  destructor Destroy; override;
end;
constructor TCheckData.Create;
begin
  inherited Create;
  OrdCodes:= TIntegerList.Create;
end;
destructor TCheckData.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(OrdCodes);
  inherited Destroy;
end;
//===================== проверка закрывающих док-тов заказов за период изменений
procedure CheckClosingDocsByPeriod_new(tbegin, tend: TDateTime; flSaveTime: boolean=True);
const nmProc = 'CheckClosingDocsByPeriod_new'; // имя процедуры/функции
var ibGB, ibOrd: TIBDatabase;
    ibsGB, ibsOrd: TIBSQL;
    LocalStart: TDateTime;
    i, AccCount, EditCount, AddCount, DelCount, invCode, accInd, j, jj, jd: Integer;
    lstBlock, errmess: TStringList;
    sCode, ss, s: String;
    olData: TObjectList;
    olTmp: TList;
    cd, cd1: TCheckData;
  //-------------------------------------------------------
  function FindAccOrdData(acc, ord: Integer): Integer;
  // возвращает: -2 - не нашли, -1 - нашли с этим заказом,
  // >-1 - индекс элемента с параметрами счета
  var ii: Integer;
  begin
    result:= -2;
    for ii:= 0 to olData.Count-1 do begin
      cd:= TCheckData(olData[ii]);
      if (cd.Account.ID<>acc) then Continue;
      result:= ii;
      if (ord<1) then exit;
      if (cd.OrdCodes.IndexOf(ord)<0) then Continue;
      result:= -1;
      exit;
    end;
  end;
  //-------------------------------------------------------
begin
  ibGB:= nil;
  ibsGB:= nil;
  ibOrd:= nil;
  ibsOrd:= nil;
  LocalStart:= now();
  lstBlock:= TStringList.Create; // строки изменений для execute block
  errmess:= TStringList.Create;
  AccCount:= 0;
  EditCount:= 0;
  AddCount:= 0;
  DelCount:= 0;
  olTmp:= TList.Create;  // доп.список кодов объединенных счетов с кодами заказов
  olData:= TObjectList.Create; // список счетов с прикрепленными кодами заказов
  try try
    ibGB:= cntsGRB.GetFreeCnt;
    ibOrd:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, -1, tpRead);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpRead);
                                      // новый день - проверяем "зависшие" счета  ???
    if not SameDate(Date, tbegin) {((Date-tbegin)>1)} then begin
      if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
      ibsOrd.SQL.Text:= 'SELECT min(ORDRGBACCTIME) FROM ORDERSREESTR'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+
        ' and ORDRSTATUS<'+IntToStr(orstClosed)+' and ORDRGBACCCODE>0'+ // orstAnnulated
        ' and ORDRGBACCTIME between :dd and :tbegin';
      ibsOrd.ParamByName('dd').AsDateTime:= Date-30; // за месяц
      ibsOrd.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsOrd.ExecQuery;
      if not ibsOrd.Fields[0].IsNull and (ibsOrd.Fields[0].AsDateTime>0) then
        tbegin:= ibsOrd.Fields[0].AsDateTime;
      ibsOrd.Close;
      ibsOrd.SQL.Clear;
    end;
    TestCssStopException;

    if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
    ibsGB.SQL.Text:= 'select piavAccCode PInvCode, piavOrdCode, PInvNumber, PInvDate,'+
      '  PInvCrncCode, PInvSupplyDprtCode, PInvSumm, PINVPROCESSED, PINVCLIENTCOMMENT,'+
      '  INVCCODE, INVCNUMBER, INVCDATE, INVCSUMM, INVCCRNCCODE, INVCSUPPLYDPRTCODE,'+
      '  PINVANNULKEY, pinvcombinedcode from (select piavAccCode, piavOrdCode from'+
      '  (select p1.piavAccCode, p1.piavOrdCode from payinvalter_vlad p1'+ // счета CSS
      '    where p1.piavLastTime between :tbegin and :tend and p1.piavAccCode is not null'+
      '  union select prc.pinvcode piavAccCode, p11.piavOrdCode from payinvalter_vlad p11'+
      '    left join payinvoicereestr pr on pr.pinvcode = p11.piavAccCode'+
      '    left join payinvoicereestr prc on prc.pinvcode = pr.pinvcombinedcode'+
      '    where p11.piavLastTime between :tbegin and :tend'+ // объединенные счета
      '      and prc.pinvcode is not null and pr.pinvannulkey = "T"'+
      '  union select p2.piavAccCode, p2.piavOrdCode from invoicealter_vlad'+
      '    left join INVOICEREESTR on INVCCODE=iavInvCode'+   // накладные
      '    left join SUBCONTRACT on SbCnCode=INVCSUBCONTRACT and SbCnDocmType=99'+
      '    left join payinvalter_vlad p2 on p2.piavAccCode=SbCnDocmCode'+
      '    where iavLastTime between :tbegin and :tend and p2.piavAccCode is not null)'+
      '  group by piavAccCode, piavOrdCode order by piavAccCode, piavOrdCode) s'+
      '  left join PayInvoiceReestr r on r.PInvCode=s.piavAccCode'+
      '  left join SUBCONTRACT sb on sb.SbCnDocmCode=r.PInvCode and sb.SbCnDocmType=99'+
      '  left join INVOICEREESTR i on i.INVCSUBCONTRACT=sb.SbCnCode'+
      '  where (PInvCode>0) and ((piavOrdCode is not null and piavOrdCode>0)'+
      '    or (pinvwebcomment is not null and pinvwebcomment<>""))';
    ibsGB.ParamByName('tbegin').AsDateTime:= tbegin;
    ibsGB.ParamByName('tend').AsDateTime  := tend;
    ibsGB.ExecQuery;
    while not ibsGB.Eof do begin
      invCode:= ibsGB.FieldByName('PInvCode').AsInteger;
      jd:= ibsGB.FieldByName('pinvcombinedcode').AsInteger;
      jj:= ibsGB.FieldByName('piavOrdCode').AsInteger;
      if GetBoolGB(ibsGB, 'PINVANNULKEY') then begin  // если счет аннулирован
        // если есть объединенный счет - запоминаем к заказу вместо аннулированного
        if (jd>0) then begin
          cd:= TCheckData.Create;
          cd.Account.ID:= jd;
          if (jj>0) then cd.OrdCodes.Add(jj);
          ibsOrd.Close;
          if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
          if (ibsOrd.SQL.Text='') then
            ibsOrd.SQL.Text:= 'select OCDOrderCode from OrdersClosingDocs where OCDAccCode=:acc';
          ibsOrd.ParamByName('acc').AsInteger:= invCode;
          ibsOrd.ExecQuery;
          while not ibsOrd.Eof do begin //------ строки по 1 аннулированному счету
            i:= ibsOrd.FieldByName('OCDOrderCode').AsInteger;
            if (i>0) then cd.OrdCodes.Add(i); // добавляем код заказа к счету
            TestCssStopException;
            ibsOrd.Next;
          end; //  while not ibsOrd.Eof
          olTmp.Add(cd);
        end; // if (jd>0)
        ibsOrd.Close;
                                                     // удаляем строки по счету
        lstBlock.Add('delete from OrdersClosingDocs where OCDAccCode='+IntToStr(invCode)+';');
        while not ibsGB.Eof and (invCode=ibsGB.FieldByName('PInvCode').AsInteger) do
          ibsGB.Next;
        Inc(AccCount);
        Inc(DelCount);
        Continue;
      end;

      accInd:= FindAccOrdData(invCode, jj);
      if (accInd=-2) then begin //-------------------- не нашли
        cd:= TCheckData.Create;
        if (jj>0) then cd.OrdCodes.Add(jj); // добавляем код заказа к счету
        with cd.Account do begin // заносим данные счета в структуру
          ID          := invCode;
          Number      := ibsGB.FieldByName('PInvNumber').AsString;
          Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
          Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
          CurrencyCode:= ibsGB.FieldByName('PInvCrncCode').AsInteger;
          Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
          Commentary  := CheckSpecSumbs(fnReplaceQuotedForWeb(ibsGB.FieldByName('PINVCLIENTCOMMENT').AsString));
          DprtID      := ibsGB.FieldByName('PInvSupplyDprtCode').AsInteger;
        end;
        with cd.Invoice do begin // заносим данные накладной в структуру
          ID            := ibsGB.FieldByName('INVCCODE').AsInteger;
          if (ID>0) then begin
            Number      := ibsGB.FieldByName('INVCNUMBER').AsString;
            Data        := ibsGB.FieldByName('INVCDATE').AsDateTime;
            Summa       := ibsGB.FieldByName('INVCSUMM').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('INVCCRNCCODE').AsInteger;
            DprtID      := ibsGB.FieldByName('INVCSUPPLYDPRTCODE').AsInteger;
          end;
        end;
        olData.Add(cd); // добавляем новый элемент с параметрами счета

      end else if (accInd>-1) and (jj>0) then // нашли элемент с параметрами счета
        cd.OrdCodes.Add(jj); // добавляем код заказа к счету

      Inc(AccCount);
      TestCssStopException;
      ibsGB.Next;
    end;
    ibsGB.Close;
    ibsGB.SQL.Clear;
    //------------------------------ обрабатываем доп.список объединенных счетов
    s:= '';
    for i:= olTmp.Count-1 downto 0 do begin
      cd1:= TCheckData(olTmp[i]);
      jj:= FindAccOrdData(cd1.Account.ID, 0); // ищем объединенные счета

      if (jj<0) then begin // не нашли счет - заполняем параметры счета
        if (ibsGB.SQL.Text='') then begin
          if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
          ibsGB.SQL.Text:= 'select PInvNumber, PInvDate, PInvCrncCode,'+
            '  PInvSupplyDprtCode, PInvSumm, PINVPROCESSED, PINVCLIENTCOMMENT,'+
            '  PINVANNULKEY, INVCCODE, INVCNUMBER, INVCDATE, INVCSUMM,'+
            '  INVCCRNCCODE, INVCSUPPLYDPRTCODE from PayInvoiceReestr'+
            '  left join SUBCONTRACT on SbCnDocmCode=PInvCode and SbCnDocmType=99'+
            '  left join INVOICEREESTR on INVCSUBCONTRACT=SbCnCode where PInvCode=:acc';
        end;
        ibsGB.ParamByName('acc').AsInteger:= cd1.Account.ID;
        ibsGB.ExecQuery;
        if not (ibsGB.Eof and ibsGB.Bof) then begin
          with cd1.Account do begin // заносим данные счета в структуру
            Number      := ibsGB.FieldByName('PInvNumber').AsString;
            Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
            Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('PInvCrncCode').AsInteger;
            Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
            Commentary  := CheckSpecSumbs(fnReplaceQuotedForWeb(ibsGB.FieldByName('PINVCLIENTCOMMENT').AsString));
            DprtID      := ibsGB.FieldByName('PInvSupplyDprtCode').AsInteger;
          end;
          with cd1.Invoice do begin // заносим данные накладной в структуру
            ID            := ibsGB.FieldByName('INVCCODE').AsInteger;
            if (ID>0) then begin
              Number      := ibsGB.FieldByName('INVCNUMBER').AsString;
              Data        := ibsGB.FieldByName('INVCDATE').AsDateTime;
              Summa       := ibsGB.FieldByName('INVCSUMM').AsFloat;
              CurrencyCode:= ibsGB.FieldByName('INVCCRNCCODE').AsInteger;
              DprtID      := ibsGB.FieldByName('INVCSUPPLYDPRTCODE').AsInteger;
            end;
          end;
          olData.Add(cd1); // переносим элемент в общий список
          Inc(AccCount);
        end; // else prFree(cd);
        ibsGB.Close;

      end else                    // нашли - добавляем коды заказов
        for jj:= 0 to cd1.OrdCodes.Count-1 do cd.OrdCodes.Add(cd1.OrdCodes[jj]);

    end; // for i:= olTmp.Count-1 downto 0
//------------------------------------------------- если есть счета для проверки
    s:= '';
    ss:= '';
    if (olData.Count>0) then begin
      ibsOrd.Close;
      if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
      ibsOrd.SQL.Text:= 'select d.*, iif(ordrcode is null, '+IntToStr(orstNoDefinition)+
        ', ORDRSTATUS) STATUS from OrdersClosingDocs d'+
        ' left join ordersreestr on ordrcode=d.OCDOrderCode where d.OCDAccCode=:acc';
      for accInd:= 0 to olData.Count-1 do begin
        cd:= TCheckData(olData[accInd]);
        jj:= 0;
        jd:= 0;
        ibsOrd.Close;
        ibsOrd.ParamByName('acc').AsInteger:= cd.Account.ID;
        ibsOrd.ExecQuery;
        while not ibsOrd.Eof do begin //------------ проверяем строки по 1 счету
          i:= ibsOrd.FieldByName('STATUS').AsInteger;

          if (i=orstNoDefinition) then j:= -1
          else j:= cd.OrdCodes.IndexOf(ibsOrd.FieldByName('OCDOrderCode').AsInteger);
          if (j>-1) then cd.OrdCodes.Delete(j); // удаляем код проверенного заказа

          sCode:= ' where OCDCODE='+ibsOrd.FieldByName('OCDCODE').AsString+';';

          if (i=orstNoDefinition) or (i=orstAnnulated) then begin // если заказа нет или аннулирован
            lstBlock.Add('delete from OrdersClosingDocs'+sCode); // удаляем строку
            Inc(jd);

          end else begin // проверяем изменения
            invCode:= ibsOrd.FieldByName('OCDInvCODE').AsInteger;
            ss:= ''; // строка изменений
            with cd.Account do begin
              if (Number<>ibsOrd.FieldByName('OCDAccNumber').AsString) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccNumber='+fnStrQuoted(Number);
              if (Data<>ibsOrd.FieldByName('OCDAccDate').AsDateTime) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDate='+
                     fnStrQuoted(FormatDateTime(cDateFormatY4, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDAccSumm').AsFloat) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccSumm='+fnSetDecSep(FloatToStr(Summa), 3);
              if (CurrencyCode<>ibsOrd.FieldByName('OCDAccCrnc').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCrnc='+IntToStr(CurrencyCode);
              if (Processed<>GetBoolGB(ibsOrd, 'OCDAccPROCESSED')) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccPROCESSED='+
                     fnStrQuoted(fnIfStr(Processed, 'T', 'F'));
              if (DprtID<>ibsOrd.FieldByName('OCDAccDprt').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDprt='+IntToStr(DprtID);
              if (Commentary<>CheckSpecSumbs(ibsOrd.FieldByName('OCDAccCOMMENT').AsString)) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCOMMENT='+fnStrQuoted(Commentary);
            end; // with cd.Account
            with cd.Invoice do if (ID>0) then begin // есть есть накладная - проверяем
              if (ID<>invCode) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE='+IntToStr(ID);
              if (Number<>ibsOrd.FieldByName('OCDInvNUMBER').AsString) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER='+fnStrQuoted(Number);
              if (Data<>ibsOrd.FieldByName('OCDInvDATE').AsDateTime) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE='+
                     fnStrQuoted(FormatDateTime(cDateFormatY4, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM='+fnSetDecSep(FloatToStr(Summa), 3);
              if (CurrencyCode<>ibsOrd.FieldByName('OCDInvCRNC').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC='+IntToStr(CurrencyCode);
              if (DprtID<>ibsOrd.FieldByName('OCDInvDPRT').AsInteger) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT='+IntToStr(DprtID);
            end else if (invCode>0) then begin // если нет и была накладная в Order - убираем
              ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE=0';
              if (ibsOrd.FieldByName('OCDInvNUMBER').AsString<>'') then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER=""';
              if not ibsOrd.FieldByName('OCDInvDATE').IsNull then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE=null';
              if fnNotZero(ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM=0';
              if (ibsOrd.FieldByName('OCDInvCRNC').AsInteger>0) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC=0';
              if (ibsOrd.FieldByName('OCDInvDPRT').AsInteger>0) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT=0';
            end; // with cd.Invoice
            if (ss<>'') then begin
              lstBlock.Add(' update OrdersClosingDocs set '+ss+sCode);
              Inc(jj);
            end;
          end; // проверили изменения

          TestCssStopException;
          ibsOrd.Next;
        end; //  while not ibsOrd.Eof
        ibsOrd.Close;
        if (jj>0) then Inc(EditCount);
        if (jd>0) then Inc(DelCount);

        for j:= 0 to cd.OrdCodes.Count-1 do begin //------------ добавляем новые
          with cd.Account do begin
            s:= 'OCDOrderCode, OCDAccCode, OCDAccNumber, OCDAccDate, OCDAccCrnc,'+
                ' OCDAccDprt, OCDAccSumm, OCDAccPROCESSED, OCDAccCOMMENT';
            ss:= IntToStr(cd.OrdCodes[j])+', '+IntToStr(ID)+', "'+Number+'", "'+
                 FormatDateTime(cDateFormatY4, Data)+'", '+IntToStr(CurrencyCode)+
                 ', '+IntToStr(DprtID)+', '+fnSetDecSep(FloatToStr(Summa), 3)+', "'+
                 fnIfStr(Processed, 'T', 'F')+'", "'+Commentary+'"';
          end; // with cd.Account
          with cd.Invoice do if (ID>0) then begin
            s:= s+', OCDInvCODE, OCDInvDPRT, OCDInvNUMBER, OCDInvDATE, OCDInvSUMM, OCDInvCRNC';
            ss:= ss+', '+IntToStr(ID)+', '+IntToStr(DprtID)+', "'+Number+'", "'+
                 FormatDateTime(cDateFormatY4, Data)+'", '+
                 fnSetDecSep(FloatToStr(Summa), 3)+', '+IntToStr(CurrencyCode);
          end; //  with cd.Invoice
          lstBlock.Add(' if(exists(select * from ordersreestr'+
            ' where ordrcode='+IntToStr(cd.OrdCodes[j])+')) then'+
            '  update or insert into OrdersClosingDocs ('+s+') values ('+ss+')'+
            ' matching (OCDOrderCode, OCDAccCode);');
          Inc(AddCount);
        end; // for j:= 0 to cd.OrdCodes.Count-1
      end; // accInd:= 0 to olData.Count-1
    end;  // if (olData.Count>0)

    if (lstBlock.Count>0) then begin
      ibsOrd.SQL.Clear;
      fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
      for i:= lstBlock.Count-1 downto 0 do begin
        ibsOrd.SQL.Add(lstBlock[i]);
        lstBlock.Delete(i);
        if (i=0) or (ibsOrd.SQL.Count>49) then begin
          try  // вносим изменения в таблицу
            if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
            ibsOrd.SQL.Insert(0, 'execute block as begin ');
            ibsOrd.SQL.Add(' end');
            ibsOrd.ExecQuery;
            ibsOrd.Transaction.Commit;
          except
            on E: Exception do begin
              ibsOrd.Transaction.Rollback;
              flSaveTime:= False;
              prMessageLOGS(nmProc+': execute block '#10+E.Message, fLogCache, false);
              if flTestDocs then
                for j:= 0 to ibsOrd.SQL.Count-1 do errmess.Add(ibsOrd.SQL[j]);
            end;
          end;
          ibsOrd.SQL.Clear;
        end; // if (i=0) or
        TestCssStopException;
      end; // for i:= lstBlock.Count-1 downto 0
    end; // if (lstBlock.Count>0)

  except
    on E: Exception do begin
      flSaveTime:= False;
      if flTestDocs then prMessageLOGS(nmProc+': '+E.Message, fLogDebug, false);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    prFree(lstBlock);
    prFree(olTmp);
    prFree(olData);
    if flSaveTime then begin // пишем время сверки закрывающих документов
      i:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
      s:= FormatDateTime(cDateTimeFormatY4S, tend);
      Cache.SaveNewConstValue(pcCheckClosingDocsTime, i, s);
    end;
    prMessageLOGS(nmProc+': '+IntToStr(AccCount)+' acc '+
      fnIfStr(AddCount>0, IntToStr(AddCount)+' add ', '')+
      fnIfStr(DelCount>0, IntToStr(DelCount)+' del ', '')+
      fnIfStr(EditCount>0, IntToStr(EditCount)+' edit ', '')+
      ' - '+GetLogTimeStr(LocalStart), fLogCache, false);
    if flTestDocs then begin
      if (AccCount>0) then s:= ': проверено - '+IntToStr(AccCount)
      else s:= ': Не найдены счета для сверки док-тов';
      prMessageLOGS(nmProc+s, fLogDebug, false);             // если были ошибки
      for j:= 0 to errmess.Count-1 do prMessageLOGS(errmess[j], fLogDebug, false);
    end;
    prFree(errmess);
  end;
  TestCssStopException;
end;
(*
//======== заполнить таблицу закр.док-тов и проставить коды заказов закр.док-там
procedure FillOrdersClosingDocs(FirstRecs: Integer=0);
const nmProc = 'FillOrdersClosingDocs'; // имя процедуры/функции
var ibGB, ibOrd, ibGBr, ibOrdr: TIBDatabase;
    ibsGB, ibsOrd, ibsGBr, ibsOrdr: TIBSQL;
    iDocs, iAcc, j, iCount, iAnul: Integer;
    flInv, flAnul: Boolean;
    lstBlock: TStringList;
    LocalStart, dLast, dAnul: TDateTime;
    sInv1, sInv2: String;
begin
  ibsGB:= nil;
  ibsOrd:= nil;
  ibsGBr:= nil;
  ibsOrdr:= nil;
//  ibGB:= nil;
//  ibOrd:= nil;
  lstBlock:= TStringList.Create;
  iDocs:= 0; // счетчик строк док-тов
  iAcc:= 0; // счетчик счетов, у кот. проставлен код заказа
  iAnul:= 0; // счетчик аннулированных заказов
  LocalStart:= now();
  try
    ibOrdr:= cntsORD.GetFreeCnt;
    try
      ibsOrdr:= fnCreateNewIBSQL(ibOrdr, 'ibsOrdr_'+nmProc, -1, tpRead, True);
      ibsOrdr.SQL.Text:= 'SELECT'+fnIfStr(FirstRecs>0, ' first '+IntToStr(FirstRecs), '')+
        ' ORDRCODE, ORDRGBACCCODE, ORDRGBACCTIME FROM ORDERSREESTR'+
        ' left join OrdersClosingDocs on OCDOrderCode=ORDRCODE'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2011" and OCDOrderCode is null'+
        ' order by ORDRCODE';
      ibsOrdr.ExecQuery;
      if (ibsOrdr.Eof and ibsOrdr.Bof) then begin
        if flTest then prMessageLOGS(nmProc+': '+MessText(mtkNotFoundOrders)+' без документов', fLogDebug, false);
        Exit;
      end;

      ibGBr:= cntsGRB.GetFreeCnt;
      ibGB:= cntsGRB.GetFreeCnt;
      ibOrd:= cntsORD.GetFreeCnt;
      try
        ibsGBr:= fnCreateNewIBSQL(ibGBr, 'ibsGBr_'+nmProc, -1, tpRead, True);
        ibsGB := fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpWrite);   // для записи
        ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, -1, tpWrite); // для записи
        j:= 0;
        while not ibsOrdr.Eof do begin //------------ идем по списку заказов
              // вынимаем список закрывающих док-тов по 1 заказу из Grossbee
          ibsGBr.SQL.Text:= 'select d.*, PIAVLASTTIME, PIAVORDCODE, IAVLASTTIME'+
            ' from Vlad_CSS_GetAllClosingDocs('+ibsOrdr.FieldByName('ORDRGBACCCODE').AsString+') d'+
            ' left join PAYINVALTER_VLAD on PIAVACCCODE=d.PInvCode'+
            ' left join INVOICEALTER_VLAD on IAVINVCODE=d.InvCODE'+
            ' where PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
          ibsGBr.ExecQuery;
          lstBlock.Clear;
          iCount:= 0; // счетчик счетов по 1 заказу
          while not ibsGBr.Eof do begin
            flInv:= ibsGBr.FieldByName('InvCODE').AsInteger>0;
                                // вычисляем последнее время изменений
            dLast:= max(ibsGBr.FieldByName('PIAVLASTTIME').AsDateTime,
                        ibsOrdr.FieldByName('ORDRGBACCTIME').AsDateTime);
            if flInv then
              dLast:= max(dLast, ibsGBr.FieldByName('IAVLASTTIME').AsDateTime);
                                   // список для записи кода заказа
            if ibsGBr.FieldByName('PIAVORDCODE').AsInteger<1 then
              lstBlock.Add('execute procedure Vlad_CSS_SetAlterAccount('+
                ibsGBr.FieldByName('PInvCode').AsString+', 0, '+
                ibsOrdr.FieldByName('ORDRCODE').AsString+', 2);');

            try     //---------------------- пишем строку с док-тами в Ord
              with ibsOrd.Transaction do if not InTransaction then StartTransaction;
              if flInv then begin
                sInv1:= ', OCDInvCODE, OCDInvNUMBER, OCDInvDPRT,'+
                        ' OCDInvCRNC, OCDInvSUMM, OCDInvDATE';
                sInv2:= ', '+ibsGBr.FieldByName('InvCODE').AsString+', :InvNUMBER, '+
                        ibsGBr.FieldByName('InvDPRT').AsString+', '+
                        ibsGBr.FieldByName('InvCRNC').AsString+', :InvSUMM, :InvDATE';
              end else begin
                sInv1:= '';
                sInv2:= '';
              end;
              ibsOrd.SQL.Text:= 'insert into OrdersClosingDocs (OCDOrderCode,'+
                ' OCDAccCode, OCDAccNumber, OCDAccDate, OCDAccCrnc, OCDAccSumm,'+
                ' OCDAccPROCESSED, OCDAccDprt, OCDAccCOMMENT, OCDTIMEADD'+sInv1+
                ') values ('+ibsOrdr.FieldByName('ORDRCODE').AsString+', '+
                ibsGBr.FieldByName('PInvCode').AsString+', :AccNumber, :AccDate, '+
                ibsGBr.FieldByName('PInvCrnc').AsString+','+' :AccSumm, :AccPROCESSED, '+
                ibsGBr.FieldByName('PInvDprt').AsString+', :AccCOMMENT, :OCDTIME'+sInv2+')';
              ibsOrd.ParamByName('AccNumber').AsString   := ibsGBr.FieldByName('PInvNumber').AsString;
              ibsOrd.ParamByName('AccDate').AsDateTime   := ibsGBr.FieldByName('PInvDate').AsDateTime;
              ibsOrd.ParamByName('AccSumm').AsFloat      := ibsGBr.FieldByName('PInvSumm').AsFloat;
              ibsOrd.ParamByName('AccPROCESSED').AsString:= ibsGBr.FieldByName('PINVPROCESSED').AsString;
              ibsOrd.ParamByName('AccCOMMENT').AsString  := ibsGBr.FieldByName('PInvCOMMENT').AsString;
              ibsOrd.ParamByName('OCDTIME').AsDateTime   := dLast;
              if flInv then begin
                ibsOrd.ParamByName('InvNUMBER').AsString := ibsGBr.FieldByName('InvNUMBER').AsString;
                ibsOrd.ParamByName('InvSUMM').AsFloat    := ibsGBr.FieldByName('InvSUMM').AsFloat;
                ibsOrd.ParamByName('InvDATE').AsDateTime := ibsGBr.FieldByName('InvDATE').AsDateTime;
              end;
              ibsOrd.ExecQuery;
              ibsOrd.Transaction.Commit;
              Inc(iCount);
              Inc(iDocs);

              if j>100 then begin // вывод процесса в лог
                j:= 0;
                if flTest then prMessageLOGS(nmProc+': '+IntToStr(iDocs)+' док., '+
                  IntToStr(iAcc+lstBlock.Count)+' сч., '+IntToStr(iAnul)+' аннул.', fLogDebug, false);
                Application.ProcessMessages;
              end else inc(j);
            except
              on E: Exception do begin
                prMessageLOGS(nmProc+': insert into OrdersClosingDocs ORDRCODE='+
                  ibsOrdr.FieldByName('ORDRCODE').AsString+#10+E.Message, fLogDebug, false);
                ibsOrd.Transaction.Rollback;
              end;
            end;
            ibsOrd.Close;

            ibsGBr.Next;
          end;
          ibsGBr.Close; // прошли список закрывающих док-тов по 1 заказу из Grossbee

          if lstBlock.Count>0 then try  // проставляем код заказа счетам в альтер-таблице Grossbee
            Inc(iAcc, lstBlock.Count);
            lstBlock.Insert(0, 'execute block as begin');
            lstBlock.Add('end');
            with ibsGB.Transaction do if not InTransaction then StartTransaction;
            ibsGB.SQL.Clear;
            ibsGB.SQL.AddStrings(lstBlock);
            ibsGB.ExecQuery;
            ibsGB.Transaction.Commit;
          except
            on E: Exception do begin
              prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogDebug, false);
              ibsGB.Transaction.Rollback;
            end;
          end;
          ibsGB.Close;

          if (iCount<1) then begin                   // если счетов не нашли
            dAnul:= Now;
            ibsGBr.SQL.Text:= 'select PInvAnnulDate, PInvAnnulKey from PAYINVOICEREESTR'+
                              ' where PInvCode='+ibsOrdr.FieldByName('ORDRGBACCCODE').AsString;
            ibsGBr.ExecQuery;        // проверяем аннуляцию связанного счета
            flAnul:= (ibsGBr.Bof and ibsGBr.Eof);
            if not flAnul and (ibsGBr.FieldByName('PInvAnnulKey').AsString='T') then begin
              flAnul:= True;
              if not ibsGBr.FieldByName('PInvAnnulDate').IsNull then begin // дата аннуляции
                dAnul:= ibsGBr.FieldByName('PInvAnnulDate').AsDateTime;
                if (YearOf(dAnul)<2000) then dAnul:= Now; // на всяк.случай
              end;
            end;
            if flAnul then try                               // аннулируем заказ
              with ibsOrd.Transaction do if not InTransaction then StartTransaction;
              ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstAnnulated)+
                ', ORDRANNULATEREASON=:anulREASON, ORDRANNULATEDATE=:anulDate'+
                ' where ORDRCODE='+ibsOrdr.FieldByName('ORDRCODE').AsString;
              ibsOrd.ParamByName('anulREASON').AsString:= 'Все счета по заказу аннулированы.';
              ibsOrd.ParamByName('anulDate').AsDateTime:= dAnul;
              ibsOrd.ExecQuery;
              ibsOrd.Transaction.Commit;
              Inc(iAnul);
            except
              on E: Exception do begin
                prMessageLOGS(nmProc+': update ORDERSREESTR '+#10+E.Message, fLogDebug, false);
                ibsOrd.Transaction.Rollback;
              end;
            end;
            ibsGBr.Close;
          end;
          cntsOrd.TestSuspendException;
          ibsOrdr.Next;
        end;
      finally
        prFreeIBSQL(ibsOrd);
        cntsOrd.SetFreeCnt(ibOrd);
        prFreeIBSQL(ibsGB);
        cntsGRB.SetFreeCnt(ibGB);
        prFreeIBSQL(ibsGBr);
        cntsGRB.SetFreeCnt(ibGBr);
      end;
    finally
      prFreeIBSQL(ibsOrdr);
      cntsOrd.SetFreeCnt(ibOrdr);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+#10+E.Message, fLogDebug, false);
  end;
  prFree(lstBlock);
  if flTest then prMessageLOGS(nmProc+': '+IntToStr(iDocs)+
    ' док-тов, '+IntToStr(iAcc)+' сч., '+IntToStr(iAnul)+' аннул. - '+GetLogTimeStr(LocalStart), fLogDebug, false);
end;
*)
(*
//================================= сформировать счет в Grossbee (главный склад)
procedure prOrderToGBn_Ord(Stream: TBoBMemoryStream; ThreadData: TThreadData; CreateMail: boolean=false);
const nmProc = 'prOrderToGBn_Ord'; // имя процедуры/функции
      nfdeadlock = 'deadlock';
//------------------------------------------ параметры заказа (для записи счета)
type
  ROrderOpts = record
    ORDRCODE, DCACCODE, FirmID, ORDRSOURCE, recCloseDocs, contID, deliv, DprtID,
      DestID, ttID, smID, stID, accType, currID: Integer;
    ORDRNUM, DCACNUMBER, commDeliv, commWarrant, comment: String;
    pDate: TDateTime;
    Firma: TFirmInfo;
    Contract: TContract;
  end;
var i, TryCount, ErrCount, RecCount: integer;
    s, s1, ss2, s3, ss3, ErrorStr, ErrStr, STORAGEnew, wCode, WaresErrMess, accLine, ss1: String;
    Success, ChangeStorage, ErrTransGB, flSaveCont, flCheckShipParams: boolean;
    accLines: TStringList;
    ibGB, ibGBt, ibOrd, ibOrdW: TIBDatabase;
    ibsGB, ibsOrd, ibsOrdW, ibsGBt: TIBSQL;
    price, Qty, AccSumm: Double;
    Ware: TWareInfo;
    LocalStart, dd: TDateTime;
    Order: ROrderOpts;
{  //-------------------------------------------
  procedure SaveToLogTransInfo(emess, dop: string);
  var i: integer;
      s, ntr: string;
  begin
    i:= pos('concurrent transaction number is ', emess);
    if i<1 then exit;
    s:= '';
    ntr:= copy(emess, i+33, length(emess));
    for i:= 1 to length(ntr) do
      if SysUtils.CharInSet(ntr[i], ['0'..'9']) then s:= s+ntr[i] else break;
    if s='' then exit;
    try
      prMessageLOGS(' ', nfdeadlock, False);
      prMessageLOGS('E.Message: '+emess, nfdeadlock, False);
      prMessageLOGS('TransInfo (id='+s+') --------------- begin', nfdeadlock, False);
      if dop<>'' then prMessageLOGS('addi_info: '+dop, nfdeadlock, False);
      with ibsGBt.Transaction do if not InTransaction then StartTransaction;
      if ibsGBt.SQL.Text='' then begin
        ibsGBt.SQL.Text:= 'select T.mon$timestamp tr_begin, '+
          ' DATEDIFF(SECOND FROM T.mon$timestamp TO current_timestamp) tr_sec, '+
          ' A.mon$user tr_user, A.mon$remote_process tr_proc, '+
          ' cast( S.mon$sql_text as varchar (2400)) tr_sql from MON$TRANSACTIONS T'+
          ' left join MON$STATEMENTS S on S.mon$transaction_id = T.mon$transaction_id'+
          ' left join MON$ATTACHMENTS A on A.mon$attachment_id = T.mon$attachment_id'+
          ' where T.mon$transaction_id = :tid';
        ibsGBt.Prepare;
      end;
      ibsGBt.ParamByName('tid').AsString:= s;
      ibsGBt.ExecQuery;
      while not ibsGBt.Eof do begin
        prMessageLOGS('tr_begin='+ibsGBt.Fields[0].AsString+
          ', tr_sec='+ibsGBt.Fields[1].AsString+
          ', tr_user='+ibsGBt.Fields[2].AsString+
          ', tr_proc='+ibsGBt.Fields[3].AsString, nfdeadlock, False);
        prMessageLOGS('tr_sql='+ibsGBt.Fields[4].AsString, nfdeadlock, False);
        ibsGBt.Next;
      end;
      prMessageLOGS('TransInfo (id='+s+') --------------- end'#10#10, nfdeadlock, False);
    except
      on E: Exception do ErrorStr:= ErrorStr+#13#10'error SaveToLogTransInfo:'+E.Message;
    end;
    if ibsGBt.Transaction.InTransaction then ibsGBt.Transaction.Rollback;
    ibsGBt.Close;
  end;  }
  //-------------------------------------------
begin
  LocalStart:= now();
  ErrorStr:= '';   // сообщение о глобальной ошибке
  ErrStr:= '';     // сообщение об ошибках записи товаров
  ErrCount:= 0;
  RecCount:= 0;
  ErrTransGB:= False;
  ibsOrd:= nil;
  ibsOrdW:= nil;
  ibGB:= nil;
  ibOrd:= nil;
  ibsGB:= nil;
  ibsGBt:= nil;
  ibGBt:= nil;
  accLines:= TStringList.Create;
  Order.contID:= 0;
  flSaveCont:= False;
  Order.Contract:= nil;
  try try
    Stream.Position:= 0;
    Order.ORDRCODE:= Stream.ReadInt;
    flCheckShipParams:= Stream.ReadBool;

    ibOrd:= cntsORD.GetFreeCnt;                           // тут всякие проверки
    ibOrdW:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, ThreadData.ID, tpWrite);
    ibsOrdW:= fnCreateNewIBSQL(ibOrdW, 'ibsOrdW_'+nmProc, ThreadData.ID, tpRead, True);

//    Order.sORDRCODE:= IntToStr(Order.ORDRCODE);

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.SQL.Text:= 'SELECT ORDRACCOUNTINGTYPE, ORDRNUM, ORDRCODE, ORDRFIRM,'+
      ' ORDRSOURCE, ORDRDATE, ORDRWARRANT, ORDRWARRANTPERSON, ORDRWARRANTDATE,'+
      ' ORDRSTORAGECOMMENT, ORDRDELIVERYTYPE, ORDRCONTRACT, ORDRSHIPDATE,'+
      ' ORDRDESTPOINT, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID, ORDRCURRENCY'+
      ' FROM ORDERSREESTR WHERE ORDRCODE='+IntToStr(Order.ORDRCODE);
    ibsOrdW.ExecQuery;
    if (ibsOrdW.Bof and ibsOrdW.Eof) then raise Exception.Create(MessText(mtkNotValidParam));

    Order.FirmID:= ibsOrdW.FieldByName('ORDRFIRM').AsInteger; // проверяем фирму
    if (Order.FirmID<1) then raise Exception.Create(MessText(mtkNotFirmExists));
    Cache.TestFirms(Order.FirmID, True);
    if not Cache.FirmExist(Order.FirmID) then raise Exception.Create(MessText(mtkNotFirmExists));

//    Order.ORDRFIRM:= IntToStr(Order.FirmID);
    Order.Firma:= Cache.arFirmInfo[Order.FirmID];
    Order.contID:= ibsOrdW.FieldByName('ORDRCONTRACT').AsInteger;
    i:= Order.contID;
    Order.Contract:= Order.Firma.GetContract(Order.contID);
    if (Order.Contract.Status=cstClosed) then           // проверка на доступность контракта
      raise Exception.Create('Контракт '+Order.Contract.Name+' недоступен');

    Order.accType:= ibsOrdW.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;

    flSaveCont:= (Order.contID>0) and (i<>Order.contID) and not Order.Contract.Fictive;
    Order.DprtID:= Order.Contract.MainStorage;
//    Order.STORAGE:= Order.Contract.MainStoreStr;

    Order.currID:= ibsOrdW.FieldByName('ORDRCURRENCY').AsInteger;
    if (Order.currID<>Cache.BonusCrncCode) then
      Order.currID:= Order.Contract.DutyCurrency;

    Order.ORDRNUM:= ibsOrdW.FieldByName('ORDRNUM').AsString;
    Order.ORDRSOURCE:= ibsOrdW.FieldByName('ORDRSOURCE').AsInteger;
    Order.pDate:= ibsOrdW.FieldByName('ORDRSHIPDATE').AsDateTime;
    Order.DestID:= ibsOrdW.FieldByName('ORDRDESTPOINT').AsInteger;
    Order.ttID:= ibsOrdW.FieldByName('ORDRTIMETIBLE').AsInteger;
    Order.smID:= ibsOrdW.FieldByName('ORDRSHIPMETHOD').AsInteger;
    Order.stID:= ibsOrdW.FieldByName('ORDRSHIPTIMEID').AsInteger;
    Order.deliv:= ibsOrdW.FieldByName('ORDRDELIVERYTYPE').AsInteger;

//-------------------------------------------------------- формируем комментарий
    Order.commWarrant:= '';
    if (Order.currID=cUAHCurrency) then begin
      ss2:= ibsOrdW.FieldByName('ORDRWARRANT').AsString;
      if ss2<>'' then ss2:= ' N'+ss2;
      dd:= ibsOrdW.FieldByName('ORDRWARRANTDATE').AsDateTime;
      if (YearOf(dd)<2000) then s3:= '' else s3:= ' от '+FormatDateTime(cDateFormatY4, dd);
      ss3:= ibsOrdW.FieldByName('ORDRWARRANTPERSON').AsString;
      if ss3<>'' then ss3:= ' Выдана '+ss3;
      if (ss2<>'') or (ss3<>'') or (s3<>'') then Order.commWarrant:= 'Доверенность'+ss2+s3+ss3+'. ';
    end;
    case Order.deliv of
      cDelivTimeTable: Order.commDeliv:= 'Доставка. ';  // Доставка по расписанию
      cDelivSelfGet  : Order.commDeliv:= 'Самовывоз. '; // Самовывоз
      else begin
        if (Order.deliv<>cDelivReserve) then Order.deliv:= cDelivReserve;
        Order.commDeliv:= 'Резерв. ';    // Резерв
      end;
    end;
    Order.comment:= ibsOrdW.FieldByName('ORDRSTORAGECOMMENT').AsString;
    ss3:= fnIfStr(Order.comment='', '', Order.comment+'. ')+Order.commDeliv+
          Order.commWarrant+'Зак. '+Order.ORDRNUM+' от '+
          FormatDateTime(cDateFormatY4, ibsOrdW.FieldByName('ORDRDATE').AsDateTime)+'.';
    s1:= Copy(ss3, 1, Cache.AccWebCommLength);
    ibsOrdW.Close;
    ss3:= '';

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.SQL.Text:= 'SELECT ORDRLNWARE, sum(ORDRLNCLIENTQTY) as ORDRLNCLIENTQTY'+
      ' FROM ORDERSLINES where ORDRLNORDER='+IntToStr(Order.ORDRCODE)+
      ' and ORDRLNCLIENTQTY>:p0 group by ORDRLNWARE';
    ibsOrdW.Prepare;
    ibsOrdW.ParamByName('p0').AsFloat:= constDeltaZero;

    ibGBt:= cntsGRB.GetFreeCnt;
    ibGB:= cntsGRB.GetFreeCnt;
    ibsGBt:= fnCreateNewIBSQL(ibGBt, 'ibsGBt_'+nmProc, ThreadData.ID);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, ThreadData.ID, tpWrite);

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.ExecQuery;
    if (ibsOrdW.Bof and ibsOrdW.Eof) then // если нет строк товаров - не пишем
      raise Exception.Create(MessText(mtkNotFoundWares));

//------------------------------------------------------- запись заголовка счета
    Order.DCACCODE:= 0;
    Success:= false;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      STORAGEnew:= IntToStr(Order.DprtID);
      Application.ProcessMessages;
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;

      ibsGB.SQL.Text:= 'Select NewAccCode, NewAccNumber, NewDprtCode'+
        ' from Vlad_CSS_AddAccountHeaderC('+IntToStr(Order.ORDRCODE)+', 0, '+
        IntToStr(Order.FirmID)+', '+IntToStr(Order.contID)+', '+
        IntToStr(Order.DprtID)+', '+IntToStr(Order.currID)+', :WEBCOMMENT)';
      ibsGB.ParamByName('WEBCOMMENT').AsString:= s1;
      ibsGB.ExecQuery; //---------------- запись строки заголовка в базу

      if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('NewAccCode IsEmpty')
      else if (ibsGB.FieldByName('NewAccCode').AsInteger<1)
        or (ibsGB.FieldByName('NewAccNumber').AsString='') then
        raise Exception.Create('NewAccCode<1 or empty NewAccNumber');

      Order.DCACCODE:= ibsGB.FieldByName('NewAccCode').AsInteger;
      Order.DCACNUMBER:= trim(ibsGB.FieldByName('NewAccNumber').AsString);
      STORAGEnew:= ibsGB.FieldByName('NewDprtCode').AsString; // получаем склад резервирования
      ChangeStorage:= (IntToStr(Order.DprtID)<>STORAGEnew); // проверяем изменение склада

      if ChangeStorage then try // если склад изменен - добавляем сообщение в комментарий
        ibsGB.Close;
        ibsGB.SQL.Text:= 'execute procedure Vlad_CSS_AddCommToAcc('+
                         IntToStr(Order.DCACCODE)+', :CLIENTCOMMENT)';
        ibsGB.ParamByName('CLIENTCOMMENT').AsString:=
          'ВНИМАНИЕ! Склад резервирования изменен на склад по умолчанию.';
        ibsGB.ExecQuery;
      except
        on E: Exception do ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                           'Ошибка записи комментария клиенту в счет '+Order.DCACNUMBER;
      end;

      if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
      ibsGB.Close;
      if ChangeStorage then begin // новый склад, если изменен
//        Order.STORAGE:= STORAGEnew;
//        Order.DprtID:= StrToInt(Order.STORAGE);
        Order.DprtID:= StrToInt(STORAGEnew);
      end;
      Success:= true;
      break;
    except
      on E: Exception do begin
//        if (Pos('deadlock', E.Message)>0) then SaveToLogTransInfo(E.Message, '');
        if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
        ibsGB.Close;
        if ErrorStr='' then ErrorStr:= 'Ошибка записи заголовка счета по заказу '+Order.ORDRNUM;
        if (Pos('lock', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+CutLockMess(E.Message)
        else if (Pos('NewAcc', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+E.Message
        else begin
          ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
          break;
        end;
        if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval); // если deadlock, то ждем немного
      end;
    end;
    if not Success then
      raise Exception.Create('Ошибка записи заголовка счета по заказу '+Order.ORDRNUM);

//------------------------------------------- записываем привязку заказа к счету
    with ibsOrd.Transaction do if not InTransaction then StartTransaction;
    ibsOrd.Close;
    ibsOrd.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstAccepted)+
      ', ORDRGBACCCODE='+IntToStr(Order.DCACCODE)+', ORDRGBACCNUMBER=:ACCNUMBER,'+
      fnIfStr(flSaveCont, ' ORDRCONTRACT='+IntToStr(Order.contID)+',', '')+
      ' ORDRGBACCTIME="NOW" WHERE ORDRCODE='+IntToStr(Order.ORDRCODE);
    ibsOrd.ParamByName('ACCNUMBER').AsString:= Order.DCACNUMBER;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      Application.ProcessMessages;
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.ExecQuery;
      ibsOrd.Transaction.Commit;
      break;
    except
      on E: Exception do begin
        with ibsOrd.Transaction do if InTransaction then Rollback;
        if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
          Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
        else begin
          ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                     'Ошибка записи статуса в заказ '+IntToStr(Order.ORDRCODE);
          break;
        end;
      end;
    end;
    ibsOrd.Close;

//------------------------------------------------ записываем параметры отгрузки
    ss1:= '';
    if flCheckShipParams then begin
      ss1:= CheckAccountShipParams(Order.deliv, Order.ContID, Order.DprtID,
        Order.pDate, Order.DestID, Order.ttID, Order.smID, Order.stID, True);
      if (ss1<>'') then ErrorStr:= ErrorStr+#13#10+ss1;
    end;
                          // Доставка по расписанию - код времени не пишем - УиК
    if (Order.deliv=cDelivTimeTable) and (Order.ttID>0) then Order.stID:= 0;

    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
      ibsGB.SQL.Text:= 'Select ErrMess from Vlad_CSS_SetAccountShipParams('+
        IntToStr(Order.DCACCODE)+', '+fnIfStr(Order.pDate>DateNull, ':dd', 'null')+', '+IntToStr(Order.DestID)+', '+
        IntToStr(Order.ttID)+', '+IntToStr(Order.smID)+', '+IntToStr(Order.stID)+')';
      if (Order.pDate>DateNull) then ibsGB.ParamByName('dd').AsDate:= Order.pDate;
      ibsGB.ExecQuery;
      if (ibsGB.Bof and ibsGB.Eof) then
        raise Exception.Create('Error Vlad_CSS_SetAccountShipParams');
      ss1:= ibsGB.FieldByName('ErrMess').AsString;
      if (ss1<>'') then raise Exception.Create(ss1);
      if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
      ibsGB.Close;
      break;
    except
      on E: Exception do begin
        if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
        ibsGB.Close;
        if ErrorStr='' then ErrorStr:= 'Ошибка записи параметров отгрузки счета по заказу '+Order.ORDRNUM;
        if (Pos('lock', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+CutLockMess(E.Message)
        else begin
          ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
          break;
        end;
        if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval); // если deadlock, то ждем немного
      end;
    end;
    ss1:= '';
//----------------------------------------- строка закрывающих док-тов без суммы
    Order.recCloseDocs:= 0;
    with ibsOrd.Transaction do if not InTransaction then StartTransaction;
    ibsOrd.SQL.Text:= 'insert into OrdersClosingDocs (OCDOrderCode, OCDAccCode,'+
      ' OCDAccNumber, OCDAccDate, OCDAccCrnc, OCDAccDprt) values ('+IntToStr(Order.ORDRCODE)+', '+
      IntToStr(Order.DCACCODE)+', :AccNumber, "TODAY", '+IntToStr(Order.currID)+', '+
      IntToStr(Order.DprtID)+') returning OCDCODE';
    ibsOrd.ParamByName('AccNumber').AsString:= Order.DCACNUMBER;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      Application.ProcessMessages;
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.ExecQuery;
      if not (ibsOrd.Bof and ibsOrd.Eof) then
        Order.recCloseDocs:= ibsOrd.FieldByName('OCDCODE').AsInteger;
      ibsOrd.Transaction.Commit;
      break;
    except
      on E: Exception do begin
        with ibsOrd.Transaction do if InTransaction then Rollback;
        Order.recCloseDocs:= 0;
        if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
          Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
        else begin
          ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                     'Ошибка записи строки док-тов, счет '+IntToStr(Order.DCACCODE);
          break;
        end;
      end;
    end;
    ibsOrd.Close;

{    if Cache.flAccTimeToLog then begin
      ss3:= 'время записи заголовка - '+GetLogTimeStr(LocalStart);
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
    end; }

    accLines.Clear;
//------------------------ записали заголовок счета - пишем строки товаров счета
    if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
    ibsGB.SQL.Text:= 'select * from Vlad_CSS_AddAccLineC('+                         // SW 99903544
      IntToStr(Order.DCACCODE)+', '+IntToStr(Order.DprtID)+', :LNWARECODE, :ORDRLNCLIENTQTY)';
    ibsGB.Prepare;
    while not ibsOrdW.EOF do begin
      Success:= false;
      try                             // проверяем товар
        Ware:= Cache.GetWare(ibsOrdW.FieldByName('ORDRLNWARE').AsInteger);
        wCode:= ibsOrdW.FieldByName('ORDRLNWARE').AsString;
        Qty:= ibsOrdW.FieldByName('ORDRLNCLIENTQTY').AsFloat;
                                    // убираем из наименования длинные пробелы
        ss1:= StringReplace(Ware.Name, StringOfChar(' ', 2), StringOfChar(' ', 1), [rfReplaceAll]);

        if (Ware=NoWare) or not Ware.IsMarketWare(Order.FirmID, Order.contID) then
          raise Exception.Create('Ошибка записи товара в счет: '+ // сообщение в письмо
            fnIfStr(Ware=NoWare, 'код '+wCode, ss1)+', заказ - '+FormatFloat('# ##0', Qty));

        if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
        ibsGB.ParamByName('LNWARECODE').AsInteger   := Ware.ID;
        ibsGB.ParamByName('ORDRLNCLIENTQTY').AsFloat:= Qty;

        for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
          Application.ProcessMessages;
          if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
          ibsGB.ExecQuery; // записываем строку
          if (ibsGB.Bof and ibsGB.Eof) then
            raise Exception.Create('NewLineCode IsEmpty');
          if (ibsGB.Fields[0].AsInteger<1) then
            raise Exception.Create('NewLineCode = '+ibsGB.Fields[0].AsString);

          if fnNotZero(ibsGB.FieldByName('ResQty').AsFloat-Qty) then begin // проверка пересчета кол-ва
            Qty:= ibsGB.FieldByName('ResQty').AsFloat; // фактическое кол-во
            ss3:= 'товар '+ss1+': заказ '+ibsOrdW.FieldByName('ORDRLNCLIENTQTY').AsString+
              ' пересчитан по кратности на '+ibsGB.FieldByName('ResQty').AsString;
            ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
            WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
          end;

          price:= ibsGB.FieldByName('ResPrice').AsFloat;
          if not fnNotZero(price) then // проверка 0-й цены
            ErrStr:= fnIfStr(ErrStr='', '', ErrStr+#13#10)+'товар '+ss1+' записан с 0-й ценой';

          accLine:= fnMakeAddCharStr(ss1, 40, True)+
                    fnMakeAddCharStr(ibsGB.FieldByName('ResQty').AsString, 10)+
                    fnMakeAddCharStr(FormatFloat(cFloatFormatSumm, price), 10);

          with ibsGB.Transaction do if InTransaction then Commit;
          ibsGB.Close;

          accLines.Add(accLine);
          Success:= true;
          Break;
        except
          on E: Exception do begin
//            if (Pos('deadlock', E.Message)>0) then SaveToLogTransInfo(E.Message, '');
            with ibsGB.Transaction do if InTransaction then Rollback;
            ibsGB.Close;
            if (TryCount=1) then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
              'Ошибка записи товара счета '+Order.DCACNUMBER+' по заказу '+trim(Order.ORDRNUM)+
              ', код '+wCode+' заказ - '+FormatFloat('# ##0', Qty);
            ss3:= '';
            if (Pos('lock', E.Message)>0) then ss3:= CutLockMess(E.Message)
            else if (pos('Order of ware more rest', E.Message)>0)
              or (pos('NewLineCode', E.Message)>0) then ss3:= E.Message;
            if ss3='' then begin
              ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
              break;
            end else
              ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+ss3;
                                             // если deadlock, то ждем немного
            if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval);
          end;
        end;

        if Success then begin
          i:= Order.DprtID; // снимаем с остатка в кеше
          if i>0 then Cache.CheckWareRest(Ware.RestLinks, i, Qty, True);

        end else begin
          ss3:= 'Ошибка записи товара в '+fnGetGBDocName(docAccount, 1, 0, 4)+': '+
            fnIfStr(Ware=NoWare, 'код '+wCode, ss1)+', заказ - '+FormatFloat('# ##0', Qty);
          if Ware<>NoWare then
            WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
          raise Exception.Create(ss3); // сообщение в письмо
        end;

      except
        on E: Exception do begin
          with ibsGB.Transaction do if InTransaction then Rollback;
          if E.Message<>'' then
            ErrStr:= fnIfStr(ErrStr='', '', ErrStr+#13#10)+E.Message;
          inc(ErrCount);
        end;
      end;
      ibsOrdW.Next;
      inc(RecCount);
    end; // while not ibsOrdW.EOF
    ibsOrdW.Close;
    ibsGB.Close;

//---------------------------- записали товары - проверяем ошибки записи товаров
    Success:= true;
    if ErrCount>0 then begin
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+'Ошибка записи товаров в '+
        fnGetGBDocName(docAccount, 1, 0, 4)+' '+Order.DCACNUMBER+' - '+IntToStr(ErrCount)+' поз.';
      Success:= (ErrCount<RecCount);
    end;
    if not Success then try                        // если все не записались
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
      ibsGB.SQL.Text:= 'execute procedure Vlad_CSS_AddCommToAcc(:CODE, :CLIENTCOMMENT)';
      ibsGB.ParamByName('CODE').AsInteger:= Order.DCACCODE;
      ibsGB.ParamByName('CLIENTCOMMENT').AsString:= ' - Ошибка записи товаров в '+fnGetGBDocName(docAccount, 1, 0, 4)+'.';
      ibsGB.ExecQuery;         // пишем в комментарий счета
      ibsGB.Transaction.Commit;
    except
      with ibsGB.Transaction do if InTransaction then Rollback;
    end;
{    if Cache.flAccTimeToLog then begin
      ss3:= 'время записи счета     - '+GetLogTimeStr(LocalStart);
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
    end; }

//---------------------------------------- записали счет - проверяем сумму счета
    ibsGBt.Close;
    with ibsGBt.Transaction do if not InTransaction then StartTransaction;
    ibsGBt.SQL.Text:= 'SELECT r.PInvSumm aSUMM, r.PInvDate aDATE,'+
      ' (select sum(pinvlnprice*pinvlncount) from PAYINVOICELINES'+
      '   where pinvlndocmcode=r.PInvCode) sumlines'+
      ' from PayInvoiceReestr r where r.PInvCode='+IntToStr(Order.DCACCODE);
    ibsGBt.ExecQuery;
    if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('Not found aCODE='+IntToStr(Order.DCACCODE));
    ss1:= ibsGBt.FieldByName('aDATE').AsString;
    AccSumm:= ibsGBt.FieldByName('aSUMM').AsFloat;
    price:= ibsGBt.FieldByName('sumlines').AsFloat;
    ibsGBt.Close;
    ibsGBt.SQL.Text:= '';

//-------------------------------- если unit-счет - добавляем к unit-резерву к/а
    if (Order.currID=Cache.BonusCrncCode) then Order.firma.BonusRes:= Order.firma.BonusRes+AccSumm;

//------------------------------------- пишем сумму в строку закрывающих док-тов
    if (Order.recCloseDocs>0) then begin
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.SQL.Text:= 'update OrdersClosingDocs set OCDAccSumm=:AccSumm'+
                        ' where OCDCODE='+IntToStr(Order.recCloseDocs);
      ibsOrd.ParamByName('AccSumm').AsFloat:= AccSumm;
      for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
        Application.ProcessMessages;
        with ibsOrd.Transaction do if not InTransaction then StartTransaction;
        ibsOrd.ExecQuery;
        ibsOrd.Transaction.Commit;
        break;
      except
        on E: Exception do begin
          with ibsOrd.Transaction do if InTransaction then Rollback;
          if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
            Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
          else begin
            ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                       'Ошибка записи суммы в строку док-тов, счет '+IntToStr(Order.DCACCODE);
            break;
          end;
        end;
      end; // for TryCount
      ibsOrd.Close;
    end; //  if recCloseDocs>0

//--------------------------------------------- отсылаем письмо о создании счета
    if CreateMail then begin
      s:= prSendMessAboutCreateAccount(Order.ORDRCODE, Order.DCACCODE,
        Order.FirmID, Order.contID, Order.DprtID, Order.currID, ThreadData.ID,
        AccSumm, price, Order.DCACNUMBER, Order.ORDRNUM, ss1, ErrStr, accLines);
      if s<>'' then ErrorStr:= ErrorStr+fnIfStr(ErrorStr='', '', #13#10)+s;
    end; // if CreateMail

//---------------------------------------------------------------- ответ клиенту
    Stream.Clear;
    if WaresErrMess<>'' then begin // если были ошибки при записи товаров
      Stream.WriteInt(erWareToAccount);
      Stream.WriteStr(WaresErrMess);
    end else Stream.WriteInt(aeSuccess); // признак того, что запрос обработан корректно
  except
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка записи документа.');
      ErrorStr:= ErrorStr+fnIfStr(ErrorStr='', '', #13#10)+E.Message;
    end;
  end;
  finally
    if (ErrorStr<>'') or (ErrStr<>'') then
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, ErrorStr, ErrStr, '', false, 'error');
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    prFreeIBSQL(ibsGBt);
    cntsGRB.SetFreeCnt(ibGBt);
    prFreeIBSQL(ibsOrd);
    cntsORD.SetFreeCnt(ibOrd);
    prFreeIBSQL(ibsOrdW);
    cntsORD.SetFreeCnt(ibOrdW);
    prFree(accLines);
    Stream.Position:= 0;
  end;
//  if ToLog(9) then prMessageLOGS(nmProc+': '+GetLogTimeStr(LocalStart), 'OrderToGB', false); // пишем в log
end;
*)
//======================== записать товары в счет Grossbee с объединением счетов
function fnOrderToGB(OrderID: Integer; flCheckShipParams, CreateMail: Boolean;
         var WaresErrMess: String; ThreadData: TThreadData): Integer;
const nmProc = 'fnOrderToGB'; // имя процедуры/функции
      cstStarting =  0;
      cstSaved    =  1;
      cstCutSaved =  2;
      cstErrLock  = -1;
      cstErrFatal = -9;
var i, TryCount, ErrCount, RecCount, j, STORAGEnew, MeetPerson: integer;
    ErrPos, s, s1, ss2, ss3, accLine, wCutName,     SaveErrStr, // строка ошибок в письмо
      sQty, sDoc2, sMeet, sResQty, sDprtID, sAccID,   ErrorStr, // строка ошибок в лог
      sDivis, sDoc1, sDoc4, sOrderID, sContID, sCurrID: String;
    Success, flSaveCont, flDontJoin, flProcessed, flMeet{, flNewAddLineJoin}: boolean;
    ibGB, ibGBt, ibOrd: TIBDatabase;
    ibsGB, ibsOrd, ibsGBt: TIBSQL;
    price, ResQty: Double;
    Ware: TWareInfo;
    LocalStart: TDateTime;
    Ord: ROrderOpts;
    tc: TTwoCodes; // ID1- код товара, Qty-кол-во, ID2: 0- не обработан, 1- записан, -1 - ошибка записи
  //-------------------------------------------
  function BreakOnTrySaveWareException(accNum, EMessage: String): Boolean;
  begin
    Result:= False;
    if ibsGB.Transaction.InTransaction then ibsGB.Transaction.RollbackRetaining;
    ibsGB.Close;
    if (TryCount=1) then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
      'Ошибка записи товара '+wCutName+', код '+IntToStr(tc.ID1)+' в '+sDoc4+' '+
      accNum+' из заказа '+Ord.ORDRNUM+', кол-во - '+sQty;
    ss3:= '';
    if (Pos('lock', EMessage)>0) then begin
      tc.ID2:= cstErrLock; // ошибка доступа
      ss3:= CutLockMess(EMessage);
    end else if (pos('NewLineCode', EMessage)>0) then ss3:= EMessage
    else if (pos('Order of ware more rest', EMessage)>0) then begin
      tc.ID2:= cstErrFatal; // фатальная ошибка
      ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+EMessage;
      Result:= True;
      exit;
    end else if (pos('заблокирован', EMessage)>0) then begin
      tc.ID2:= cstErrFatal; // фатальная ошибка
      ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+'товар заблокирован';
      Result:= True;
      exit;
    end;
    if (ss3<>'') then
      ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+'(попытка '+IntToStr(TryCount)+'): '+ss3
    else begin
      tc.ID2:= cstErrFatal; // фатальная ошибка
      if (EMessage<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+EMessage;
      Result:= True;
      exit;
    end;                             // если deadlock, то ждем немного
    if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval);
  end;
  //-------------------------------------------
  function DoAfterTrySaveWare(accNum: String): String;
  begin
    Result:= '';
    if Success then begin
//      tc.ID2:= cstSaved;
      if (ResQty>0) and (Ord.DprtID>0) then // снимаем факт с остатка в кеше
        Cache.CheckWareRest(Ware.RestLinks, Ord.DprtID, ResQty, True);
    end else begin
      Result:= 'Ошибка записи товара в '+sDoc4+' '+accNum+': '+wCutName+', кол-во - '+sQty;
      if (Ware<>NoWare) then
        WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+Result;
    end;
  end;
  //-------------------------------------------
  function ExceptionOnCheckWare(accNum: String): String;
  begin
    Result:= '';
    Ware:= Cache.GetWare(tc.ID1);   // убираем из наименования длинные пробелы
    wCutName:= StringReplace(Ware.Name, StringOfChar(' ', 2), StringOfChar(' ', 1), [rfReplaceAll]);
    tc.Qty:= RoundTo(tc.Qty, -3);
    sQty:= StringReplace(FloatToStr(tc.Qty), ',', '.', [rfReplaceAll]);

    if (Ware=NoWare) or not Ware.IsMarketWare(Ord.Firma.ID, Ord.Contract.ID) then begin
      If (Ware=NoWare) then wCutName:=  'код '+IntToStr(tc.ID1);
      tc.ID2:= cstErrFatal; // фатальная ошибка
      Result:= 'Ошибка записи товара в '+sDoc4+' '+accNum+': '+wCutName+', кол-во - '+sQty;
      exit;
    end;
    sDivis:= StringReplace(FloatToStr(RoundTo(Ware.divis, -3)), ',', '.', [rfReplaceAll]);
  end;
  //-------------------------------------------
  procedure AddAccLine(lst: TStringList);
  begin
    accLine:= fnMakeAddCharStr(wCutName, 40, True)+
              fnMakeAddCharStr(sResQty, 10)+
              fnMakeAddCharStr(FormatFloat(cFloatFormatSumm, price), 10);
    lst.Add(accLine);
  end;
  //-------------------------------------------
begin
  LocalStart:= now();
  ErrorStr:= '';   // сообщение о глобальной ошибке
  SaveErrStr:= ''; // сообщение об ошибках записи товаров
  WaresErrMess:= '';
  sDoc1:= fnGetGBDocName(docAccount, 1, 0, 1);
  sDoc2:= fnGetGBDocName(docAccount, 1, 0, 2);
  sDoc4:= fnGetGBDocName(docAccount, 1, 0, 4);
  ErrCount:= 0;
  RecCount:= 0;
  ResQty:= 0;
  ibOrd:= nil;
  ibsOrd:= nil;
  ibGB:= nil;
  ibsGB:= nil;
  ibGBt:= nil;
  ibsGBt:= nil;
  flSaveCont:= False;
  flProcessed:= False;
  Ord.Contract:= nil;
  Result:= aeSuccess;
  Ord.olOrdWares:= TObjectList.Create;
  Ord.accSing.accLines:= TStringList.Create;
  Ord.accJoin.accLines:= TStringList.Create;
  MeetPerson:= 0;
  sMeet:= '';
  flMeet:= False;
  try try
    sOrderID:= IntToStr(OrderID);
    ibOrd:= cntsORD.GetFreeCnt; //------------------------------ всякие проверки
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, ThreadData.ID, tpRead, True);
    ibsOrd.SQL.Text:= 'SELECT ORDRACCOUNTINGTYPE, ORDRNUM, ORDRCODE, ORDRFIRM,'+
      ' ORDRDATE, ORDRCURRENCY, ORDRSTORAGECOMMENT, ORDRDELIVERYTYPE,'+
      ' ORDRSTATUS, ORDRCONTRACT, ORDRSHIPDATE, OrdrDontJoinAcc,'+
      ' ORDRDESTPOINT, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID'+
      fnIfStr(flMeetPerson, ', ordrAccMeetPerson', '')+
      ' FROM ORDERSREESTR WHERE ORDRCODE='+sOrderID;
    ibsOrd.ExecQuery;
    if (ibsOrd.Bof and ibsOrd.Eof) then
      raise Exception.Create(MessText(mtkNotValidParam));

    j:= ibsOrd.FieldByName('ORDRFIRM').AsInteger; //------------ проверяем фирму
    if (j>0) then begin
      Cache.TestFirms(j, True);
      if not Cache.FirmExist(j) then j:= 0;
    end;
    if (j<1) then raise Exception.Create(MessText(mtkNotFirmExists));
    Ord.Firma:= Cache.arFirmInfo[j];

    Ord.ORDRNUM:= ibsOrd.FieldByName('ORDRNUM').AsString;
    j:= ibsOrd.FieldByName('ORDRCONTRACT').AsInteger; //----- проверяем контракт
    i:= j;
    Ord.Contract:= Ord.Firma.GetContract(j);

    if (Ord.Contract.Status=cstClosed) then begin //------- если контракт закрыт
      if (ibsOrd.FieldByName('ORDRSTATUS').AsInteger>orstForming) then begin
        ibsOrd.Close;
        fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
        ibsOrd.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstForming)+
          ' WHERE ORDRCODE='+sOrderID; // возвращаем статус "Формируется"
ErrPos:= '0';
        s1:= RepeatExecuteIBSQL(ibsOrd, accRepeatCount); // accRepeatCount попыток
        if (s1<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                          'Ошибка записи статуса в заказ '+Ord.ORDRNUM+': '+s1;
      end;
      raise Exception.Create('Контракт '+Ord.Contract.Name+' недоступен');
    end; // if (Ord.Contract.Status=cstClosed)

    flSaveCont:= (Ord.Contract.ID>0) and (i<>Ord.Contract.ID) and not Ord.Contract.Fictive;
    Ord.DprtID:= Ord.Contract.MainStorage;

    //---------------------------------- определяем валюту и признак объединения
    Ord.accType:= ibsOrd.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;
    Ord.currID:= ibsOrd.FieldByName('ORDRCURRENCY').AsInteger;
    if (Ord.currID<>Cache.BonusCrncCode) then begin
      Ord.currID:= Ord.Contract.DutyCurrency;
if not flNewSaveAcc then flDontJoin:= True else
      flDontJoin:= GetBoolGB(ibsOrd, 'OrdrDontJoinAcc');
    end else flDontJoin:= True; // призовые заказы - отдельные счета всегда

    Ord.pDate:= ibsOrd.FieldByName('ORDRSHIPDATE').AsDateTime;
    Ord.DestID:= ibsOrd.FieldByName('ORDRDESTPOINT').AsInteger;
    Ord.ttID:= ibsOrd.FieldByName('ORDRTIMETIBLE').AsInteger;
    Ord.smID:= ibsOrd.FieldByName('ORDRSHIPMETHOD').AsInteger;
    Ord.stID:= ibsOrd.FieldByName('ORDRSHIPTIMEID').AsInteger;
    Ord.deliv:= ibsOrd.FieldByName('ORDRDELIVERYTYPE').AsInteger;

    sDprtID:= IntToStr(Ord.DprtID);
    sContID:= IntToStr(Ord.Contract.ID);
    sCurrID:= IntToStr(Ord.currID);

//-------------------------------------------------------- формируем комментарии
    Ord.comment:= ibsOrd.FieldByName('ORDRSTORAGECOMMENT').AsString;
    if (Ord.comment<>'') then begin
      if (copy(Ord.comment, length(Ord.comment), 1)<>'.') then
        Ord.comment:= Ord.comment+'. '
      else Ord.comment:= Ord.comment+' ';
      Ord.comment:= StringReplace(Ord.comment, '''', '`', [rfReplaceAll]);
      Ord.comment:= StringReplace(Ord.comment, '"', '`', [rfReplaceAll]);
    end;
    case Ord.deliv of
      cDelivTimeTable: Ord.commDeliv:= 'Доставка. ';  // Доставка по расписанию
      cDelivSelfGet  : Ord.commDeliv:= 'Самовывоз. '; // Самовывоз
      else if not flNotReserve then begin
        if (Ord.deliv<>cDelivReserve) then Ord.deliv:= cDelivReserve;
        Ord.commDeliv:= 'Резерв. ';    // Резерв
      end;
    end;
    Ord.commOrder:= 'Заказ '+Ord.ORDRNUM+' от '+
          FormatDateTime(cDateFormatY2, ibsOrd.FieldByName('ORDRDATE').AsDateTime)+'.';

if flMeetPerson then begin
    flMeet:= (Ord.deliv in [cDelivTimeTable, cDelivSelfGet]);
    if flMeet then begin
      MeetPerson:= ibsOrd.FieldByName('ordrAccMeetPerson').AsInteger;
      sMeet:= IntToStr(MeetPerson);
    end;
end; // flMeetPerson

    ibsOrd.Close;
    ss3:= '';

//----------------------------------------------- формируем список строк товаров
    if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
    ibsOrd.SQL.Text:= 'SELECT ORDRLNWARE, sum(ORDRLNCLIENTQTY) as QTY'+
      ' FROM ORDERSLINES where (ORDRLNORDER='+sOrderID+
      ' and ORDRLNCLIENTQTY>0) group by ORDRLNWARE';
ErrPos:= '1';
    ibsOrd.ExecQuery;
    while not ibsOrd.EOF do begin
      tc:= TTwoCodes.Create(ibsOrd.FieldByName('ORDRLNWARE').AsInteger,
                            cstStarting, ibsOrd.FieldByName('QTY').AsFloat);
      Ord.olOrdWares.Add(tc);
      TestCssStopException;
      ibsOrd.Next;
    end;
    ibsOrd.Close;
    if (Ord.olOrdWares.Count<1) then // если нет строк товаров - не пишем
      raise Exception.Create(MessText(mtkNotFoundWares));

    fnSetTransParams(ibsOrd.Transaction, tpWrite); // готовим ibsOrd к записи

    ibGBt:= cntsGRB.GetFreeCnt;
    ibGB:= cntsGRB.GetFreeCnt;
    ibsGBt:= fnCreateNewIBSQL(ibGBt, 'ibsGBt_'+nmProc, ThreadData.ID);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, ThreadData.ID, tpWrite);

//------------------------------------------------- проверяем параметры отгрузки
    if flCheckShipParams then begin
      j:= Ord.stID;
      s1:= CheckAccountShipParams(Ord.deliv, Ord.Contract.ID, Ord.DprtID, Ord.pDate,
        Ord.DestID, Ord.ttID, Ord.smID, Ord.stID, True);
      if (s1<>'') then begin
        s1:= 'Ошибка записи параметров отгрузки: '+s1;
        ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+s1;
        SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+s1;
      end;
    end;

    ord.accJoin.ID:= 0;
    ord.accSing.ID:= 0;
//////////////////////////////////////////////////////////// счет для добавления
    if not flDontJoin then try // ищем счет для добавления (все товары в наличии)
      if not ibsGBt.Transaction.InTransaction then ibsGBt.Transaction.StartTransaction;
      ibsGBt.SQL.Text:= ' select AddAccCode, AddAccNumber, Processed, webcomm, aDATE'+
        ' from Vlad_CSS_GetAccForJoin('+IntToStr(Ord.Firma.ID)+', '+sContID+', '+
        sDprtID+', '+IntToStr(Ord.deliv)+', '+IntToStr(Ord.DestID)+', '+
        IntToStr(Ord.ttID)+', '+IntToStr(Ord.smID)+', '+IntToStr(Ord.stID)+', '+
        fnIfStr(flMeet, sMeet, '-1')+', "'+FormatDateTime(cDateFormatY4, Ord.pDate)+'")';
ErrPos:= '2';
      ibsGBt.ExecQuery;
      if not (ibsGBt.Eof and ibsGBt.Bof) then begin
        ord.accJoin.ID     := ibsGBt.FieldByName('AddAccCode').AsInteger;
        ord.accJoin.Num    := ibsGBt.FieldByName('AddAccNumber').AsString;
        Ord.accJoin.sDate  := ibsGBt.FieldByName('aDATE').AsString;
        ord.accJoin.webcomm:= ibsGBt.FieldByName('webcomm').AsString;
        flProcessed        := GetBoolGB(ibsGBt, 'Processed');
      end;
    except
      on E: Exception do begin
        if (ErrorStr='') then ErrorStr:= 'Ошибка поиска '+sDoc2+' для заказа '+Ord.ORDRNUM;
        ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+e.Message;
      end;
    end; // if not flDontJoin
    ibsGBt.Close;
    ibsGBt.ParamCheck:= True;

    sAccID:= IntToStr(ord.accJoin.ID); // может быть '0'
    if (ord.accJoin.ID>0) then begin
//      flNewAddLineJoin:= TestRDB(cntsGRB, trkProc, 'Vlad_CSS_AddLineToJoinAcc');
//================================================ нашли счет - добавляем товары
      Ord.accJoin.AccSumm:= 0;
      Ord.accJoin.sumlines:= 0;
//      if flNewAddLineJoin then begin
        if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
        ibsGB.SQL.Text:= 'select NewLineCode, ResQty, ResPrice'+
                         ' from Vlad_CSS_AddLineToJoinAcc('+sAccID+', :WareID, :aOrder)';
//----------------------------------------------  потом убрать
{      end else begin
        ibsGB.ParamCheck:= False;
        if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
        ibsGB.SQL.Add('execute block returns (NewLineCode integer,'+
                      ' ResQty double precision, ResPrice double precision)');
        ibsGB.SQL.Add('as declare variable xOrder double precision;'+
                     ' declare variable xCount double precision;');
        ibsGB.SQL.Add(' declare variable xRest double precision;'+
                      ' declare variable xDivis double precision;'+
                      ' declare variable xWare integer; declare variable xMeas integer;');
        ibsGB.SQL.Add('begin NewLineCode=0; ResQty=0; ResPrice=0;');
        //----------- строку с индексом 4 - будем менять
        ibsGB.SQL.Add(' xWare=0; xOrder=0; xDivis=1; xMeas=1;');
        //----------------------------------------------
        ibsGB.SQL.Add(' select Rmarket from GetWareRestsCSS_Vlad(:xWare, '+sDprtID+') into :xRest;');
        ibsGB.SQL.Add(' if (xRest<=0) then begin suspend; exit; end'); // нет наличия - возвращаем 0
        ibsGB.SQL.Add(' execute procedure Vlad_CSS_GetContWarePrice(:xWare, :xMeas, '+ // расчет цены товара
                      sContID+', '+sCurrID+') returning_values :ResPrice;');
                      //----- если есть кратность - пересчитываем заказ товара
        ibsGB.SQL.Add(' if (xDivis>1.0) then begin'+
                      // округляем до ближайшего большего целого и умножаем на кратность
                      '  xOrder=CEILING(xOrder/xDivis)*xDivis;');
                      // если в наличии меньше заказа - снимаем заказ по кратности
        ibsGB.SQL.Add('  while (xOrder>xRest) do begin xOrder=xOrder-xDivis;');
                      // нет наличия с учетом кратности - возвращаем 0
        ibsGB.SQL.Add('   if (xOrder<=0) then begin suspend; exit; end end');
                      //--- без учета кратности в наличии меньше заказа - берем наличие
        ibsGB.SQL.Add(' end else if (xOrder>xRest) then xOrder=xRest;  ResQty=xOrder;');
        ibsGB.SQL.Add(' insert into PayInvoiceLines (PInvLnWareCode, PInvLnUnitCode,'+ // вставляем строку
                      '  PInvLnDocmCode, PInvLnSupplyDprtCode, PInvLnPrice, PInvLnOrder,'+
                      '  PInvLnCount) values (:xWare, :xMeas, '+sAccID+', '+sDprtID+
                      ', :ResPrice, :xOrder, :ResQty) returning PInvLnCode, PInvLnCount,'+
                      ' PInvLnPrice into :NewLineCode, :ResQty, :ResPrice; ');
        ibsGB.SQL.Add(' suspend; end');
      end;  }
//---------------------------------------------- потом убрать

      for j:= 0 to Ord.olOrdWares.Count-1 do begin
        tc:= TTwoCodes(Ord.olOrdWares[j]);
        ResQty:= 0;
        Success:= false;
        try
          s1:= ExceptionOnCheckWare(Ord.accJoin.Num);    // проверяем товар
          if (s1<>'') then raise Exception.Create(s1);

          if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;

//          if flNewAddLineJoin then begin
            ibsGB.ParamByName('WareID').AsInteger:= tc.ID1;
            ibsGB.ParamByName('aOrder').AsFloat:= tc.Qty;

//---------------------------------------------- потом убрать
//          end else begin
  //---------------- меняем строку (индекс = 4) ibsGB.SQL
//            ibsGB.SQL[4]:= ' xWare='+IntToStr(tc.ID1)+'; xOrder='+sQty+
//                           '; xDivis='+sDivis+'; xMeas='+IntToStr(ware.measID)+';';
  //-----------------------------------------------------
//          end;
//---------------------------------------------- потом убрать

          for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
            Application.ProcessMessages;
            if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
ErrPos:= '3-'+IntToStr(j)+'-'+IntToStr(TryCount);

            ibsGB.ExecQuery;       // записываем строку
            if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('Empty NewLineCode');

            ResQty:= ibsGB.FieldByName('ResQty').AsFloat;  // фактическое кол-во
            price:= ibsGB.FieldByName('ResPrice').AsFloat; // цена

            if ibsGB.Transaction.InTransaction then
              if (ResQty>0) then ibsGB.Transaction.Commit else ibsGB.Transaction.Rollback;
            ibsGB.Close;

            if not (ResQty>0) then tc.ID2:= cstStarting
            else begin //--------------------------- если записали строку товара
              sResQty:= StringReplace(FloatToStr(RoundTo(ResQty, -3)), ',', '.', [rfReplaceAll]);
              //------------------------------------------------ проверка кол-ва
              if (ResQty>tc.Qty) then begin // пересчитывали по кратности
                tc.ID2:= cstSaved;
                ss3:= 'товар '+wCutName+': заказ '+sQty+' пересчитан по кратности на '+sResQty;
                SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+ss3;
                WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
              end else if (ResQty<tc.Qty) then begin // не хватило наличия - записали частично
                tc.Qty:= tc.Qty-ResQty;             // остаток для записи в отдельный счет
                tc.ID2:= cstCutSaved;
              end else tc.ID2:= cstSaved;  // факт=заказ - записали все кол-во
              //-------------------------------------------------- проверка цены
              if fnNotZero(price) then
                Ord.accJoin.sumlines:= Ord.accJoin.sumlines+RoundToHalfDown(ResQty*price)
              else SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+
                                        'товар '+wCutName+' записан с 0-й ценой';
              AddAccLine(Ord.accJoin.accLines);
            end;  // if (ResQty>0)
            Success:= true;
            Break;
          except
            on E: Exception do
              if BreakOnTrySaveWareException(Ord.accJoin.Num, E.Message) then break;
          end; // for TryCount:= 1 to

          s1:= DoAfterTrySaveWare(Ord.accJoin.Num);
          if (s1<>'') then raise Exception.Create(s1); // сообщение в письмо ???
        except
          on E: Exception do begin
            if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
            if (tc.ID2>cstErrLock) then tc.ID2:= cstErrLock; // ошибка записи
            // в этом счете ошибки не считаем и не пишем !!!
//            if (E.Message<>'') then
//              SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+E.Message;
            // в этом счете ошибки считаем только фатальные
//            if (tc.ID2=cstErrFatal) then inc(ErrCount);
          end;
        end;
      end; // for j:= 0 to Ord.olOrdWares.Count-1

      RecCount:= 0; //--------------------- проверяем наличие записанных товаров
      for j:= 0 to Ord.olOrdWares.Count-1 do begin
        tc:= TTwoCodes(Ord.olOrdWares[j]);
        if (tc.ID2<cstSaved) then Continue; // товар не записан
//        if (tc.ID2=cstCutSaved) then tc.ID2:= cstStarting;
        inc(RecCount);
      end;
      if (RecCount<1) then ord.accJoin.ID:= 0; // если ничего не записали - обнуляем код
    end; // if (ord.accJoin.ID>0)
    ibsGB.ParamCheck:= True;

    if (ord.accJoin.ID>0) then begin
      //---------------- добавляем комментарий из заказа в WEB-комментарий счета
      Ord.accJoin.webcomm:= Ord.accJoin.webcomm+fnIfStr(Ord.accJoin.webcomm='', '', ' ')+
        'Добав. '+IntToStr(RecCount)+' поз. из зак.'+Ord.ORDRNUM;
      if (Ord.comment<>'') and (pos(Ord.comment, Ord.accJoin.webcomm)<1) then
        Ord.accJoin.webcomm:= Ord.accJoin.webcomm+' ('+Ord.comment+')';
      Ord.accJoin.webcomm:= fnReplaceQuotedForWeb(Ord.accJoin.webcomm);
      Ord.accJoin.webcomm:= fnChangeEndOfStrBySpace(Ord.accJoin.webcomm);
      Ord.accJoin.webcomm:= Copy(Ord.accJoin.webcomm, 1, Cache.AccWebCommLength);

      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
      ibsGB.SQL.Clear;
      ibsGB.ParamCheck:= False;
      ibsGB.SQL.Add('execute block returns (ResSumm double precision) as'+
                    ' declare variable xOrd integer=-1; begin');
      ibsGB.SQL.Add(' select PInvSumm from PayInvoiceReestr'+
                    '  where PInvCode='+sAccID+' into ResSumm;');
      ibsGB.SQL.Add(' update PayInvoiceReestr set PINVWEBCOMMENT="'+
                    Ord.accJoin.webcomm+'" where PinvCode='+sAccID+';');
                                              // проверяем/записываем код заказа
      ibsGB.SQL.Add(' select piavOrdCode from payinvalter_vlad'+
                    '  where piavAccCode='+sAccID+' into :xOrd;');
      ibsGB.SQL.Add(' if (xOrd is null or xOrd<1) then');
      ibsGB.SQL.Add('  update or insert into payinvalter_vlad'+
                    '   (piavAccCode, piavOrdCode, piavLastTime) values ('+
                    sAccID+', '+sOrderID+', "NOW") matching (piavAccCode);');
      if flProcessed then                 // восстанавливаем признак "Обработан"
        ibsGB.SQL.Add(' update PayInvoiceReestr set PInvProcessed="T"'+
                      '  where PinvCode='+sAccID+';');
      ibsGB.SQL.Add(' suspend; end');
ErrPos:= '4';
      s1:= RepeatExecuteIBSQL(ibsGB, 'ResSumm', ss3, accRepeatCount);
      if (s1<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
        'Ошибка записи комментария в '+sDoc4+' '+Ord.accJoin.Num+' из заказа '+Ord.ORDRNUM+': '+s1
      else Ord.accJoin.AccSumm:= StrToFloat(ss3);
      ibsGB.ParamCheck:= True;

      //-------- записываем привязку заказа к счету и строку закрывающих док-тов
      Ord.accJoin.recDoc:= 0;
      ibsOrd.ParamCheck:= False;
      ibsOrd.SQL.Clear;
      sQty:= StringReplace(FloatToStr(RoundTo(Ord.accJoin.AccSumm, -2)), ',', '.', [rfReplaceAll]);
      if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
      ibsOrd.SQL.Add('execute block returns (RecCode integer) as begin RecCode=0;');
      ibsOrd.SQL.Add(' update or insert into OrdersClosingDocs (OCDOrderCode,'+
                     ' OCDAccCode, OCDAccNumber, OCDAccDate, OCDAccCrnc,'+
                     ' OCDAccDprt, OCDAccSumm, OCDINVCODE) values');
      ibsOrd.SQL.Add(' ('+sOrderID+', '+sAccID+', "'+Ord.accJoin.Num+'", "'+
                     Ord.accJoin.sDate+'", '+sCurrID+', '+sDprtID+', '+sQty+', null)');
      ibsOrd.SQL.Add(' MATCHING (OCDOrderCode, OCDAccCode, OCDINVCODE)'+
                     ' returning OCDCODE into :RecCode;');
      ibsOrd.SQL.Add(' update OrdersClosingDocs set OCDAccSumm='+sQty+' where'+
                     ' OCDAccCode='+sAccID+' and OCDCODE<>:RecCode;');
      ibsOrd.SQL.Add(' UPDATE ORDERSREESTR SET ORDRGBACCCODE='+sAccID+
                     ', ORDRGBACCNUMBER="'+Ord.accJoin.Num+'",'+
                     fnIfStr(flSaveCont, ' ORDRCONTRACT='+sContID+',', '')+
                     ' ORDRGBACCTIME="NOW" WHERE ORDRCODE='+sOrderID+';');
      ibsOrd.SQL.Add(' suspend; end');
ErrPos:= '5';
      s1:= RepeatExecuteIBSQL(ibsOrd, 'RecCode', Ord.accJoin.recDoc, accRepeatCount);
      if (s1<>'') or (Ord.accJoin.recDoc<1) then
        ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
          'Ошибка записи привязки '+sDoc2+' '+Ord.accJoin.Num+' к заказу '+Ord.ORDRNUM+': '+s1;
      ibsOrd.ParamCheck:= True;

    end; // if (ord.accJoin.ID>0)
//////////////////////////////////////////////////////////////// добавили в счет

    i:= 0; // проверяем наличие товаров для записи отдельного счета
    for j:= 0 to Ord.olOrdWares.Count-1 do begin
      tc:= TTwoCodes(Ord.olOrdWares[j]);
      if (tc.ID2=cstSaved) then Continue;    // товар уже записан
      inc(i);
    end;

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  запись отдельного счета
    RecCount:= 0;
    if (i>0) then begin  // Доставка по расписанию - код времени не пишем - УиК
      if (Ord.deliv=cDelivTimeTable) and (Ord.ttID>0) then Ord.stID:= 0;
  //-------------------------------------------- запись заголовка отдельного счета
      ord.accSing.webcomm:= Ord.comment+Ord.commDeliv+Ord.commOrder;
      Ord.accSing.webcomm:= fnReplaceQuotedForWeb(Ord.accSing.webcomm);
      Ord.accSing.webcomm:= fnChangeEndOfStrBySpace(Ord.accSing.webcomm);
      Ord.accSing.webcomm:= Copy(Ord.accSing.webcomm, 1, Cache.AccWebCommLength);
      Ord.accSing.ID:= 0;
      ss2:= 'ВНИМАНИЕ! Склад резервирования изменен на склад по умолчанию.';
      ibsGB.ParamCheck:= False;
      ibsGB.SQL.Clear;
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
      ibsGB.SQL.Add('execute block returns (NewAccCode integer, NewAccNumber varchar(16),'+
                    ' NewDprtCode integer, ErrMess varchar(100))');
      ibsGB.SQL.Add(' as begin NewAccCode=0; NewAccNumber=""; NewDprtCode=0; ErrMess="";');
      ibsGB.SQL.Add(' Select NewAccCode, NewAccNumber, NewDprtCode'); // запись строки заголовка в базу
//      ibsGB.SQL.Add('   from Vlad_CSS_AddAccountHeaderC('+sOrderID+', '+sAccID+', '+
      ibsGB.SQL.Add('   from Vlad_CSS_AddAccountHeaderC('+sOrderID+', 0,'+ // ссылку на accJoin не пишем !!! (29.12.2016 ВЧ)
                    IntToStr(Ord.Firma.ID)+', '+sContID+', '+
                    sDprtID+', '+sCurrID+', "'+ord.accSing.webcomm+'")');
      ibsGB.SQL.Add(' into :NewAccCode, :NewAccNumber, :NewDprtCode;');
      ibsGB.SQL.Add(' update PayInvoiceReestr set PINVCLIENTCOMMENT="'+ // спец.признак - счет в работе
                    cSpecDelim+'" where PInvCode=:NewAccCode;');
      ibsGB.SQL.Add(' if (NewDprtCode<>'+sDprtID+') then '+ // если склад изменен - сообщение в комментарий
                    '  execute procedure Vlad_CSS_AddCommToAcc(:NewAccCode, "'+ss2+'");');
      if flDontJoin then                                         // признак - не объединять счета
        ibsGB.SQL.Add(' update PayInvoiceReestr set PInvDontJoin="T" where PInvCode=:NewAccCode;');

if flMeetPerson then
      if (MeetPerson>0) then begin
        ibsGB.SQL.Add(' if (exists(select * from personphones'+
                      '  left join persons on prsncode=PPhPersonCode'+
                      '  where pphcode='+IntToStr(MeetPerson)+
                      '   and prsnarchivedkey="F" and PPhArchivedKey="F")) then');
        ibsGB.SQL.Add('  update PayInvoiceReestr set PINVMEETPERSON='+ // встречающий
                      IntToStr(MeetPerson)+' where PInvCode=:NewAccCode;');
      end; // if (MeetPerson>0)

      ibsGB.SQL.Add(' Select ErrMess from Vlad_CSS_SetAccountShipParams(:NewAccCode,'+ // параметры отгрузки
                    fnIfStr(Ord.pDate>DateNull, '"'+FormatDateTime(cDateFormatY4, Ord.pDate)+
                    '"', 'null')+','+IntToStr(Ord.DestID)+','+IntToStr(Ord.ttID)+','+
                    IntToStr(Ord.smID)+','+IntToStr(Ord.stID)+') into :ErrMess; suspend; end');
      ss3:= '';
      Success:= false;
      for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
        Application.ProcessMessages;
        if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
ErrPos:= '6-'+IntToStr(TryCount);
        ibsGB.ExecQuery;
        if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('NewAccCode IsEmpty');

        Ord.accSing.ID:= ibsGB.FieldByName('NewAccCode').AsInteger;
        Ord.accSing.Num:= trim(ibsGB.FieldByName('NewAccNumber').AsString);
        if (Ord.accSing.ID<1) then raise Exception.Create('NewAccCode<1');
        if (Ord.accSing.Num='') then raise Exception.Create('empty NewAccNumber');

        STORAGEnew:= ibsGB.FieldByName('NewDprtCode').AsInteger; // получаем склад резервирования
        ss3:= ibsGB.FieldByName('ErrMess').AsString;

        if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
        Success:= true;
        if (Ord.DprtID<>STORAGEnew) then begin // новый склад, если изменен
          Ord.DprtID:= STORAGEnew;
          sDprtID:= IntToStr(Ord.DprtID);
        end;
        break;
      except
        on E: Exception do begin
          if ibsGB.Transaction.InTransaction then ibsGB.Transaction.RollbackRetaining;
          ibsGB.Close;
          if (ErrorStr='') then ErrorStr:= 'Ошибка записи заголовка '+sDoc2+' по заказу '+Ord.ORDRNUM;
          if (Pos('lock', E.Message)>0) then
            ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+'(попытка '+IntToStr(TryCount)+'): '+CutLockMess(E.Message)
          else if (Pos('NewAcc', E.Message)>0) then
            ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+'(попытка '+IntToStr(TryCount)+'): '+E.Message
          else begin
            if (E.Message<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+E.Message;
            break;
          end;
          if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval); // если deadlock, то ждем немного
        end;
      end; // for TryCount
      ibsGB.Close;
      if not Success then
        raise Exception.Create('Ошибка записи заголовка '+sDoc2+' по заказу '+Ord.ORDRNUM);
      if (ss3<>'') then
        if (ErrorStr<>'') then ErrorStr:= ErrorStr+#13#10+ss3
        else ErrorStr:= 'Ошибка записи параметров отгрузки в '+sDoc4+' '+Ord.accSing.Num+#13#10+ss3;

//------------------------ записали заголовок счета - пишем строки товаров счета
      sAccID:= IntToStr(Ord.accSing.ID);
      ibsGB.ParamCheck:= True;
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;

{      if TestRDB(cntsGRB, trkProc, 'Vlad_CSS_AddAccLineF') then
        ibsGB.SQL.Text:= 'select NewLineCode, ResQty, ResPrice'+
                         ' from Vlad_CSS_AddAccLineF('+
                         Cache.GetConstItem(pcAccFactWithFillDprt).StrValue+', '+
                         sAccID+', '+sDprtID+', :LNWARECODE, :ORDRLNCLIENTQTY)'
      else   }
        ibsGB.SQL.Text:= 'select NewLineCode, ResQty, ResPrice'+
                         ' from Vlad_CSS_AddAccLineC('+
                         sAccID+', '+sDprtID+', :LNWARECODE, :ORDRLNCLIENTQTY)';

      ibsGB.Prepare;

      for j:= 0 to Ord.olOrdWares.Count-1 do begin
        tc:= TTwoCodes(Ord.olOrdWares[j]);
        if (tc.ID2=cstSaved) then Continue; // товар уже записан

        ResQty:= 0;
        Success:= false;
        try
          s1:= ExceptionOnCheckWare(Ord.accSing.Num); // проверяем товар
          if (s1<>'') then raise Exception.Create(s1);

          if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
          ibsGB.ParamByName('LNWARECODE').AsInteger   := Ware.ID;
          ibsGB.ParamByName('ORDRLNCLIENTQTY').AsFloat:= tc.Qty;

          for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
            Application.ProcessMessages;
            if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
ErrPos:= '7-'+IntToStr(j)+'-'+IntToStr(TryCount);
            ibsGB.ExecQuery;       // записываем строку
            if (ibsGB.Bof and ibsGB.Eof) or (ibsGB.FieldByName('NewLineCode').AsInteger<1) then
              raise Exception.Create('Empty NewLineCode');

            ResQty:= ibsGB.FieldByName('ResQty').AsFloat;  // заказ (возможно пересчитан)
            price:= ibsGB.FieldByName('ResPrice').AsFloat;
            if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
            ibsGB.Close;

            sResQty:= StringReplace(FloatToStr(RoundTo(ResQty, -3)), ',', '.', [rfReplaceAll]);
//            if fnNotZero(ResQty-tc.Qty) then begin // проверка пересчета кол-ва
            if (ResQty>tc.Qty) then begin // проверка пересчета кол-ва
              ss3:= 'товар '+wCutName+': заказ '+sQty+' пересчитан по кратности на '+sResQty;
              SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+ss3;
              WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
            end;

            if not fnNotZero(price) then // проверка 0-й цены
              SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+
                           'товар '+wCutName+' записан с 0-й ценой';
            AddAccLine(Ord.accSing.accLines);
            Success:= true;
            Break;
          except
            on E: Exception do
              if BreakOnTrySaveWareException(Ord.accSing.Num, E.Message) then break;
          end;

          s1:= DoAfterTrySaveWare(Ord.accSing.Num);
          if (s1<>'') then raise Exception.Create(s1); // сообщение в письмо ???
        except
          on E: Exception do begin
            if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
            if E.Message<>'' then
              SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+E.Message;
            inc(ErrCount);
          end;
        end;
        inc(RecCount);
      end; // for i:= 0 to Ord.olOrdWares.Count-1 do
      ibsGB.Close;

//---------------------------- записали товары - проверяем ошибки записи товаров
      Success:= true;
      if (ErrCount>0) then begin
        SaveErrStr:= SaveErrStr+fnIfStr(SaveErrStr='', '', #13#10)+
         'Ошибка записи товаров в '+sDoc4+' '+Ord.accSing.Num+' - '+IntToStr(ErrCount)+' поз.';
        Success:= (ErrCount<RecCount);
      end;
      ibsGB.ParamCheck:= False;
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
      ibsGB.SQL.Clear;
      ibsGB.SQL.Add('execute block as begin'); // убираем спец.признак - счет в работе
      ibsGB.SQL.Add(' update PayInvoiceReestr set PINVCLIENTCOMMENT="" where PInvCode='+sAccID+';');
      if not Success then                        // если все не записались
        ibsGB.SQL.Add('execute procedure Vlad_CSS_AddCommToAcc('+sAccID+
                      ', " - Ошибка записи товаров в '+sDoc4+'.");');
      ibsGB.SQL.Add(' end');

      s1:= RepeatExecuteIBSQL(ibsGB, accRepeatCount); // accRepeatCount попыток
      if (s1<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
        'Ошибка записи комментария в '+sDoc4+' '+sAccID+': '+s1;
      ibsGB.ParamCheck:= True;

//---------------------------------------- записали счет - проверяем сумму счета
      ibsGBt.Close;
      if not ibsGBt.Transaction.InTransaction then ibsGBt.Transaction.StartTransaction;
      ibsGBt.SQL.Text:= 'SELECT r.PInvSumm aSUMM, r.PInvDate aDATE,'+
        ' (select sum(pinvlnprice*pinvlncount) from PAYINVOICELINES'+
        '   where pinvlndocmcode=r.PInvCode) sumlines'+
        ' from PayInvoiceReestr r where r.PInvCode='+sAccID;
      ibsGBt.ExecQuery;
      if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('Not found aCODE='+sAccID);
      Ord.accSing.AccSumm:= ibsGBt.FieldByName('aSUMM').AsFloat;
      Ord.accSing.sumlines:= ibsGBt.FieldByName('sumlines').AsFloat;
      Ord.accSing.sDate:= ibsGBt.FieldByName('aDATE').AsString;
      ibsGBt.Close;

  //-------------------------------- если unit-счет - добавляем к unit-резерву к/а
      if (Ord.currID=Cache.BonusCrncCode) then
        Ord.firma.BonusRes:= Ord.firma.BonusRes+Ord.accSing.AccSumm;

//--------------------------------------------------- строка закрывающих док-тов
      Ord.accSing.recDoc:= 0;
      ibsOrd.Close;
      ibsOrd.ParamCheck:= False;
      ibsOrd.SQL.Clear;
      sQty:= StringReplace(FloatToStr(RoundTo(Ord.accSing.AccSumm, -2)), ',', '.', [rfReplaceAll]);
      if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
      ibsOrd.SQL.Add('execute block returns (RecCode integer) as begin RecCode=0;');
      ibsOrd.SQL.Add(' insert into OrdersClosingDocs (OCDOrderCode, OCDAccCode,'+
                     ' OCDAccNumber, OCDAccDate, OCDAccCrnc, OCDAccDprt, OCDAccSumm)');
      ibsOrd.SQL.Add(' values ('+sOrderID+', '+sAccID+',"'+Ord.accSing.Num+'", "'+
                     Ord.accSing.sDate+'",'+sCurrID+','+sDprtID+', '+sQty+')'+
                     ' returning OCDCODE into RecCode;');
      if (ord.accJoin.ID<1) then //---------- записываем привязку заказа к счету
        ibsOrd.SQL.Add(' UPDATE ORDERSREESTR SET ORDRGBACCCODE='+sAccID+
                       ', ORDRGBACCNUMBER="'+Ord.accSing.Num+'",'+
                       fnIfStr(flSaveCont, ' ORDRCONTRACT='+sContID+',', '')+
                       ' ORDRGBACCTIME="NOW" WHERE ORDRCODE='+sOrderID+';');
      ibsOrd.SQL.Add(' suspend; end');
ErrPos:= '8';
      s1:= RepeatExecuteIBSQL(ibsOrd, 'RecCode', Ord.accSing.recDoc, accRepeatCount);
      if (s1<>'') or (Ord.accSing.recDoc<1) then
        ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
          'Ошибка записи строки док-тов, '+sDoc1+' '+Ord.accSing.Num+': '+s1;
      ibsOrd.ParamCheck:= True;
    end; //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX запись отдельного счета

    //------------------------------------------------------------ меняем статус
    if not ibsOrd.Transaction.InTransaction then ibsOrd.Transaction.StartTransaction;
    ibsOrd.SQL.Text:= ' UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstAccepted)+
                      ' WHERE ORDRCODE='+sOrderID;
    s1:= RepeatExecuteIBSQL(ibsOrd, accRepeatCount);
    if (s1<>'') then begin
      s:= '!!! Сбой при замене статуса заказа '+Ord.ORDRNUM;
      SaveErrStr:= fnIfStr(SaveErrStr='', '', SaveErrStr+#13#10)+s+
                   ', возможно формирование дубликата счета.';
      ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+s+': '+s1;
    end;


//-------------------------------- отсылаем письмо о создании / добавлении счета
    if CreateMail then begin
      s:= prSendMessAboutCreateAccount(Ord, ThreadData.ID, SaveErrStr);
      if (s<>'') then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+s;
    end; // if CreateMail

//---------------------------------------------------------------- ответ клиенту
    if (WaresErrMess<>'') then Result:= erWareToAccount; // если были ошибки при записи товаров
  except
    on E: Exception do begin
      Result:= aeCommonError;
      WaresErrMess:= 'Ошибка записи документа.';
      ErrorStr:= ErrorStr+fnIfStr(ErrorStr='', '', #13#10)+E.Message;
    end;
  end;
  finally
    if (ErrorStr<>'') or (SaveErrStr<>'') then fnWriteToLogPlus(ThreadData,
      lgmsSysError, nmProc, ErrorStr, SaveErrStr, 'Заказ '+Ord.ORDRNUM, false, 'error');
//      lgmsSysError, nmProc, ErrorStr, SaveErrStr, 'ErrPos= '+ErrPos, false, 'error');
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    prFreeIBSQL(ibsGBt);
    cntsGRB.SetFreeCnt(ibGBt);
    prFreeIBSQL(ibsOrd);
    cntsORD.SetFreeCnt(ibOrd);
    prFree(Ord.accSing.accLines);
    prFree(Ord.accJoin.accLines);
    prFree(Ord.olOrdWares);
  end;
  if flDebug then prMessageLOGS(nmProc+': '+GetLogTimeStr(LocalStart), fLogDebug, false); // пишем в log
end;

//================================ получить текущий курс валюты (def - EUR->UAH)
function GetRateCurr(crnc: Integer=cDefCurrency; crncTo: Integer=cUAHCurrency): Double;
var ibsGB: TIBSQL;
    ibGB: TIBDatabase;
begin
  Result:= 0;
  ibGB:= nil;
  ibsGB:= nil;
  try try
    ibGB:= cntsGRB.GetFreeCnt;
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsOrd_GetRateCurr', -1, tpRead, True);
                       // пересчитываем 1.0 из одной валюты в другую
    ibsGB.SQL.Text:= 'select resultvalue from convertmoney (1.0, '+
                     IntToStr(crnc)+', '+IntToStr(crncTo)+', "TODAY")'+
                     ' where exists(select * from RateCrnc where RateCrncCode='+IntToStr(crnc)+')';
    ibsGB.Prepare;
    ibsGB.ExecQuery;
    if not (ibsGB.Bof and ibsGB.Eof) and not ibsGB.fields[0].IsNull then
      Result:= ibsGB.fields[0].AsFloat;
    ibsGB.Transaction.Rollback;
  except
    on E: Exception do prMessageLOGS('GetRateCurr: '+E.Message);
  end;
  finally
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
  end;
end;
//=============================== проверяем, не относится ли логин к запрещенным
function fnNotLockingLogin(Login: String): Boolean;
begin
  Result:= true;
  Login:= UpperCase(Login);
  if (Pos('ABUSE', Login)>0)    or (Copy(Login, 1, 3)='ADM')    or
     (Pos('EVERYONE', Login)>0) or (Pos('INPUT', Login)>0)      or
     (Pos('LIST', Login)>0)     or (Pos('MDAEMON', Login)>0)    or
     (Pos('ORDER', Login)>0)    or (Pos('POSTMASTER', Login)>0) or
     (Pos('SERVERMAIL', Login)>0) then Result:= false;
end;
//======================================== признак записи в LOG в зав-ти от вида
function ToLog(vid: Integer): Boolean;
// запись в текстовый LOG: 0- сообщения потоков, 1- содержимое ответов, 2- события,
// 3- FormVladTables, 4- форм.остатков, 5- запись заказа, 6- сообщения почтовика,
// 7- содержание запросов, 8- чистка старых ответов, 9- OrderToGB
// запись в ib_ord: соответственно 10+x
begin
  Result:= vid in SaveToLog;
end;
//============================================================= виды логирования
// если запущены почтовые потоки, можно изменить "на лету", иначе только при запуске или Resume
procedure GetLogKinds;
var pIniFile: TIniFile;
    ar: Tas;
    i, j: integer;
begin
  pIniFile:= TINIFile.Create(nmIniFileBOB);
  try
    ar:= fnSplitString(pIniFile.ReadString('Logs', 'SaveToLog', ''), ',');
    if (length(ar)>0) then for i:= Low(ar) to High(ar) do begin
      j:= StrToIntDef(ar[i], 0);
      if not (j in SaveToLog) then Include(SaveToLog, j);
    end;
  finally
    prFree(pIniFile);
    setLength(ar, 0);
  end;
end;

//******************************************************************************
//                       функции системных сообщений
//******************************************************************************
//============================================ строка "сообщение от" CSS-сервера
function GetMessageFromSelf: String;
begin
  Result:= FormatDateTime(cDateTimeFormatY2S, Now)+' Message from '+
           Application.Name+', '+fnGetComputerName+#10;
end;
//================================================ отправить системное сообщение
function n_SysMailSend(ToAdres, Subj: String; Body: TStrings=nil; Attachments: TStrings=nil;
         From: string =''; nmIniFile: string =''; flSaveToFile: boolean=False): string;
// ToAdres - адрес кому, Subj - тема, Body - строки сообщения, Attachments - список прикрепленных файлов
// From - адрес от кого, nmIniFile - имя ini-файла
var IdSMTP0: TIdSMTP;
    MsgRecive0: TIdMessage;
    pIniFile: TIniFile;
    PlugMail, fname, dir, s: string;
    i, j: integer;
    AttErrors: TStringList;
    htmpart: TIdText;
begin
  Result:= '';
  AttErrors:= nil;
  if nmIniFile='' then nmIniFile:= nmIniFileBOB;
  while Cache.flMailSendSys do begin
    sleep(101); // ждем, если идет отправка сист.сообщения
    Application.ProcessMessages;
  end;
  try
    ToAdres:= trim(ToAdres);
    if (ToAdres='') or not fnCheckEmail(ToAdres) then
      raise Exception.Create('Некорректное значение ToAdres='+ToAdres);
    pIniFile:= TINIFile.Create(nmIniFile);
    IdSMTP0:= TIdSMTP.Create(nil);
    MsgRecive0:= TIdMessage.Create(nil);
    Cache.flMailSendSys:= True;
    try
      IdSMTP0.AuthType:= satNone; // отключаем авторизацию
      IdSMTP0.ConnectTimeout:= 120000;
      IdSMTP0.Port:= pIniFile.ReadInteger('mail', 'SysPortTo', 0); // PortTo = 25
      if IdSMTP0.Port<1 then
        raise Exception.Create('Некорректное значение SysPortTo='+pIniFile.ReadString('mail', 'SysPortTo', ''));
      IdSMTP0.Host:= pIniFile.ReadString('mail', 'SysHost', '');  // Host = 'gatenet'
      IdSMTP0.Username:= pIniFile.ReadString('mail', 'SysServerID', ''); // логин
      IdSMTP0.Password:= pIniFile.ReadString('mail', 'SysServerPW', ''); // пароль
//      MsgRecive0.CharSet:= cCharSetUtf;
//      MsgRecive0.CharSet:= cCharSetKoi;  // переводим все в Koi-8

      MsgRecive0.ContentType:= 'multipart/mixed';
      htmpart:= TIdText.Create(MsgRecive0.MessageParts, nil);
      htmpart.ContentType:= 'text/html; charset='+LowerCase(cCharSetWin);
      if Assigned(Body) then
        htmpart.Body.Text:= StringReplace(body.Text, #10, '<br>', [rfReplaceAll]);

      MsgRecive0.CharSet:= cCharSetWin;
      MsgRecive0.OnInitializeISO:= VSMail.OnInitISO;
      PlugMail:= pIniFile.ReadString('mail', 'PlugMail', ''); // адрес-заглушка
      if PlugMail='' then begin
        MsgRecive0.Recipients.EMailAddresses:= ToAdres; // адреса "кому"
        MsgRecive0.Subject:= Subj; // тема
      end else begin
        MsgRecive0.Recipients.EMailAddresses:= PlugMail; // адреса "кому"
        MsgRecive0.Subject:= Subj+' (для '+ToAdres+')'; // тема
      end;
      if (From='') then From:= pIniFile.ReadString('mail', 'SysAdresFrom', ''); // адрес "от кого"
      i:= pos(',', From); //  если адресов у отправителя несколько - берем 1-й
      if i>0 then From:= copy(From, 1, i-1);
      MsgRecive0.From.Text:= From; // адрес "от кого"

//      MsgRecive0.Date:= Now;
      MsgRecive0.UseNowForDate:= True;
      MsgRecive0.ExtraHeaders.Add(VSMail.Xstring);  // вставка строки в заголовок

      if Assigned(Attachments) and (Attachments.Count>0) then begin  // прикрепляем файлы
        dir:= fnGetErrMailFilesDir;
        for i:= Attachments.Count-1 downto 0 do begin
          s:= Attachments[i];
          if not SysUtils.FileExists(s) then j:= -1
          else j:= GetFileSize(s) div (1024*1024);
          fname:= ExtractFileName(s);
          if (j<0) then begin                           // файл не найден
            s:= 'не найден вложенный файл '+fname;
            MsgRecive0.Body.Add(s);
            if not assigned(AttErrors) then begin
              AttErrors:= TStringList.Create;
              AttErrors.Add('При отправке письма на E-mail '+ToAdres);
            end;
            AttErrors.Add(s);
            Attachments.Delete(i);
                                                        // файл слишком большой
          end else if (j>Cache.GetConstItem(pcMaxAttFileSizeMB).IntValue) then begin
            s:= ' - Не передан файл '+fname+' (более '+IntToStr(j)+' МБ).';
//            MsgRecive0.Body.Add(s);
            htmpart.Body.Text:= htmpart.Body.Text+'<br>'+s;

            if RenameFile(Attachments[i], fnTestDirEnd(dir)+fname) then begin
              s:= ', срок хранения файла - '+IntToStr(Cache.GetConstItem(pcMailFilesStoringDays).IntValue)+' суток.';
              htmpart.Body.Text:= htmpart.Body.Text+'<br> - Файл перемещен в папку '+fnGetComputerName+':'+dir+s;
              htmpart.Body.Text:= htmpart.Body.Text+'<br> Если Вы не получили файл из браузера, сообщите системным администраторам';
              htmpart.Body.Text:= htmpart.Body.Text+'<br> имена папки и файла из этого письма с запросом о передаче Вам файла по сети.';
//              MsgRecive0.Body.Add(' - Файл перемещен в папку '+fnGetComputerName+':'+dir+s);
//              MsgRecive0.Body.Add(' Если Вы не получили файл из браузера, сообщите системным администраторам');
//              MsgRecive0.Body.Add(' имена папки и файла из этого письма с запросом о передаче Вам файла по сети.');
            end;
            Attachments.Delete(i);

          end else begin                                // прикрепляем файл
            TIdAttachmentFile.Create(MsgRecive0.MessageParts, Attachments[i]);
            sleep(101);
          end;
        end; // for i:= Attachments.Count-1 downto 0
      end;

      for i:= 1 to RepeatCount do // RepeatCount попыток подключения
        try
          Application.ProcessMessages;
          IdSMTP0.Connect; // подключаемся к почтовому серверу
          sleep(101);
          if IdSMTP0.Connected then break else raise Exception.Create(''); // проверяем подключение
        except
          on E: Exception do
            if i<RepeatCount then sleep(997)
            else raise Exception.Create('Нет подключения к '+IdSMTP0.Host+': '+E.Message);
        end;

      IdSMTP0.Send(MsgRecive0); // отправляем письмо
      sleep(101);
    finally
      prFree(MsgRecive0);
      if Assigned(IdSMTP0) and IdSMTP0.Connected then IdSMTP0.Disconnect;
      prFree(IdSMTP0);
      prFree(pIniFile);
      Cache.flMailSendSys:= False;
    end;
  except
    on E: Exception do Result:= E.Message;
  end;

//------------------------------------------------------------------------------
  if (Result<>'') and flSaveToFile then try // запись набора строк письма в файл
    s:= '';
    if fnSaveMailStringsToFile(ToAdres, Subj, From, Body, Attachments, s) then
      Result:= Result+#13#10'  письмо записано в файл '+s
    else Result:= Result+#13#10'  '+MessText(mtkErrMailToFile)+' '+s;
  except end;
//------------------------------------------------------------------------------
  if assigned(AttErrors) then begin
    if AttErrors.Count>0 then begin
      prMessageLOGS('Error send files:');
      for i:= 0 to AttErrors.Count-1 do prMessageLOGS(AttErrors[i]);
      AttErrors.Insert(0, GetMessageFromSelf);
      s:= n_SysMailSend(fnGetSysAdresVlad(caeOnlyDayLess), 'Error send file', AttErrors, nil, '', '', flSaveToFile);
      if (s<>'') then prMessageLOGS('Error send mail to admins: '+s);  // ???
    end;
  end;
  prFree(AttErrors);
end;
//========================================== проверка незабранных файлов отчетов
procedure TestOldErrMailFiles;
var path: string;
    SearchRec: TSearchRec;
    cMailFilesStorDays: Integer;
begin
  try
    path:= fnGetErrMailFilesDir;
    if (FindFirst(path, faDirectory, SearchRec)<>0) then Exit;
    path:= path+PathDelim;
    cMailFilesStorDays:= Cache.GetConstItem(pcMailFilesStoringDays).IntValue;
    try                                       // ищем файлы rep*.zip - отчеты
      if (FindFirst(path+'rep*.zip', faAnyFile, SearchRec)=0) then repeat
        if ((Now-SearchRec.TimeStamp)>cMailFilesStorDays) then // если файл пролежал cMailFilesStorDays суток - удаляем
          DeleteFile(path+SearchRec.Name);
        Application.ProcessMessages;
      until FindNext(SearchRec)<>0;
    except
      on E: Exception do if (E.Message<>'') then prMessageLOGS('TestOldMailFiles: '+E.Message);
    end;
  finally
    FindClose(SearchRec);
  end;
end;
//=============================================================== Email филиала
function fnGetManagerMail(code: Integer; Mailelse: String): String;
begin
  if Cache.DprtExist(code) and (Cache.arDprtInfo[code].MailOrder<>'') then
    Result:= Cache.arDprtInfo[code].MailOrder
  else Result:= Mailelse;
end;
//================================================ допустимое время для операций
function fnGetActionTimeEnable(kind: integer=caeOnlyDay): Boolean;
var h, dw: integer;
begin
  Result:= True;
  h:= HourOfTheDay(Now);  // HourOfTheDay returns a value between 0 and 23
  dw:= DayOfTheWeek(Now); // DayOfTheWeek returns a value between 1 and 7, where 1 indicates Monday and 7 indicates Sunday.
  case kind of
    caeOnlyDay: Result:= (h in [8..18]);     // только днем - можно с 8 до 19
    caeOnlyDayLess:                          // только днем и по выходным поменьше
      if (dw in [DaySaturday, DaySunday]) then Result:= (h in [9..17]) // по выходным можно с 9 до 18
      else Result:= (h in [8..18]);                                     // в раб.дни можно с 8 до 19
    caeOnlyWorkDay:                          // только днем в рабочие дни
      Result:= not (dw in [DaySaturday, DaySunday]) and (h in [8..18]);
    caeOnlyWorkTime:                         // только в рабочее время - пн-пт с 9 до 18
      Result:= not (dw in [DaySaturday, DaySunday]) and (h in [9..17]);
    caeSmallWork:                            // только в периоды малой загрузки системы
//      if flDebug then Result:= True else                        // debug
      if (dw=DaySunday) then Result:= True                      // по воскресеньям
      else if (dw=DaySaturday) then Result:= not (h in [9..16]) // не по субботам с 9 до 17
      else Result:= not (h in [9..17]);                         // не в раб.дни с 9 до 18
    caeTechWork:  // период тех.работ
      Result:= (h in [0..fnIfInt((dw=DaySunday), 7, 4), 23]);
  end;
end;
//==================================================== адреса для сист.сообщений
function fnGetSysAdresVlad(kind: integer=caeOnlyDay): string;
var s, s1: string;
    ar: Tas;
    i: integer;
begin
  Result:= '';
  s:= GetIniParam(nmIniFileBOB, 'mail', 'SysAdresVlad');
  ar:= fnSplitString(s, ',');
  for i:= Low(ar) to High(ar) do begin
    if (pos('@sms.', ar[i])<1) then s1:= ar[i]
    else if fnGetActionTimeEnable(kind) then s1:= ar[i] else s1:= ''; // отрезаем адреса для SMS
    if s1<>'' then Result:= Result+fnIfStr(Result='', '', ',')+s1;
  end;
  setLength(ar, 0);
end;

//******************************************************************************
//              функции отправки системных сообщений из файлов
//******************************************************************************
//============================================ запись набора строк письма в файл
function fnSaveMailStringsToFile(ToAdres, Subj, From: String;
         Body, Attachments: TStrings; var FileName: String): Boolean;
var FileHandle, i: integer;
    s, file_block, ex: string;
    list: TStringList;
begin
  Result:= False;
  list:= TStringList.Create; // формируем набор строк для записи в файл
  try
    if Assigned(Body) then list.AddStrings(Body); // пишем тело письма
    list.Insert(0, ToAdres);  // вставляем строку с адресом кому
    list.Insert(1, Subj);     // вставляем строку с темой
    if From='' then From:= 'no'; // не пишем пустых строк для корректного считывания
    list.Insert(2, From);     // вставляем строку с адресом от кого

    if Assigned(Attachments) and (Attachments.Count>0) then begin // если есть приложенные файлы - переименовываем
      s:= fnGetMailFilesPath+'att';                // папка прилож.файлов для писем из файлов
      if not DirectoryExists(s) then CreateDir(s); // если нет папки - создаем
      for i:= 0 to Attachments.Count-1 do begin
        file_block:= fnTestDirEnd(s)+ExtractFileName(Attachments.Strings[i]); // новое имя файла
        FileHandle:= 0;
        ex:= ExtractFileExt(file_block); // расширение файла
        while FileExists(file_block) do begin // проверяем уникальность имени файла в папке
          inc(FileHandle);
          file_block:= copy(file_block, 1, pos(ex, file_block)-1)+'_'+IntToStr(FileHandle)+ex;
        end;
        RenameFile(Attachments.Strings[i], file_block); // переносим файл ??? или копируем
        Attachments.Strings[i]:= file_block;           // переписываем в Attachments
      end;
      s:= Attachments.CommaText;
    end else s:= 'no'; // не пишем пустых строк для корректного считывания
    list.Insert(3, s);  // вставляем строку с именами приложенных файлов

    FileHandle:= -1;
    if FileName='' then s:= fnGenRandString(6) else s:= FileName;
    FileName:= PrefixMailFile+s+ExtMailFile; // имя файла письма
    s:= fnGetMailFilesPath+FileName;         // полное имя файла

    for i:= 1 to RepeatCount do try
      while FileExists(s) do begin  // проверяем уникальность имени файла
        s:= fnGenRandString(6, true);
        FileName:= PrefixMailFile+s+ExtMailFile; // имя файла для записи
        s:= fnGetMailFilesPath+FileName;         // полное имя файла
      end;

      file_block:= fnGetLockFileName(s); // файл блокировки (защита на время записи)
      try
        FileHandle:= fnTestFileCreate(file_block); // создаем файл блокировки
        Result:= fnStringsLogToFile(list, s); // запись набора строк письма в файл
      except end;

      if (FileHandle>-1) then DeleteFile(file_block); // удаляем файл блокировки
      if Result then break;
    except end;
  finally
    prFree(list);
  end;
end;
//========================================================== путь к файлам писем
function fnGetMailFilesPath: String;
begin
  Result:= GetAppExePath+DirMailFiles;     // полное имя папки
  if not DirectoryExists(Result) then CreateDir(Result); // если нет - создаем
  Result:= fnTestDirEnd(Result);                         // путь
end;
//============================================== папка с неотправленными файлами
function fnGetErrMailFilesDir: String;
begin
  Result:= fnGetMailFilesPath+'err';
  if not DirectoryExists(Result) then CreateDir(Result); // если папки нет - создаем
end;
//========================================================= имя файла блокировки
function fnGetLockFileName(FileName: String): String;
begin
  Result:= ChangeFileExt(FileName, '.lck'); // меняем расширение
end;
//======================================================= сообщения пользователю
function MessText(kind: TMessTextKind; str: string=''): String;
begin
  case kind of
    mtkNotValidLogin   : Result:= 'Логин должен иметь длину от 5 до '+fnIfStr(str='', '20', str)+' символов и состоять только из цифр и латинских букв.';
    mtkNotValidPassw   : Result:= 'Пароль должен иметь длину от 5 до '+fnIfStr(str='', '20', str)+' символов и состоять только из цифр и латинских букв.';
    mtkNotRightExists  : Result:= 'У Вас нет прав на выполнение этой операции.'; // not ...Empl...UserRoleExists
    mtkNotClientOfFirm : Result:= 'Пользователь не относится к числу должностных лиц контрагента.'; // Client...FirmID<>FirmID
    mtkErrorUserID     : Result:= 'Некорректный код пользователя.';
    mtkNotFoundWares   : Result:= 'Не найдены товары';
    mtkNotFoundWaresSem: Result:= 'Не найдены товары в наличии на складе';
    mtkNotFoundRecord  : Result:= 'Не найдена строка для редактирования.';
    mtkNotFoundData    : Result:= 'Нет данных.';
    mtkEmptySysName    : Result:= 'Не задано системное наименование.';
    mtkNotParams       : Result:= 'Не заданы параметры.';
    mtkNotEnoughParams : Result:= 'Не хватает параметров';
    mtkNotValidParam   : Result:= 'Некорректный параметр';
    mtkNotChanges      : Result:= 'Нет изменений.';
    mtkErrEditRecord   : Result:= 'Ошибка изменения строки в базе данных.';
    mtkErrAddRecord    : Result:= 'Ошибка добавления строки в базу данных.';
    mtkErrDelRecord    : Result:= 'Ошибка удаления строки из базы данных.';
    mtkErrProcess      : Result:= 'Ошибка выполнения.';
    mtkErrConnectToDB  : Result:= 'Ошибка подключения к базе данных.';
    mtkModelNodeLink   : Result:= 'связь модели с узлом';
    mtkWareModNodeLink : Result:= 'связь товара с моделью и узлом';
    mtkWareAttrValue   : Result:= 'значение атрибута товара';
    mtkExitBySuspend   : Result:= 'прерываю процесс по команде Suspend';
    mtkErrCopyFile     : Result:= 'Ошибка копирования в файл ';
    mtkCommonErrorText : Result:= 'Ошибка на стороне сервера ';
    mtkFuncNotAvailabl : Result:= 'функция недоступна';
    mtkWareModNodeUse  : Result:= 'условие применения товара к модели и узлу';
    mtkWareModNodeUses : Result:= 'набор условий применения товара к модели и узлу';
    mtkWareArticleLink : Result:= 'связь товара с артикулом';
    mtkWareOrNumLink   : Result:= 'связь товара с оригинальным номером';
    mtkWareModNodeText : Result:= 'связь текста с товаром, моделью и узлом';
    mtkWareModNodeTexts: Result:= 'набор связей текстов с товаром, моделью и узлом';
    mtkRegOrdAddOrAnn  : Result:= 'Заявка уже принята или аннулирована.';
    mtkRegOrdNotYourFil: Result:= 'Заявка не относится к Вашему филиалу.';
    mtkNotFoundRegOrd  : Result:= 'Не найдена заявка.';
    mtkNotSetLogin     : Result:= 'Не задан логин.';
    mtkErrFormTmpPass  : Result:= 'Ошибка формирования временного пароля.';
    mtkNotSetRegion    : Result:= 'Не задан регион.';
    mtkNotFoundNodes   : Result:= 'Не найдены узлы';
    mtkErrMailToFile   : Result:= 'Ошибка записи письма в файл';
    mtkMailWillSend    : Result:= '!!!  Сообщение записано и будет отправлено позже.';
    mtkLockingLogin    : Result:= 'Логин `'+str+'` уже зарегистрирован в системе.';        // not fnNotLockingLogin
    mtkNotFoundFile    : Result:= 'Не найден файл ';
    mtkNotFoundOrNum   : Result:= 'Не найден оригинальный номер';
    mtkNotEmplExist    : Result:= 'Не найден сотрудник'+fnIfStr(str='', '.', ', код - '+str);         // not EmplExist(
    mtkNotFoundEmplMail: Result:= 'Не найден E-mail сотрудника '+str;
    mtkNotClientExist  : Result:= 'Не найден пользователь'+fnIfStr(str='', '.', ', код - '+str);      // not ClientExist(
    mtkNotFirmExists   : Result:= 'Не найден контрагент'+fnIfStr(str='', '.', ', код - '+str);        // not FirmExist(
    mtkNotFoundFirmCont: Result:= 'Не найден контракт контрагента'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundFirms   : Result:= 'Не найдены контрагенты.';
    mtkNotDprtExists   : Result:= 'Не найдено подразделение'+fnIfStr(str='', '.', ', код - '+str);    // not DprtExist(
    mtkNotFoundTypeSys : Result:= 'Не найдена система учета'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundModel   : Result:= 'Не найдена модель'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundModLine : Result:= 'Не найден модельный ряд'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundManuf   : Result:= 'Не найден производитель'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundNode    : Result:= 'Не найден узел'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundWare    : Result:= 'Не найден товар'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundAttGr   : Result:= 'Не найдена группа атрибутов'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundOrder   : Result:= 'Не найден заказ'+fnIfStr(str='', '', ', код - '+str);
    mtkNotFoundOrders  : Result:= 'Не найдены заказы';
    mtkNotFoundCont    : Result:= 'Не найден контракт'+fnIfStr(str='', '', ', код - '+str);
    mtkContNotAvailable: Result:= 'Контракт недоступен'+fnIfStr(str='', '', ', код - '+str);
    mtkNotFoundAvaiCont: Result:= 'Не найден доступный контракт';
    mtkEmptyName       : Result:= 'Не задано наименование'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotEditOrder    : Result:= 'Заказ нельзя редактировать'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotProcOrder    : Result:= 'Заказ нельзя отправить на обработку'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotSysManuf     : Result:= 'Производитель не относится к системе'+fnIfStr(str='', '.', ', код - '+str);
    mtkDuplicateName   : Result:= 'В системе уже есть наименование '+fnIfStr(str='', '', QuotedStr(str));
    mtkDuplicateSysNm  : Result:= 'В системе уже есть системное наименование '+fnIfStr(str='', '', QuotedStr(str));
    mtkNotFirmProcess  : Result:= 'Обработка запросов по контрагенту '+str+' заблокирована.';
    mtkNotLoginProcess : Result:= 'Обработка запросов по логину '+str+' заблокирована.';
    mtkBlockCountLogin : Result:= 'Обработка запросов по логину '+str+' заблокирована из-за превышения лимита запросов.';
    mtkErrSendMess     : Result:= 'Ошибка передачи сообщения'+fnIfStr(str='', '.', ' '+str);
    mtkSpecifyInquiry  : Result:= 'По Вашему запросу найдено слишком много товаров. Пожалуйста, уточните запрос.';
    mtkNotFoundEngine  : Result:= 'Не найден двигатель'+fnIfStr(str='', '.', ', код - '+str);
    mtkFuncNotEnable   : Result:= 'Функция временно недоступна.';
    mtkNotManagerMail  : Result:= 'Не найден адрес менеджера '+fnIfStr(str='', '.', ' '+str);
    mtkNotCreateDir    : Result:= 'Невозможно создать папку'+fnIfStr(str='', '', ' '+str)+'.';
    mtkNotDelPrevFile  : Result:= 'Невозможно удалить предыдущий файл.';
    mtkEndDateMoreBegin: Result:= 'Начальная дата больше конечной!';
    mtkNotEndDateMore  : Result:= 'Конечная дата отчета не может быть дальше чем '+str;
    mtkNotFoundBrand   : Result:= 'Не найден бренд'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundBrandWar: Result:= 'Не найдены товары этого бренда.';
    mtkImportError     : Result:= 'При импорте были обнаружены ошибки. Смотрите отчет!';
    mtkImportSuccess   : Result:= 'Все данные загружены.';
    mtkNotFoundDataUse : Result:= 'Нет данных по выбранным условиям.';
    mtkWareAnalogLink  : Result:= 'связь товара с аналогом';
    mtkWareSatelLink   : Result:= 'связь товара с сопутствующим товаром';
    mtkOnlyFormingOrd  : Result:= 'Операция доступна только для заказов со статусом '+arOrderStatusNames[orstForming];
    mtkUnknownSysType  : Result:= 'Неизвестный тип системы'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundDocum   : Result:= 'Не найден документ'+fnIfStr(str='', '.', ', код - '+str);
  end;
end;                                     // MessText(mtkNotFoundDocum, )
//================================================ запись в Stream инфо о товаре
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream; ffp: TForFirmParams;
          WareID: integer; AnalogsCount: integer=0; SatellsCount: integer=0;
          RestSem: integer=-1; RestTitle: String=''; ModelsEx: Boolean=True);
const nmProc = 'prSaveShortWareInfoToStream'; // имя процедуры/функции
var ware: TWareInfo;
    sMargin, sBonus, ActTitle, ActText: string;
    bon: double;
    prices: TDoubleDynArray;
    i, iCode, aCode: Integer;
    flag: Boolean;
begin
  try
    ware:= Cache.GetWare(WareID);
    Stream.WriteInt(WareID);             // код товара

    iCode:= ware.AttrGroupID;
    if (iCode<1) then begin
      iCode:= ware.GBAttGroup;
      if (iCode>0) then iCode:= iCode+cGBattDelta;
    end;
    Stream.WriteInt(iCode);   // группа атрибутов

    Stream.WriteInt(AnalogsCount);        // кол-во аналогов
    Stream.WriteInt(SatellsCount);        // кол-во сопут.товаров
    Stream.WriteStr(ware.WareBrandName);  // бренд
    Stream.WriteStr(ware.BrandNameWWW);   // бренд для файла логотипа
    Stream.WriteStr(ware.BrandAdrWWW);    // адрес ссылки на сайт бренда
    Stream.WriteStr(ware.Name);           // наименование
    Stream.WriteBool(ware.IsSale);        // признак распродажи
    Stream.WriteBool(ware.IsNonReturn);   // признак невозврата
    Stream.WriteBool(ware.IsCutPrice);    // признак уценки
    Stream.WriteStr(Ware.PrDirectName);   // название направления по продуктам
    Stream.WriteStr(ware.MeasName);       // ед.изм.
    Stream.WriteDouble(Ware.divis);       // кратность отпуска товара

    aCode:= Ware.GetActionParams(ActTitle, ActText);
    Stream.WriteInt(aCode);         // код акции
    Stream.WriteStr(ActTitle);      // заголовок
    Stream.WriteStr(ActText);       // текст

    Stream.WriteInt(RestSem); // семафор остатков: 0- красный, 1- желтый, 2- зеленый, 3- спец.семафор, другое - нет

if flSpecRestSem then
    Stream.WriteStr(RestTitle); // подсказка для спец.семафора

    Stream.WriteInt(4); // кол-во систем учета

    Stream.WriteInt(constIsAuto); // код системы учета AUTO
    flag:= ModelsEx and ware.SysModelsExists(constIsAuto);
    Stream.WriteBool(flag); // признак наличия моделей AUTO

    Stream.WriteInt(constIsMoto); // код системы учета MOTO
    flag:= ModelsEx and ware.SysModelsExists(constIsMoto);
    Stream.WriteBool(flag); // признак наличия моделей MOTO

//------------------------------------ добавляем грузовики и оси
    Stream.WriteInt(constIsCV); // код системы учета грузовиков
    flag:= ModelsEx and ware.SysModelsExists(constIsCV);
    Stream.WriteBool(flag); // признак наличия моделей грузовиков

    Stream.WriteInt(constIsAx); // код системы учета осей
    flag:= ModelsEx and ware.SysModelsExists(constIsAx);
    Stream.WriteBool(flag); // признак наличия моделей осей

    sMargin:= '0';
    sBonus:= '0';
//----------------- цены Гроссби (0- Розница, 1- со скидкой, 2- со след.скидкой)
    if ware.IsINFOgr then begin
      for i:= 0 to High(arPriceColNames) do
        Stream.WriteStr(trim(FormatFloat(cFloatFormatSumm, 0)));
    end else begin
      prices:= ware.CalcFirmPrices(ffp);  // цены (0- Розница, 1- со скидкой, 2- со след.скидкой)
      for i:= 0 to High(prices) do Stream.WriteStr(trim(FormatFloat(cFloatFormatSumm, prices[i])));
      if (ffp.currID>0) then begin
        if ffp.ForClient and (ffp.currID<>Cache.BonusCrncCode) then // цена товара с наценкой (% к продажной) для клиента
          sMargin:= trim(FormatFloat(cFloatFormatSumm, prices[0]));
//          sMargin:= trim(FormatFloat(cFloatFormatSumm, ware.MarginPrice(ffp)));

        if not fnNotZero(ffp.rate) then
          prices:= ware.CalcFirmPrices(ffp.ForFirmID, cDefCurrency, ffp.contID);
        bon:= prices[1]*Cache.GetPriceBonusCoeff(ffp.currID);
        sBonus:= trim(FormatFloat(cFloatFormatSumm, bon)); // баллы (не unit-заказ)
      end;
    end;
    Stream.WriteStr(sMargin);         // цена с наценкой
    Stream.WriteStr(sBonus);          // бонусы (не unit-заказ)
    Stream.WriteStr(ware.CommentWWW); // описание товара для Web с учетом типа товара
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  SetLength(prices, 0);
end;
//======================= запись в Stream инфо о товаре (вызов из prGetWareList)
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream; WareID, FirmID, UserID: integer;
          AnalogsCount: integer=0; currID: Integer=0; ForFirmID: integer=0; SatellsCount: integer=0;
          contID: integer=0; RestSem: integer=-1; RestTitle: String=''; ModelsEx: Boolean=True);
const nmProc = 'prSaveShortWareInfoToStream'; // имя процедуры/функции
var ware: TWareInfo;
    sMargin, sBonus, ActTitle, ActText: string;
    rate, bon: double;
    prices: TDoubleDynArray;
    i, iCode, aCode: Integer;
    arSys: Tai;
    flag: Boolean;
begin
  try
    ware:= Cache.GetWare(WareID);
    Stream.WriteInt(WareID);             // код товара

    iCode:= ware.AttrGroupID;
    if (iCode<1) then begin
      iCode:= ware.GBAttGroup;
      if (iCode>0) then iCode:= iCode+cGBattDelta;
    end;
    Stream.WriteInt(iCode);   // группа атрибутов

    Stream.WriteInt(AnalogsCount);       // кол-во аналогов
    Stream.WriteInt(SatellsCount);       // кол-во сопут.товаров
    Stream.WriteStr(ware.WareBrandName); // бренд
    Stream.WriteStr(ware.BrandNameWWW);  // бренд для файла логотипа
    Stream.WriteStr(ware.BrandAdrWWW);   // адрес ссылки на сайт бренда
    Stream.WriteStr(ware.Name);          // наименование
    Stream.WriteBool(ware.IsSale);       // признак распродажи
    Stream.WriteBool(ware.IsNonReturn);  // признак невозврата
    Stream.WriteBool(ware.IsCutPrice);   // признак уценки
    Stream.WriteStr(Ware.PrDirectName);  // название направления по продуктам
    Stream.WriteStr(ware.MeasName);      // ед.изм.
    Stream.WriteDouble(Ware.divis);      // кратность отпуска товара

    aCode:= Ware.GetActionParams(ActTitle, ActText);
    Stream.WriteInt(aCode);         // код акции
    Stream.WriteStr(ActTitle);      // заголовок
    Stream.WriteStr(ActText);       // текст

    Stream.WriteInt(RestSem); // семафор остатков: 0- красный, 1- желтый, 2- зеленый, 3- спец.семафор, другое - нет

if flSpecRestSem then
    Stream.WriteStr(RestTitle);     // подсказка для спец.семафора

//    Stream.WriteInt(2); // кол-во систем учета (в Webarm закреплены 2 системы)  ???
    Stream.WriteInt(constIsAuto); // код системы учета AUTO
    flag:= ModelsEx and ware.SysModelsExists(constIsAuto);
    Stream.WriteBool(flag); // признак наличия моделей AUTO

    Stream.WriteInt(constIsMoto); // код системы учета MOTO
    flag:= ModelsEx and ware.SysModelsExists(constIsMoto);
    Stream.WriteBool(flag); // признак наличия моделей MOTO

// добавить грузовики и оси (пока в Webarm закреплены 2 системы)  ???
{//------------------------------------ добавляем грузовики и оси
    Stream.WriteInt(constIsCV); // код системы учета грузовиков
    flag:= ModelsEx and ware.SysModelsExists(constIsCV);
    Stream.WriteBool(flag); // признак наличия моделей грузовиков

    Stream.WriteInt(constIsAx); // код системы учета осей
    flag:= ModelsEx and ware.SysModelsExists(constIsAx);
    Stream.WriteBool(flag); // признак наличия моделей осей  }

    if not Cache.CurrExists(currID) then // определяем валюту, если она не задана
      if (FirmId=IsWe) then currID:= 0
      else if CheckNotValidUser(UserID, FirmID, sBonus) then currID:= 0  // здесь sBonus - заглушка
      else currID:= Cache.arClientInfo[UserID].SEARCHCURRENCYID; // берем валюту из настроек пользователя

    if (FirmId<>IsWe) or (ForFirmID<1) then ForFirmID:= FirmID; // к/а для скидок
    sMargin:= '0';
    sBonus:= '0';
//------------------------------------------------- цены Гроссби
    if ware.IsINFOgr then begin
      for i:= 0 to High(arPriceColNames) do
        Stream.WriteStr(trim(FormatFloat(cFloatFormatSumm, 0)));
    end else begin
      prices:= ware.CalcFirmPrices(ForFirmID, currID, contID); // цены (0- Розница, 1- со скидкой, 2- со след.скидкой)
      for i:= 0 to High(prices) do
        Stream.WriteStr(trim(FormatFloat(cFloatFormatSumm, prices[i])));
      if (currID>0) then begin
                             // цена товара с наценкой (% к продажной) для клиента
        if (FirmId<>IsWe) and (currID<>Cache.BonusCrncCode) then
          sMargin:= trim(FormatFloat(cFloatFormatSumm, prices[0]));
//          sMargin:= trim(FormatFloat(cFloatFormatSumm, ware.MarginPrice(ForFirmID, UserID, currID, contID)));

        rate:= Cache.Currencies.GetCurrRate(currID);    // ???
        if not fnNotZero(rate) then prices:= ware.CalcFirmPrices(ForFirmID, cDefCurrency, contID);
        bon:= prices[1]*Cache.GetPriceBonusCoeff(currID);
        sBonus:= trim(FormatFloat(cFloatFormatSumm, bon)); // баллы (не unit-заказ)
      end;
    end;
    Stream.WriteStr(sMargin);         // цена с наценкой
    Stream.WriteStr(sBonus);          // бонусы (не unit-заказ)
    Stream.WriteStr(ware.CommentWWW); // описание товара для Web с учетом типа товара
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  SetLength(prices, 0);
  SetLength(arSys, 0);          // чистим массивы
end;
//========= запись в Stream блока семафоров наличия товаров (вызов только в Web)
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; ffp: TForFirmParams; wCodes: Tai);
const nmProc = 'prSaveWareRestsExists'; // имя процедуры/функции
var iCount, i, iSem, iPos: integer;
    sArrive: String;
begin
  if not Assigned(wCodes) then SetLength(wCodes, 0);
  iCount:= 0;
  try
    iPos:= Stream.Position;
    Stream.WriteInt(iCount);

    if not ffp.ForClient then Exit; // не надо передавать при ForFirmID<1
    if not Cache.FirmExist(ffp.ForFirmID)
      or not Assigned(wCodes) or (Length(wCodes)<1) then Exit; // нет товаров
    ffp.FillStores;

    for i:= 0 to High(wCodes) do if (wCodes[i]>0) and Cache.WareExist(wCodes[i])
      and Cache.GetWare(wCodes[i]).IsMarketWare(ffp.ForFirmID, ffp.contID) then begin
      iSem:= GetContWareRestsSem(wCodes[i], ffp, sArrive);

      Stream.Writeint(wCodes[i]);
      Stream.Writeint(iSem);

if flSpecRestSem then
      Stream.WriteStr(sArrive); // подсказка к семафору (пока только к 3)

      Inc(iCount);
    end;
    if (iCount>0) then begin
      Stream.Position:= iPos;
      Stream.Writeint(iCount);
      Stream.Position:= Stream.Size;
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
end;
//======================== получить коды складов контракта и код главного склада
function fnGetContMainStoreAndStoreCodes(FirmID, ContID: Integer; var StorageCodes: Tai): Integer;
const nmProc = 'fnGetContMainStoreAndStoreCodes'; // имя процедуры/функции
var Contract: TContract;
begin
  Result:= 0;
  SetLength(StorageCodes, 0);
  if not Cache.FirmExist(FirmID) then Exit;
  Contract:= Cache.arFirmInfo[FirmID].GetContract(ContID);
  Result:= Contract.MainStorage;
  StorageCodes:= Contract.GetContVisStoreCodes;
end;
//============================ проверка семафоров наличия товаров (Web & WebArm)
procedure prCheckWareRestsExists(ffp: TForFirmParams; var OLmarkets: TObjectList; var RestCount: Integer);
const nmProc = 'prCheckWareRestsExists'; // имя процедуры/функции
var i: integer;
    tc: TTwoCodes;
begin
  if not Assigned(OLmarkets) then Exit;
  RestCount:= 0;
  try
    if not ffp.ForClient  // не надо передавать при ForFirmID<1
      or not Cache.FirmExist(ffp.ForFirmID) or (OLmarkets.Count<1) then Exit; // нет товаров
    ffp.FillStores;

    for i:= 0 to OLmarkets.Count-1 do begin
      tc:= TTwoCodes(OLmarkets[i]);
      tc.ID2:= GetContWareRestsSem(tc.ID1, ffp, tc.Name);
      if (tc.ID2>0) then Inc(RestCount);
    end; // for i:= 0 to OLmarkets.Count-1
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
end;
//============ запись в Stream списка видимых сотруднику к/а для выбора (WebArm)
procedure prSaveEmplFirmsChoiceList(Stream: TBoBMemoryStream; EmplID: Integer);
const nmProc = 'prSaveEmplFirmsChoiceList'; // имя процедуры/функции
var i, j, k, jj, ind0, ii: integer;
    firm: TFirmInfo;
    lst: TList;  // not Free !!! список всех доступных фирм
    arLst: array of TList;
    lstf: TStringList; // список филиалов
//    empl: TEmplInfoItem;
//    flAllFirms: Boolean;
begin
  SetLength(arLst, 0);
  lst:= nil;
  lstf:= nil;
  if not Cache.EmplExist(EmplID) then raise EBOBError.Create(MessText(mtkNotEmplExist));

//  empl:= Cache.arEmplInfo[EmplID];                      // все к.а - ЦОК + УиК
//  flAllFirms:= empl.UserRoleExists(rolOPRSK) or empl.UserRoleExists(rolUiK)
//                or empl.UserRoleExists(rolWorkWithOrders); // + работа с заказами (НК)
  try
//    if flAllFirms then begin // все к/а
    lst:= TList.Create;
    for i:= 1 to High(Cache.arFirmInfo) do if Cache.FirmExist(i) then begin
      firm:= Cache.arFirmInfo[i];
      if firm.Arhived then Continue;
//      lst.Add(TLink.Create(0, firm));
      lst.Add(firm);
    end;
    lst.Sort(DirNameSortCompare); // сортируем по наименованию
//    lst.Sort(LinkNameSortCompare); // сортируем по наименованию
//    end else
//      lst:= Cache.GetEmplVisFirmLinkList(EmplID);  // not Free !!! здесь фирмы уже отсортированы по наименованию
    if (lst.Count<1) then raise EBOBError.Create(MessText(mtkNotFoundFirms));
    try
      lstf:= Cache.GetFilialList(False);   // False - полные наименования
      lstf.Sort;          // сортируем филиалы по наименованию

      ind0:= lstf.Count;
      SetLength(arLst, ind0+1); // готовим листы фасовки (+1 для неопознанных)
      for i:= 0 to High(arLst) do arLst[i]:= TList.Create;
      k:= 0;  // код филиала
      j:= -1; // индекс листа филиала
      for i:= 0 to lst.Count-1 do begin // фасуем доступные фирмы по филиалам
//        firm:= GetLinkPtr(lst[i]);
        firm:= lst[i];
        jj:= firm.GetDefContract.Filial;
        if (k<>jj) then begin
          k:= jj;
          j:= lstf.IndexOfObject(Pointer(k));
        end;
        if (j>-1) then arLst[j].Add(firm)  // заносим ссылку на фирму в лист филиала
        else arLst[ind0].Add(firm);        // заносим ссылку на фирму в лист неопознанных
  {if flDebug then
        if (pos('Ремтехкомплект', firm.Name)>0) then begin
          prMessageLOGS('---------- firm.Name  : '+firm.Name, fLogCache);
          prMessageLOGS('---------- firm.ID    : '+IntToStr(firm.ID), fLogCache);
          prMessageLOGS('---------- firm.Filial: '+IntToStr(jj), fLogCache);
          prMessageLOGS('---------- index      : '+IntToStr(j), fLogCache);
        end;  }
      end;

      if (arLst[ind0].Count>0) then begin // добавляем фиктивный филиал
        lstf.AddObject('Филиал не определен', Pointer(0));
      end else begin
        arLst[ind0].Free;
        SetLength(arLst, ind0); // убираем лист для неопознанных
      end;

      Stream.WriteInt(lstf.Count);    // передаем список всех филиалов
      for i:= 0 to lstf.Count-1 do begin
        Stream.WriteInt(Integer(lstf.Objects[i]));  // код филиала
        Stream.WriteStr(lstf[i]);                   // наимен.
      end;

      k:= Stream.Position;
      Stream.WriteInt(lst.Count); // кол-во фирм
      jj:= 0; // счетчик (для надежности)
      for i:= 0 to lstf.Count-1 do begin
        ii:= Integer(lstf.Objects[i]); // код филиала
//  if flDebug then prMessageLOGS('---------- filial '+IntToStr(ii)+': '+lstf[i]+' '+IntToStr(arLst[i].Count)+' firms', fLogDebug, false);
        for j:= 0 to arLst[i].Count-1 do begin // передаем фирмы
          firm:= arLst[i][j];
          Stream.WriteInt(firm.ID);             // код фирмы
          Stream.WriteInt(ii);                  // код филиала
          Stream.WriteStr(firm.UPPERSHORTNAME); // краткое наимен.
          Stream.WriteStr(firm.Name);           // полное наимен.
  //if flDebug then prMessageLOGS('----- firm'+IntToStr(firm.ID)+': '+firm.UPPERSHORTNAME+' '+firm.Name, fLogDebug, false);
          inc(jj);
        end;
      end;
      if jj<>lst.Count then begin // если случаем кол-во не то
        Stream.Position:= k;
        Stream.WriteInt(jj); // передаем кол-во
        Stream.Position:= Stream.Size;
      end;
    except
      on E: EBOBError do raise EBOBError.Create(E.Message);
      on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
    end;
  finally
    for i:= 0 to High(arLst) do prFree(arLst[i]);
    SetLength(arLst, 0);
    prFree(lstf);
//    if flAllFirms then begin
//      for i:= 0 to lst.Count-1 do TLink(lst[i]).Free;
    prFree(lst);
//    end;
  end;
end;
//====================================== запись в Stream списка складов(+путей),
//======================================= видимых сотруднику для выбора (WebArm)
procedure prSaveEmplStoresChoiceList(Stream: TBoBMemoryStream; EmplID: Integer; flWithRoad: Boolean=False);
const nmProc = 'prSaveEmplStoresChoiceList'; // имя процедуры/функции
// flWithRoad=False - только склады, flWithRoad=True - склады + пути
var i, k, jj: integer;
    store: TDprtInfo;
    lst: TList;  // not Free !!! список всех видимых сотруднику складов
begin
  if not Cache.EmplExist(EmplID) then raise EBOBError.Create(MessText(mtkNotEmplExist));
  lst:= TList.Create;
//  lst:= Cache.GetEmplVisStoreLinkList(EmplID);  // not Free !!!
  try
    for i:= 1 to High(Cache.arDprtInfo) do if Cache.DprtExist(i) then begin
      store:= Cache.arDprtInfo[i];
      if not (store.IsStoreHouse or (flWithRoad and store.IsStoreRoad)) then Continue;
      lst.Add(store);
    end;
    if (lst.Count<1) then raise EBOBError.Create('Не найдены доступные склады');
    lst.Sort(DirNameSortCompare);  // склады сортируем по наименованию

    try
      k:= Stream.Position;
      Stream.WriteInt(0); // кол-во складов
      jj:= 0; // счетчик
      for i:= 0 to lst.Count-1 do begin // передаем склады
        store:= Lst[i];
  //      store:= GetLinkPtr(Lst[i]);
        Stream.WriteInt(store.ID);             // код склада
        Stream.WriteStr(store.MainName);       // полное наимен.
        Stream.WriteStr(store.ColumnName);     // наимен. колонки
        Stream.WriteBool(store.IsStoreRoad);   // признак пути
        inc(jj);
      end;
      Stream.Position:= k;
      Stream.WriteInt(jj); // передаем кол-во
      Stream.Position:= Stream.Size;
    except
      on E: EBOBError do raise EBOBError.Create(E.Message);
      on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
    end;
  finally
    prFree(lst);
  end;
end;
//========================================== запись в Stream сообщения об ошибке
procedure prSaveCommonError(Stream: TBoBMemoryStream; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
var s: String;
begin
  if flEBOB then begin
    Stream.Clear;
    Stream.WriteInt(aeCommonError);
    Stream.WriteStr(fnReplaceQuotedForWeb(Emess));
    fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', Emess, MyText);
  end else begin
    Stream.Clear;
    Stream.WriteInt(aeCommonError);
    s:= '';
    if flPRS then s:= CutPRSmess(Emess);
    if s='' then s:= MessText(mtkErrProcess);
    Stream.WriteStr(s);
    fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', Emess, MyText);
  end;
  Stream.Position:= 0;
end;
//========================================== запись в строку сообщения об ошибке
procedure prSaveCommonErrorStr(var errStr: String; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
begin
  if flEBOB then begin
    errStr:= fnReplaceQuotedForWeb(Emess);
    fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', Emess, MyText);
  end else begin
    errStr:= '';
    if flPRS then errStr:= CutPRSmess(Emess);
    if errStr='' then errStr:= MessText(mtkErrProcess);
    fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', Emess, MyText);
  end;
end;
//=========================================== обрезка сообщений от exception ORD
function CutEMess(Emess: String): String;
var i, j: Integer;
begin
  Result:= Emess;
  for j:= Low(arExceptNames) to High(arExceptNames) do begin
    i:= pos(arExceptNames[j], Result);
    if i>0 then begin
      Result:= copy(Result, i, length(Result));
      i:= pos('At procedure', Result);
      if i>0 then Result:= copy(Result, 1, i-1);
      Exit;
    end;
  end;
end;
//============================ обрезка сообщений от exception ORD + resDoNothing
function CutEMess(Emess: String; var ResCode: Integer): String;
begin
  Result:= CutEMess(Emess);
  if pos(arExceptNames[0], Result)>0 then ResCode:= resDoNothing;
end;
//=========================================== обрезать сообщение deadlock и т.п.
function CutLockMess(mess: String): String;
begin
  if (Pos('deadlock', mess)>0) then Result:= 'deadlock ...'
  else if (Pos('another user', mess)>0) or (Pos('lock conflict', mess)>0) then
    Result:= 'lock conflict ...'
  else Result:= mess;
end;
//====================================================== обрезать сообщение PRS.
function CutPRSmess(mess: String): String;
var i: Integer;
begin
  i:= pos('PRS.', mess);
  if i>0 then begin
    Result:= copy(mess, i+4);
    i:= pos(#13#10, Result);
    if i>0 then Result:= copy(Result, 1, i-1);
  end else Result:= mess;
end;
//======================================== Проверить пользователя (Web & WebArm)
function CheckNotValidUser(pUserID, pFirmID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  if pFirmID=isWe then begin                    // проверки WebArm
    if not Cache.EmplExist(pUserID) then errmess:= MessText(mtkNotEmplExist);
  end else                                      // проверки Web
    if not Cache.FirmExist(pFirmID) then errmess:= MessText(mtkNotFirmExists)
    else if Cache.arFirmInfo[pFirmID].Blocked then errmess:= MessText(mtkNotFirmProcess)
    else if not Cache.ClientExist(pUserID) then errmess:= MessText(mtkNotClientExist)
    else with Cache.arClientInfo[pUserID] do
      if Blocked then errmess:= MessText(mtkBlockCountLogin, Login)
      else if FirmID<>pFirmID then errmess:= MessText(mtkNotClientOfFirm);
  Result:= errmess<>'';
end;
//===================================== Получить систему и валюту (Web & WebArm)
procedure prCheckUserForFirmAndGetCurr(UserID, FirmID: Integer;
          var ForFirmID, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);
var errmess: String;
begin
  CurrID:= 0;
  if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
  if FirmID=isWe then begin                    //------------- WebArm
    if (ForFirmID>0) and (not Cache.FirmExist(ForFirmID)  // если задан к/а
      {or not Cache.CheckEmplVisFirm(UserID, ForFirmID)}) then ForFirmID:= 0;
    currID:= fnIfInt(PriceInUah, 1, cDefCurrency);
  end else begin                                //------------- Web
    currID:= Cache.arClientInfo[UserID].SearchCurrencyID;
  end;
  if not Cache.CurrExists(currID) then currID:= cDefCurrency;
end;
(*//===================================== Получить систему и валюту (Web & WebArm)
procedure prCheckUserForFirmAndGetSysCurr(UserID, FirmID: Integer;
          var ForFirmID, Sys, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);
var errmess: String;
begin
  Sys:= 0;
  CurrID:= 0;
  if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
  if FirmID=isWe then begin                    //------------- WebArm
    if (ForFirmID>0) and (not Cache.FirmExist(ForFirmID)  // если задан к/а
      {or not Cache.CheckEmplVisFirm(UserID, ForFirmID)}) then ForFirmID:= 0;
    currID:= fnIfInt(PriceInUah, 1, cDefCurrency);
  end else begin                                //------------- Web
    currID:= Cache.arClientInfo[UserID].SearchCurrencyID;
  end;
  if not Cache.CurrExists(currID) then currID:= cDefCurrency;
end;  *)
//======================================================== проверка сумм док-тов
procedure CheckDocSum;
const nmProc='CheckDocSum';
var GB_IBS: TIBSQL;
    GB_IBD: TIBDatabase;
    i, j, iType, iDocm: integer;
    mess, adr: string;
    curdocs: array of TTwoCodes;
    curdoc: TTwoCodes;
    fl: boolean;
    Body: TStringList;
begin
  if not Assigned(Cache) then Exit;
  if not Cache.flCheckDocSum then exit;
  if not fnGetActionTimeEnable(caeOnlyWorkTime) then Exit; // только в рабочее время
  if (dLastCheckDocTime<>DateNull) and
    (Now<IncMinute(dLastCheckDocTime, Cache.GetConstItem(pcCheckDocInterval).IntValue)) then exit;
  GB_IBS:= nil;
  GB_IBD:= nil;
  Body:= TStringList.Create;
  setlength(curdocs, 0);
  try try
    GB_IBD:= cntsGRB.GetFreeCnt;
    GB_IBS:= fnCreateNewIBSQL(GB_IBD, 'GB_IBS_'+nmProc, -1, tpRead, true);
    iType:= 102; //------------------------------------------------------- счета
    GB_IBS.SQL.Text:= 'select pinvcode, pinvnumber, pinvdate, delta,'+
      ' firmcode, firmmainname, crncshortname'+
      ' from (select rr.pinvcode, rr.pinvnumber, rr.pinvdate, f.firmcode, f.firmmainname,'+
      '  rr.pinvsumm-(1-rr.disc/100)*Lsum delta, cur.crncshortname, rr.Lsum, rr.LCount'+
      '  from (select r.pinvcode, r.pinvnumber, r.pinvdate, r.pinvwarelinecount LCount,'+
      '   r.pinvsumm, r.pinvdiscount disc, r.PInvRecipientCode, r.pinvcrnccode,'+
      '   (select sum(l.pinvlnprice*l.pinvlncount) from PAYINVOICELINES l'+
      '    where l.pinvlndocmcode=r.pinvcode) Lsum from PAYINVOICEREESTR r'+
      '  inner join userpsevdonimreestr on userfirmcode=r.PInvRecipientCode and (usercode<>1)'+
      '  where r.pinvdate>:From order by r.PInvRecipientCode, r.pinvdate) rr'+
      ' left join firms f on f.firmcode = rr.PINVRECIPIENTCODE'+
      ' left join currency cur on cur.crnccode = rr.pinvcrnccode)'+
      ' where ABS(delta)>:Delta or (Lsum>0 and LCount=0)';
    GB_IBS.ParamByName('From').AsDate:= Cache.GetConstItem(pcCheckDocFromDate).DateValue;
    GB_IBS.ParamByName('Delta').AsFloat:= Cache.GetConstItem(pcCheckDocSumDelta).DoubValue;
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iDocm:= GB_IBS.FieldByName('pinvcode').AsInteger;
      j:= length(curdocs); // запоминаем все док-ты
      setlength(curdocs, j+1);
      curdocs[j]:= TTwoCodes.Create(iType, iDocm);
      fl:= False;
      if CheckDocsList.Count>0 then for i:= 0 to CheckDocsList.Count-1 do begin
        with TTwoCodes(CheckDocsList.objects[i]) do fl:= (ID1=iType) and (ID2=iDocm);
        if fl then break;
      end;
      if not fl then begin // если такого док-та в списке нет - дописываем
        mess:= '  счет N '+GB_IBS.FieldByName('pinvnumber').AsString+' от '+
          FormatDateTime(cDateFormatY4, GB_IBS.FieldByName('pinvdate').AsDate)+
          ' - разница = '+FormatFloat('# ##0.000', GB_IBS.FieldByName('delta').AsFloat)+
          ' '+GB_IBS.FieldByName('crncshortname').AsString+
          '   к/а '+GB_IBS.FieldByName('firmmainname').AsString;
        CheckDocsList.AddObject(mess, TTwoCodes.Create(iType, iDocm));
      end;
      TestCssStopException;
      GB_IBS.Next;
    end;
    GB_IBS.Close;


    iType:= -1; //----------------------------------------- контракты без валюты
    GB_IBS.SQL.Text:= 'select f.firmmainname, c.contcode, gn.rNum contnumber'+
      ' from contract c left join firms f on f.firmcode=c.contsecondparty'+
      ' left join Vlad_CSS_GetFullContNum(c.contnumber, c.contnkeyyear, c.contpaytype) gn on 1=1'+
      ' where c.contendingdate>"today" and (c.contdutycrnccode is null or c.contdutycrnccode < 1)'+
      '  and c.contfirstparty=(select userfirmcode from userpsevdonimreestr where usercode=1)'+
      '  and f.firmarchivedkey="F" and f.firmservicefirm="F"'+
      '  and f.FirmOrganizationType=0 and (f.firmchildcount=0'+
      '  or not exists(select * from firms ff where ff.firmmastercode=f.firmcode'+
      '  and ff.FirmOrganizationType=0))';

    if flDebug then GB_IBS.SQL.Text:= GB_IBS.SQL.Text+' and c.contcode<200';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iDocm:= GB_IBS.FieldByName('contcode').AsInteger;
      j:= length(curdocs); // запоминаем все док-ты
      setlength(curdocs, j+1);
      curdocs[j]:= TTwoCodes.Create(iType, iDocm);
      fl:= False;
      if CheckDocsList.Count>0 then for i:= 0 to CheckDocsList.Count-1 do begin
        with TTwoCodes(CheckDocsList.objects[i]) do fl:= (ID1=iType) and (ID2=iDocm);
        if fl then break;
      end;
      if not fl then begin // если такого док-та в списке нет - дописываем
        mess:= 'к/а - '+fnMakeAddCharStr(GB_IBS.FieldByName('firmmainname').AsString, 40, True)+
               ' - контракт '+GB_IBS.FieldByName('contnumber').AsString;
        CheckDocsList.AddObject(mess, TTwoCodes.Create(iType, iDocm));
      end;
      TestCssStopException;
      GB_IBS.Next;
    end;

    for i:= CheckDocsList.Count-1 downto 0 do begin // удаляем те, что ушли
      curdoc:= TTwoCodes(CheckDocsList.Objects[i]);
      fl:= False;
      for j:= 0 to High(curdocs) do begin
        fl:= (curdoc.ID1=curdocs[j].ID1) and (curdoc.ID2=curdocs[j].ID2);
        if fl then break;
      end;
      if fl then Continue;
      prFree(curdoc);
      CheckDocsList.Delete(i);
    end;

    fl:= False;
    for i:= 0 to CheckDocsList.Count-1 do begin // сначала счета
      if (CheckDocsList[i]='') then Continue;
      if (TTwoCodes(CheckDocsList.Objects[i]).ID1<0) then begin
        fl:= True;     // признак, что есть контракты
        Continue;      // контракты пропускаем
      end;
      Body.Add(CheckDocsList[i]);
    end;  // for

    if fl then begin // есть контракты
      Body.Add(' ');
      Body.Add('------------------------------------------------');
      Body.Add('   не задана валюта контракта / задолженности');
      Body.Add('------------------------------------------------');
      for i:= 0 to CheckDocsList.Count-1 do begin
        if (CheckDocsList[i]='') then Continue;
        if (TTwoCodes(CheckDocsList.Objects[i]).ID1>0) then Continue; // счета пропускаем
        Body.Add(CheckDocsList[i]);
      end;  // for
    end;

    if Body.Count>0 then begin
      adr:= Cache.GetConstItem(pcCheckDocMail).StrValue;
      if adr='' then adr:= fnGetSysAdresVlad(caeOnlyWorkDay);
      mess:= n_SysMailSend(adr, 'Проблемные документы', Body, nil, '', '', True);
      if (mess<>'') and (Pos(MessText(mtkErrMailToFile), mess)>0) then
        raise Exception.Create('Ошибка отправки письма о проблемных док-тах')
      else begin
        prMessageLOGS(nmProc+': Отправлено письмо о проблемных док-тах на E-mail '+adr, 'system');
        for i:= 0 to CheckDocsList.Count-1 do
          if (CheckDocsList[i]<>'') then CheckDocsList[i]:= '';
      end;
    end;
    dLastCheckDocTime:= Now;
  finally
    prFreeIBSQL(GB_IBS);
    cntsGRB.SetFreeCnt(GB_IBD);
    prFree(Body);
    for i:= 0 to High(curdocs) do prFree(curdocs[i]);
    setlength(curdocs, 0);
  end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;
//============================================================= проверка адресов
procedure CheckClientsEmails;
const nmProc='CheckClientsEmails';
var GB_IBS: TIBSQL;
    GB_IBD: TIBDatabase;
    i, iFirm: integer;
    mess, adr, sFirm, s: string;
    fl: boolean;
    Body: TStringList;
  //------------------------------------
  procedure SaveFirm;
  begin
    Body.Add('');
    Body.Add('---------- '+sFirm);
    fl:= False;
  end;
  //------------------------------------
begin
  if not Assigned(Cache) then Exit;
  if not Cache.flCheckCliEmails then exit;
  if not fnGetActionTimeEnable(caeOnlyWorkTime) then Exit; // только в рабочее время
  if (dLastCheckCliEmails<>DateNull) and    // если не прошел заданный интервал
    (Now<IncHour(dLastCheckCliEmails, Cache.GetConstItem(pcZeroPricesIntHour).IntValue)) then exit;
  GB_IBS:= nil;
  GB_IBD:= nil;
  Body:= TStringList.Create;
  try try
    GB_IBD:= cntsGRB.GetFreeCnt;
    GB_IBS:= fnCreateNewIBSQL(GB_IBD, 'GB_IBS_'+nmProc, -1, tpRead, true);

    GB_IBS.SQL.Text:= 'select * from (select f.firmmastercode, f.firmcode,'+
      '  f.firmmainname, f.firmemail, null contcode,  null contnumber,'+
      '  null contsecondemail, null prsncode, null prsnpost, null prsnname,'+
      '  null prsnlogin, null peemail from firms f where f.firmarchivedkey="F"'+
      '  and f.FirmOrganizationType=0 and (f.firmchildcount=0'+
      '    or not exists(select * from firms ff where ff.firmmastercode=f.firmcode'+
      '    and ff.FirmOrganizationType=0))'+
      '  and f.firmservicefirm="F" and (f.firmemail is not null)'+
      ' union select f2.firmmastercode, f2.firmcode, f2.firmmainname, null firmemail,'+
      '  c.contcode, gn.rNum contnumber, c.contsecondemail, null prsncode,'+
      '  null prsnpost, null prsnname, null prsnlogin, null peemail from firms f2'+
      '  left join contract c on c.contsecondparty=f2.firmcode where f2.firmarchivedkey="F"'+
      '  left join Vlad_CSS_GetFullContNum(c.contnumber, c.contnkeyyear, c.contpaytype) gn on 1=1'+
      '  and f2.FirmOrganizationType=0 and (f2.firmchildcount=0'+
      '    or not exists(select * from firms ff where ff.firmmastercode=f2.firmcode'+
      '    and ff.FirmOrganizationType=0))'+
      '  and f2.firmservicefirm="F" and c.contfirstparty='+
      '  (select u.userfirmcode from userpsevdonimreestr u where u.usercode=1)'+
      '  and c.contendingdate>"today" and (c.contsecondemail is not null)'+
      ' union select f1.firmmastercode, f1.firmcode, f1.firmmainname, null firmemail, null contcode,'+
      '  null contnumber, null contsecondemail, pr.prsncode, pr.prsnpost, pr.prsnname,'+
      '  pr.prsnlogin, pm.peemail from firms f1 left join persons pr on pr.prsnfirmcode=f1.firmcode'+
      '  left join personemails pm on pm.pepersoncode=pr.prsncode where f1.firmarchivedkey="F"'+
      '  and f1.FirmOrganizationType=0 and (f1.firmchildcount=0'+
      '    or not exists(select * from firms ff where ff.firmmastercode=f1.firmcode'+
      '    and ff.FirmOrganizationType=0))'+
      '  and f1.firmservicefirm="F" and pr.prsnarchivedkey="F"'+
      '  and pm.pearchivedkey="F" and (pm.peemail is not null))'+
      '  order by firmmastercode, firmcode, firmemail nulls last, contcode nulls last, prsncode nulls last';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iFirm:= GB_IBS.FieldByName('firmcode').AsInteger;
      fl:= True;
      sFirm:= 'к/а '+GB_IBS.FieldByName('firmmainname').AsString;
      adr:= GB_IBS.FieldByName('firmemail').AsString;
      if (adr<>'') and not fnCheckEmail(adr) then begin
        if fl then SaveFirm;
        Body.Add('к/а - E-mail: '+adr);
      end;
      while not GB_IBS.Eof and (iFirm=GB_IBS.FieldByName('firmcode').AsInteger) do begin
        i:= GB_IBS.FieldByName('contcode').AsInteger;
        if (i>0) then begin
          s:= 'контракт '+GB_IBS.FieldByName('contnumber').AsString;
          adr:= GB_IBS.FieldByName('contsecondemail').AsString;
          if (adr<>'') and not fnCheckEmail(adr) then begin
            if fl then SaveFirm;
            Body.Add(s+' - E-mail: '+adr);
          end;
        end;
        i:= GB_IBS.FieldByName('prsncode').AsInteger;
        if (i>0) then begin
          s:= 'польз. '+GB_IBS.FieldByName('prsnpost').AsString+', '+GB_IBS.FieldByName('prsnname').AsString;
          adr:= GB_IBS.FieldByName('peemail').AsString;
          if (adr<>'') and not fnCheckEmail(adr) then begin
            if fl then SaveFirm;
            Body.Add(s+' - E-mail: '+adr);
          end;
        end;
        TestCssStopException;
        GB_IBS.Next;
      end;
      TestCssStopException;
    end;
    GB_IBS.Close;

    fl:= True;
    GB_IBS.SQL.Text:='Select EMPLCODE, EMPLMANCODE,'+
      ' MANLASTNAME, MANNAME, MANPATRONYMICNAME, MANWORKEMAIL'+
      ' FROM EMPLOYEES inner join MANS on EMPLMANCODE=MANCODE'+
      ' where EMPLARCHIVE="F" and MANARCHIVE="F"';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      adr:= GB_IBS.FieldByName('MANWORKEMAIL').AsString;
      if (adr<>'') and not fnCheckEmail(adr) then begin
        if fl then begin
          Body.Add('');
          Body.Add('');
          Body.Add('---------- сотрудники Компании');
          fl:= False;
        end;
        s:= GB_IBS.FieldByName('MANLASTNAME').AsString+' '+
            GB_IBS.FieldByName('MANNAME').AsString+' '+
            GB_IBS.FieldByName('MANPATRONYMICNAME').AsString;
        Body.Add(s+' - E-mail: '+adr);
      end;
      TestCssStopException;
      GB_IBS.Next;
    end;
    GB_IBS.Close;

    if Body.Count>0 then begin
      Body.Insert(0, 'Правила написания E-mail:');
      Body.Insert(1, '- формат (имя)@(домен)');
      Body.Insert(2, '- (имя) может содержать только англ.буквы, цифры, точку, тире, подчеркивание');
      Body.Insert(3, '- (домен) может содержать только англ.буквы, цифры, точку, тире');
      Body.Insert(4, '- (имя) и (домен) не должны начинаться и заканчиваться точкой');
      Body.Insert(5, '- (домен) должен содержать не менее 1-й точки');
      Body.Insert(6, '- (домен) должен содержать не менее 2-х символов после последней точки');
      Body.Insert(7, '- несколько E-mail в строке разделяются только запятыми.');
      Body.Insert(8, '');
      Body.Insert(9, 'Перечень E-mail, не соответствующих правилам:');

      adr:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // общий Email отдела УИК
      if adr='' then adr:= fnGetSysAdresVlad(caeOnlyWorkDay);
      mess:= n_SysMailSend(adr, 'Проблемные E-mail', Body, nil, '', '', True);
      if (mess<>'') and (Pos(MessText(mtkErrMailToFile), mess)>0) then
        raise Exception.Create('Ошибка отправки письма о проблемных E-mail')
      else
        prMessageLOGS(nmProc+': Отправлено письмо о проблемных E-mail на E-mail '+adr, 'system');
    end;
    dLastCheckCliEmails:= Now;
  finally
    prFreeIBSQL(GB_IBS);
    cntsGRB.SetFreeCnt(GB_IBD);
    prFree(Body);
  end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;
//=========== Формирование списка префиксов для добавления к артикулу при поиске
function GetLstPrefixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // must Free Result
// UseOnlyBrand = True. вынимать код бренда. False - если по ID необходим конроль группы
var BID: Integer;
begin
  Result:= TStringList.Create;
  if UseOnlyBrand then BID:= Cache.GetGrpID(pBrandID) else BID:= pBrandID;
  case BID of
    85413: Result.Append('AVX');  // CONTITECH
  end;
end;
//=========== Формирование списка суффиксов для добавления к артикулу при поиске
function GetLstSufixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // must Free Result
// UseOnlyBrand = True. вынимать код бренда. False - если по ID необходим конроль группы
var BID: Integer;
begin
  Result:= TStringList.Create;
  if UseOnlyBrand then BID:= Cache.GetGrpID(pBrandID) else BID:= pBrandID;
  case BID of
    85413: Result.Append('LD');   // CONTITECH
  end;
end;
//============= сортировка TStringList по наименованию товара, если ID в Objects
function ObjWareNameSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var s1, s2: String;
begin
  with Cache do try
    s1:= GetWare(Integer(List.Objects[Index1]), True).Name;
    s2:= GetWare(Integer(List.Objects[Index2]), True).Name;
    Result:= AnsiCompareText(s1, s2);
  except
    Result:= 0;
  end;
end;
//-- свернуть ноды дерева узлов с 1 ребенком, TreeList[i] - Pointer(TSecondLink)
procedure prHideTreeNodes(var ListNodes, listParCodes: TList; flOnlySameName, flOnlyOneLevel: boolean);
const nmProc = 'prHideTreeNodes'; // имя процедуры/функции
var i, j, jj, ii, NodeIndex, levelCount, iDel, iDel1: Integer;
    flHide, flNotFound: boolean;
    NodeName: String;
    link: TSecondLink;
    Node: TAutoTreeNode;
    arNodeCodes, arParCodes, arNodes1, arNodes2, arParIn: Tai;
    arNodeNames: Tas;
  //----------------------------------------------
  procedure FillNodeCodes(var arNodes: Tai; ParCode: Integer);
  var i: integer;
  begin
    setLength(arNodes, 0); // массив кодов конечных главных нод в ветке
    setLength(arParIn, 0);  // массив кодов внутренних неконечных нод в ветке
    with ListNodes do for i:= 0 to Count-1 do begin
      link:= Items[i];
      Node:= link.LinkPtr;
      if (Node.ID=ParCode) then prAddItemToIntArray(ParCode, arParIn);
      if (Length(arParIn)<1) or // не дошли до родителя
        (fnInIntArray(Integer(listParCodes[i]), arParIn)<0) then Continue; // не тот родитель
      if Node.IsEnding then
        prAddItemToIntArray(Node.MainCode, arNodes) // конечная нода
      else prAddItemToIntArray(Node.ID, arParIn); // неконечная нода
    end;
  end;
  //----------------------------------------------
  procedure HideNodesWithOneChild;
  var i, jj, ChildCount: integer;
  begin
    NodeIndex:= -1;
    NodeName:= '';
    levelCount:= 0;  // счетчик уровней спрятанных нод
    with ListNodes do for i:= Count-1 downto 0 do begin //-- чистим ненужные ноды - идем снизу
      ChildCount:= 0;
      link:= Items[i];
      Node:= link.LinkPtr;
      ii:= Integer(listParCodes[i]); // код родителя текущей ноды
      flHide:= not Node.IsEnding and (ii>0) and (NodeIndex=(i+1)) // нода не конечная и не 1-й уровень
        and (Node.ID=Integer(listParCodes[NodeIndex]));           // и родитель стоит перед ребенком
      if flHide and flOnlySameName then flHide:= (Node.Name=NodeName);
      if flHide and flOnlyOneLevel then flHide:= (levelCount<1);
      if flHide then begin
        for jj:= NodeIndex+1 to listParCodes.Count-1 do
          if (Node.ID=Integer(listParCodes[jj])) then begin
            flHide:= False;
            break;
          end;                   // если у текущей ноды были дети раньше
        if not flHide then begin // проверяем, есть ли еще дети у верхней ноды
          for jj:= 0 to listParCodes.Count-1 do begin
            if ii=Integer(listParCodes[jj]) then inc(ChildCount);
          end;
          flHide:= ChildCount<2;
        end;
      end; // if flHide
      if flHide then begin // ноду прячем
        for jj:= i+1 to listParCodes.Count-1 do // переназначаем родителя всем детям текущей ноды
          if (Integer(listParCodes[jj])=Node.ID) then listParCodes[jj]:= listParCodes[i];
        Delete(i);
        listParCodes.Delete(i);
        inc(iDel);
        Dec(NodeIndex);
        inc(levelCount);
      end else begin
        NodeName:= Node.Name; // запоминаем последнюю неспрятанную ноду
        NodeIndex:= i;
        levelCount:= 0;               // сбрасываем счетчик уровней
      end;
    end; // for i:= Count-1 downto 0
  end;
  //----------------------------------------------
begin
  setLength(arNodeCodes, 0);
  setLength(arNodeNames, 0);
  setLength(arParCodes, 0);
  setLength(arNodes1, 0);
  setLength(arNodes2, 0);
  setLength(arParIn, 0);
  with ListNodes do try // список нод дерева
    repeat
      iDel:= 0;
//---------------------------------- сворачиваем ноды с 1-м ребенком
      HideNodesWithOneChild;
//---------------------------------- ищем дубликаты конечных нод у 1-го родителя
      iDel1:= 0;
      setLength(arParCodes, 0);     // массив родит.кодов конечных нод
      for i:= 0 to Count-1 do begin
        link:= Items[i];
        Node:= link.LinkPtr;
        if Node.IsEnding then prAddItemToIntArray(Integer(listParCodes[i]), arParCodes);
      end;
      for j:= High(arParCodes) downto 0 do begin
        setLength(arNodeCodes, 0);
        for i:= Count-1 downto 0 do begin // проверяем ноды 1-го родителя - идем снизу
          link:= Items[i];
          Node:= link.LinkPtr;
          if (Node.ID=arParCodes[j]) then break; // дошли до родителя
          if not Node.IsEnding then Continue; // не конечная нода
          if (Integer(listParCodes[i])<>arParCodes[j]) then Continue; // не тот родитель
          if (fnInIntArray(Node.MainCode, arNodeCodes)>-1) then begin // нашли дубликат
            Delete(i);
            listParCodes.Delete(i);
            inc(iDel);
            inc(iDel1);
          end else prAddItemToIntArray(Node.MainCode, arNodeCodes);
        end;
      end; // for j:= High(arParCodes) downto 0

//--------------------------- если были дубликаты конечных нод - еще сворачиваем
      if (iDel1>0) then HideNodesWithOneChild;

//----------------------------------------- ищем дубликаты веток у 1-го родителя
      setLength(arParCodes, 0);  // массив кодов родителей родителей конечных нод
      setLength(arParIn, 0);     // массив кодов родителей конечных нод
      for i:= Count-1 downto 0 do begin
        link:= Items[i];
        Node:= link.LinkPtr;
        jj:= Integer(listParCodes[i]);
        if Node.IsEnding then prAddItemToIntArray(jj, arParIn)
        else if (jj>0) and (fnInIntArray(Node.ID, arParIn)>-1) then
          prAddItemToIntArray(jj, arParCodes);
      end;

      for j:= 0 to High(arParCodes) do begin
        setLength(arNodeCodes, 0);     // здесь - массив кодов не конечных нод (веток)
        setLength(arNodeNames, 0);     // массив наименований не конечных нод (веток)
        for i:= Count-1 downto 0 do begin // заполняем массив кодов веток
          link:= Items[i];
          Node:= link.LinkPtr;
          if (Node.ID=arParCodes[j]) then break; // дошли до родителя
          if Node.IsEnding then Continue; // конечная нода
          if (Integer(listParCodes[i])<>arParCodes[j]) then Continue; // не тот родитель
          if fnInIntArray(Node.ID, arNodeCodes)<0 then begin
            jj:= Length(arNodeCodes);
            setLength(arNodeCodes, jj+1);
            arNodeCodes[jj]:= Node.ID;
            setLength(arNodeNames, jj+1);
            arNodeNames[jj]:= Node.Name;
          end;
        end; // for i:= Count-1 downto 0

        while (Length(arNodeCodes)>1) do begin // ищем дубликаты, если не менее 2-х веток
          NodeName:= arNodeNames[0];  // наименование род.ноды 1-й ветки
          FillNodeCodes(arNodes1, arNodeCodes[0]); // заполняем массив главных кодов конечных нод 1-й ветки
   //--------------------------------------------- сверяем остальные ветки с 1-й
          if Length(arNodes1)>0 then for jj:= 1 to High(arNodeCodes) do begin
            if flOnlySameName and (arNodeNames[jj]<>NodeName) then Continue; // не совп.наименование

            FillNodeCodes(arNodes2, arNodeCodes[jj]); // заполняем массив главных кодов конечных нод jj-й ветки
            if (Length(arNodes2)<1) then Continue;
            if Length(arNodes2)<>Length(arNodes1) then Continue; // не совп.кол-во нод

            flNotFound:= False;
            for ii:= 0 to High(arNodes2) do begin // сверяем массивы кодов конечных нод
              flNotFound:= fnInIntArray(arNodes2[ii], arNodes1)<0;
              if flNotFound then break;
            end;
            if flNotFound then Continue; // jj-ветка <> 1-й ветке
   //---------------------------------------------------- убираем дубликат ветки
            setLength(arNodes2, 0); // здесь - коды нод ветки для удаления
            setLength(arParIn, 0); // массив кодов родительских нод в ветке
            levelCount:= -1;
            for i:= 0 to Count-1 do begin
              link:= Items[i];
              Node:= link.LinkPtr;
              if (Node.ID=arNodeCodes[jj]) then begin // ищем род.ноду jj-й ветки и ее индекс
                levelCount:= i; // индекс, от которого перебирать ноды
                prAddItemToIntArray(Node.ID, arNodes2);
                prAddItemToIntArray(Node.ID, arParIn);
                arNodeCodes[jj]:= 0;  // удаляем код род.ноды jj-й ветки из массива
              end;
              if levelCount<0 then Continue; // не дошли до род.ноды jj-й ветки
              if fnInIntArray(Integer(listParCodes[i]), arParIn)<0 then Continue; // не тот родитель
              if not Node.IsEnding then
                prAddItemToIntArray(Node.ID, arParIn); // неконечные ноды запоминаем
              prAddItemToIntArray(Node.ID, arNodes2);  // коды детей ветки
            end;

            for i:= Count-1 downto levelCount do begin // удаляем ноды ветки
              link:= Items[i];
              Node:= link.LinkPtr;
              if (fnInIntArray(Node.ID, arNodes2)<0) then Continue;
              Delete(i);
              listParCodes.Delete(i);
              inc(iDel);
            end;
   //----------------------------------------------------- убрали дубликат ветки
          end; // for jj:= 1 to High(arNodeCodes)
          arNodeCodes[0]:= 0; // удаляем код род.ноды проверенной ветки из массива
          ii:= 0;
          while (Length(arNodeCodes)>ii) do
            if (arNodeCodes[ii]<1) then begin
              prDelItemFromArray(ii, arNodeCodes);
              prDelItemFromArray(ii, arNodeNames);
            end else Inc(ii);
        end; // while (Length(arNodeCodes)>1)
      end; // for j:= 0 to High(arParCodes)
    until (iDel<1);
//--------------------------- еще раз сворачиваем для надежности
    HideNodesWithOneChild;
  finally
    setLength(arNodeCodes, 0);
    setLength(arNodeNames, 0);
    setLength(arParCodes, 0);
    setLength(arNodes1, 0);
    setLength(arNodes2, 0);
    setLength(arParIn, 0);
  end;
end;

//=================================================== формируем имя файла отчета
function fnFormRepFileName(pSubName, pNameOrExt: string; pOpKind: integer): string;
// возвращает имя файла без пути !!!
// pSubName - строка-идентификатор отчета ("26", "30_1", ...)
// pNameOrExt (Экспорт) - расширение файла отчета, можно без точки - добавит
// pNameOrExt (Импорт)  - имя исх.файла импорта с расширением, можно с путем - отрежет
// pOpKind - вид операции [constOpExport, constOpImport]
var pFileExt, MidName: String;
begin
  Result:= '';
  MidName:= '';
  pFileExt:= '';
  if (pSubName='') then
    raise EBOBError.Create(MessText(mtkNotValidParam)+' - пустой идентификатор файла');
  case pOpKind of
    constOpImport: begin // Импорт
        if (length(pNameOrExt)<5) then
          raise EBOBError.Create(MessText(mtkNotValidParam)+' - имя файла импорта '+pNameOrExt);

        MidName:= ExtractFileName(pNameOrExt);                // убираем путь
        pFileExt:= ExtractFileExt(MidName);                   // вынимаем расширение
        MidName:= copy(MidName, 1, pos(pFileExt, MidName)-1); // вынимаем имя до расширения

        MidName:= MidName+'_import_'+pSubName;                // добавляем идентификатор импорта
      end; // constOpImport

    constOpExport: begin // Экспорт/отчет
        if length(pNameOrExt)<3 then            // расширение
          raise EBOBError.Create(MessText(mtkNotValidParam)+' - расширение файла '+pNameOrExt);

        if (copy(pNameOrExt, 1, 1)='.') then pFileExt:= pNameOrExt
        else begin // если в начале расширения нет точки
          if pos('.', pNameOrExt)>0 then // если есть точка дальше
            raise EBOBError.Create(MessText(mtkNotValidParam)+' - расширение файла '+pNameOrExt);
          pFileExt:= '.'+pNameOrExt;      // добавляем точку
        end;

        MidName:= 'report_'+pSubName;     // формируем начало имени файла - идентификатор отчета
      end; // constOpExport

    else raise EBOBError.Create(MessText(mtkNotValidParam)+' операции '+IntToStr(pOpKind));
  end; // case
  if (MidName='') or (length(pFileExt)<3) then // на всяк.случай
    raise EBOBError.Create(MessText(mtkNotValidParam)+' - имя файла '+MidName+pFileExt);

  Result:= MidName+FormatDateTime('_yy.mm.dd_(hh.nn)', Now)+pFileExt;
end;
//================================== отправляет сообщение пользователя об ошибке
function fnSendErrorMes(FirmID, UserID, MesType, WareId, AnalogId, OrNumId, ModelId, NodeId: Integer;
         SenderMess, AttrMess: String; ThreadData: TThreadData): String;
const nmProc = 'fnSendErrorMes'; // имя процедуры/функции
// Exception передает наружу, возвращает сообщение для пользователя
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    Body, SENDERCOMM, MessForSender: TStringList;
    Employee: TEmplInfoItem;
    Client: TClientInfo;
    Model: TModelAuto;
    Node: TAutoTreeNode;
    Eng: TEngine;
    Ware, Analog: TWareInfo;
    ONum: TOriginalNumInfo;
    email, emailM, s, s1, sErr, sMonitoring: string;
    SysID, ManagerID, i, EmplID: integer;
    Monitorings: Tai;
  //-------------------------------------
  procedure AddEmployeeMail(eid: Integer);
  begin
    if fnInIntArray(eid, Monitorings)>-1 then exit;
    if not Cache.EmplExist(eid) then Cache.TestEmpls(eid);
    if not Cache.EmplExist(eid) then begin
      sErr:= sErr+fnIfStr(sErr='', '', #10)+
        MessText(mtkNotEmplExist, IntToStr(eid));
      exit;
    end;
    Employee:= Cache.arEmplInfo[eid];
    if Employee.Mail='' then
      sErr:= sErr+fnIfStr(sErr='', '', #10)+
        MessText(mtkNotManagerMail, Employee.EmplShortName)
    else begin
      email:= email+fnIfStr(email='', '', ',')+Employee.Mail;
      sMonitoring:= sMonitoring+fnIfStr(sMonitoring='', '', #10)+
        Employee.Mail+' ('+Employee.EmplShortName+')';
    end;
  end;
  //-------------------------------------
begin
  Result:= '';
  OrdIBD:= nil;
  OrdIBS:= nil;
  Body:= TStringList.Create;
  SENDERCOMM:= TStringList.Create;
  MessForSender:= TStringList.Create;
  email:= '';
  emailM:= '';
  s:= '';
  s1:= '';
  sErr:= '';
  sMonitoring:= '';
  SetLength(Monitorings, 0);
  EmplID:= 0;
  try try
    if (FirmID=isWe) then begin
      if not Cache.EmplExist(UserId) then raise EBOBError.Create(MessText(mtkNotEmplExist));
      Employee:= Cache.arEmplInfo[UserId];
      Body.Add('Сотрудник Компании '+Employee.EmplLongName+
        #10'(E-mail: '+fnIfStr(Employee.Mail='', 'не найден', Employee.Mail)+') сообщает:'#10);

    end else begin
      if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
      Client:= Cache.arClientInfo[UserId];
      Body.Add('Представитель контрагента '+Client.FirmName+' - '+Client.Name+', '+Client.Post+
        #10+'(E-mail: '+fnIfStr(Client.Mail='', 'не найден', Client.Mail)+') сообщает:'#10);
    end;

    Ware:= Cache.GetWare(WareId);
    if not Assigned(Ware) or (Ware=NoWare) then
      raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareId)));

    Monitorings:= Cache.GetConstEmpls(pcErrMessMonitoringEmpl);

//------------------------------------------- формируем тексты и адреса рассылки
    case MesType of // case 1
      constWrongAttribute: begin //---------------------- атрибуты
        if Ware.IsAUTOWare then begin
          EmplID:= GetSysTypeEmpl(constIsAuto);
          AddEmployeeMail(EmplID);
        end else if Ware.IsMOTOWare then begin
          EmplID:= GetSysTypeEmpl(constIsMoto);
          AddEmployeeMail(EmplID);
        end else email:= email+fnIfStr(email='', '', ',')+
                         Cache.GetConstItem(pcUIKdepartmentMail).StrValue;

        SENDERCOMM.Add('Ошибка параметров товара '+Ware.Name+': '+AttrMess); // формирум текст для базы
        Body.Add('--- Ошибка параметров товара.');                           // формирум текст для письма
        Body.Add('Товар: '+Ware.Name);
        Body.Add(AttrMess);
      end; // constWrongAttribute

      constWrongEngineNode: begin //-------------------- двигатели - только авто
        SysID:= constIsAuto;
        if not Cache.FDCA.Engines.ItemExists(ModelId) then
          raise EBOBError.Create(MessText(mtkNotFoundEngine, IntToStr(ModelId)));
        Eng:= Cache.FDCA.Engines.GetEngine(ModelId);
        if not Cache.FDCA.AutoTreeNodesSys[SysID].NodeGet(NodeId, Node) then
          raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeId)));

        EmplID:= GetSysTypeEmpl(SysID);
        AddEmployeeMail(EmplID);

        SENDERCOMM.Add('Товар '+Ware.Name+' не соответствует узлу '+  // формирум текст для базы
          Node.Name+' двигателя '+Eng.WebName);
        Body.Add('--- Ошибка соответствия товара двигателю и узлу.'); // формирум текст для письма
        Body.Add('Двигатель: '+Eng.WebName);
        Body.Add('Узел: '+Node.Name);
        Body.Add('Товар: '+Ware.Name);
      end; // constWrongEngineNode

      constWrongModelNode: begin //---------------------- модели - авто или мото
        if not Cache.FDCA.Models.ModelExists(ModelId) then
          raise EBOBError.Create(MessText(mtkNotFoundModel, IntToStr(ModelId)));
        Model:= Cache.FDCA.Models.GetModel(ModelId);
        SysID:= Model.TypeSys;
        if not Cache.FDCA.AutoTreeNodesSys[SysID].NodeGet(NodeId, Node) then      // NodeID=-1 ???
          raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeId)));

        EmplID:= GetSysTypeEmpl(SysID);
        AddEmployeeMail(EmplID);

        SENDERCOMM.Add('Товар '+Ware.Name+' не соответствует узлу '+ // формирум текст для базы
          Node.Name+' модели '+Model.WebName);
        Body.Add('--- Ошибка соответствия товара модели и узлу.');   // формирум текст для письма
        Body.Add('Модель: '+Model.WebName);
        Body.Add('Узел: '+Node.Name);
        Body.Add('Товар: '+Ware.Name);
      end; // constWrongModelNode

      constWrongAnalog..constWrongOrNum: begin
        EmplID:= Ware.ManagerID; // менеджер товара
        AddEmployeeMail(EmplID);

        case MesType of // case 2
          constWrongAnalog: begin
            if not Cache.WareExist(AnalogId) then
              raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(AnalogId)));
            Analog:= Cache.GetWare(AnalogId);

            ManagerID:= Analog.ManagerID;  // менеджер аналога
            if (ManagerID<>EmplID) then   // если менеджер другой - добавляем его адрес
              AddEmployeeMail(ManagerID);

            SENDERCOMM.Add('Товар '+Analog.Name+       // формирум текст для базы
              ' не является аналогом товара '+Ware.Name);
            Body.Add('--- Ошибка указания аналога.');  // формирум текст для письма
            Body.Add('Товар: '+Ware.Name);
            Body.Add('Аналог: '+Analog.Name);
          end; // constWrongAnalog

          constWrongDescription: begin
            SENDERCOMM.Add('Ошибка в описании товара '+Ware.Name); // формирум текст для базы
            Body.Add('--- Ошибка в описании товара.');
            Body.Add('Товар: '+Ware.Name);
          end; // constWrongDescription

          constWrongOrNum: begin
            if not Cache.FDCA.OrigNumExist(OrNumId) then
              raise EBOBError.Create('Не найден оригинальный номер');
            ONum:= Cache.FDCA.GetOriginalNum(OrNumId);

            SENDERCOMM.Add('Товару '+Ware.Name+                        // формирум текст для базы
              ' не соответствует оригинальный номер '+ONum.Name+' ('+ONum.ManufName+')');
            Body.Add('--- Ошибка соответствия оригинального номера.'); // формирум текст для письма
            Body.Add('Товар: '+Ware.Name);
            Body.Add('Оригинальный номер: '+ONum.Name+' ('+ONum.ManufName+')');
          end; // constWrongOrNum
        end; // case 2
      end; // constWrongAnalog..constWrongOrNum

      else raise EBOBError.Create('Неопознанный тип ошибки, код '+IntToStr(MesType));
    end; // case 1

    s:= '--- Причина (текст отправителя): ';
    SENDERCOMM.Add(s);          // формирум текст для базы
    SENDERCOMM.Add(SenderMess);
    Body.Add(s);                // формирум текст для письма
    Body.Add(SenderMess);

//---------------------------------------------------------------- формируем SQL
    s:= 'CEMSCEMKCODE, CEMSWARECODE';
    s1:= IntToStr(MesType)+', '+IntToStr(WareId);
    if (ModelId>0) then begin
      s := s +', CEMSMODELCODE';
      s1:= s1+', '+IntToStr(ModelId);
    end;
    if (NodeId>0) then begin
      s := s +', CEMSNODECODE';
      s1:= s1+', '+IntToStr(NodeId);
    end;
    if (AnalogId>0) then begin
      s := s +', CEMSANALOGCODE';
      s1:= s1+', '+IntToStr(AnalogId);
    end;
    if (OrNumId>0) then begin
      s := s +', CEMSONUMCODE';
      s1:= s1+', '+IntToStr(OrNumId);
    end;
    if (FirmID>0) and (FirmID<>isWe) then begin
      s := s +', CEMSFIRMCODE';
      s1:= s1+', '+IntToStr(FirmID);
    end;
    if (EmplID>0) then begin
      s := s +', CEMSWORKERCODE';
      s1:= s1+', '+IntToStr(EmplID);
    end;
    s := s +', CEMSSENDERCODE, CEMSSENDTIME, CEMSSENDERCOMM';
    s1:= s1+', '+IntToStr(UserID)+', "NOW", :CEMSSENDERCOMM';

//----------------------------------------------------------------- пишем в базу
    try
      OrdIBD:= CntsOrd.GetFreeCnt();
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBSQL_'+nmProc, ThreadData.ID, tpWrite, True);
      OrdIBS.SQL.Text:= 'INSERT INTO CLIENTERRMESSAGES ('+s+') VALUES ('+s1+')';
      OrdIBS.ParamByName('CEMSSENDERCOMM').AsString:= SENDERCOMM.Text;
      OrdIBS.ExecQuery;
      OrdIBS.Transaction.Commit;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;

//--------------------------------------------------- отсылаем письмо менеджерам
    s:= '';
    s1:= '';
    if email<>'' then begin
      s:= n_SysMailSend(email , 'Уведомление об ошибке данных товара', Body, nil,  '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then begin // если письмо не записано в файл
        prMessageLOGS(nmProc+'(send mail to managers): '+s);
        if sMonitoring<>'' then sMonitoring:= '  Ошибка отправки уведомления об ошибке на E-mail:'#10+sMonitoring;
      end else if sMonitoring<>'' then sMonitoring:= '  Уведомление об ошибке выслано на E-mail:'#10+sMonitoring;
      if sMonitoring<>'' then Body.Add(#10+sMonitoring);
    end;

//----------------------------------------------------- отсылаем письмо контролю
    if sErr<>'' then Body.Add(#10+sErr);
    emailM:= Cache.GetEmplEmails(Monitorings);
    if (emailM='') then s1:= 'Не найдены E-mail рассылки'
    else begin
      s1:= n_SysMailSend(emailM, 'Уведомление об ошибке данных товара', Body, nil,  '', '', True);
      if (s1<>'') and (Pos(MessText(mtkErrMailToFile), s1)<1) then s1:= ''; // если письмо записано в файл
    end;
    if (s1<>'') then prMessageLOGS(nmProc+'(send mail to monitoring): '+s1);

//------------------------------------------------- формируем ответ пользователю
    if (s='') or (s1='') then begin // если отправлено хоть кому-нибудь
      MessForSender.Add('Ваше сообщение об ошибке принято.');
    end else begin
      MessForSender.Add(MessText(mtkErrSendMess));
      MessForSender.Add(MessText(mtkMailWillSend));
      if (Pos(MessText(mtkErrMailToFile), s)>0) // если письмо не записано в файл, т.е. запись в базу прошла,
        and (Pos(MessText(mtkErrMailToFile), s1)>0) then begin // а письмо никому не ушло - пишем в лог
        prMessageLOGS(nmProc+': Ошибка отправки уведомления на E-mail: '+fnIfStr(email='', '', '('+email+')')+emailM);
        for i:= 0 to Body.Count-1 do prMessageLOGS('  '+Body[i]);
      end;
    end;
    MessForSender.Add('Благодарим за сотрудничество.');

    Result:= MessForSender.Text;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message+
      #10'FirmID='+IntToStr(FirmID)+', UserID='+IntToStr(UserID)+
      ', MesType='+IntToStr(MesType)+', WareId='+IntToStr(WareId)+#10+
      fnIfStr(AnalogId>-1, ' AnalogId='+IntToStr(AnalogId), '')+
      fnIfStr(OrNumId>-1, ' OrNumId='+IntToStr(OrNumId), '')+
      fnIfStr(ModelId>-1, ' ModelId='+IntToStr(ModelId), '')+
      fnIfStr(NodeId>-1, ' NodeId='+IntToStr(NodeId), '')+#10+
      fnIfStr(SenderMess<>'', ' SenderMess='+SenderMess, '')+
      fnIfStr(AttrMess<>'', ' AttrMess='+AttrMess, ''));
  end;
  finally
    prFree(MessForSender);
    prFree(Body);
    prFree(SENDERCOMM);
    SetLength(Monitorings, 0);
  end;
end;
{//================================== отправляет сообщение пользователя менеджеру
function fnSendClientMes(FirmID, UserID, Source: Integer; SenderMess: String;
                         ThreadData: TThreadData; var Response: String; ContID: Integer=0): Boolean;
const nmProc = 'fnSendClientMes'; // имя процедуры/функции
// в Result возвращает признак успешной отправки сообщения,
// ошибки записывает в лог, в Response возвращает сообщение для пользователя
var Filial, EmplID, i: integer;
    s, To_, ToAdm, Delim, nm: string;
    Strings: TStringList;
    Client : TClientInfo;
    Firm   : TFirmInfo;
    ar: Tai;
begin
  Result:= False;
  Response:= '';
  nm:= '';
  Strings:= nil;
  SetLength(ar, 0);
  try
    if not (Source in [cosByVlad, cosByWeb]) then Source:= cosByWeb;
    if Source=cosByVlad then Delim:= cStrVladDelim else Delim:= ''; // разделитель для Vlad

    if (trim(SenderMess)='') then
      raise EBOBError.Create('Нельзя отправить пустое сообщение');
    if not Cache.ClientExist(UserID) then
      raise Exception.Create(MessText(mtkNotClientExist, IntToStr(UserID)));

    Client:= Cache.arClientInfo[UserID];
    if not Cache.FirmExist(FirmID) then FirmID:= Client.FirmID
    else if (FirmID<>Client.FirmID) then raise Exception.Create(MessText(mtkNotClientOfFirm));

    if not Cache.FirmExist(FirmID) then
      raise Exception.Create(MessText(mtkNotFirmExists, IntToStr(FirmID)));

    Firm:= Cache.arFirmInfo[FirmID];
    Filial:= Firm.GetDefContract.Filial;
    if not Cache.DprtExist(Filial) then
      raise Exception.Create(MessText(mtkNotDprtExists, IntToStr(Filial)));

    if Client.Mail='' then raise EBOBError.Create(
      'Нельзя отправить сообщение, '+Delim+'т.к. Вашего E-mail нет в базе данных. '+Delim+
      'Сообщите свои логин и E-mail '+Delim+'торговому представителю Компании.');
                                       // добавляем подпись и Email пользователя
    nm:= Client.Name+', '+Firm.Name;
    s:= StringOfChar('-', 40);
    SenderMess:= SenderMess+#10#10+s+#10'Пользователь: '+nm+
      #10#10'E-mail пользователя: '+Client.Mail;
    if (ContID>0) then begin

      prAddItemToIntArray(Firm.GetContract(ContID).Manager, ar)
    end else for i:= 0 to Firm.FirmManagers.Count-1 do
      prAddItemToIntArray(Firm.FirmManagers[i], ar);

    if (Length(ar)<1) then
      SenderMess:= SenderMess+#10#10'Менеджер контрагента не найден.'
    else for i:= 0 to High(ar) do begin            // добавляем менеджеров
      EmplID:= ar[i];
      if not Cache.EmplExist(EmplID) then Cache.TestEmpls(EmplID);
      if Cache.EmplExist(EmplID) then with Cache.arEmplInfo[EmplID] do
        SenderMess:= SenderMess+#10#10'Менеджер контрагента: '+EmplShortName+
                     ' ( E-mail: '+fnIfStr(Mail<>'', Mail, 'не найден')+' )';
    end;

    Strings:= TStringList.Create;
    Strings.Text:= SenderMess;     // вставляем в начало шапку
    Strings.Insert(0, 'ВНИМАНИЕ! Письмо создано сервером системы заказов, '+
      'E-mail пользователя для ответа указан в письме.'#10#10+
      'Текст сообщения:'#10+StringOfChar('-', 40)+#10);

    ToAdm:= Cache.GetConstEmails(pcEmplORDERAUTO);
    if (ToAdm='') then ToAdm:= fnGetSysAdresVlad(caeOnlyWorkDay);
    To_:= fnGetManagerMail(Filial, ToAdm);
    if (To_=ToAdm) then ToAdm:= '';
                                                    // отправляем от CSS-сервера
    s:= n_SysMailSend(To_, 'Сообщение от пользователя системы приема заказов', Strings, nil, '', '', true);

    if (s<>'') then begin
      if Pos(MessText(mtkErrMailToFile), s)<1 then begin // если записали в файл
        Response:= MessText(mtkErrSendMess, 'от пользователя')+Delim+MessText(mtkMailWillSend);
        raise EBOBError.Create(s);

      end else begin  // если не записали в файл
        Strings.Insert(0, GetMessageFromSelf);
        if ToAdm<>'' then begin
          Strings.Add(#10'Текст ошибки:'#10+s); // добавляем Текст ошибки 1-й отправки
                                            // отправляем от CSS-сервера админам
          ToAdm:= n_SysMailSend(ToAdm, MessText(mtkErrSendMess, 'от пользователя'), Strings, nil, '', '', true);
          if ToAdm<>'' then s:= s+#10+MessText(mtkErrSendMess, 'админам')+#10+ToAdm+
                                #10'Текст письма: '+Strings.Text;
        end;
        raise Exception.Create(s);
      end;
    end;

    Response:= 'Ваше сообщение отправлено от имени:'+Delim+'  '+nm+'. '+Delim+
               'Ответ будет направлен на Ваш E-mail:'+Delim+'  '+Client.Mail+'. '+Delim+
               'Если эта информация не является корректной, '+Delim+
               ' сообщите свой логин и правильные данные '+Delim+
               ' торговому представителю Компании.';
    Result:= True;
  except
    on E: EBOBError do begin
      if Response='' then Response:= E.Message;
      fnWriteToLogPlus(ThreadData, lgmsUserError, nmProc, E.Message);
    end;
    on E: Exception do begin
      if Response='' then Response:= MessText(mtkErrSendMess, 'от пользователя');
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, E.Message);
    end;
  end;
  prFree(Strings);
  SetLength(ar, 0);
end; }
//============================ формирование отчета по запросам клиента за период
function fnRepClientRequests(UserID: integer; StartTime, EndTime: TDateTime; var FName: string): string;
const nmProc = 'fnRepClientRequests'; // имя процедуры/функции  // возвращает имя файла отчета
var Pool: TIBCntsPool;
    LogIBD: TIBDatabase;
    LogIBS: TIBSQL;
    MiddleFileName, FNameZip, Content, s: string;
    file_csv: textfile;
    iCount: integer;
    Client: TClientInfo;
begin
  FName:= '';
  iCount:= 0;
  LogIBD:= nil;
  LogIBS:= nil;
  try
    if not Cache.ClientExist(UserID) then
      raise EBOBError.Create(MessText(mtkNotClientExist, IntToStr(UserID)));
    if (EndTime<Date) and cntsSufLOG.BaseConnected then Pool:= cntsSufLOG else Pool:= cntsLOG;
    if not Assigned(Pool) then raise EBOBError.Create(MessText(mtkErrConnectToDB));


    Client:= Cache.arClientInfo[UserID];
    MiddleFileName:= DirFileErr+'Requests_'+Client.Login+'_'+
               FormatDateTime('_dd.mm_(hh.nn.ss)', EndTime);
    FName:= MiddleFileName+'.csv';
    if FileExists(FName) and not SysUtils.DeleteFile(FName) then begin
      FName:= '';
      raise EBOBError.Create(MessText(mtkNotDelPrevFile));
    end;

    AssignFile(file_csv, FName);
    try
      filemode:= fmOpenReadWrite; //назначаем файл
      if FileExists(FName) then Reset(file_csv) else ReWrite(file_csv);
      Append(file_csv);                            // Добавляем шапку:
      Content:= 'Запросы пользователя с логином <'+Client.Login+'>, контрагент '+
                Client.FirmName+' к системе заказов с '+
                FormatDateTime(cDateTimeFormatY2S, StartTime)+
                ' по '+FormatDateTime(cDateTimeFormatY2S, EndTime);
      WriteLn(file_csv, Content);
      Content:= 'Код команды;Дата;Команда;Параметры команды';
      WriteLn(file_csv, Content);                  // шапка добавлена
      try
        LogIBD:= Pool.GetFreeCnt;
        LogIBS:= fnCreateNewIBSQL(LogIBD, 'LogIBS_'+nmProc, -1, tpRead, true);
        LogIBS.SQL.Text:= 'SELECT THLGBEGINTIME, LCCOMMAND, LCCOMMDESCR,'+
          ' cast(THLGPARAMS as varchar(2400)) THLGPARAMS FROM LOGTHREADS'+
          ' left outer join LOGCOMMANDS on LCCOMMAND=THLGCOMMAND'+
          ' where THLGTYPE in ('+IntToStr(thtpWeb)+', '+IntToStr(thtpMail)+
          ') and not (THLGCOMMAND in ('+IntToStr(csWebAutentication)+', '+
          IntToStr(csBackJobAutentication)+')) and THLGUSERID='+IntToStr(UserID)+
          ' and THLGBEGINTIME between :DateStart and :DateEnd order by THLGBEGINTIME';
        LogIBS.ParamByName('DateStart').AsDateTime:= StartTime;    // Начальное время
        LogIBS.ParamByName('DateEnd').AsDateTime  := EndTime;      // Конечное время
        LogIBS.ExecQuery;
        while not LogIBS.EOF do begin
          try
            s:= StringReplace(LogIBS.FieldByName('THLGPARAMS').AsString, #13#10,' ', [rfReplaceAll]);
            Content:= LogIBS.FieldByName('LCCOMMAND').AsString+';'+
              // добавляем перед датой пробел, чтобы Excel не обрезал сек
              FormatDateTime(' '+cDateTimeFormatY2S, LogIBS.FieldByName('THLGBEGINTIME').AsDateTime)+';'+
              LogIBS.FieldByName('LCCOMMDESCR').AsString+';'+s+';';
            WriteLn(file_csv, Content);
            inc(iCount);
          except
            on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
          end;
          TestCssStopException;
          LogIBS.Next;
        end;
      finally
        prFreeIBSQL(LogIBS);
        Pool.SetFreeCnt(LogIBD, True);
      end;
    finally
      CloseFile(file_csv);
    end;
    if iCount=0 then raise EBOBError.Create(MessText(mtkNotFoundDataUse));

    FNameZip:= MiddleFileName+'.zip';
    s:= ZipAddFiles(FNameZip, FName);
    if (s<>'') then raise Exception.Create(s);

    SysUtils.DeleteFile(FName);
    FName:= FNameZip;
  except
    on E: Exception do begin
      if FName<>'' then begin
        if FileExists(FName) then SysUtils.DeleteFile(FName);
        FName:= '';
      end;
      Result:= nmProc+': '+E.Message;
    end;
  end;
end;
//===================================== блокировка/разблокировка клиента в базе
function SaveClientBlockType(BlockType, UserID: Integer; var BlockTime: TDateTime; EmplID: Integer=0): Boolean;
const nmProc = 'SaveClientBlockType';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    ss: String;
    command, cliType: Integer;
begin
  Result:= False;
  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
    if (EmplID<1) then EmplID:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue
    else if not Cache.EmplExist(EmplID) then
      raise EBOBError.Create(MessText(mtkNotEmplExist, IntToStr(EmplID)));

    case BlockType of
    cbBlockedBySearchLimit, cbBlockedTmpByConnLimit, cbBlockedByConnectLimit, cbBlockedByEmpl: begin // блокировка
        command:= csBlockWebUser;
        cliType:= BlockType;
        case BlockType of
        cbBlockedBySearchLimit:  // автоматически в CSSweb из-за превышения лимита поисковых запросов за день
            ss:= 'блокировка системой заказов по лимиту запросов';
        cbBlockedTmpByConnLimit: // автоматически в CSSweb из-за превышения лимита коннектов в ед.времени
            ss:= 'блокировка системой заказов по лимиту запросов временно';
        cbBlockedByConnectLimit: // автоматически в CSSweb из-за превышения лимита коннектов в ед.времени
            ss:= 'блокировка системой заказов по лимиту запросов повторно';
        cbBlockedByEmpl:         // сотрудником в WebArm
            ss:= 'блокировка сотрудником '+Cache.arEmplInfo[EmplID].EmplShortName;
        end;
      end; // блокировка

    cbUnBlockedTmpByCSS, cbUnBlockedByEmpl: begin // разблокировка
        command:= csUnblockWebUser;
        cliType:= cbNotBlocked;
        case BlockType of
        cbUnBlockedTmpByCSS:     // автоматически в CSSweb
            ss:= 'разблокировка системой заказов временной блокировки';
        cbUnBlockedByEmpl:       // сотрудником в WebArm
            ss:= 'разблокировка сотрудником '+Cache.arEmplInfo[EmplID].EmplShortName;
        end;
      end; // разблокировка

    else raise EBOBError.Create('Неизвестная команда');
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt;   // блокировка/разблокировка клиента
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      ORD_IBS.SQL.Text:= 'select rTIME from SetClientBlockMark('+IntToStr(command)+', '+
        IntToStr(BlockType)+', '+IntToStr(cliType)+', '+IntToStr(UserID)+', '+IntToStr(EmplID)+', :comm)';
      ORD_IBS.ParamByName('comm').AsString:= ss;
      ORD_IBS.ExecQuery;
      if not (ORD_IBS.Bof and ORD_IBS.Eof) then BlockTime:= ORD_IBS.Fields[0].AsDateTime;
      ORD_IBS.Transaction.Commit;
      Result:= True;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+'('+IntToStr(UserID)+'): '+E.Message);
  end;
end;
//=============== установить флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
function SetLongProcessFlag(cdlpKind: Integer; NotCheck: Boolean=False): Boolean;
// NotCheck=True - без проверки других флагов
const nmProc = 'SetLongProcessFlag';
var //ORD_IBD: TIBDatabase;
    //ORD_IBS: TIBSQL;
    s: String;
begin
  Result:= False;
  if not (cdlpKind in [cdlpFillCache..cdlpForeignPr]) then Exit;
  s:= '';
//  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
{
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'select rOtherFlag from CheckLongProcessFlag('+IntToStr(ServerID)+', :ftxt)';
      ORD_IBS.ParamByName('ftxt').AsString:= cdlpNames[cdlpKind];
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Eof and ORD_IBS.Bof) then raise Exception.Create('Empty');
      s:= ORD_IBS.Fields[0].AsString;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    Result:= (s='');
}
    Result:= NotCheck;   // временно
    with Cache do begin
      if not Result then begin
{        Result:= (LongProcessFlag=cdlpNotLongPr);
        if Result then
        if AllowWebArm then begin
//          Result:= (ImpCheck.CheckList.Count<1);
          if (LongProcessFlag=cdlpNotLongPr) // выполняется отчет или импорт
            and (ImpCheck.CheckList.Count>0) then LongProcessFlag:= cdlpRepOrImp
          else if (LongProcessFlag=cdlpRepOrImp)
            and (ImpCheck.CheckList.Count<1) then LongProcessFlag:= cdlpNotLongPr;
        end; }
        Result:= (LongProcessFlag=cdlpNotLongPr);
      end;

      if Result then begin
        LongProcessFlag:= cdlpKind;
  //    end else begin
  //      LongProcessFlag:= cdlpForeignPr;
  //      cdlpNames[cdlpForeignPr]:= s;
      end;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  if flTest then prMessageLOGS(nmProc+': LongProcessFlag='+
                 cdlpNames[Cache.LongProcessFlag], fLogDebug, False);
end;
//==================== снять флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
function SetNotLongProcessFlag(cdlpKind: Integer): Boolean;
// снять можно только такой же флаг
const nmProc = 'SetNotLongProcessFlag';
var //ORD_IBD: TIBDatabase;
    //ORD_IBS: TIBSQL;
    s: String;
begin
  Result:= False;
  if not (cdlpKind in [cdlpFillCache..cdlpForeignPr]) then Exit;
  s:= '';
//  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
{
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'select rOtherFlag from CheckLongProcessFlag('+IntToStr(ServerID)+', :ftxt)';
      ORD_IBS.ParamByName('ftxt').AsString:= cdlpNames[cdlpKind];
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Eof and ORD_IBS.Bof) then raise Exception.Create('Empty');
      s:= ORD_IBS.Fields[0].AsString;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    Result:= (s='');
}

    Result:= (Cache.LongProcessFlag=cdlpKind); // временно

    with Cache do if Result then begin
      LongProcessFlag:= cdlpNotLongPr;
//    end else begin
//      LongProcessFlag:= cdlpForeignPr;
//      cdlpNames[cdlpForeignPr]:= s;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  if flTest then prMessageLOGS(nmProc+': LongProcessFlag='+
                 cdlpNames[Cache.LongProcessFlag], fLogDebug, False);
end;
//============================== must Free, поиск товаров по наименованию в кэше
function SearchWareNames(Template: string; IgnoreSpec: Integer=0;
         ManagID: Integer=-1; ByComments: boolean=False): Tai;
const nmProc = 'SearchWareNames';
// возвращает массив кодов товаров, отсортированных по наименованию
var list: TStringList;
    i, j: integer;
    fl: boolean;
    s, ss, mess: String;
begin
  SetLength(Result, 0);
  if not Assigned(Cache) or (Template='') then Exit;
  list:= fnCreateStringList(False, 100);
  mess:= '';
  with Cache do try
    s:= AnsiUpperCase(Template);
    ss:= fnDelSpcAndSumb(s);
    if ByComments and (IgnoreSpec=3) then ByComments:= False;
    j:= High(arWareInfo);

    for i:= 1 to j do try
      if not WareExist(i) then Continue;
      with Cache.arWareInfo[i] do begin
        if IsArchive or (PgrID<1) then Continue;                                           // отсев по архивности
        if (PgrID=Cache.pgrDeliv) then Continue;                                           // пропускаем доставки
        if (ManagID>-1) and (ManagID<>ManagerID) then Continue;                            // отсев по менеджеру
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, Name)>0;
          1: fl:= pos(ss, NameBS)>0;
          2: fl:= (pos(s, Name)>0) or (pos(ss, NameBS)>0);
          3: if (Name=s) then begin // полное совпадение
               list.AddObject(Name, pointer(i));
               break;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, CommentUP)>0);
        if not fl then Continue;
        if list.Capacity=list.Count then list.Capacity:= list.Count+100;
        list.AddObject(Name, pointer(i));
      end; // with arWareInfo[i]
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(i)+': '+E.Message;
    end; // for

    if list.Count<1 then Exit else if list.Count>1 then list.Sort;
    SetLength(Result, list.Count);
    for i:= 0 to list.Count-1 do Result[i]:= integer(list.Objects[i]);
  finally
    prFree(list);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;
//========== возвращает отсортированный массив кодов всех аналогов товара WareID
function fnGetAllAnalogs(WareID: integer; ManufID: integer=-1): Tai; // must Free
// sysID=0 - и авто, и мото
var i, Counter, ShowKind: integer;
    a1, a2, anw: Tai;
    ErrorPos: string;
    Ware: TWareInfo;
    list: TStringList;
begin
  ErrorPos:= '0';
  SetLength(Result, 0);
  list:= nil;
  try try
    if not Cache.WareExist(WareID) then
        raise Exception.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));
    Ware:= Cache.arWareInfo[WareId];
    if Ware.IsArchive then exit;

    ShowKind:= Cache.GetConstItem(pcAnalogsShowKind).IntValue; // режим вывода аналогов
    ErrorPos:= '1';           // получаю максимальное кол-во аналогов через OН
    if (ShowKind in [ca_OE, ca_GR_OE, ca_Ex_OE,
      ca_TD_OE, ca_GR_Ex_OE, ca_GR_TD_OE, ca_Ex_TD_OE, ca_GR_Ex_TD_OE]) then begin
      Counter:= Cache.FDCA.fnGetListAnalogsWithManufacturer(WareID, ManufID, a1, a2);
      if (Counter<0) then Counter:= 0;
    end else Counter:= 0;

    ErrorPos:= '2';
    anw:= Ware.analogs; // аналоги из кеша
    Counter:= Counter+Length(anw);
    if (Counter<1) then exit;

    list:= TStringList.Create; // общий список для сортировки
    list.Capacity:= Counter;

    for i:= 0 to High(anw) do if Cache.WareExist(anw[i]) then begin
      Ware:= Cache.arWareInfo[anw[i]];            // аналоги из кеша
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    for i:= 0 to High(a1) do if Cache.WareExist(a1[i]) and (fnInIntArray(a1[i], anw)<0) then begin
      Ware:= Cache.arWareInfo[a1[i]];             // аналоги через OН ManufID
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    for i:= 0 to High(a2) do if Cache.WareExist(a2[i]) and (fnInIntArray(a2[i], anw)<0)
                            and (fnInIntArray(a2[i], a1)<0) then begin
      Ware:= Cache.arWareInfo[a2[i]];             // аналоги через OН
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    if list.Count>1 then list.Sort; // сортировка общего списка

    SetLength(Result, list.Count);
    for i:= 0 to list.Count-1 do Result[i]:= Integer(list.Objects[i]);
  except
    on E: Exception do
      raise Exception.Create('fnGetAllAnalogs (ErrorPos='+ErrorPos+'): '+E.Message);
  end;
  finally
    SetLength(a1, 0);
    SetLength(a2, 0);
    SetLength(anw, 0);
    prFree(list);
  end;
end;
//========= поиск товаров (с типами и аналогами) по наименованию в кэше (Webarm)
function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer=0;
         ManagID: Integer=-1; ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
         flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList; // must Free
const nmProc = 'SearchWaresTypesAnalogs';
// возвращает TObjectList, отсортированный по наименованию товара, в Objects - TSearchWareOrOnum
// если TypeCodes пустой - в TypeCodes собираем типы
// если TypeCodes не пустой - отсев рез-тов поиска по типам
var iWare, j, pType: integer;
    flTypeSelection, flSelecting, flContaining, fl, flBreak, flMarket: boolean;
    s, ss, mess: String;
    ware: TWareInfo;
    arAnalogs, arTypes, ar: Tai;
begin
  Result:= TObjectList.Create;
  if not Assigned(TypeCodes) then SetLength(TypeCodes, 0);
  if not Assigned(Cache) or (Template='') then Exit;
  SetLength(arTypes, 0);

  mess:= '';
  flTypeSelection:= (Length(TypeCodes)>0); // признак - отсеивать по TypeCodes или собирать типы в TypeCodes

  flBreak:= False; // для полного совпадения
  with Cache do try
    s:= AnsiUpperCase(Template);

    if not (flSale or flCutPrice or flLamp) then begin
      if (IgnoreSpec in [1, 2]) then ss:= fnDelSpcAndSumb(s);
      if ByComments and (IgnoreSpec=3) then ByComments:= False;
    end;

    for iWare:= 1 to High(arWareInfo) do try
      if not WareExist(iWare) then Continue;
      ware:= Cache.GetWare(iWare, True);
      if not Assigned(ware) or (ware=NoWare) then Continue; // отсев по наличию
      if ware.IsArchive or (ware.PgrID<1) then Continue;    // отсев по архивности
      if ware.IsPrize then Continue;                        // отсев призов
      if (ware.PgrID=Cache.pgrDeliv) then Continue;         // отсев доставок
      if (ManagID>0) and (ManagID<>ware.ManagerID) then Continue;         // отсев по менеджеру

//------------------------------------------------------------- спец.виды поиска
      if flSale then fl:= ware.IsSale              //------- отсев по распродаже
      else if flCutPrice then fl:= ware.IsCutPrice //----------- отсев по уценке
      else if flLamp then fl:= (pos(s, ware.CommentUP)>0) //---- отсев по лампам

      else begin //----------------------------------- отсев по ключу поиска
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, ware.Name)>0;
          1: fl:= pos(ss, ware.NameBS)>0;
          2: fl:= (pos(s, ware.Name)>0) or (pos(ss, ware.NameBS)>0);
          3: begin // полное совпадение
               fl:= (ware.Name=s);
               flBreak:= fl;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, ware.CommentUP)>0);
      end;
      if not fl then Continue;

      SetLength(arAnalogs, 0);
      SetLength(ar, 0);
      try
        arAnalogs:= fnGetAllAnalogs(iWare); // (Webarm)
        //---------------------- отсев по наличию цены, аналогов или сопут.товаров
        flMarket:= ware.IsMarketWare;
        if OnlyWithPriceOrAnalogs and not flMarket
          and (Length(arAnalogs)<1) and not ware.SatelliteExists() then Continue;

        //-------------------------------------------------- отсев по типам товара
        flSelecting:= not flTypeSelection; // True для первичного поиска, False для отсева

        if not ware.IsInfoGr or ware.HasFixedType then begin // товары с типом - по собственному типу
          pType:= ware.TypeID;
          flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
          if not flContaining then
            if flTypeSelection then Continue // отсев товаров
            else prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы

        end else try // инфо-товары без типа - по аналогам (как оригинальные номера)
          arTypes:= ware.GetAnalogTypes; // массив кодов типов аналогов (с нулевым)
          for j:= 0 to High(arTypes) do begin // перебираем типы аналогов
            pType:= arTypes[j];
            flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
            if flTypeSelection and flContaining then begin
              flSelecting:= True;                    // отсев и тип есть в массиве типов
              break;
            end else if not flTypeSelection and not flContaining then
              prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы
          end;
          if not flSelecting then Continue; // если не подходит по типам при отсеве
        finally
          SetLength(arTypes, 0);
        end;

        if (Result.Capacity=Result.Count) then Result.Capacity:= Result.Count+100;
        ar:= ware.GetSatellites;
        Result.Add(TSearchWareOrOnum.Create(iWare, Length(ar), True, flMarket, arAnalogs));
      finally
        SetLength(ar, 0);
        SetLength(arAnalogs, 0);
      end;

      if flBreak then Break; // полное совпадение
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(iWare)+': '+E.Message;
    end; // for

  finally
    SetLength(arTypes, 0);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;
//================== поиск товаров (с типами и аналогами) по наименованию в кэше
function SearchWaresTypesAnalogs_new(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer; // must Free
         ByComments, flSale, flCutPrice, flSemafores: boolean; ffp: TForFirmParams): TObjectList;
const nmProc = 'SearchWaresTypesAnalogs_new';
// возвращает TObjectList, отсортированный по наименованию товара, в Objects - TSearchWareOrOnum
// если TypeCodes пустой - в TypeCodes собираем типы
// если TypeCodes не пустой - отсев рез-тов поиска по типам
// здесь сразу заполняем семафоры, если надо - отсеиваем по красным
var iWare, j, pType: integer;
    flTypeSelection, flSelecting, flContaining, fl, flBreak, flMarket, flTypeByAnalogs: boolean;
    s, ss, mess: String;
    ware, analog: TWareInfo;
    arTypes: Tai;
    WA: TSearchWareOrOnum;
    tt: TTwoCodes;
begin
  Result:= TObjectList.Create;
  if not Assigned(TypeCodes) then SetLength(TypeCodes, 0);
  if not Assigned(Cache) or (Template='') then Exit;

  mess:= '';
  flTypeSelection:= (Length(TypeCodes)>0); // признак - отсеивать по TypeCodes или собирать типы в TypeCodes

  flBreak:= False; // для полного совпадения
  with Cache do try
    s:= AnsiUpperCase(Template);

    if not (flSale or flCutPrice) then begin
      if (IgnoreSpec in [1, 2]) then ss:= fnDelSpcAndSumb(s);
      if ByComments and (IgnoreSpec=3) then ByComments:= False;
    end;

    for iWare:= 1 to High(arWareInfo) do if Assigned(arWareInfo[iWare]) then try
//      if not WareExist(iWare) then Continue;
//      ware:= Cache.GetWare(iWare, True);
      ware:= arWareInfo[iWare];

if flWareForSearch then begin
      if not ware.ForSearch then Continue;
end else begin
      if not ware.IsWare or (ware=NoWare) then Continue;    // отсев по наличию
      if ware.IsArchive or (ware.PgrID<1) then Continue;    // отсев по архивности
      if ware.IsPrize then Continue;                        // отсев призов
      if (ware.PgrID=Cache.pgrDeliv) then Continue;         // отсев доставок
      if ware.IsINFOgr and (ware.AnalogLinks.LinkCount<1) then Continue; // инфо-товар без аналогов
end; // if flWareForSearch

//------------------------------------------------------------- спец.виды поиска
      if flSale then fl:= ware.IsSale              //------- отсев по распродаже
      else if flCutPrice then fl:= ware.IsCutPrice //----------- отсев по уценке
      else begin //----------------------------------- отсев по ключу поиска
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, ware.Name)>0;
          1: fl:= pos(ss, ware.NameBS)>0;
          2: fl:= (pos(s, ware.Name)>0) or (pos(ss, ware.NameBS)>0);
          3: begin // полное совпадение
               fl:= (ware.Name=s);
               flBreak:= fl;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, ware.CommentUP)>0);
      end;
      if not fl then Continue;

      SetLength(arTypes, 0); // массив кодов типов аналогов (с нулевым)
      flTypeByAnalogs:= (ware.IsInfoGr and not ware.HasFixedType); // инфо-товар без типа

      flMarket:= ware.IsMarketWare(ffp);
      if not flMarket and (ware.AnalogLinks.LinkCount<1) then Continue; // непродажный товар без аналогов

      WA:= TSearchWareOrOnum.Create(iWare, 0, True, flMarket);
      if flSemafores and flMarket then
        WA.RestSem:= GetContWareRestsSem(WA.ID, ffp, WA.SemTitle); // подсказка к семафору

      //-------------------------------------- отсев по наличию цены, аналогов
      for j:= 0 to ware.AnalogLinks.ListLinks.Count-1 do begin
        analog:= GetLinkPtr(ware.AnalogLinks.ListLinks[j]);
        if analog.IsINFOgr or not analog.IsMarketWare(ffp) then Continue; // инфо и без цен пропускаем
        tt:= TTwoCodes.Create(analog.ID, -1);
        if flSemafores then begin // если нужны семафоры
          tt.ID2:= GetContWareRestsSem(tt.ID1, ffp, tt.Name); // подсказка к семафору
          if ffp.HideZeroRests and (tt.ID2<1) then begin // если надо - отсеиваем красные
            prFree(tt);
            Continue;
          end;
        end;
        if flTypeByAnalogs then prAddItemToIntArray(analog.TypeID, arTypes);
        WA.OLAnalogs.Add(tt);
      end; // for j:= 0 to
      if (WA.OLAnalogs.Count<1) and
        (not flMarket or (flSemafores and ffp.HideZeroRests and (WA.RestSem<1))) then begin
        prFree(WA);
        Continue;
      end;

      //-------------------------------------------------- отсев по типам товара
      flSelecting:= not flTypeSelection; // True для первичного поиска, False для отсева

      if not flTypeByAnalogs then begin // товары с типом - по собственному типу
        pType:= ware.TypeID;
        flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
        if not flContaining then
          if flTypeSelection then begin
            prFree(WA);
            Continue; // отсев товаров
          end else prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы

      end else begin // инфо-товары без типа - по аналогам (как ОН)
        for j:= 0 to High(arTypes) do begin // перебираем типы аналогов
          pType:= arTypes[j];
          flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
          if flTypeSelection and flContaining then begin
            flSelecting:= True;                    // отсев и тип есть в массиве типов
            break;
          end else if not flTypeSelection and not flContaining then
            prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы
        end; // for j:= 0 to High(arTypes)
        if not flSelecting then begin
          prFree(WA);
          Continue; // если не подходит по типам при отсеве
        end;
      end;
      if (Result.Capacity=Result.Count) then Result.Capacity:= Result.Count+100;
      Result.Add(WA);

      if flBreak then Break; // полное совпадение
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(iWare)+': '+E.Message;
    end; // for
  finally
    SetLength(arTypes, 0);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;
//====================================== Поиск оригинального номера по вхождению
function SearchWareOrigNums_new(Template: String; IgnoreSpec: Integer; // must Free
         var TypeCodes: Tai; flSemafores: boolean; ffp: TForFirmParams): TObjectList;
const nmProc = 'SearchWareOrigNums_new';
// возвращает массив кодов ориг.номеров, отсортированных по наименованию, имеющих товары
// если TypeCodes пустой - в TypeCodes собираем типы
// если TypeCodes не пустой - отсев рез-тов поиска по типам
// здесь сразу заполняем семафоры, если надо - отсеиваем по красным
var i, j, pType: Integer;
    mess: String;
    flTypeSelection, flSelecting, flContaining: boolean;
    arTypes: Tai;
    WA: TSearchWareOrOnum;
    tt: TTwoCodes;
    OrigNum: TOriginalNumInfo;
    analog: TWareInfo;
begin
  Result:= TObjectList.Create;
  if not Assigned(TypeCodes) then SetLength(TypeCodes, 0);

  Template:= AnsiUpperCase(fnDelSpcAndSumb(Template));
  if Template='' then Exit;
  flTypeSelection:= (Length(TypeCodes)>0); // признак - отсеивать по TypeCodes или собирать типы в TypeCodes

  with Cache do try
    for i:= 1 to High(Cache.FDCA.arOriginalNumInfo) do try
      if not Cache.FDCA.OrigNumExist(i) then Continue;

      OrigNum:= Cache.FDCA.arOriginalNumInfo[i];
      if not Assigned(OrigNum.Links) or (OrigNum.Links.LinkCount<1) then Continue;

      if (pos(Template, OrigNum.OriginalNum)<1) then Continue;

      WA:= TSearchWareOrOnum.Create(OrigNum.ID, 0, False, False);
      SetLength(arTypes, 0); // массив кодов типов аналогов (с нулевым)
      //-------------------------------------------- отсев по наличию аналогов
      for j:= 0 to OrigNum.Links.ListLinks.Count-1 do begin    // идем по аналогам
        analog:= GetLinkPtr(OrigNum.Links.ListLinks[j]);
        if analog.IsINFOgr or not analog.IsMarketWare(ffp) then Continue; // инфо и без цен пропускаем
        tt:= TTwoCodes.Create(analog.ID, -1);
        if flSemafores then begin // если нужны семафоры
          tt.ID2:= GetContWareRestsSem(tt.ID1, ffp, tt.Name);
          if ffp.HideZeroRests and (tt.ID2<1) then begin // если надо - отсеиваем красные
            prFree(tt);
            Continue;
          end;
        end;
        prAddItemToIntArray(analog.TypeID, arTypes); // собираем типы
        WA.OLAnalogs.Add(tt);
      end; // for j:= 0 to High(arAnalogs)
      if (WA.OLAnalogs.Count<1) then begin
        prFree(WA);
        Continue;
      end;

      //-------------------------------------------------- отсев по типам товара
      flSelecting:= not flTypeSelection; // True для первичного поиска, False для отсева

      for j:= 0 to High(arTypes) do begin // перебираем типы аналогов
        pType:= arTypes[j];
        flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
        if flTypeSelection and flContaining then begin
          flSelecting:= True;                    // отсев и тип есть в массиве типов
          break;
        end else if not flTypeSelection and not flContaining then
          prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы
      end;
      if not flSelecting then begin
        prFree(WA);
        Continue; // если не подходит по типам при отсеве
      end;

      if (Result.Capacity=Result.Count) then Result.Capacity:= Result.Count+100;
      Result.Add(WA);
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'onID='+IntToStr(i)+': '+E.Message;
    end; // for
  finally
    SetLength(arTypes, 0);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;


{//======================= простановка признака WareSemafor всем клиентам системы
function SetSemMarkForClients(pSysID: Integer; SemMark: String='T'): String;
const nmProc='SetSemMarkForClients';
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    i, j, ii: integer;
    Client: TClientInfo;
    Firma: TFirmInfo;
begin
  Result:= '';
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  try
    ORD_IBD:= cntsORD.GetFreeCnt;
    ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'GB_IBS_'+nmProc, -1, tpWrite, True);
    ORD_IBS.SQL.Text:= 'UPDATE WEBORDERCLIENTS SET'+
      ' WOCLWARERESTSEMAFOR="'+SemMark+'" where WOCLCODE=:user';
    for i:= 1 to High(Cache.arFirmInfo) do begin
      if not Cache.FirmExist(i) then Continue;
      Firma:= Cache.arFirmInfo[i];
      if not (pSysID in [constIsAuto, constIsMoto]) then Continue;
      if not Firma.CheckSysType(pSysID) then Continue;
      for j:= 1 to High(Firma.FirmClients) do begin
        ii:= Firma.FirmClients[j];
        if not Cache.ClientExist(ii) then Continue;
        Client:= Cache.arClientInfo[ii];
        if (Client.WareSemafor=(SemMark='T')) then Continue;
        try
          with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
          ORD_IBS.ParamByName('user').AsInteger:= ii;
          ORD_IBS.ExecQuery;
          with ORD_IBS.Transaction do if InTransaction then Commit;
          Client.WareSemafor:= (SemMark='T');
        except
          on E: Exception do begin
            with ORD_IBS.Transaction do if InTransaction then Rollback;
            prMessageLOGS(nmProc+': id='+IntToStr(i)+' '+E.Message, fLogCache);
          end;
        end;
        ORD_IBS.Close;
      end;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  prFreeIBSQL(ORD_IBS);
  cntsORD.SetFreeCnt(ORD_IBD);
end;  }
//===================== список порций текстов и условий к связке 3 для просмотра
function GetModelNodeWareUsesAndTextsPartsView(ModelID, NodeID, WareID: Integer): TObjectList; // must Free Result
// в TObjectList[i] - TStringList, в TStringList - Delimiter=Char(iPart), QuoteChar=Char(iSrc) (если неправильная: +cWrongPart)
const nmProc = 'GetModelNodeWareUsesAndTextsPartsView';
var iType, iSrc, iPart, iWrong: integer;
    s, TypeName, str: String;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    lst: TStringList;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    Model: TModelAuto;
    flNewLst: Boolean;
begin
  Result:= TObjectList.Create;
  flNewLst:= True;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  lst:= nil;
  with Cache do begin
    with FDCA do begin
      if not Models.ModelExists(ModelID) then
        raise EBOBError.Create(MessText(mtkNotFoundModel, IntToStr(ModelID)));
      Model:= Models[ModelID];
      nodes:= AutoTreeNodesSys[Model.TypeSys];
    end;
    if not nodes.NodeExists(NodeID) then
      raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeID)));
    if not Model.NodeLinks.LinkExists(NodeID) then
      raise EBOBError.Create('Не найдена связка модели с узлом');
    node:= nodes[NodeID];
    if not node.IsEnding then raise EBOBError.Create('Узел не конечный');
    if NodeID<>node.MainCode then begin
      NodeID:= node.MainCode;
      if not nodes.NodeExists(NodeID) then
        raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeID))+' (главный)');
      if not Model.NodeLinks.LinkExists(NodeID) then
        raise EBOBError.Create('Не найдена связка модели с главным узлом');
//      node:= nodes[NodeID];
    end;
    if not Model.NodeLinks.DoubleLinkExists(NodeID, WareID) then
      raise EBOBError.Create('Не найдена связка модели и узла с товаром');
    try
      ORD_IBD:= cntsOrd.GetFreeCnt;
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
      ORD_IBS.SQL.Text:= 'select * from GetModelNodeWareUsesPartsView_n('+
        IntToStr(ModelID)+', '+IntToStr(NodeID)+', '+IntToStr(WareID)+')';
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // номер порции
        if (iPart<1) then begin // пропускаем специальные порции (если есть)
          TestCssStopException;
          while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do ORD_IBS.Next;
          Continue;
        end;
        iSrc:= ORD_IBS.FieldByName('rSrc').AsInteger; // источник
        iWrong:= ORD_IBS.FieldByName('rWrong').AsInteger; // признак неправильной
        if flNewLst then begin
          lst:= TStringList.Create;
          flNewLst:= False;
        end;
        while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
          iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
          TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
          s:= '';
          while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
            and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
            s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
            cntsORD.TestSuspendException;
            ORD_IBS.Next;
          end;
          s:= str+TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
          lst.Add(s);
        end; // while not ORD_IBS.Eof and (iPart=

        if lst.Count>0 then begin
          lst.Delimiter:= Char(iPart);
          if iWrong>0 then iSrc:= iSrc+cWrongPart; // если неправильная - +cWrongPart
          lst.QuoteChar:= Char(iSrc);
          Result.Add(lst);
          flNewLst:= True;
        end;
      end; //  while not ORD_IBS.Eof
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
      if not flNewLst then prFree(lst);
    end;
  end;
end;
//===================== установить/убрать признак WRONG порции условий и текстов
function SetUsageTextPartWrongMark(pModelID, pNodeID, pWareID, pPart, pUserID: Integer; flWrong: Boolean): String;
const nmProc = 'SetUsageTextPartWrongMark';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
begin
  Result:= '';
  ORD_IBS:= nil;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if (pPart<1)    then raise EBOBError.Create(MessText(mtkNotValidParam)+' номера порции');
    if (pUserID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' пользователя');
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'execute procedure SetUsageTextPartWrongMark('+IntToStr(pModelID)+
        ', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+IntToStr(pPart)+', '+
        IntToStr(pUserID)+', "'+fnIfStr(flWrong, 'T', 'F')+'")';
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrEditRecord);
      prMessageLOGS(nmProc+': '+E.Message);
    end;
  end;
end;
{//=========================== сверка TD->link_supplier_brand и ORD->BrandReplace
procedure CheckSuppliersBrandsLinks;
const nmProc = 'CheckSuppliersBrandsLinks'; // имя процедуры/функции
      maxStrLen = 1200;
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    pMainNode, lenS, lenGaStr, iCount, startCount, pUserID: Integer;
    s, sTime, GaStr: String;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('GaStr').AsString:= GaStr;
    tdtIBS.ExecQuery;
    tdtIBS.Close;
    GaStr:= '';
    lenGaStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
                                                  // проверка необходимости сверки
      ordIBS.SQL.Text:= 'select BRRPGBCODE, BRRPTDCODE from BRANDREPLACE order by BRRPGBCODE, BRRPTDCODE';
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) and
        (ordIBS.Fields[0].AsDateTime<=GetConstItem(pcCheckGAMainNodeTime).DateValue) then Exit;
      ordIBS.Close;

// if (exists(select * from data_suppliers where ds_mf_id = 501)) then insert into link_supplier_brand (lsbSupplier, lsbBrand) values ((select ds_id from data_suppliers where ds_mf_id = 501),35);

      sTime:= FormatDateTime(cDateTimeFormatY4S, Now);
      pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;

      tdtIBD:= cntsTDT.GetFreeCnt;
      try
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpWrite, true);
        tdtIBS.SQL.Text:= 'update link_GA_MainNode set lgm_Check=0'; // сбрасываем флажки проверки
        tdtIBS.ExecQuery;
        startCount:= tdtIBS.RowsAffected; // запоминаем кол-во записей
        tdtIBS.Close;
        tdtIBS.SQL.Text:= 'execute procedure check_ga_MainNode_Links(:GaStr)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select TRNAMAINCODE, TRNATDCODE from TREENODESAUTO'+
          ' where TRNATDGA="T" group by TRNAMAINCODE, TRNATDCODE order by TRNAMAINCODE';
        ordIBS.ExecQuery;
        iCount:= 0;
        GaStr:= '';
        lenGaStr:= 0;
        while not ordIBS.Eof do begin
          pMainNode:= ordIBS.fieldByName('TRNAMAINCODE').AsInteger;
          s:= '';
          while not ordIBS.Eof and (pMainNode=ordIBS.fieldByName('TRNAMAINCODE').AsInteger) do begin
            s:= s+fnIfStr(s='', '', ',')+ordIBS.fieldByName('TRNATDCODE').AsString; // собираем порцию кодов GA по pMainNode
            inc(iCount);
            TestCssStopException;
            ordIBS.Next;
          end;
          s:= ordIBS.fieldByName('TRNAMAINCODE').AsString+'='+s; // строка по pMainNode
          lenS:= length(s);

          if (lenGaStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          GaStr:= GaStr+fnIfStr(GaStr='', '', ';')+s;
          lenGaStr:= length(GaStr);
        end;
        ordIBS.Close;
        if GaStr<>'' then CheckPortion; // последняя порция - обрабатываем

        if (iCount<startCount) then begin             // удаляем непроверенные
          tdtIBS.SQL.Text:= 'delete from link_GA_MainNode where lgm_Check=0';
          tdtIBS.ExecQuery;
          tdtIBS.Close;
        end;
        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    s:= SaveNewConstValue(pcCheckGAMainNodeTime, pUserID, sTime);
    if s<>'' then prMessageLOGS(nmProc+': '+s);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;  }

//====================================== проверка логина в списке поиска логинов
procedure CheckWorkLogins(userID: Integer; Login: String);
var i, j: Integer;
begin
  if (Login='') then exit;
  with Cache.arClientInfo.WorkLogins do begin // проверка логина в списке поиска логинов
    i:= IndexOf(Login);
    if (i<0) then AddObject(Login, Pointer(userID))
    else begin
      j:= Integer(Objects[i]);
      if (j<>userID) then Objects[i]:= Pointer(userID);
    end;
  end;
end;
//============================================== проверка клонов/блоков клиентов
procedure CheckClonedOrBlockedClients(LogFile: String='');
const nmProc = 'CheckClonedOrBlockedClients'; // имя процедуры/функции
var ordIBD: TIBDatabase;
    ordIBS: TIBSQL;
//    iCount,
    pUserID: Integer;
    s, sTime: String;
    tbegin, tend, tt: TDateTime;
begin
  ordIBS:= nil;
//  iCount:= 0;
  tend:= 0;
  tt:= Date;
  tbegin:= Cache.GetConstItem(pcCheckClonBlockClients).DateValue; // время последней проверки
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBD.Close;  // нужно "свежее" соединение
      ordIBD.Open;
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
      s:= IntToStr(csWebCreateUser)+', '+IntToStr(csUnblockWebUser)+', '+IntToStr(csBlockWebUser);
      ordIBS.SQL.Text:= 'select c1.WOCLCODE user1, c1.WOCLLOGIN log1, c1.WOCLBLOCK block1,'+
        ' c2.WOCLCODE user2, c2.WOCLLOGIN log2, c2.WOCLBLOCK block2, s.PROTTIME'+
        ' from (select PROTWOCL, max(PROTTIME) PROTTIME from PROTOCOL'+
        '   where PROTCOMMAND in ('+s+') and PROTTIME>=:tbegin'+
        '     and PROTWOCL is not null group by PROTWOCL) s'+
        ' left join WEBORDERCLIENTS c1 on c1.WOCLCODE=s.PROTWOCL'+
        ' left join WEBORDERCLIENTS c2 on c2.WOCLCODE=c1.WOCLCLONEFROM order by PROTTIME';
      ordIBS.ParamByName('tbegin').AsDateTime:= max(tbegin, tt);
      ordIBS.ExecQuery;
      while not ordIBS.Eof do begin
        pUserID:= ordIBS.FieldByName('user1').AsInteger;
        s:= ordIBS.FieldByName('log1').AsString;
        if (pUserID>0) and (s<>'') then begin
          CheckWorkLogins(pUserID, s);
//          inc(iCount);
          if Cache.ClientExist(pUserID) then with Cache.arClientInfo[pUserID] do begin
            Login:= s;
            Blocked:= (ordIBS.FieldByName('block1').AsInteger<1);
          end;
        end;
        pUserID:= ordIBS.FieldByName('user2').AsInteger;
        s:= ordIBS.FieldByName('log2').AsString;
        if (pUserID>0) and (s<>'') then begin
          CheckWorkLogins(pUserID, s);
//          inc(iCount);
          if Cache.ClientExist(pUserID) then with Cache.arClientInfo[pUserID] do begin
            Login:= s;
            Blocked:= (ordIBS.FieldByName('block2').AsInteger<1);
          end;
        end;
        if (ordIBS.FieldByName('PROTTIME').AsDateTime>tend) then
          tend:= ordIBS.FieldByName('PROTTIME').AsDateTime;
        TestCssStopException;
        ordIBS.Next;
      end;
                   // ничего не нашли и новый день - переписываем время проверки
      if (tend=0) and (tbegin<=tt) then tend:= IncSecond(tt, 1);
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
      if (tend>0) then begin
        pUserID:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
        sTime:= FormatDateTime(cDateTimeFormatY4S, tend);
        s:= Cache.SaveNewConstValue(pcCheckClonBlockClients, pUserID, sTime);
        if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile, (LogFile<>''));
      end;
    end;
//    if flDebug then prMessageLOGS(nmProc+': '+IntToStr(iCount), fLogDebug, False);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile, (LogFile<>''));
  end;
//  TestCssStopException;
end;

//====================================== сверка TD->GA и TreeNodesAuto->MainNode
procedure CheckGAMainNodesLinks(LogFile: String='');
const nmProc = 'CheckGAMainNodesLinks'; // имя процедуры/функции
      maxStrLen = 1200;
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    pMainNode, lenS, lenGaStr, pUserID: Integer;
    s, sTime, GaStr, sMain: String;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('GaStr').AsString:= GaStr;
    tdtIBS.ExecQuery;
    if tdtIBS.Fields[0].AsString<>'' then
      prMessageLOGS(nmProc+': Ошибка проверки: '+tdtIBS.Fields[0].AsString);
    tdtIBS.Close;
    GaStr:= '';
    lenGaStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
                                                  // проверка необходимости сверки
      ordIBS.SQL.Text:= 'select max(TRNATIMEADD) from TREENODESAUTO'+
                        ' where TRNADTSYCODE<>'+IntToStr(constIsMoto);
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) and
        (ordIBS.Fields[0].AsDateTime<=GetConstItem(pcCheckGAMainNodeTime).DateValue) then Exit;
      ordIBS.Close;

      sTime:= FormatDateTime(cDateTimeFormatY4S, Now);
      pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;

      tdtIBD:= cntsTDT.GetFreeCnt;
      try
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpWrite, true);
        tdtIBS.SQL.Text:= 'update link_GA_MainNode set lgm_Check=0'; // сбрасываем флажки проверки
        tdtIBS.ExecQuery;
        tdtIBS.Close;
        tdtIBS.SQL.Text:= 'select rErrorStr from check_ga_MainNode_Links(:GaStr)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select TRNAMAINCODE, TRNATDCODE from TREENODESAUTO'+
          ' where TRNATDGA="T" group by TRNAMAINCODE, TRNATDCODE order by TRNAMAINCODE';
        ordIBS.ExecQuery;
        GaStr:= '';
        lenGaStr:= 0;
        while not ordIBS.Eof do begin
          pMainNode:= ordIBS.fieldByName('TRNAMAINCODE').AsInteger;
          sMain:= ordIBS.fieldByName('TRNAMAINCODE').AsString;
          s:= '';
          while not ordIBS.Eof and (pMainNode=ordIBS.fieldByName('TRNAMAINCODE').AsInteger) do begin
            s:= s+fnIfStr(s='', '', ',')+ordIBS.fieldByName('TRNATDCODE').AsString; // собираем порцию кодов GA по pMainNode
            TestCssStopException;
            ordIBS.Next;
          end;
          s:= sMain+'='+s; // строка по pMainNode
          lenS:= length(s);

          if (lenGaStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          GaStr:= GaStr+fnIfStr(GaStr='', '', ';')+s;
          lenGaStr:= length(GaStr);
        end;
        ordIBS.Close;
        if GaStr<>'' then CheckPortion; // последняя порция - обрабатываем

        tdtIBS.SQL.Text:= 'delete from link_GA_MainNode where lgm_Check=0'; // удаляем непроверенные
        tdtIBS.ExecQuery;
        tdtIBS.Close;

        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    s:= SaveNewConstValue(pcCheckGAMainNodeTime, pUserID, sTime);
    if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile, (LogFile<>''));
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile, (LogFile<>''));
  end;
  TestCssStopException;
end;
//===================== проверить наличие товаров у артикулов в TDT (по запросу)
procedure CheckArticleWareMarks(LogFile: String=''; maxStrLen: Integer = 3000);
const nmProc = 'CheckArticleWareMarks'; // имя процедуры/функции
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    lenS, lenStr, pUserID, pIdent, iCount: Integer;
    s, Str: String;
    TimeProc: TDateTime;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('Str').AsString:= Str;
    tdtIBS.ExecQuery;
    tdtIBS.Close;
    Str:= '';
    lenStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  iCount:= 0;
  TimeProc:= Now;
  with Cache do try
    if GetConstItem(pcNeedArticleWareMarks).IntValue<1 then Exit; // проверка необходимости
    ordIBD:= cntsOrd.GetFreeCnt;
    pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;
    try
      tdtIBD:= cntsTDT.GetFreeCnt;
      try                                // определяем идентификатор проверки
        ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpRead, true);
        tdtIBS.SQL.Text:= 'select Ident from GetCheckArticleWareMarksIdent';
        tdtIBS.ExecQuery;
        if (ordIBS.Eof and ordIBS.Bof) then begin
          Randomize;
          pIdent:= Random(maxStrLen+1);
        end else pIdent:= tdtIBS.Fields[0].AsInteger;
        tdtIBS.Close;

        fnSetTransParams(tdtIBS.Transaction, tpWrite);
        tdtIBS.Transaction.StartTransaction;
        tdtIBS.SQL.Text:= 'execute procedure check_ArticleWareMarks('+IntToStr(pIdent)+', :Str)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select WATDARTICLE, WATDARTSUP, count(WATDWARECODE) wareCount'+
          ' from WAREARTICLETD where WATDWRONG="F" group by WATDARTICLE, WATDARTSUP';
        ordIBS.ExecQuery;
        Str:= '';
        lenStr:= 0;
        s:= '';
        while not ordIBS.Eof do begin
          s:= ordIBS.fieldByName('wareCount').AsString+'<'+
              ordIBS.fieldByName('WATDARTSUP').AsString+'>'+
              ordIBS.fieldByName('WATDARTICLE').AsString; // строка по WATDARTICLE
          lenS:= length(s);

          if (lenStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          Str:= Str+fnIfStr(Str='', '', ';')+s;
          lenStr:= length(Str);
          Inc(iCount);
          TestCssStopException;
          ordIBS.Next;
        end;
        ordIBS.Close;
        if Str<>'' then CheckPortion; // последняя порция - обрабатываем

                          // сбрасываем признаки наличия товаров у непроверенных
        tdtIBS.SQL.Text:= 'update articles set art_warecode=0 where ART_CheckWARE<>'+
                          IntToStr(pIdent)+' and art_warecode>0';
        tdtIBS.ExecQuery;
        tdtIBS.Close;
        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    prMessageLOGS(nmProc+': '+IntToStr(iCount)+' articles - '+GetLogTimeStr(TimeProc), LogFile);
                                       // сбрасываем признак проверки
    s:= SaveNewConstValue(pcNeedArticleWareMarks, pUserID, '0');
    if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile);
  end;
  TestCssStopException;
end;
//============================== проверка фирм, активных последние DecHour часов
procedure TestLastFirms(DecHour: Integer=1);
const nmProc = 'TestLastFirms'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    FirmID, UserID, fCount: Integer;
    LocalStart, dd: TDateTime;
begin
  if DecHour<1 then Exit;
  ibs:= nil;
  LocalStart:= now();
  fCount:= 0;
  try
    ibd:= cntsORD.GetFreeCnt('', '', '', True); // IgnoreTimer=True - не закрывать по времени
    try
      dd:= Now;
      if DecHour>0 then dd:= incHour(dd, -DecHour);
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
      ibs.SQL.Text:= 'select woclfirmcode from weborderclients'+
                     ' where wocllastactiontime>:dd group by woclfirmcode';
      ibs.ParamByName('dd').AsDateTime:= dd;
      ibs.ExecQuery;
      while not ibs.Eof do begin
        FirmID:= ibs.fields[0].AsInteger;
        Cache.TestFirms(FirmID, True, True);
        if Cache.FirmExist(FirmID) then begin
          UserID:= Cache.arFirmInfo[FirmID].SUPERVISOR;
          Cache.TestClients(UserID, True, True); // сотрудники фирмы
        end;
        TestCssStopException;
        ibs.Next;
        Inc(fCount);
      end;
    finally
      prFreeIBSQL(ibs);
      cntsORD.SetFreeCnt(ibd, True);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  prMessageLOGS(nmProc+': '+IntToStr(fCount)+' к/а - '+
    GetLogTimeStr(LocalStart), fLogCache, false);
end;
//================================ проверка наименований фирм в базе логирования
procedure TestLogFirmNames;
const nmProc = 'TestLogFirmNames'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    pFirmID, iCount, i, len: Integer;
    LocalStart: TDateTime;
    lst: TStringList;
    fName, s: String;
begin
  ibs:= nil;
  ibd:= nil;
  LocalStart:= now();
  iCount:= 0;
  len:= 40;
  try
    for i:= High(Cache.arFirmInfo) downto 1 do
      if Assigned(Cache.arFirmInfo[i]) then Cache.arFirmInfo[i].State:= False;

    lst:= TStringList.Create;
    try
      ibd:= cntsLog.GetFreeCnt('', '', '', True); // IgnoreTimer=True - не закрывать по времени
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);

      ibs.SQL.Text:= 'select ff.RDB$FIELD_LENGTH fsize'+
        ' from rdb$relation_fields f, rdb$fields ff'+
        ' where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE'+
        '   and f.RDB$RELATION_NAME=:table and f.RDB$FIELD_NAME=:fname';
        ibs.ParamByName('table').AsString:= 'LOGFIRMNAMES';
        ibs.ParamByName('fname').AsString:= 'LFNFIRMNAME';
      ibs.ExecQuery;
      if not (ibs.Eof and ibs.Bof) and (ibs.FieldByName('fsize').AsInteger>0) then
        len:= ibs.FieldByName('fsize').AsInteger;
      ibs.Close;

      ibs.SQL.Text:= 'select LFNFIRMCODE, LFNFIRMNAME from LOGFIRMNAMES';
      ibs.ExecQuery; // проверяем те фирмы, кот.уже есть в базе логирования
      while not ibs.Eof do begin
        pFirmID:= ibs.fields[0].AsInteger;
        fName:=  ibs.fields[1].AsString;
        if Cache.FirmExist(pFirmID) then with Cache.arFirmInfo[pFirmID] do begin
          s:= copy(Name, 1, len);
          if (fName<>s) then lst.AddObject(s, Pointer(pFirmID)); // в список на проверку
          State:= True;
        end;
        TestCssStopException;
        ibs.Next;
      end;
      ibs.Close;

      for i:= High(Cache.arFirmInfo) downto 1 do if Assigned(Cache.arFirmInfo[i]) then
        with Cache.arFirmInfo[i] do begin    // ищем фирмы, кот.не проверяли
          if State then State:= False
          else if not Arhived and (FirmContracts.count>0) then
            lst.AddObject(copy(Name, 1, len), Pointer(ID));
        end;

      iCount:= lst.Count;
      if (iCount>0) then begin
        fnSetTransParams(ibs.Transaction, tpWrite, True);
        ibS.SQL.Text:= 'execute procedure CheckLogFirmName(:aFirm, :aFName)';
        for i:= 0 to lst.Count-1 do begin
          ibS.ParamByName('aFirm').AsInteger:= Integer(lst.Objects[i]);
          ibS.ParamByName('aFName').AsString:= lst[i];
          ibs.ExecQuery;
        end;
        ibs.Transaction.Commit;
      end;
    finally
      prFreeIBSQL(ibs);
      cntsLog.SetFreeCnt(ibd, True);
      prFree(lst);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  prMessageLOGS(nmProc+': '+IntToStr(iCount)+' к/а - '+
    GetLogTimeStr(LocalStart), fLogCache, false);
end;
//================= проверка соответствия к/а условиям фильтрации (Web & WebArm)
function CheckFirmFilterConditions(FirmID: Integer; flFirmsAdd, flAuto, flMoto: Boolean;
         Filials, Classes, Types, Firms: TIntegerList): Boolean;
const nmProc = 'CheckFirmFilterConditions'; // имя процедуры/функции
var j: Integer;
    flNot: Boolean;
    firm: TFirmInfo;
begin
  Result:= False;
  if not Cache.FirmExist(FirmID) then Exit;
  try
    firm:= Cache.arFirmInfo[FirmID];
    if firm.Arhived or firm.Blocked or (firm.SUPERVISOR<1) then Exit;

//    if not ((flAuto and firm.IsAUTOFirm) or (flMoto and firm.IsMOTOFirm)) then Exit;

    if (Firms.Count>0) then begin  // проверяем коды
      flNot:= (Firms.IndexOf(FirmID)<0);
      if flFirmsAdd then begin  //------------------------------ флаг добавления
        if not flNot then begin // есть в списке - дальше не проверяем
          Result:= True; // фирма подходит
          Exit;                            // нет в списке + нет др.условий - не подходит
        end else if (Types.Count<1) and (Classes.Count<1) and (Filials.Count<1) then Exit;
      end else                  //------------------------------ флаг исключения
        if not flNot then Exit; // есть в списке - не подходит
    end;
                                         // проверяем тип
    if (Types.Count>0) and (Types.IndexOf(firm.FirmType)<0) then Exit;
                                         // проверяем филиал
    if (Filials.Count>0) and (Filials.IndexOf(firm.GetDefContract.Filial)<0) then Exit;

    if (Classes.Count>0) then begin      // проверяем категории
      flNot:= True;
      for j:= 0 to Classes.Count-1 do begin
        flNot:= (firm.FirmClasses.IndexOf(Classes[j])<0);
        if not flNot then break;
      end;
      if flNot then Exit;
    end;

    Result:= True; // фирма подходит
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;

//-------------------------------------- проверка остановки процесса или системы
procedure CheckStopExecute(pUserID: Integer; ThreadData: TThreadData);
begin
  if Assigned(ThreadData) then
    prStopProcess(pUserID, ThreadData.ID) // проверка остановки процесса
  else TestCssStopException; // проверка остановки системы
end;
//--------------------------------------------- отображение процентов выполнения
procedure SetExecutePercent(pUserID: Integer; ThreadData: TThreadData; Percent: Double);
begin
  if Assigned(ThreadData) then
    ImpCheck.SetProcessPercent(pUserID, ThreadData.ID, Percent);
end;
//======================================== перемещаем файл nf из dirold в dirnew
function RenameErrFile(nf, dirold, dirnew: string; flPutOff: Boolean=False): string;
const nmProc = 'RenameErrFile'; // имя процедуры/функции
var i: Integer;
    list: TStringList;
    nfile, s, prefix: String;
begin
  list:= TStringList.Create;
  try
    if flPutOff then prefix:= 'p' // помечаем отложенный файл
    else prefix:= 'e';            // помечаем сбойный файл
    nfile:= fnTestDirEnd(dirnew)+prefix+'_'+nf; // новое имя файла
    i:= 0;
    Result:= '';
    if not DirectoryExists(dirnew) then CreateDir(dirnew); // если папки нет - создаем
    while FileExists(nfile) do begin
      Inc(i);
      nfile:= fnTestDirEnd(dirnew)+prefix+IntToStr(i)+'_'+nf;
    end;
    if RenameFile(fnTestDirEnd(dirold)+nf, nfile) then
      prMessageLOGS(nmProc+': Файл '+nf+' перемещен в папку '+dirnew) // пишем в log
    else Result:= Result+fnIfStr(Result='', '', #13#10)+'Файл '+nf+' не удалось переместить в папку '+dirnew;
    if not flPutOff then begin
      list.Add('Error processing file '+nf); // отправить сообщение админу пр-мы Vlad
      s:= fnGetSysAdresVlad(caeOnlyWorkDay);
      list.Insert(0, GetMessageFromSelf);
      s:= n_SysMailSend(s, 'Error processing file', list, nil, '', '', true);
      if (s<>'') then
        Result:= Result+fnIfStr(Result='', '', #13#10)+'Ошибка отправки письма об Ошибке обработки файла '+nf;
    end;
  finally
    prFree(list);
  end;
end;
//=========================================== отправить письмо с паролем клиенту
function prSendMailWithClientPassw(Kind: TKindCliMail; Login, Password, Mail: String;
         ThreadData: TThreadData; FirmName: String=''; lst: TStringList=nil): string;
//  TKindCliMail = (kcmSetMainUser, kcmRegister, kcmCreateUser, kcmRemindPass);
const nmProc = 'prSendMailWithClientPassw'; // имя процедуры/функции
var Strings: TStringList;
    errmess, subj, s1, s2: string;
    i: Integer;
    fl: Boolean;
begin
  Result:= '';
  fl:= False;
  try
    Strings:= TStringList.Create;
    Strings.Add('Здравствуйте!');
    Strings.Add('');
    if (Kind=kcmRemindPass) then begin
      subj:= 'Восстановление пароля на сайте ';
{      if not Assigned(lst) or (lst.Count<1) then begin
        Strings.Add('Логин: '+Login);
        Strings.Add('Пароль: '+Password);
        Strings.Add('Учетная запись принадлежит организации '+FirmName);
      end else  }
      for i:= 0 to lst.Count-1 do begin
        Strings.Add(lst[i]);
        fl:= fl or (pos('Ошибка', lst[i])>0);
      end;
      if not fl then begin  // если нет ошибки     // Чичков 02.05.2018
        Strings.Add('');
        Strings.Add('Если Вы не запрашивали восстановление пароля,');
        Strings.Add('рекомендуем Вам сменить его.'); // Ильясов 16.04.2018
      end;
//      Strings.Add('перешлите это письмо в службу поддержки '+Cache.GetConstItem(pcUIKdepartmentMail).StrValue);
    end else begin
      subj:= 'Доступ к сайту ';
//      Strings.Add('Предоставлен доступ к сайту http://order.vladislav.ua');
      Strings.Add('Логин: '+Login);
      Strings.Add('Пароль: '+Password);
    end;
    Strings.Add('');
    Strings.Add('С уважением,');
    Strings.Add('Компания "Владислав"'); // Ильясов 16.04.2018
//    Strings.Add('Команда ВЛАДИСЛАВ');

//    errmess:= n_SysMailSend(Mail, subj+'order.vladislav.ua', Strings, nil, '', '', true);
    errmess:= n_SysMailSend(Mail, subj+'order.vladislav.ua', Strings, nil, cNoReplayEmail, '', true);

    if errmess<>'' then begin
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', errmess, '');
      s1:= 'Произошла ошибка при отправке письма с паролем.';
      s2:= 'пароль можно получить через систему восстановления пароля';
      case Kind of
       kcmSetMainUser:
         Result:= 'Учетная запись создана успешно. '+s1+
                  ' Сообщите клиенту логин, '+s2;
       kcmCreateUser:
         Result:= 'Учетная запись создана успешно. '+s1+
                  ' Сообщите своему сотруднику логин, '+s2;
       kcmRegister:
         Result:= s1+' Сообщите клиенту логин, '+s2;
       kcmRemindPass:
         Result:= s1+' Попробуйте повторить запрос через некоторое время.'+
                  ' Если ошибка происходит регулярно, сообщите'+
                  ' в службу поддержки Ваш e-mail - возможно'+
                  ' ранее данные были внесены в базу неправильно.';
      else Result:= s1;
      end; // case Kind of
    end;
  finally
    prFree(Strings);
  end;
end;
(*//=================================== проверка заглавной буквы и пробелов текста
function CheckTextFirstUpAndSpaces(txt: String): String;
var xChar, xCharU: String;
begin
  Result:= txt;
  if (Result<>'') then Result:= trim(Result);               // убираем крайние пробелы
  if (Result<>'') then Result:= StringReplace(Result, '  ', ' ', [rfReplaceAll]); // убираем двойные пробелы
  if (Result<>'') then begin
    xChar:= copy(Result, 1, 1);
    xCharU:= AnsiUpperCase(xChar);                 // текст - с заглавной буквы
    if (xChar<>xCharU) then Result:= xCharU+copy(Result, 2);
  end
end;    *)


//******************************************************************************
//                          расписания отгрузки
//******************************************************************************
//=========================== список доступных времен самовывоза по складу, дате
function GetAvailableSelfGetTimesList(DprtID: Integer; pDate: TDateTime;
         var stID: Integer; var SL: TStringList; flWithSVKDelay: Boolean=False): String;
// String- время отгрузки, Object- код времени отгрузки
// если stID>0 и недоступно - меняем знак
const nmProc = 'GetAvailableSelfGetTimesList'; // имя процедуры/функции
var i, TestTime, TimeMin, TimeMax, SVKDelay: Integer;
    s: String;
    st: TShipTimeItem;
    flFound: Boolean;
    lst: TList;
    dprt: TDprtInfo;
begin
  Result:= '';
  if not Assigned(SL) then SL:= TStringList.Create;
  flFound:= (stID<1);
  lst:= TList.Create;
  SVKDelay:= 0;
  try
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад отгрузки');
    dprt:= Cache.arDprtInfo[DprtID];

    s:= dprt.CheckShipAvailable(pDate, 0, 0, False, False);
    if (s<>'') then raise EBOBError.Create(s);

    if flWithSVKDelay then
      SVKDelay:= Cache.GetConstItem(pcSVKSelfDelayMinutes).IntValue;
                                              // границы времен отгрузки на дату
    s:= dprt.GetShipTimeLimits(pDate, TimeMin, TimeMax, SVKDelay, False);
    if (s<>'') then raise EBOBError.Create(s);

    for i:= 0 to Cache.ShipTimes.ItemsList.Count-1 do begin
      st:= Cache.ShipTimes.ItemsList[i];
      TestTime:= (st.Hour*60+st.Minute)*60;
      if (TestTime<TimeMin) or (TestTime>TimeMax) then Continue; // проверяем время
      lst.Add(st);  // если подходит - добавляем в список
      flFound:= flFound or (st.ID=stID);
    end;
    if not flFound then // старое время не попало в список
      if Cache.ShipTimes.ItemExists(stID) then begin // старое время есть
        st:= Cache.ShipTimes[stID];
        lst.Add(st);                          // добавляем в список старое время
        stID:= -stID;                         // меняем знак у кода -> недоступно
      end else      // старое время не найдено
        stID:= 0;                             // обнуляем код
    if (lst.Count>1) then lst.Sort(ShipTimesSortCompare); // сортируем
    for i:= 0 to lst.Count-1 do begin
      st:= lst[i];
      SL.AddObject(st.Name, Pointer(st.ID)); // время отгрузки, код
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
  prFree(lst);
end;
//====================================== список доступных дат отгрузки по складу
function GetAvailableShipDatesList(DprtID, iDate: Integer; var SL: TStringList): String;
// String- строка даты отгрузки, Object- целое значение даты отгрузки (вместо кода)
// если iDate>0 и дата недоступна - меняем знак
const nmProc = 'GetAvailableShipDatesList'; // имя процедуры/функции
var i, TestTime, DateInt, DayCount: Integer;
    iHour, iMinute, iSec, iMsec: Word;
    s: String;
    flFound: Boolean;
    dprt: TDprtInfo;
    pDate: TDateTime;
    sch: TTwoCodes;
begin
  Result:= '';
  if not Assigned(SL) then SL:= TStringList.Create;
  try
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад отгрузки');
    dprt:= Cache.arDprtInfo[DprtID];

    DecodeTime(Now, iHour, iMinute, iSec, iMsec); // сегодня проверяем текущее время
    TestTime:= iHour*60+iMinute+dprt.DelayTime;  // запаздывание склада
    TestTime:= TestTime*60;
    DayCount:= Cache.GetConstItem(pcShipChoiceDays).IntValue; // кол-во дней для показа

    for i:= 0 to dprt.Schedule.Count-1 do begin
      pDate:= Date()+i;
      DateInt:= Trunc(pDate);
      flFound:= (iDate>0) and (DateInt=iDate);
      sch:= TTwoCodes(dprt.Schedule[i]);

      if ((sch.ID1<1) and (sch.ID2<1))         // дата недоступна
        or ((i=0) and (TestTime>sch.ID2)) then // сегодня проверяем текущее время
        if flFound then DateInt:= -DateInt else Continue;

      s:= FormatDateTime(cDateFormatY4, pDate);
      case DayOfTheWeek(pDate) of
        1: s:= s+' - Пн';
        2: s:= s+' - Вт';
        3: s:= s+' - Ср';
        4: s:= s+' - Чт';
        5: s:= s+' - Пт';
        6: s:= s+' - Сб';
        7: s:= s+' - Вс';
      end;
      if (i=0) then s:= s+', сегодня';
      if (i=1) then s:= s+', завтра';
      SL.AddObject(s, Pointer(DateInt)); // если подходит - добавляем в список
      if (SL.Count>=DayCount) then break; // DayCount раб.дней
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
(*//====================================== список доступных дат отгрузки по складу
function GetAvailableShipDatesList(DprtID, iDate: Integer;
         var SL: TStringList; flWithSVKDelay: Boolean=False): String;
// String- строка даты отгрузки, Object- целое значение даты отгрузки (вместо кода)
// если iDate>0 и дата недоступна - меняем знак
const nmProc = 'GetAvailableShipDatesList'; // имя процедуры/функции
var i, TestTime, DateInt, DayCount: Integer;
    iHour, iMinute, iSec, iMsec: Word;
    s: String;
    flFound: Boolean;
    dprt: TDprtInfo;
    pDate: TDateTime;
    sch: TTwoCodes;
begin
  Result:= '';
  if not Assigned(SL) then SL:= TStringList.Create;
  try
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад отгрузки');
    dprt:= Cache.arDprtInfo[DprtID];

    DecodeTime(Now, iHour, iMinute, iSec, iMsec); // сегодня проверяем текущее время
    TestTime:= iHour*60+iMinute+dprt.DelayTime;  // запаздывание склада
    if flWithSVKDelay then                       // запаздывание СВК
      TestTime:= TestTime+Cache.GetConstItem(pcSVKShipDelayMinutes).IntValue;
    TestTime:= TestTime*60;

{    DayCount:= 1; // вычисляем кол-во дней для показа
    with fnSplit(',', Cache.GetConstItem(pcAccountStorageDays).StrValue) do try  // TStringList
      for i:= 0 to Count-1 do begin
        DateInt:= StrToIntDef(Strings[i], 0);
        if (DayCount<DateInt) then DayCount:= DateInt;
      end;
    finally
      Free;
    end;  }
    DayCount:= Cache.GetConstItem(pcShipChoiceDays).IntValue; // кол-во дней для показа

    for i:= 0 to dprt.Schedule.Count-1 do begin
      pDate:= Date()+i;
      DateInt:= Trunc(pDate);
      flFound:= (iDate>0) and (DateInt=iDate);
      sch:= TTwoCodes(dprt.Schedule[i]);

      if ((sch.ID1<1) and (sch.ID2<1))         // дата недоступна
        or ((i=0) and (TestTime>sch.ID2)) then // сегодня проверяем текущее время
        if flFound then DateInt:= -DateInt else Continue;

      s:= FormatDateTime(cDateFormatY4, pDate);
      case DayOfTheWeek(pDate) of
        1: s:= s+' - Пн';
        2: s:= s+' - Вт';
        3: s:= s+' - Ср';
        4: s:= s+' - Чт';
        5: s:= s+' - Пт';
        6: s:= s+' - Сб';
        7: s:= s+' - Вс';
      end;
      if (i=0) then s:= s+', сегодня';
      if (i=1) then s:= s+', завтра';
      SL.AddObject(s, Pointer(DateInt)); // если подходит - добавляем в список
      if (SL.Count>=DayCount) then break; // DayCount раб.дней
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end; *)
//======================================= проверка параметров отгрузки для счета
function CheckAccountShipParams(delivType, ContID, DprtID: Integer; var pShipDate: TDateTime;
         var DestID, ttID, smID, stID: Integer; WithSVKDelay: Boolean): String;
const nmProc = 'CheckAccountShipParams'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    s, strErr: String;
    dprt: TDprtInfo;
    SVKDelay: Integer;
begin
  ibs:= nil;
  ibd:= nil;
  Result:= '';
  s:= '';
  SVKDelay:= 0;
  try
    if not (DelivType in [cDelivTimeTable, cDelivReserve, cDelivSelfGet, cDelivClientNow]) then
      raise EBOBError.Create('Неизвестный вид доставки - '+IntToStr(DelivType));
    if not Cache.Contracts.ItemExists(ContID) then
      raise EBOBError.Create('Не найден контракт, код - '+IntToStr(ContID));
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад, код - '+IntToStr(DprtID));

    dprt:= Cache.arDprtInfo[DprtID];
    case delivType of
      cDelivReserve: begin // резерв
        pShipDate:= 0;
        DestID:= 0;
        ttID:= 0;
        smID:= 0;
        stID:= 0;
      end; // cDelivReserve

      cDelivClientNow: begin // клиент на складе - только сегодня  ???
        strErr:= dprt.CheckShipAvailable(pShipDate, 0, 0, False, False);
        if (strErr<>'') then raise EBOBError.Create(strErr);
        DestID:= 0;
        ttID:= 0;
        smID:= Cache.GetConstItem(pcCliNowShipMethodCode).IntValue;
        stID:= 0;
      end; // cDelivClientNow

      cDelivSelfGet: begin // Самовывоз
        DestID:= 0;
        ttID:= 0;
        smID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
        if WithSVKDelay then
          SVKDelay:= Cache.GetConstItem(pcSVKSelfDelayMinutes).IntValue;
        try // проверяем время
          if (stID<1) then raise EBOBError.Create('Отсутствует время отгрузки');
          strErr:= dprt.CheckShipAvailable(pShipDate, stID, SVKDelay, True, False);
          if (strErr<>'') then raise EBOBError.Create(strErr);
        except
          on E: Exception do begin
            stID:= 0;
            raise EBOBError.Create(E.Message);
          end;
        end;
      end; // cDelivSelfGet

      cDelivTimeTable: try // доставка
        if (DestID<1) then raise EBOBError.Create('Отсутствует торговая точка');
        if (ttID<1) then raise EBOBError.Create('Отсутствует расписание');
        try
          ibd:= cntsGRB.GetFreeCnt;
          ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
          ibs.SQL.Text:= 'select rSMethodID, rSTimeID'+
            ' from Vlad_CSS_GetContDestTimeTables1'+
            '('+IntToStr(contID)+', '+IntToStr(DestID)+', '+IntToStr(DprtID)+
            ', :pDate) where RttID='+IntToStr(ttID);
          IBS.ParamByName('pDate').AsDate:= pShipDate;
          IBS.ExecQuery;
          if (IBS.Bof and IBS.Eof) then begin
            DestID:= 0;
            raise EBOBError.Create('Заданная торговая точка недоступна');
          end;
          smID:= IBS.FieldByName('rSMethodID').AsInteger;
          stID:= IBS.FieldByName('rSTimeID').AsInteger;
          strErr:= 'Заданное расписание отгрузки недоступно';
          if not Cache.ShipMethods.ItemExists(smID) then raise EBOBError.Create(strErr);
          if WithSVKDelay then
            SVKDelay:= Cache.GetConstItem(pcSVKShipDelayMinutes).IntValue;
          strErr:= dprt.CheckShipAvailable(pShipDate, stID, SVKDelay, False, True);
          if (strErr<>'') then raise EBOBError.Create(strErr);
        finally
          prFreeIBSQL(ibs);
          cntsGRB.SetFreeCnt(ibd);
        end;
      except
        on E: Exception do begin
          ttID:= 0;
          smID:= 0;
          stID:= 0;
          raise EBOBError.Create(E.Message);
        end;
      end; // cDelivTimeTable
    end; // case
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//============================================= параметры отгрузки для просмотра
function fnGetShipParamsView(contID, DprtID, DestID, ShipTableID: Integer; ShipDate: double;
         var DelivType, ShipMetID, ShipTimeID: Integer; var sDestName, sDestAdr, sArrive: String;
         var sShipMet, sShipTime, sView: String; GBdirection: Boolean=False): String;
const nmProc = 'fnGetShipParamsView'; // имя процедуры/функции
var grbIBD: TIBDatabase;
    grbIBS: TIBSQL;
    pDate: double;
    dest: TDestPoint;
    Contract: TContract;
begin
  Result:= '';
  sDestName:= '';
  sDestAdr:= '';
  sArrive:= '';
  sShipMet:= '';
  sShipTime:= '';
  sView:= '';
  grbIBD:= nil;
  grbIBS:= nil;
  try
    if not (DelivType in [cDelivTimeTable, cDelivReserve, cDelivSelfGet]) then
      DelivType:= cDelivReserve; // резерв

    if not Cache.Contracts.ItemExists(contID) then Exit;
    Contract:= Cache.Contracts[contID];

    case DelivType of
      cDelivTimeTable: begin //------------------------ Доставка по расписанию
        if (ShipDate<DateNull) then ShipDate:= 0;
        if (contID<1) or (DestID<1) or (ShipTableID<1) or (DprtID<1) then begin
          ShipMetID:= 0;
          ShipTimeID:= 0;
        end;
        if (ContID>0) and (DestID>0) then try
          grbIBD:= cntsGRB.GetFreeCnt;
          grbIBS:= fnCreateNewIBSQL(grbIBD, 'IBS_'+nmProc, -1, tpRead, True);
          dest:= Contract.GetContDestPoint(destID);
          if Assigned(dest) then begin
            sDestName:= dest.Name;
            sDestAdr:= dest.Adress;
          end else begin
            grbibs.SQL.Text:= 'select rDestName, rDestAdr'+
              ' from Vlad_CSS_GetContDestPoints('+IntToStr(ContID)+', '+
              fnIfStr(GBdirection, '1', '0')+') where RDestID='+IntToStr(DestID);
            grbIBS.ExecQuery;
            if not (grbIBS.Bof and grbIBS.Eof) then begin
              sDestName:= grbIBS.FieldByName('rDestName').AsString;
              sDestAdr:= grbIBS.FieldByName('rDestAdr').AsString;
            end;
            grbIBS.Close;
          end;
          if (DprtID>0) and (ShipDate>0) and (ShipTableID>0) then begin
            grbIBS.SQL.Text:= 'select rSMethodID, rSTimeID, rArrive'+
              ' from Vlad_CSS_GetContDestTimeTables1'+
              '('+IntToStr(contID)+', '+IntToStr(DestID)+', '+IntToStr(DprtID)+
              ', :pDate) where RttID='+IntToStr(ShipTableID);
            grbIBS.ParamByName('pDate').AsDate:= ShipDate;
            grbIBS.ExecQuery;
            if not (grbIBS.Bof and grbIBS.Eof) then begin
              ShipMetID:= grbIBS.FieldByName('rSMethodID').AsInteger;
              ShipTimeID:= grbIBS.FieldByName('rSTimeID').AsInteger;
              pDate:= grbIBS.FieldByName('rArrive').AsDateTime;
              if (pDate>DateNull) then sArrive:= FormatDateTime(cDateTimeFormatY2N, pDate);
            end;
          end;
        finally
          prFreeIBSQL(grbIBS);
          cntsGRB.SetFreeCnt(grbIBD);
        end;

        if Cache.ShipMethods.ItemExists(ShipMetID) then
          sShipMet:= TShipMethodItem(Cache.ShipMethods[ShipMetID]).Name;
        if Cache.ShipTimes.ItemExists(ShipTimeID) then
          sShipTime:= TShipTimeItem(Cache.ShipTimes[ShipTimeID]).Name;

        if (ShipDate>0) then sView:= sView+FormatDateTime(cDateFormatY2, ShipDate);
        if (sShipTime<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipTime;
        if (sShipMet<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipMet;
        if (sDestName<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sDestName;
        if (sDestAdr<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sDestAdr;
        if (sArrive<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+'План.приб.'+sArrive;
        if (sView<>'') then sView:= 'Отгрузка: '+sView else sView:= 'Доставка';
      end; // cDelivTimeTable

      cDelivReserve: begin // Резерв
        ShipMetID:= 0;
        ShipTimeID:= 0;
        sView:= 'Резервировать';
      end; // cDelivReserve

      cDelivSelfGet: begin //--------------------------------------- Самовывоз
        if (ShipDate<DateNull) then ShipDate:= 0;
        ShipMetID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
        if Cache.ShipMethods.ItemExists(ShipMetID) then
          sShipMet:= TShipMethodItem(Cache.ShipMethods[ShipMetID]).Name;
        if Cache.ShipTimes.ItemExists(ShipTimeID) then
          sShipTime:= TShipTimeItem(Cache.ShipTimes[ShipTimeID]).Name;

        if (ShipDate>0) then sView:= sView+FormatDateTime(cDateFormatY2, ShipDate);
        if (sShipTime<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipTime;
        if (sShipMet<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipMet;
        if (sView<>'') then sView:= 'Отгрузка: '+sView else sView:= 'Самовывоз';
      end; // cDelivSelfGet
    end; // case
  except
    on E: Exception do Result:= E.Message;
  end;
end;
//========================================== запись глав.пользователя в Grossbee
function SetMainUserToGB(FirmID, UserID: Integer; pDate: TDateTime; ibsGBw: TIBSQL=nil): String;
const nmProc = 'SetMainUserToGB'; // имя процедуры/функции
var ibsGB: TIBSQL;
    ibdGB: TIBDatabase;
begin
  Result:= '';
  ibdGB:= nil;
  ibsGB:= nil;
  if (pDate<=DateNull) then pDate:= Date();
  try try
    if Assigned(ibsGBw) then begin
      ibsGB:= ibsGBw;
      ibsGB.Close;
      if not ibsGB.Transaction.InTransaction then ibsGB.Transaction.StartTransaction;
    end else begin
      ibdGB:= cntsGRB.GetFreeCnt;
      ibsGB:= fnCreateNewIBSQL(ibdGB, 'ibsGB_'+nmProc, -1, tpWrite, True);
    end;
    ibsGB.SQL.Text:= 'UPDATE OR INSERT INTO GeneralPerson'+
                     ' (GnPrDate, GnPrFirmCode, GnPrPersonCode)'+
                     ' VALUES (:dd, '+IntToStr(firmID)+', '+IntToStr(UserID)+
                     ') MATCHING (GnPrFirmCode, GnPrDate)';
    ibsGB.ParamByName('dd').AsDate:= pDate;
    ibsGB.ExecQuery;
    ibsGB.Transaction.Commit;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
  finally
    if not Assigned(ibsGBw) then begin
      prFreeIBSQL(ibsGB);     // отпускаем коннект Grossbee
      cntsGRB.SetFreeCnt(ibdGB);
    end;
  end;
end;
//====== регулярная проверка в базе логирования, запускается при старте в Webarm
procedure TmpCheckRecode;
const nmProc = 'TmpCheckRecode'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    TimeProc: TDateTime;
begin
  ibd:= nil;
  ibs:= nil;
  TimeProc:= Now;
  try try
    ibd:= cntsLOG.GetFreeCnt;                                         // ib_css
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.SQL.Text:= 'select rCount from tmp_Check_Recode_err';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    i:= ibs.FieldByName('rCount').AsInteger;
    ibs.Transaction.Commit;
    prMessageLOGS(nmProc+': обработано '+IntToStr(i)+' записей, '+GetLogTimeStr(TimeProc), fLogCache, False);
  except
    on E: Exception do prMessageLOGS(nmProc+'_stop: '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsLOG.SetFreeCnt(ibd);
  end;
end;
//===================================== фоновая перекодировка в базе логирования
procedure TmpRecodeCSS;
const nmProc = 'TmpRecodeCSS'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    flStop: Boolean;
    TimeProc: TDateTime;
begin
  ibd:= nil;
  ibs:= nil;
  if not flTmpRecodeCSS then Exit;    // только в периоды малой загрузки системы
  if not flDebug and not fnGetActionTimeEnable(caeSmallWork) then Exit;
  flStop:= False;
  TimeProc:= Now;
  try try
    ibd:= cntsLOG.GetFreeCnt;                                         // ib_css
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.SQL.Text:= 'select rCount from tmp_Recode';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    i:= ibs.FieldByName('rCount').AsInteger;
    ibs.Transaction.Commit;
    flStop:= (i<1); // все перекодировали - выключаем
    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+IntToStr(i)+' записей, '+GetLogTimeStr(TimeProc), nmProc, False);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+'_stop: '+E.Message, nmProc);
//      flStop:= True;
    end;
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsLOG.SetFreeCnt(ibd);
    if flStop then SetIniParam(nmIniFileBOB, 'Options', 'flTmpRecodeCSS', '0');
  end;
end;
//============================================= фоновая перекодировка в базе ORD
procedure TmpRecodeORD;
// скриптами в базе удалены:
//  - заголовки старых заказов без товаров со статусами "Формируется", "Аннулирован"
// 1. удаляем "левые" товары из бонусных заказов
// 2. удаляем старые заказы со статусом "Удален"
const nmProc = 'TmpRecodeORD'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    flStop: Boolean;
    TimeProc: TDateTime;
//    ilst: TIntegerList;
//    s: String;
begin
  ibd:= nil;
  ibs:= nil;
  if not flTmpRecodeORD then Exit;    // только в периоды малой загрузки системы
  if not flDebug and not fnGetActionTimeEnable(caeSmallWork) then Exit;
  flStop:= False;
  TimeProc:= Now;
//  ilst:= TIntegerList.Create;
  try try
    ibd:= cntsORD.GetFreeCnt;                                         // ib_ord
{
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
//    ibs.SQL.Text:= 'select ordrlncode lncode, ordrlnware from ordersreestr'+        // 1
//      ' left join orderslines on ordrlnorder=ordrcode where ordrdate>"01.04.2016"'+ // 1
//      ' and ordrcurrency=22 and ordrstatus='+IntToStr(orstForming);                 // 1
    ibs.SQL.Text:= 'select first 1000 ordrcode lncode from ordersreestr'+   // 2
      ' where ordrdate<"01.01.2016" and ordrstatus='+IntToStr(orstDeleted); // 2
    ibs.ExecQuery;
    while not ibs.Eof do begin
//      i:= ibs.FieldByName('ordrlnware').AsInteger;                 // 1
//      if Cache.WareExist(i) and not Cache.GetWare(i).IsPrize then  // 1
      ilst.Add(ibs.FieldByName('lncode').AsInteger);       // 2
      TestCssStopException; // проверка остановки системы
      ibs.Next;
    end;
    ibs.Close;
    if (ilst.Count>0) then begin
      fnSetTransParams(IBS.Transaction, tpWrite, True);
//      IBS.SQL.Text:= 'execute procedure DelOrderLine(:LineID)'; // 1
      IBS.SQL.Text:= 'delete from ordersreestr where ordrcode=:LineID'; // 2
//      s:= 'LineID=';                                            // 1
      s:= 'orderID=';                                                   // 2
      for i:= 0 to ilst.Count-1 do begin
        try
          with IBS.Transaction do if not InTransaction then StartTransaction;
          IBS.ParamByName('LineID').AsInteger:= ilst[i];
          IBS.ExecQuery;
          IBS.Transaction.Commit;
        except
          on E: Exception do prMessageLOGS(nmProc+': del error '+s+
                             IntToStr(ilst[i])+': '+E.Message, nmProc, False);
        end;
        TestCssStopException; // проверка остановки системы
      end;
    end;
    flStop:= (ilst.Count<1); // все перекодировали - выключаем
    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+IntToStr(ilst.Count)+' записей, '+
      GetLogTimeStr(TimeProc), nmProc, False);
}
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.SQL.Text:= 'select rCount from tmp_Recode';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    i:= ibs.FieldByName('rCount').AsInteger;
    ibs.Transaction.Commit;
    flStop:= (i<1); // все перекодировали - выключаем

    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+IntToStr(i)+' записей, '+GetLogTimeStr(TimeProc), nmProc, False);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+'_stop: '+E.Message, nmProc);
//      flStop:= True;
    end;
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsORD.SetFreeCnt(ibd, True);
    if flStop then SetIniParam(nmIniFileBOB, 'Options', 'flTmpRecodeORD', '0');
//    prFree(ilst);
  end;
end;
//========================== фоновая перекодировка/чистка таблиц в базе Grossbee
procedure TmpRecodeGRB;
const nmProc = 'TmpRecodeGRB'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i, j: Integer;
    s, sDate, days, recs: String;
    flStop: Boolean;
    TimeProc: TDateTime;
    rIniFile: TINIFile;
begin
  ibd:= nil;
  ibs:= nil;
  if not flTmpRecodeGRB then Exit;    // только в периоды малой загрузки системы
  if not flDebug and not fnGetActionTimeEnable(caeSmallWork) then Exit;
  flStop:= False;
  TimeProc:= Now;
  s:= '';
  i:= 0;
  rIniFile:= TINIFile.Create(nmIniFileBOB);
  try try
    days:= rIniFile.ReadString('Options', 'RecodeGRBdays', '10');
    recs:= rIniFile.ReadString('Options', 'RecodeGRBrecs', '500');
    sDate:= rIniFile.ReadString('Options', 'RecodeGRBdateTo', '01.01.2018');

    ibd:= cntsGRB.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.ParamCheck:= False; // фоновая чистка alter-таблиц док-тов
    ibs.SQL.Text:= ' execute block returns (rCount integer) as'+
      ' declare variable xCode integer=0; declare variable xDateTest timestamp="'+sDate+'";'+
{      ' declare variable xDateEnd timestamp; declare variable xDays integer='+days+';'+

      ' begin rCount=0; select min(piavLastTime) from payinvalter_vlad into :xDateEnd;'+
      ' if (xDateEnd<xDateTest) then begin'+
      '  xDateEnd=xDateEnd+xDays; if (xDateEnd>xDateTest) then xDateEnd=xDateTest;'+
      '  for select first '+recs+' piavAccCode from payinvalter_vlad'+
      '   where piavLastTime<:xDateEnd order by piavLastTime desc'+
      '  into :xCode do begin rCount=rCount+1;'+             // payinvalter_vlad
      '   delete from payinvalter_vlad where piavAccCode=:xCode; end end suspend;'+

      ' rCount=0; select min(iavLastTime) from invoicealter_vlad into :xDateEnd;'+
      ' if (xDateEnd<xDateTest) then begin'+
      '  xDateEnd=xDateEnd+xDays; if (xDateEnd>xDateTest) then xDateEnd=xDateTest;'+
      '  for select first '+recs+' iavInvCode from invoicealter_vlad'+
      '   where iavLastTime<:xDateEnd order by iavLastTime desc'+
      '  into :xCode do begin rCount=rCount+1;'+            // invoicealter_vlad
      '   delete from invoicealter_vlad where iavInvCode=:xCode; end end suspend;'+ }
      '   declare variable xDateEnd timestamp; declare variable xCodeEnd integer=0;'+

      ' begin rCount=0; select min(piavLastTime) from payinvalter_vlad into :xDateEnd;'+
      '   if (xDateEnd<xDateTest) then begin xDateEnd=xDateEnd+'+days+';'+
      '    if (xDateEnd>xDateTest) then xDateEnd=xDateTest;'+
      '    select Min(piavAccCode) from payinvalter_vlad'+
      '      where piavLastTime<:xDateEnd into :xCode;'+
      '    if (xCode is not null and xCode>0) then begin xCodeEnd=xCode+'+recs+';'+
      '      delete from payinvalter_vlad where'+
      '       (piavAccCode between :xCode and :xCodeEnd) and piavLastTime<:xDateEnd;'+
      '      rCount=ROW_COUNT; end end suspend;'+

      '   rCount=0; xCode=0; select min(iavLastTime) from invoicealter_vlad into :xDateEnd;'+
      '   if (xDateEnd<xDateTest) then begin xDateEnd=xDateEnd+'+days+';'+
      '    if (xDateEnd>xDateTest) then xDateEnd=xDateTest;'+
      '    select Min(iavInvCode) from invoicealter_vlad'+
      '     where iavLastTime<:xDateEnd into :xCode;'+
      '    if (xCode is not null and xCode>0) then begin xCodeEnd=xCode+'+recs+';'+
      '      delete from invoicealter_vlad where'+
      '        (iavInvCode between :xCode and :xCodeEnd) and iavLastTime<:xDateEnd;'+
      '      rCount=ROW_COUNT; end end suspend;'+

      ' end';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    while not ibs.Eof do begin
      j:= ibs.FieldByName('rCount').AsInteger;
      i:= i+j;
      s:= s+fnIfStr(s='', '', '+')+IntToStr(j);
      TestCssStopException;
      ibs.Next;
    end;
    ibs.Transaction.Commit;
    flStop:= (i<1); // все перекодировали - флаг выключения

    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+s+' записей, '+GetLogTimeStr(TimeProc), nmProc, False);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+'_stop: '+E.Message, nmProc);
//      flStop:= True;
    end;
  end;
  finally
    prFree(rIniFile);
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsGRB.SetFreeCnt(ibd, True);                        // выключаем
    if flStop then SetIniParam(nmIniFileBOB, 'Options', 'flTmpRecodeGRB', '0');
  end;
end;
//========================================== проверка номера мобильного телефона
function CheckMobileNumber(num: String): Boolean;
//const opCodes: array[0..15] of String = ('039'{Golden Telecom}, '050'{MTC},
// '063'{Life}, '066'{Джинс}, '067'{Киевстар/Djuice}, '068'{Beeline/WellCOM/МОБI},
// '073'{Life}, '091'{Utel}, '092'{PEOPLEnet}, '093'{Life}, '094'{Интертелеком},
// '095'{МТС/Джинс}, '096'{Киевстар/Djuice}, '097'{Киевстар/Djuice/Мобилыч},
// '098'{Киевстар/Djuice/Мобилыч}, '099'{Экотел(1..6)/Джинс});
var pref: String;
    i: Integer;
    c: Char;
begin
  Result:= False;
  if (num='') then Exit; // пустой номер
  i:= 1;
  repeat // ищем позицию кода оператора
    c:= num[i];
    if SysUtils.CharInSet(c, ['(', '+', '3', '8', ' ']) then Inc(i)
    else c:= '~'; // маркер выхода их цикла
  until (c='~');
  pref:= copy(num, i, 10);
  if (length(pref)<10) then Exit; // некорректная длина номера
//  pref:= copy(num, i, length(num));
//  if (length(pref)<>10) then Exit; // некорректная длина номера

  pref:= copy(num, i, 3); // код оператора

  Result:= (Cache.MobilePhoneSigns.IndexOf(pref)>=0);
{
  for i:= Low(opCodes) to High(opCodes) do begin // ищем в массиве кодов
    Result:= (pref=opCodes[i]);
    if Result then Exit;
  end;
  Result:= (pref='050') or (pref='066') or (pref='095') or (pref='099')  // MTC
        or (pref='067') or (pref='096') or (pref='097') or (pref='098')  // Kyivstar
        or (pref='068') or (pref='063') or (pref='093') or (pref='073')  // Beeline, Life
        or (pref='091') or (pref='092') or (pref='094') or (pref='039'); // Utel, PEOPLEnet, Интертелеком, Golden Telecom
}
end;
//============================================ номер мобильного телефона без +38
function GetMobileNumber10(num: String): String;
// возвращает пустую строку, если номер некорректный
var i: Integer;
    c: Char;
begin
  Result:= '';
  if (num='') then Exit; // пустой номер
  num:= fnDelSpcAndSumb(num);
  i:= 1;
  repeat // ищем позицию кода оператора
    c:= num[i];
    if SysUtils.CharInSet(c, ['+', '3', '8', ' ']) then Inc(i)
    else c:= '~'; // маркер выхода их цикла
  until (c='~');
  if (Cache.MobilePhoneSigns.IndexOf(copy(num, i, 3))<0) then Exit; // не нашли код оператора
  num:= copy(num, i, length(num));
  if (length(num)<>10) then Exit; // некорректная длина номера
  Result:= num;
end;
//======================================= исключение фиктивного адреса из строки
function ExtractFictiveEmail(emails: String): String;
var i: Integer;
begin
  Result:= emails;
  Result:= StringReplace(Result, ' ', '', [rfReplaceAll]);
  i:= pos(cFictiveEmail, Result);
  if (i<1) then Exit;
  Result:= StringReplace(Result, cFictiveEmail, '', [rfReplaceAll, rfIgnoreCase]);
  Result:= StringReplace(Result, ',,', ',', [rfReplaceAll]);
  if (copy(Result, 1, 1)=',') then Result:= copy(Result, 2, length(Result));
  if (copy(Result, length(Result), 1)=',') then Result:= copy(Result, 1, length(Result)-1);
end;
//======================================= исключение фиктивного адреса из списка
function ExtractFictiveEmail(emails: TStringList): TStringList; // must Free !!!
var i: Integer;
begin
  Result:= TStringList.Create;
  for i:= 0 to eMails.Count-1 do // пропускаем фиктивный адрес
    if (eMails[i]<>cFictiveEmail) then Result.Add(eMails[i]);
end;
//=============================== проверка соответствия ФИО пользователя шаблону
function CheckClientFIO(CliName: String): String;
const xChars = 'АБВГДЕЁЖЗИЙКЛМОНПРСТУФХЦЧШЩЭЫЮЯ';
var s: String;
    i: Integer;
begin
  Result:= '';
  s:= trim(CliName); // ???
  try
    if (s='') then raise Exception.Create(''); // пусто

    i:= pos(' ', s); // фамилию из двух (как минимум) символов не нашли
    if (i<3) then raise Exception.Create('');
    if not (pos(copy(s, 1, 1), xChars)>0) then raise Exception.Create(''); // 1-я буква фамилии не заглавная

    s:= copy(s, i+1, length(s)); //--- строка ИО
    if (s='') then raise Exception.Create(''); // пусто
    if not (pos(copy(s, 1, 1), xChars)>0) then raise Exception.Create(''); // 1-я буква имени не заглавная

    i:= pos(' ', s);
    case i of
      0: begin //---------------------------- ищем 2 точки - 2-й вариант шаблона
        i:= pos('.', s); // 1-я точка
        if (i<2) then raise Exception.Create(''); // нет точки или в начале строки
        s:= copy(s, i+1, length(s)); //--- строка после 1-й точки
        if (s='') then raise Exception.Create(''); // пусто
        if not (pos(copy(s, 1, 1), xChars)>0) then raise Exception.Create(''); // 1-я буква отчества не заглавная
        i:= pos('.', s); // 2-я точка
        if (i<2) then raise Exception.Create(''); // нет точки или в начале строки
      end; // 0

      1: raise Exception.Create(''); // пробел в начале строки ИО

      else begin //----------------------------- 2 пробела - 1-й вариант шаблона
        s:= copy(s, i+1, length(s)); //--- строка О
        if not (pos(copy(s, 1, 1), xChars)>0) then raise Exception.Create(''); // 1-я буква отчества не заглавная
        Exit;
      end; // else
    end; // case
  except
    on e: Exception do
      Result:= 'ФИО не соответствует формату "Иванов Иван Иванович" или "Иванов И.И."';
  end;
end;
//============ остатки товара для контракта по колонкам (сегодня, завтра, >1 дня)
function GetContWareRestsByCols(wareID, ContID, StorageCount: Integer): TDoubleDynArray;
const nmProc = 'GetContWareRestsByCols';
var i, StoreMain: Integer;
    OList: TObjectList;
    flVis, flAdd: Boolean;
    Contract: TContract;
    dprt: TDprtInfo;
    pqty: Double;
begin
  if (StorageCount<1) then StorageCount:= 1;
  SetLength(Result, StorageCount); // индекс масссива: 0-сегодня, 1- завтра, 2- >1 дня
  for i:= 0 to High(Result) do Result[i]:= 0;
  flVis:= (StorageCount>1);
  flAdd:= (StorageCount>2);
  try
    Contract:= Cache.Contracts[ContID];
    StoreMain:= Contract.MainStorage;

    OList:= Cache.GetWareRestsByStores(WareID); // наличие по колонкам
    try
      Result[0]:= fnGetQtybyIDDef(OList, StoreMain, 0);
      if flVis then begin
        dprt:= Cache.arDprtInfo[StoreMain];
        for i:= 0 to dprt.StoresFrom.Count-1 do with TTwoCodes(dprt.StoresFrom[i]) do
          if (ID2=1) or (flAdd and (ID2>1)) then begin
            pqty:= fnGetQtybyIDDef(OList, ID1, 0);
            if (ID2=1) then Result[1]:= Result[1]+pqty else Result[2]:= Result[2]+pqty;
          end;
      end; // if flVis
    finally
      prFree(OList);
    end;

  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
end;
//==================================== проверяем возможность поставки на сегодня
//===== есть - возвращает текст для подсказки времени доступности (спец.семафор)
function CheckDprtTodayFill(dprtID: Integer; RestList: TObjectList): String;
const nmProc = 'CheckDprtTodayFill';
var j, i: Integer;
    dprt: TDprtInfo;
    cqr: TCodeAndQty;
    cds: TCodeAndDates;
    rest: Double;
begin
  Result:= '';
  try
    dprt:= Cache.arDprtInfo[dprtID];
    for j:= 0 to dprt.FillTT.Count-1 do begin
      cds:= TCodeAndDates(dprt.FillTT[j]); // код склада, дата/время показа, дата/время прибытия

if not flmyDebug then begin
      if (cds.Date1<Now()) then Continue;      // Date1 - граничное дата/время показа
      if (cds.Date2>(Date()+1)) then Continue; // Date2 - время прибытия (здесь нужно сегодня)
end;
      rest:= 0;
      for i:= 0 to RestList.Count-1 do begin
        cqr:= TCodeAndQty(RestList[i]);    // код склада, кол-во
        if (cqr.ID<>cds.ID) then Continue; // не тот склад
        rest:= cqr.Qty;
        break;
      end;
      if not fnNotZero(rest) then Continue; // нет остатка

      Result:= 'Доступен '+AnsiLowerCase(cds.Name); // текст - время прибытия
      Exit;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
end;
//================================================= колонки остатков по прибытию
function GetDprtWareRestsByArrive(dprtID: Integer; WareQty: Double;
                                  var wrba: TWareRestsByArrive): String;
const nmProc = 'GetDprtWareRestsByArrive';
var j, i, iw, wareID, StoreMain, restIdx: Integer;
    dprt: TDprtInfo;
    cds: TCodeAndDates;
    rest, WareRest: Double;
    RestList: TObjectList;
    TitleList: TStringList;
    s, title: String;
    restCols: TDoubleDynArray;
    ttList: TObjectList;
    tc: TTwoCodes;
    fl: Boolean;
    arFlagDel_0, arFlagDel_1: array of Boolean;
//    store: TStorageDescr;
begin
  Result:= '';
  RestList:= nil;
  TitleList:= TStringList.Create; // список заголовкоа колонок
  ttList:= TObjectList.Create; // список ближайших расписаний складов
  try
    SetLength(wrba.arRestLists, Length(wrba.arWares)); // строки остатков по колонкам
    for iw:= 0 to High(wrba.arRestLists) do
      wrba.arRestLists[iw]:= TStringList.Create;

    StoreMain:= dprtID;
    dprt:= Cache.arDprtInfo[StoreMain];
    //------------------------------------- составляем список заголовков колонок
    //------------------------- и список ближайших расписаний складов пополнения
//    TitleList.Add(dprt.ColumnName); // 1-й - склад контракта
    TitleList.Add('Сегодня, '+dprt.ColumnName); // 1-й - склад контракта
    for j:= 0 to dprt.FillTT.Count-1 do begin  // склады пополнения
      cds:= TCodeAndDates(dprt.FillTT[j]); // код склада, дата/время показа, дата/время прибытия
      if (cds.Date1<Now()) then Continue;  // Date1 - граничное дата/время показа

//      tc:= nil;
      fl:= False;
      for i:= 0 to ttList.Count-1 do begin
        tc:= TTwoCodes(ttList[i]);
        fl:= (tc.ID1=cds.ID);
        if fl then break;
      end;
      if fl then Continue; // этот склад уже есть

      title:= cds.Name; // заголовок - время прибытия
      restIdx:= TitleList.IndexOf(title); // ищем индекс колонки
      if (restIdx<0) then restIdx:= TitleList.Add(title);

      tc:= TTwoCodes.Create(cds.ID, restIdx); // код склада, индекс колонки
      ttList.Add(tc);
    end;
    SetLength(restCols, TitleList.Count);    // остатки текущего товара по колонкам
    SetLength(arFlagDel_0, TitleList.Count); // массив флагов удаления колонок c нулевыми остатками
    for i:= 0 to High(arFlagDel_0) do arFlagDel_0[i]:= True;
    SetLength(arFlagDel_1, TitleList.Count); // массив флагов удаления лишних колонок "есть"
    for i:= 0 to High(arFlagDel_1) do arFlagDel_1[i]:= True;

    //------------------------------------------------------ обрабатываем товары
    for iw:= 0 to High(wrba.arWares) do try
      wareID:= wrba.arWares[iw];
      RestList:= Cache.GetWareRestsByStores(wareID); // наличие по складам

      for i:= 0 to High(restCols) do restCols[i]:= 0; // чистим массив остатков
      rest:= fnGetQtybyIDDef(RestList, StoreMain, 0); // наличие на главном складе
      WareRest:= rest; // наличие текущего товара по всем складам
      restCols[0]:= rest;
      // ----------------------------------- собираем остатки по колонкам
      for j:= 0 to ttList.Count-1 do begin
        tc:= TTwoCodes(ttList[j]); // код склада, индекс колонки
        rest:= fnGetQtybyIDDef(RestList, tc.ID1, 0);
        if not fnNotZero(rest) then Continue; // нет остатка

        restIdx:= tc.ID2;
        restCols[restIdx]:= restCols[restIdx]+rest;
        WareRest:= WareRest+rest;
      end;

      if (iw>0) and not fnNotZero(WareRest) then begin // обнуляем коды аналогов без остатков
        wrba.arWares[iw]:= 0;
        Continue;
      end;

      // ----------------------------------- строковые остатки по колонкам
//      fl:= False; // флаг наличия остатка "есть"
      WareRest:= 0;
      for j:= 0 to High(restCols) do begin
        rest:= restCols[j];
        WareRest:= WareRest+rest;

//        if (WareRest>=WareQty) then //  "есть", т.к. набрали нужное кол-во
//          s:= fnRestValuesForWeb(WareQty, WareRest)
//        else
//          s:= fnRestValuesForWeb(WareQty, rest);
        s:= fnRestValuesForWeb(WareQty, WareRest);
        wrba.arRestLists[iw].Add(s);

        fl:= not fnNotZero(rest); // нет остатка
        arFlagDel_0[j]:= arFlagDel_0[j] and fl; // нет остатков - удалять колонку
        if fl then Continue;
                              // кол-во осн.товара по всем складам
        if (iw=0) then wrba.WareTotal:= wrba.WareTotal+rest;

        if (j=0) then Continue; // 0-ю колонку не проверяем

        arFlagDel_1[j]:= arFlagDel_1[j] and // все повторные "есть" - удалять колонку
          (copy(s, 1, 4)='&gt;') and (copy(wrba.arRestLists[iw][j-1], 1, 4)='&gt;');
      end;
    finally
      prFree(RestList);
    end; // for iw:= 0 to High(wrba.arWares)

    // удаляем колонки без остатков и с повторами "есть", кроме 0-й (главн.склад)
    for j:= High(arFlagDel_0) downto 1 do if arFlagDel_0[j] or arFlagDel_1[j] then begin
      TitleList.Delete(j);
      for i:= 0 to High(wrba.arRestLists) do
        if (wrba.arRestLists[i].Count>j) then wrba.arRestLists[i].Delete(j);
    end;

    //------------------------------ формируем массив складов для передачи в CGI
    SetLength(wrba.Storages, TitleList.Count);
    for j:= 0 to TitleList.Count-1 do begin
      fl:= (j=0);
      if fl then begin
        i:= StoreMain;
        s:= dprt.Name;
      end else begin
        i:= cAggregativeStorage+j-1;
        s:= '';
      end;
      wrba.Storages[j].Code     := IntToStr(i);
      wrba.Storages[j].FullName := s;
      wrba.Storages[j].ShortName:= TitleList[j];
      wrba.Storages[j].IsVisible:= True;
      wrba.Storages[j].IsReserve:= fl;
      wrba.Storages[j].IsSale   := fl;
    end; // for j:= 0 to TitleList.Count-1

  except
    on E: Exception do Result:= E.Message;
  end;
  prFree(TitleList);
  prFree(ttList);
  SetLength(restCols, 0);
  SetLength(arFlagDel_0, 0);
  SetLength(arFlagDel_1, 0);
end;
//======================================== семафор остатков товара для контракта
function GetContWareRestsSem(wareID: Integer; ffp: TForFirmParams; var sArrive: String): Integer;
const nmProc = 'GetContWareRestsSem';
var j: Integer;
    OList: TObjectList;
begin
  Result:= 0;
  sArrive:= '';
  try
    OList:= Cache.GetWareRestsByStores(WareID);  // расчет семафора
    try
      for j:= 0 to OList.Count-1 do with TCodeAndQty(OList[j]) do begin
        if (Qty<constDeltaZero) then Continue;  // нет остатка
        if (ID=ffp.StoreMain) then begin
          Result:= 2; // наличие на сегодня (главный склад)
          break;
        end;
        if (fnInIntArray(ID, ffp.StoreCodes)<0) then Continue; // нет в списке складов
        Result:= 1; // наличие на потом
      end; // for j:= 0 to OList.Count-1

if flSpecRestSem then
      //------------- проверяем возможность поставки на сегодня (спец.семафор=3)
      if ffp.ForClient and (Result=1) then begin
        sArrive:= CheckDprtTodayFill(ffp.StoreMain, OList); // подсказка для спец.семафора
        if (sArrive<>'') then Result:= 3;
{if flDebug and (sArrive<>'') then
  prMessageLOGS('ware= '+fnMakeAddCharStr(IntToStr(wareID), 5)+' dprt= '+
    fnMakeAddCharStr(IntToStr(ffp.StoreMain), 5)+' title= '+sArrive, fLogDebug, false);  }
      end; // if ffp.ForClient and (Result=1)

    finally
      prFree(OList);
    end;

    if not ffp.ForClient and (Result=1) then Result:= 2; // для Webarm
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
end;
//==============================================================================
function GetYearFromLoadModels: String;
var tdfrom: Integer;
begin
  Result:= '';
  tdFrom:= Cache.GetConstItem(pcTDTmodelsYearFrom).IntValue;
  if (tdFrom<1) then Exit;
  Result:= IntToStr(tdFrom);
  if (tdFrom<1900) or (tdFrom>3000) then // легкая проверка
    raise Exception.Create(MessText(mtkNotValidParam)+' года - '+Result);
end;


//******************************************************************************
//                           TForFirmParams
//******************************************************************************
constructor TForFirmParams.Create(pFirmID, pUserID: Integer; pForFirmID: Integer=0;
                                  pCurrID: Integer=0; pContID: Integer=0);
var s: String;
begin
  FirmId:= pFirmID;
  UserID:= pUserID;
  ForFirmID:= pForFirmID;
  currID:= pcurrID;
  contID:= pcontID;
  ForClient:= (FirmId<>IsWe);
  if not Cache.CurrExists(currID) then // определяем валюту, если она не задана
    if not ForClient then currID:= 0
    else if CheckNotValidUser(UserID, FirmID, s) then currID:= 0
    else currID:= Cache.arClientInfo[UserID].SEARCHCURRENCYID; // берем валюту из настроек пользователя
  if ForClient and (ForFirmID<1) then ForFirmID:= FirmID; // к/а для скидок
  if (currID>0) then rate:= Cache.Currencies.GetCurrRate(currID) else rate:= 0;    // ???
  arSys:= SysTypes.GetDirCodes;   // коды систем учета
  SetLength(StoreCodes, 0);
  StoreMain:= 0;
  HideZeroRests:= ForClient and not Cache.arFirmInfo[FirmID].ShowZeroRests;
end;
//==============================================================================
destructor TForFirmParams.Destroy;
begin
  SetLength(arSys, 0); // чистим массив
  SetLength(StoreCodes, 0);
  inherited;
end;
//==============================================================================
procedure TForFirmParams.FillStores;
begin
  if not Assigned(self) then Exit;
  if (StoreMain>0) then Exit;
  StoreMain:= fnGetContMainStoreAndStoreCodes(ForFirmID, ContID, StoreCodes);
end;
//==============================================================================
function TForFirmParams.NeedSemafores: Boolean;
begin
  Result:= Assigned(self) and (ForClient or (ForFirmID>0));
end;

//******************************************************************************
//                          TFirmPhoneParams
//******************************************************************************
constructor TFirmPhoneParams.Create(pNames: String; pSMScount: Integer);
begin
  Names:= pNames;
  SetLength(arSMSind, pSMScount);
end;
//==============================================================================
destructor TFirmPhoneParams.Destroy;
begin
  SetLength(arSMSind, 0);
  inherited;
end;


{
procedure TestFile;
var Stream: TBoBMemoryStream;
    ThreadData: TThreadData;
    s: string;
begin
  prMessageLOGS('----------- Check File', fLogDebug, false);

  ThreadData:= fnCreateThread(thtpTestN);
  Stream:= TBoBMemoryStream.Create;

  Stream.WriteInt(3854562);
  Stream.WriteInt(32751);
  Stream.WriteInt(291634);

  prGetBankAccountFile(Stream, ThreadData);

  s:= IntToStr(Stream.ReadInt);
  prMessageLOGS('result - '+s, fLogDebug, false);

  prFree(Stream);
  prDestroyThreadData(ThreadData, 'Test');
end;
}

//******************************************************************************
//                              TWareRestsByArrive
//******************************************************************************
constructor TWareRestsByArrive.Create;
begin
  inherited;
  SetLength(arWares, 0);      // 0- код товара, 1... - коды аналогов
  SetLength(Storages, 0);     // набор колонок (складов)
//  SetLength(WareTotals, 0);   //
  SetLength(arRestLists, 0);
  WareTotal:= 0;
end;
//==============================================================================
destructor TWareRestsByArrive.Destroy;
var i: Integer;
begin
  SetLength(arWares, 0);      // 0- код товара, 1... - коды аналогов
  SetLength(Storages, 0);     // набор колонок (складов)
//  SetLength(WareTotals, 0);   //
  for i:= 0 to High(arRestLists) do prFree(arRestLists[i]);
  SetLength(arRestLists, 0);
  inherited;
end;

//******************************************************************************
initialization
begin
  SaveToLog:= [];
  CheckDocsList:= TStringList.Create;
  dLastCheckDocTime:= DateNull;
  dLastCheckCliEmails:= DateNull;
  VSMail:= TVSMail.Create;
  brcWebDelim         := fnCodeBracketsForWeb(cWebDelim);
  brcWebBoldBlackBegin:= fnCodeBracketsForWeb(cWebBoldBlackBegin);
  brcWebBoldEnd       := fnCodeBracketsForWeb(cWebBoldEnd);
  brcWebColorRedBegin := fnCodeBracketsForWeb(cWebColorRedBegin);
  brcWebColorBlueBegin:= fnCodeBracketsForWeb(cWebColorBlueBegin);
  brcWebColorEnd      := fnCodeBracketsForWeb(cWebColorEnd);
//  brcWebItalBegin     := fnCodeBracketsForWeb(cWebItalBegin);
//  brcWebItalEnd       := fnCodeBracketsForWeb(cWebItalEnd);
  flDebug:= False;
  flTest:= False;
  flTestDocs:= False;
  SleepFillLinksInt:= 10;
end;
finalization
begin
  prFree(VSMail);
  prFree(CheckDocsList);
  SaveToLog:= [];
end;
//******************************************************************************

end.

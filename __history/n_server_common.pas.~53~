unit n_server_common; // общие функции

interface
uses Windows, Classes, SysUtils, IniFiles, System.DateUtils, Math, DB, Forms, Contnrs,
     IBDatabase, IBSQL, IdSMTP, IdMessage, IdAttachmentFile, IdCharsets, IdText,
     Controls, IdGlobal, IdContext, IdTCPServer, ShellAPI, Types,
     n_free_functions, v_constants, v_DataTrans, v_Functions,
     n_constants, n_functions, n_DataSetsManager, n_LogThreads, n_DataCacheAddition;

type
//------------------------------------------------------------ vc
  TMyClass = class
    procedure ServerExecute(AContext: TIdContext);
    procedure ServerWEBConnect(AContext: TIdContext);
    procedure ServerWEBArmConnect(AContext: TIdContext);
    procedure ServerManageConnect(AContext: TIdContext);
  public
  end;
//------------------------------------------------------------ vc

  TVSMail = class // Vladislav Software Mail
  public
    Xstring: String;
    constructor Create;
    procedure CheckXstring(section: String=''; value: String='');
    procedure OnInitISO(var VHeaderEncoding: Char; var VCharSet: String);
  end;

  TWareAndAnalogs = class // код товара и массив его аналогов
  public
    WareID, RestSem: Integer;
    arAnalogs, arSatells: Tai;
//    AutoModelsExists, MotoModelsExists, RestsExists: Boolean;
//    OLAnalogs, OLSatells: TObjectList; // (TTwoCodes - ID, sem)
    constructor Create(pWareID: Integer; parAnalogs, parSatells: Tai);
    destructor Destroy; override;
  end;

  TSearchWareOrOnum = class // рез-т поиска: код товара/ОН, аналоги, сопут.товары
  public
    ID, RestSem, SatCount: Integer; // код товара/ОН, семафор наличия, кол-во сопут.товаров
    IsWare: Boolean;      // признак товара
//    AutoModelsExists, MotoModelsExists, RestsExists: Boolean;
    OLAnalogs: TObjectList; // (TTwoCodes - ID, sem) аналоги, сопут.товары
    constructor Create(pID, pSatCount: Integer; pIsWare, pIsMarket: Boolean; parAnalogs: Tai=nil);
    destructor Destroy; override;
  end;

  TForFirmParams = class
  public
    FirmID, UserID, ForFirmID, currID, contID: integer;
    rate: double;
    arSys: Tai; // коды систем учета
    ForClient: Boolean;
    constructor Create(pFirmID, pUserID, pForFirmID, pCurrID, pContID: Integer);
    destructor Destroy; override;
  end;

  TFirmPhoneParams = class
  public
    Names: String;
    arSMSind: Tai; //
    constructor Create(pNames: String; pSMScount: Integer);
    destructor Destroy; override;
  end;


var
  VSMail: TVSMail;
  nmIniFileBOB: string;
  RepeatSaveInterval: Integer; // интервал задержки попыток записи в мсек
  accRepeatCount    : Integer; // кол-во попыток посадки счета
  SleepFillLinksInt : Integer; // интервал задержки заполнения связок
  FormingOrdersLimit: Integer; // лимит вывода в списке незакрытых заказов
  SaveToLog: set of Byte;      // набор видов записи в LOG
  flCSSnew, flDebug, flTest, flTestDocs, flClientStoragesView_2col, flMargins,
    flTmpRecodeCSS, flTmpRecodeORD, flNewSearchLine, flWareAction, flResLimit,
    flClientStoragesView_add, flContManagerBKEonly, flNewModeCGI: boolean;
  CheckDocsList: TStringList;
  dLastCheckDocTime, dLastCheckCliEmails: TDateTime;
  brcWebDelim, brcWebBoldBlackBegin, brcWebBoldEnd,
    brcWebColorRedBegin, brcWebColorBlueBegin, brcWebColorEnd: string;
//  brcWebItalBegin, brcWebItalEnd: string;
//------------------------------------------------------------ vc
  AppStatus: integer; //Статус приложения
  StopList: Tas;
  ManageCommandsLock: boolean = false;
  GBWork: boolean; // признаки работоспособности GB
  thCheckStoppedOrders: TThread;
  thCheckDBConnectThread: TThread;
  thManageThread: TThread;
  thCheckSMSThread: TThread;      //vv
  ServerWeb, ServerWebArm, ServerManage: TIDTCPServer;
  MyClass: TMyClass;
  ImageList: TImageList;
  DescrDir: string; // папка, родительская для рисунков и описаний
  DirFileErr: String; // папка д/сбойных и врем. файлов

  function fnGetNumOrder(Prefix, NumOrd: String; Source: Integer=5): String; // формируем номер заказа для сервера
  function fnCheckOrderWebLogin(S: string): boolean;
  function fnCheckOrderWebPassword(S: string): boolean;
  function fnGenWebPass: string;  // Генерирует пароль
  function fnGetThreadsCount(Server: TIdTCPServer): integer;
  procedure SetAppCaption;                 // заголовок формы
  function GetAppImageList: TImageList;    // иконка
  procedure SetAppStatus(Status: integer); // устанавливает атрибутику статусов приложения
//  function fnCheckKindOfStorage(StorageId, FirmId, Kind: integer) : boolean; // проверяет свойство заданного склада
// Функция для пользовательской сортировки товаров в StringList с учетом бренда
function fnWareCompareByBrand(List: TStringList; Index1, Index2: Integer): Integer;
// Функция получения товаров по заданному бренду
function fnGetWareListByBrand(Brand: integer; Sys: byte = 255; Sort: boolean = false): TStringList;
// выдает значение системной настройки, адаптированное под вывод пользователю
function fnGetAdaptedConstValue(ConstID: integer): string;
// проверяет, просрочено ли время доставки
function CheckShipmentDateTime(Data: TDate; TimeCode: integer): boolean;

//======== используется для сортировки списка типов товаров в результатах поиска
function TypeNamesSortCompare(List: TStringList; Index1, Index2: Integer): Integer;

// используется для сортировки объектов типа TTwoCodes в TObjectList при выводе списка типов товаров в результатах поиска
//function CompareTypeNamesForTwoCodes(Item1, Item2: Pointer): Integer;
// используется для сортировки объектов типа TTwoCodes в TObjectList при выводе списка производителей авто/мото
function SortCompareManufNamesForTwoCodes(Item1, Item2: Pointer): Integer;
// используется для сортировки StringList в TObjectList при выводе порций условий применимости
function SortCompareConditionPortions(Item1, Item2: Pointer): Integer;
//------------------------------------------------------------ vc
//----------------------------------------- v_CSSServerManageProcs
procedure prGetFullStatus(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prExecuteServerCommand(Stream: TBoBMemoryStream; ThreadData: TThreadData; ACommand: integer; AIP: string);
procedure prUpdateCacheSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
procedure prGetActionsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
//----------------------------------------- v_CSSServerManageProcs

//                    функции по работе с заказами и т.п.
 function fnGetClosingDocsOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
          var Status: integer; id: Integer=-1): string; // Уточняет статус заказа и возвращает данные по закрывающим документам (Grossbee/Order)
 function fnGetClosingDocsFromOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
          var Status: integer; id: Integer=-1): string; // Уточняет статус заказа и возвращает данные по закрывающим документам из Order
procedure prOrderToGBn_Ord(Stream: TBoBMemoryStream; ThreadData: TThreadData; CreateMail: boolean=false); // сформировать счета в Grossbee
//procedure prOrderToGBn_2col(Stream: TBoBMemoryStream; ThreadData: TThreadData; CreateMail: boolean=false); // сформировать счет в Grossbee (главный склад)
 function prSendMessAboutCreateAccount(ORDRCODE, DCACCODE, ORDRSOURCE, FirmID, // отправить письмо о формировании счета в Grossbee
          contID, storID, crnc, IDq: Integer; SumDoc, SumLines: Double;
          DCACNUMBER, ORDRNUM, sDate, ErrStr: string; accLines: TStringList): string;
 function GetRateCurr(crnc: Integer=cDefCurrency; crncTo: Integer=1): Double; // получить текущий курс валюты (def - EUR->UAH)
 function fnNotLockingLogin(Login: String): Boolean;                          // проверяем, не относится ли логин к запрещенным

procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;               // запись в Stream инфо о товаре
          WareID, FirmID, UserID: integer; AnalogsCount: integer=0;
          currID: Integer=0; ForFirmID: integer=0; SatellsCount: integer=0;
          contID: integer=0; RestSem: integer=-1; ModelsEx: Boolean=True); overload;
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;              // запись в Stream инфо о товаре
          ffp: TForFirmParams; WareID: integer; AnalogsCount: integer=0;
          SatellsCount: integer=0; RestSem: integer=-1; ModelsEx: Boolean=True); overload;
procedure prSaveWaresModelsExists(Stream: TBoBMemoryStream; FirmSys: Integer; wCodes: Tai); overload; // запись в Stream блока инфы о наличии привязанных моделей по всем системам
procedure prSaveWaresModelsExists(Stream: TBoBMemoryStream; OLmarkets: TObjectList); overload; // запись в Stream блока инфы о наличии привязанных моделей по всем системам
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; ForFirmID, ContID: Integer; wCodes: Tai); overload; // запись в Stream блока семафоров наличия товаров (Web & WebArm)
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; OLmarkets: TObjectList); overload; // запись в Stream блока семафоров наличия товаров (Web & WebArm)
procedure prCheckWareRestsExists(FirmID, ContID: Integer; var OLmarkets: TObjectList; var RestCount: Integer); overload;
procedure prCheckWareRestsExists(ffp: TForFirmParams; var OLmarkets: TObjectList; var RestCount: Integer); overload;

procedure prSaveEmplFirmsChoiceList(Stream: TBoBMemoryStream; EmplID: Integer);             // запись в Stream списка видимых сотруднику к/а для выбора (WebArm)
procedure prSaveEmplStoresChoiceList(Stream: TBoBMemoryStream; EmplID: Integer; flWithRoad: Boolean=False); // запись в Stream списка видимых сотруднику складов(+путей) для выбора (WebArm)

procedure CheckDocSum;                                                        // проверка сумм док-тов
procedure CheckClientsEmails;                                                 // проверка адресов

// function fnGetStoragesArray(pUserID, pFirmID: integer; ReservedOnly: boolean=false; contID: integer=0): TasD;  // склады клиента
procedure prHideTreeNodes(var ListNodes, listParCodes: TList; flOnlySameName, flOnlyOneLevel: boolean); // свернуть ноды дерева узлов с 1 ребенком, в TreeList[i] - Pointer(TSecondLink)
 function fnRepClientRequests(UserID: integer; StartTime, EndTime: TDateTime; var FName: string): string; // формирование отчета по запросам клиента за период
 function SaveClientBlockType(BlockType, UserID: Integer;                     // блокировка/разблокировка клиента в базе
          var BlockTime: TDateTime; EmplID: Integer=0): Boolean;
// function SetSemMarkForClients(pSysID: Integer; SemMark: String='T'): String; // простановка признака WareSemafor всем клиентам системы

 function GetModelNodeWareUsesAndTextsPartsView(ModelID, NodeID, WareID: Integer): TObjectList; // must Free, список порций текстов и условий к связке 3 для просмотра
 function SetUsageTextPartWrongMark(pModelID, pNodeID, pWareID, pPart, // установить/убрать признак WRONG порции условий и текстов
          pUserID: Integer; flWrong: Boolean): String;
//function CheckTextFirstUpAndSpaces(txt: String): String; // проверка заглавной буквы и пробелов текста

//                       функции сообщений
 function fnGetManagerMail(code: Integer; Mailelse: String): String; // Email филиала
 function fnGetSysAdresVlad(kind: integer=caeOnlyDay): string;       // адреса для сист.сообщений
 function GetMessageFromSelf: String;                                // строка "сообщение от" CSS-сервера
 function n_SysMailSend(ToAdres, Subj: String; Body: TStrings=nil; Attachments: TStrings=nil;
          From: string =''; nmIniFile: string =''; flSaveToFile: boolean=False): string; // отправить системное сообщение
procedure TestOldErrMailFiles;                                                           // проверка незабранных файлов отчетов
 function MessText(kind: TMessTextKind; str: string=''): String;                         // текст сообщения пользователю
// function FindAdressSysSaleDirector(SysID: Integer; var eml: string): Boolean;           // адрес директора по системе
 function CutEMess(Emess: String): String;  overload;                                    // обрезка сообщений от exception ORD
 function CutEMess(Emess: String; var ResCode: Integer): String;  overload;              // обрезка сообщений от exception ORD + resDoNothing
 function CutLockMess(mess: String): String;                                             // обрезка сообщений deadlock и т.п.
 function CutPRSmess(mess: String): String;                                              // обрезать сообщение PRS.
 function fnFormRepFileName(pSubName, pNameOrExt: string; pOpKind: integer): string;     // формируем имя файла отчета
 function fnSendErrorMes(FirmID, UserID, MesType, WareId, AnalogId, OrNumId, ModelId, NodeId: Integer;
          SenderMess, AttrMess: String; ThreadData: TThreadData): String;      // отправляет сообщение пользователя об ошибке, Exception передает наружу, возвращает сообщение для пользователя
// function fnSendClientMes(FirmID, UserID, Source: Integer; SenderMess: String; // отправляет сообщение пользователя менеджеру
//          ThreadData: TThreadData; var Response: String; ContID: Integer=0): Boolean;
 function prSendMailWithClientPassw(Kind: TKindCliMail; Login, Password, Mail: String; // отправить письмо с паролем клиенту
                                    ThreadData: TThreadData; FirmName: String=''): string;
//              функции отправки сообщений из файлов
 function fnSaveMailStringsToFile(ToAdres, Subj, From: String;
          Body, Attachments: TStrings; var FileName: String): Boolean; // запись набора строк письма в файл
 function fnGetMailFilesPath: String;                                  // путь к файлам писем
 function fnGetErrMailFilesDir: String;                                // папка с неотправленными файлами
 function fnGetLockFileName(FileName: String): String;                 // имя файла блокировки

//              функции проверок
 function CheckNotValidUser(pUserID, pFirmID: Integer; var errmess: string): boolean;     // Проверить валидность пользователя
// function CheckNotValidFirmSys(FirmID, SysID: Integer; var errmess: string): boolean;     // Проверить систему фирмы
 function CheckNotValidModelManage(UserID, SysID: Integer; var errmess: string): boolean; // Проверить права сотрудника на работу с моделями системы
 function CheckNotValidTNAManage(UserID, SysID: Integer; var errmess: string): boolean;   // Проверить права сотрудника на работу с деревом узлов системы
 function CheckNotValidManuf(ManufID: Integer; SysID: Integer;             // Получить производителя и проверить доступность
          var Manuf: TManufacturer; var errmess: string): boolean;
 function CheckNotValidModelLine(ModelLineID: Integer; var SysID: Integer; // Получить модельный ряд, систему и проверить доступность
          var ModelLine: TModelLine; var errmess: string): boolean;
 function CheckNotValidModel(ModelID: Integer; var SysID: Integer;          // Получить модель, систему и проверить доступность
          var Model: TModelAuto; var errmess: string): boolean;
 procedure TestCssStopException;         // проверка для остановки длит.процесса при остановке системы
  function SetLongProcessFlag(cdlpKind: Integer; NotCheck: Boolean=False): Boolean; // установить флаг длительного процесса (тестирования кеша и т.п)
  function SetNotLongProcessFlag(cdlpKind: Integer): Boolean; // снять флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
procedure prCheckUserForFirmAndGetSysCurr(UserID, FirmID: Integer; // проверить UserID, FirmID, ForFirmID и получить систему, валюту
          var ForFirmID, Sys, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);

//              функции для спец.процессов
procedure CheckGAMainNodesLinks(LogFile: String='');                            // сверка TD->GA и TreeNodesAuto->MainNode
procedure CheckArticleWareMarks(LogFile: String=''; maxStrLen: Integer = 3000); // проверить наличие товаров у артикулов в TDT
procedure TestLastFirms(DecHour: Integer=1);                                    // проверка фирм, активных последние DecHour часов
procedure TestLogFirmNames;                                                     // проверка наименований фирм в базе логирования
procedure CheckClosingDocsAll(CompareTime: boolean=True);                       // пакетная проверка закрывающие док-тов заказов
procedure CheckClosingDocsByPeriod(tbegin, tend: TDateTime;                     // проверка закрывающие док-тов заказов за период изменений
          flSaveTime: boolean=True; flalter: boolean=True);
procedure CheckWorkLogins(userID: Integer; Login: String);                      // проверка логина в списке поиска логинов
procedure CheckClonedOrBlockedClients(LogFile: String='');                      // проверка клонов/блоков клиентов
//procedure FillOrdersClosingDocs(FirstRecs: Integer=0); // заполнить таблицу закр.док-тов и проставить коды заказов закр.док-там

//             разные функции
 function ToLog(vid: Integer): Boolean; // признак записи в LOG в зав-ти от вида
procedure GetLogKinds;                  // виды логирования
 function RepeatExecuteIBSQL(IBS: TIBSQL): string;  overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var StrValue: string): string;  overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var IntValue: Integer): string;  overload;
 function RepeatExecuteIBSQL(IBS: TIBSQL; var FnamesValues: Tas): string;  overload;
 function GetEmplTmpFilePath(EmplID: Integer; var pFilePath, errmess: string): boolean;  // путь к рабочим файлам сотрудника
 function GetBoolGB(ibsql: TIBSQL; Fname: string): boolean;                              // Перевести значение поля Fname ibsql в boolean
 function GetLstPrefixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // Формирование списка префиксов для доавления к артикулу при поиске
 function GetLstSufixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList;  // Формирование списка префиксов для доавления к артикулу при поиске, not Object
 function ObjWareNameSortCompare(List: TStringList; Index1, Index2: Integer): Integer; // сортировка TStringList по наименованию товара, если ID в Objects
 function fnGetActionTimeEnable(kind: integer=caeOnlyDay): Boolean;           // допустимое время для операций
procedure prSaveCommonError(Stream: TBoBMemoryStream; ThreadData: TThreadData; // запись в Stream сообщения об ошибке
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
procedure prSaveCommonErrorStr(var errStr:String; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);  //запись в строку сообщения об ошибке
function CheckFirmFilterConditions(FirmID: Integer; // проверка соответствия к/а условиям фильтрации (Web & WebArm)
         flFirmsAdd, flAuto, flMoto: Boolean; Filials, Classes, Types, Firms: TIntegerList): Boolean;
 function RenameErrFile(nf, dirold, dirnew: string; flPutOff: Boolean=False): string; // перемещаем файл nf из dirold в dirnew
procedure CheckStopExecute(pUserID: Integer; ThreadData: TThreadData); // проверка остановки процесса или системы
procedure SetExecutePercent(pUserID: Integer; ThreadData: TThreadData; Percent: Double); // отображение процентов выполнения

//             функции поиска
 function SearchWareNames(Template: string; IgnoreSpec: Integer=0; // must Free, поиск товаров по наименованию (описанию) в кэше
          ManagID: Integer=-1; ByComments: boolean=False): Tai;
 function fnGetAllAnalogs(WareID: integer; ManufID: integer=-1; sysID: integer=0): Tai; // must Free, возвращает массив кодов всех аналогов товара WareID
{ function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai;     // must Free, поиск товаров (с типами и аналогами) по наименованию в кэше
          IgnoreSpec: Integer=0; ManagID: Integer=-1;
          ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
          flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList; }
 function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer=0; // must Free, поиск товаров (с типами и аналогами) по наименованию в кэше
          ManagID: Integer=-1; ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
          flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList;

//              функции для доставок
 function GetAvailableSelfGetTimesList(DprtID: Integer; pDate: TDateTime;                     // список доступных времен самовывоза по складу, дате
          var stID: Integer; var SL: TStringList; flWithSVKDelay: Boolean=False): String;
 function GetAvailableShipDatesList(DprtID, iDate: Integer;                                   // список доступных дат отгрузки по складу
         var SL: TStringList; flWithSVKDelay: Boolean=False): String;
 function CheckAccountShipParams(delivType, ContID, DprtID: Integer; var pShipDate: TDateTime; // проверка параметров отгрузки для счета
          var DestID, ttID, smID, stID: Integer; flWithSVKDelay: Boolean=False): String;
 function fnGetShipParamsView(contID, DprtID, DestID, ShipTableID: Integer; ShipDate: double; // параметры отгрузки для просмотра
          var DelivType, ShipMetID, ShipTimeID: Integer; var sDestName, sDestAdr, sArrive: String;
          var sShipMet, sShipTime, sView: String; GBdirection: Boolean=False): String;
 function SetMainUserToGB(FirmID, UserID: Integer; pDate: TDateTime; ibsGBw: TIBSQL=nil): String; // запись глав.пользователя в Grossbee

procedure TmpRecodeCSS;   // фоновая перкодировка в базе логирования
procedure TmpCheckRecode; // регулярная проверка в базе логирования
procedure TmpRecodeORD;   // фоновая перекодировка в базе ORD
function CheckMobileNumber(num: String): Boolean; // проверка мобильного номера телефона

implementation
uses n_IBCntsPool, n_DataCacheObjects, n_DataCacheInMemory, // n_vlad_init,
     t_ImportChecking, t_WebArmProcedures, n_WebArmProcedures,
     n_server_main, n_CSSservice, n_OnlinePocedures, n_CSSThreads,
     s_OnlineProcedures, s_WebArmProcedures;

//----------------------------------------- vc
//============================================================
function fnGetThreadsCount(Server: TIdTCPServer): integer;
var aList: TList;
begin
  aList:= Server.Contexts.LockList;
  try
    Result:= aList.Count;
  except
    Result:= 0;
  end;
  Server.Contexts.UnlockList;
end;
//=========================================== формируем номер заказа для сервера
function fnGetNumOrder(Prefix, NumOrd: String; Source: Integer=5): String;
// FirmCod - код фирмы, NumOrd - № заказа клиента, Source - источник (по умолчанию: 5-Vlad)
var s: String;
begin
  if pos('_',NumOrd)>0 then begin
    Result:= NumOrd;
    Exit;
  end;
  case Source of
    5: s:= '_V_'; // разделитель для Автомат.заказа через программу "vlad"
    6: s:= '_W_'; // разделитель для Автомат.заказа через Интернет
  else s:= '_';   // разделитель для других источников
  end; // case
  Result:= Prefix+s+NumOrd; // номер заказа: FirmShortName(FirmCod)_V(Source)_NumOrd
end;
//================= проверяет валидность логина Web-пользователя системы заказов
function fnCheckOrderWebLogin(S: string): boolean;
var i, j: integer;
    c:  Char;
begin
  Result:= false;
  j:= Length(s);
  if (j<5) or (j>Cache.CliLoginLength) then exit;
  for i:= 1 to j do begin
    c:= s[i];
    if not (SysUtils.CharInSet(c, ['a'..'z', 'A'..'Z', '0'..'9', '_'])) then exit;
  end;
  Result:= true;
end;
//================= проверяет валидность пароля Web-пользователя системы заказов
function fnCheckOrderWebPassword(S: string): boolean;
var i, j: integer;
    c:  Char;
begin
  Result:= false;
  j:= Length(s);
  if (j<5) or (j>Cache.CliPasswLength) then exit;
  for i:= 1 to j do begin
    c:= s[i];
    if not (SysUtils.CharInSet(c, ['a'..'z', 'A'..'Z', '0'..'9', '_'])) then exit;
  end;
  Result:= true;
end;
//============================================================ Генерирует пароль
function fnGenWebPass: string;
var len: integer;
    c: char;
begin
  Result:= '';
  Randomize;
  len:= 5+Random(4);
  while Length(Result)<(len+1) do begin
    c:= char(48+Random(123-48));
    if (SysUtils.CharInSet(c, ['a'..'z', '0'..'9'])) then Result:= Result+c;
  end;
end;
//========================================================= определяем ImageList
function GetAppImageList: TImageList;
var i: integer;
    nImageList: string;
begin
  Result:= Form1.ilDefault;                 // читаем имя ImageList из ini-файла
  nImageList:= GetIniParam(nmIniFileBOB,'service','ImageList','');
  if nImageList='' then Exit;
  for i:= 0 to Form1.ComponentCount-1 do
    if (Form1.Components[i] is TImageList) and
      (Form1.Components[i].Name=nImageList) then begin
      Result:= (Form1.Components[i] as TImageList);
      Exit;
    end;
end;
//============================================================== заголовок формы
procedure SetAppCaption;
begin
  Form1.lbAliases.Caption:= 'CSS-server,  GrossBee: '+cntsGRB.dbPath;
end;
//================================= устанавливает атрибутику статусов приложения
procedure SetAppStatus(Status: integer);
begin
  AppStatus:= Status;
  Form1.Caption:= Application.Title+': '+
    fnIfStr(IsServiceCSS, 'Служба ', 'Приложение ')+arCSSServerStatusNames[Status];
  if not IsServiceCSS and (Form1.Caption[length(Form1.Caption)]='а') then
    Form1.Caption:= Copy(Form1.Caption, 1, length(Form1.Caption)-1)+'о';
  ImageList.GetIcon(AppStatus,Application.Icon); // меняем Application.Icon
  Form1.btSuspend.Enabled:= (AppStatus=stWork);
  Form1.btResume.Enabled:= (AppStatus=stSuspended);
  Form1.bbFillarWares.Enabled:= (AppStatus=stWork);
  if not IsServiceCSS and fIconExist then begin
    SetTrayIconData;
    Shell_NotifyIcon(NIM_MODIFY, @TrayIconData);
    Application.ProcessMessages;
  end;
end;
{//========================================== проверяет свойство заданного склада
function fnCheckKindOfStorage(StorageId, FirmId, Kind: integer) : boolean;
var i: integer;
begin
  Result:=false;
  i:=Cache.GetStorageIndex(StorageId, FirmId);
  if i>-1 then case Kind of
    constStorDefault:   Result:=Cache.arFirmInfo[FirmID].Storages[i].IsDefault;
    constStorVisible:   Result:=Cache.arFirmInfo[FirmID].Storages[i].IsVisible;
    constStorReserve:   Result:=Cache.arFirmInfo[FirmID].Storages[i].IsReserve;
    constStorSale   :   Result:=Cache.arFirmInfo[FirmID].Storages[i].IsSale;
  end;
end; }
//==========================================================  TMyClass
procedure TMyClass.ServerExecute(AContext: TIdContext);
begin
;
end;
//==============================================================================
procedure TMyClass.ServerWebConnect(AContext: TIdContext);
var Stream: TBOBMemoryStream;
    i: integer;
    AThread: TIdContext;
    Command: word;
    ThreadData: TThreadData;
    ErrorPos: string;
begin
  ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  try
ErrorPos:= '1';
    i:= AThread.Connection.IOHandler.ReadLongInt;
ErrorPos:= '3';
    if (i=csOnlineOrder) then begin // если это запрос от Web-пользователя системы онлайн-заказов
ErrorPos:= '8';
      AThread.Connection.IOHandler.ReadLongInt;                // принимаем SessionID, который в данном случае не нужен
ErrorPos:= '8-2';
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));  // логирование в ib_css
ErrorPos:= '8-3';
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
ErrorPos:= '8-6';
      Stream:= TBOBMemoryStream.Create;
ErrorPos:= '8-7';
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
ErrorPos:= '8-8';
      try
        if not (GetAllBasesConnected and (AppStatus=stWork))
          then raise EBOBError.Create(GetMessageNotCanWorks);
ErrorPos:= '8-8-1';
        if (fnGetThreadsCount(ServerWeb)>Cache.GetConstItem(pcMaxServerWebConnect).IntValue)
          then raise EBOBError.Create('Сервер перегружен, повторите запрос через несколько секунд');
ErrorPos:= '8-8-2';
        case Command of
          csWebAutentication            : prAutenticateOrd(Stream, ThreadData);
          csGetAllUsersInfo             : prGetAllUsersInfo(Stream, ThreadData);
          csSearchWithOrNums            : prCommonWareSearch(Stream, ThreadData);
          csWebArmGetAnalogs            : prGetWareAnalogs(Stream, ThreadData);
          csCreateNewOrder              : prCreateNewOrderOrd(Stream, ThreadData);
          csGetOrderList                : prGetOrderListOrd(Stream, ThreadData);
          csShowOrder                   : prShowOrderOrd(Stream, ThreadData);
          csShowACOrder                 : prShowACOrderOrd(Stream, ThreadData);
          csDelLineFromOrder            : prDelLineFromOrderOrd(Stream, ThreadData);
          csChangeQtyInOrderLine        : prChangeQtyInOrderLineOrd(Stream, ThreadData);
          csRefreshPrices               : prRefreshPricesOrd(Stream, ThreadData);
          csCreateOrderByMarked         : prCreateOrderByMarkedOrd(Stream, ThreadData);
          csJoinMarkedOrders            : prJoinMarkedOrdersOrd(Stream, ThreadData);
          csGetAccountList              : prGetAccountListOrd(Stream, ThreadData);
          csGetWaresFromAccountList     : prGetWaresFromAccountList(Stream, ThreadData);
          csShowGBAccount               : prShowGBAccountOrd(Stream, ThreadData);
          csShowGBOutInvoice            : prShowGBOutInvoice(Stream, ThreadData);
          csGetUnpayedDocs              : prGetUnpayedDocs(Stream, ThreadData);
          csDeleteOrderByMark           : prDeleteOrderByMarkOrd(Stream, ThreadData);
          csRefreshPricesInFormingOrders: prRefreshPricesInFormingOrdersOrd(Stream, ThreadData);
          csSetReservValue              : prSetReservValueOrd(Stream, ThreadData);
          csSetOrderPayType             : prSetOrderPayTypeOrd(Stream, ThreadData);
          csGetOptions                  : prGetOptionsOrd(Stream, ThreadData);
          csSetOrderDefault             : prSetOrderDefaultOrd(Stream, ThreadData);
          csChangePassword              : prChangePasswordOrd(Stream, ThreadData);    // ???
          csWebSetMainUser              : prWebSetMainUserOrd(Stream, ThreadData);
          csWebResetPassword            : prWebResetPasswordOrd(Stream, ThreadData);
          csWebCreateUser               : prWebCreateUserOrd(Stream, ThreadData);
          csChangePass                  : prChangePasswordOrd(Stream, ThreadData);    // ???
          csGetRegisterTable            : prGetRegisterTableOrd(Stream, ThreadData);
          csCheckLogin                  : prCheckLoginOrd(Stream, ThreadData);
          csSaveRegOrder                : prSaveRegOrderOrd(Stream, ThreadData);
          csGetCheck                    : prGetCheck(Stream, ThreadData);                       // сверка
          csShowGBBack                  : prShowGBBack(Stream, ThreadData);
          csSendMessage2Manager         : prSendMessage2Manager(Stream, ThreadData);
          csAddLinesToOrder             : prAddLinesToOrderOrd(Stream, ThreadData);
          csAddLineFromSearchResToOrder : prAddLineFromSearchResToOrderOrd(Stream, ThreadData);
          csChangeVisibilityOfStorage   : prChangeVisibilityOfStorage(Stream, ThreadData);
          csClientsStoreMove            : prClientsStoreMove(Stream, ThreadData);
          csGetManufacturerList         : prGetManufacturerList(Stream, ThreadData);

          csOrdGetListAttrGroupNames    : prGetListAttrGroupNames(Stream, ThreadData);
          csOrdGetListGroupAttrs        : prGetListGroupAttrs(Stream, ThreadData);
          csSearchWaresByAttrValues     : prCommonSearchWaresByAttr(Stream, ThreadData);
          csGetCompareWaresInfo         : prGetCompareWaresInfo(Stream, ThreadData);
          csOrdGetWareInfo              : prGetWareInfoView(Stream, ThreadData);
          csGetFilteredGBGroupAttValues : prGetFilteredGBGroupAttValues(Stream, ThreadData); // Фильтрованные списки значений атрибутов Grossbee по группе

          csOrdGetModelLineList         : prGetModelLineList(Stream, ThreadData);
          csGetModelLineModels          : prGetModelLineModels(Stream, ThreadData);
          csGetModelTree                : prGetModelTree(Stream, ThreadData);
          csGetNodeWares                : prCommonGetNodeWares(Stream, ThreadData);
          csOrdSendWareDescrErrorMes    : prSendWareDescrErrorMes(Stream, ThreadData);
          csShowModelsWhereUsed         : prShowModelsWhereUsed(Stream, ThreadData);
          csGetRestsOfWares             : prCommonGetRestsOfWares(Stream, ThreadData);
          csGetActions                  : prGetActions(Stream, ThreadData);
          csGetTop10Model               : prGetTop10Model(Stream, ThreadData);
          csClickOnNewsCounting         : prClickOnNewsCounting(Stream, ThreadData);
          csLoadEngines                 : prLoadEngines(Stream, ThreadData);
          csGetEngineTree               : prGetEngineTree(Stream, ThreadData);
          csShowEngineOptions           : prShowEngineOptions(Stream, ThreadData);
          csLoadModelDataText           : prLoadModelDataText(Stream, ThreadData);
          csTestLinksLoading            : prTestLinksLoading(Stream, ThreadData);
          csGetFilterValues             : prGetFilterValues(Stream, ThreadData);
          csBackJobAutentication        : prAutenticateOrd(Stream, ThreadData);
          csSaveOption                  : prSaveOption(Stream, ThreadData);
          csGetSatellites               : prGetWareSatellites(Stream, ThreadData);
          csSendVINOrder                : prSendVINOrder(Stream, ThreadData);
          csGetWaresByOE                : prCommonGetWaresByOE(Stream, ThreadData);
          csHideEmptyOE                 : prHideEmptyOE(Stream, ThreadData);
          csDownloadPrice               : prDownloadPrice(Stream, ThreadData);
          csShowNotification            : prShowNotificationOrd(Stream, ThreadData);
          csConfirmNotification         : prConfirmNotification(Stream, ThreadData);
          csWaresByOE                   : prSearchWaresByOE(Stream, ThreadData);
          csContractList                : prContractList(Stream, ThreadData);
          csChangeContract              : prChangeClientLastContract(Stream, ThreadData);
          csChangeContractAccess        : prChangeContractAccess(Stream, ThreadData);
          csSendOrderForChangePersonData: prSendOrderForChangeData(resEdited, Stream, ThreadData);  // отправить заявку на изменение персональных данных
          csSendOrderForAddContactPerson: prSendOrderForChangeData(resAdded, Stream, ThreadData);   // отправить заявку на добавление контактного лица
          csSendOrderForDelContactPerson: prSendOrderForChangeData(resDeleted, Stream, ThreadData); // отправить заявку на удаление контактного лица
          csSetCliContMargins           : prSetCliContMargins(Stream, ThreadData);
          csRemindPass                  : prRemindPass(Stream, ThreadData);
          csGetContracts                : prGetContracts(Stream, ThreadData);
          csGetBonusWares               : prGetBonusWares(Stream, ThreadData);
          csGetTimeListSelfDelivery     : prGetTimeListSelfDelivery(Stream, ThreadData);    // список доступных времен самовывоза
          csGetContractDestPointsList   : prGetContractDestPointsList(Stream, ThreadData);  // список торговых точек контракта
          csGetAvailableTimeTablesList  : prGetAvailableTimeTablesList(Stream, ThreadData); // список доступных расписаний по контракту
          csGetOrderHeaderParams        : prGetOrderHeaderParams(Stream, ThreadData);       // просмотр параметров заголовка заказа
          csEditOrderHeaderParams       : prEditOrderHeaderParams(Stream, ThreadData);      // редактирование параметров заголовка заказа
          csShowBonusFormingOrder       : prShowBonusFormingOrder(Stream, ThreadData);      // просмотр бонусного неотправленного заказа
          csGetQtyByAnalogsAndStorages  : prGetQtyByAnalogsAndStoragesOrd(Stream, ThreadData);
          csEditOrderSelfComment        : prEditOrderSelfComment(Stream, ThreadData);       // редактирование комментария "для себя"
          csCheckOrderWareRests         : prCheckOrderWareRests(Stream, ThreadData);        // проверка проблем отгрузки товаров по заказу
          csGetDprtAvailableShipDates   : prGetDprtAvailableShipDates(Stream, ThreadData);  // список доступных дат отгрузки по складу
          csGetMainStoreLocation        : prGetMainStoreLocation(Stream, ThreadData);       // адрес и координаты главного склада
          csGetCheckBonus               : prGetCheckBonus(Stream, ThreadData);              // unit-движение
          csShowGBManual                : prShowGBManual(Stream, ThreadData);               // просмотр корректировок
          csGeneralNewSystemProcOrder   : prGeneralNewSystemProcOrder(Stream, ThreadData);  // общая процедура по новой схеме работы Ордер
          csGetOutInvoiceXml            : prGetOutInvoiceXml(Stream, ThreadData);           // получить накладную в виде xml-файла
          csGetFormingOrdersList        : prGetFormingOrdersList(Stream, ThreadData);       // Получить список неотправленных заказов
          csGetWareActions              : prGetWareActions(Stream, ThreadData);             // Получить список акций для "Информации"

          else raise EBOBError.Create('Не опознана Web-команда - '+IntToStr(Command));
        end; // case Command of
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          if (Command<>csTestLinksLoading) and (AppStatus=stWork) then
            fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebConnect', 'Command='+IntToStr(Command), E.Message, 'ErrorPos='+ErrorPos);
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
ErrorPos:= '8-9';
      If Stream.Size>0 then begin
        i:= Stream.Size;
ErrorPos:= '8-10: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(i);              //
ErrorPos:= '8-11: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
ErrorPos:= '8-12';
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);

    end else begin // если неизвестная сигнатура
ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end;
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebConnect', 'Ошибка общего плана ', E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerWebConnect', 'Аварийно завершен поток ', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerWebConnect');
  if (AThread<>nil) and AThread.Connection.Connected then AThread.Connection.Disconnect;
  prFree(Stream);
end; //ServerWebConnect
//==============================================================================
procedure TMyClass.ServerWebArmConnect(AContext: TIdContext);
var Stream : TBOBMemoryStream;
    i : integer;
    AThread: TIdContext;
    Command: word;
    ThreadData: TThreadData;
    ErrorPos: string;
begin
  ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  try
ErrorPos:= '1';
ErrorPos:= '2';
    i:= AThread.Connection.IOHandler.ReadLongInt;
ErrorPos:= '3';
    if i=csWebArm then begin // если это запрос от WebArm-пользователя
ErrorPos:= '8';
      AThread.Connection.IOHandler.ReadLongInt;                // принимаем SessionID, который в данном случае не нужен
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
      Stream:= TBOBMemoryStream.Create;
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
      try
        if not (GetAllBasesConnected and (AppStatus=stWork))
          then raise EBOBError.Create(GetMessageNotCanWorks);
        case Command of
          csWebArmAutentication            : prWebArmAutenticate(Stream, ThreadData);
          csShowWebArmUsers                : prShowWebArmUsers(Stream, ThreadData);
          csAEWebArmUser                   : prAEWebArmUser(Stream, ThreadData);
          csProductPage                    : prProductPage(Stream, ThreadData);
          csProductWareSearch              : prProductWareSearch(Stream, ThreadData);
          csProductGetOrigNumsAndWares     : prProductGetOrigNumsAndWares(Stream, ThreadData);
          csProductAddOrigNum              : prProductAddOrigNum(Stream, ThreadData);
          csProductDelOrigNum              : prProductDelOrigNum(Stream, ThreadData);
          csAccountsReestrPage             : prAccountsReestrPage(Stream, ThreadData);
          csAccountsGetFirmList            : prAccountsGetFirmList(Stream, ThreadData);
          csSearchWithOrNums               : prCommonWareSearch(Stream, ThreadData);
          csGetManufacturerList            : prGetManufacturerList(Stream, ThreadData);
          csWebArmGetAnalogs               : prGetWareAnalogs(Stream, ThreadData);
          csSaveWebArmUsers                : prSaveWebArmUsers(Stream, ThreadData);
          csManageBrands                   : prManageBrands(Stream, ThreadData);
          csGetBrandsGB                    : prGetBrandsGB(Stream, ThreadData);
          csGetBrandsTD                    : prGetBrandsTD(Stream, ThreadData);
          csGetLinkBrandsGBTD              : prGetLinkBrandsGBTD(Stream, ThreadData);
          csAddLinkBrandsGBTD              : prAddLinkBrandsGBTD(Stream, ThreadData);
          csDelLinkBrandsGBTD              : prDelLinkBrandsGBTD(Stream, ThreadData);
          csUiKPage                        : prUiKPage(Stream, ThreadData);
          csTNAGet                         : prTNAGet(Stream, ThreadData);
          csTNANodeAdd                     : prTNANodeAdd(Stream, ThreadData);
          csTNANodeDel                     : prTNANodeDel(Stream, ThreadData);
          csTNANodeEdit                    : prTNANodeEdit(Stream, ThreadData);
          csTNAManagePage                  : prTNAManagePage(Stream, ThreadData);
          csManufacturerAdd                : prManufacturerAdd(Stream, ThreadData);
          csManufacturerEdit               : prManufacturerEdit(Stream, ThreadData);
          csManufacturerDel                : prManufacturerDel(Stream, ThreadData);
          csGetModelLineList               : prGetModelLineList(Stream, ThreadData);
          csModelLineAdd                   : prModelLineAdd(Stream, ThreadData);
          csModelLineEdit                  : prModelLineEdit(Stream, ThreadData);
          csModelLineDel                   : prModelLineDel(Stream, ThreadData);
          csWebArmGetRegionalFirms         : prWebArmGetRegionalFirms(Stream, ThreadData);
          csWebArmGetFirmUsers             : prWebArmGetFirmUsers(Stream, ThreadData);
          csWebArmResetUserPassword        : prWebArmResetUserPassword(Stream, ThreadData);
          csWebArmSetFirmMainUser          : prWebArmSetFirmMainUser(Stream, ThreadData);
          csWebArmGetOrdersToRegister      : prWebArmGetOrdersToRegister(Stream, ThreadData);
          csWebArmAnnulateOrderToRegister  : prWebArmAnnulateOrderToRegister(Stream, ThreadData);
          csWebArmRegisterOrderToRegister  : prWebArmRegisterOrderToRegister(Stream, ThreadData);
          csGetFilialList                  : prGetFilialList(Stream, ThreadData);
          csWebArmGetRegionalZones         : prWebArmGetRegionalZones(Stream, ThreadData);
          csWebArmInsertRegionalZone       : prWebArmInsertRegionalZone(Stream, ThreadData);
          csWebArmDeleteRegionalZone       : prWebArmDeleteRegionalZone(Stream, ThreadData);
          csWebArmUpdateRegionalZone       : prWebArmUpdateRegionalZone(Stream, ThreadData);
          csGetModelLineModels             : prGetModelLineModels(Stream, ThreadData);
          csGetModelTree                   : prGetModelTree(Stream, ThreadData);
          csGetNodeWares                   : prCommonGetNodeWares(Stream, ThreadData);
          csModelAddToModelLine            : prModelAddToModelLine(Stream, ThreadData);
          csModelEdit                      : prModelEdit(Stream, ThreadData);
          csModelDel                       : prModelDel(Stream, ThreadData);
          csModelSetVisible                : prModelSetVisible(Stream, ThreadData);
          csAutoModelInfoLists             : prAutoModelInfoLists(Stream, ThreadData);
          csLoadModelData                  : prLoadModelData(Stream, ThreadData);

          csGetListAttrGroupNames          : prGetListAttrGroupNames(Stream, ThreadData);
          csGetListGroupAttrs              : prGetListGroupAttrs(Stream, ThreadData);
          csSearchWaresByAttrValues        : prCommonSearchWaresByAttr(Stream, ThreadData);
          csGetCompareWaresInfo            : prGetCompareWaresInfo(Stream, ThreadData);
          csGetWareInfoView                : prGetWareInfoView(Stream, ThreadData);
          csGetFilteredGBGroupAttValues    : prGetFilteredGBGroupAttValues(Stream, ThreadData); // Фильтрованные списки значений атрибутов Grossbee по группе

          csSendWareDescrErrorMes          : prSendWareDescrErrorMes(Stream, ThreadData);
          csImportPage                     : prImportPage(Stream, ThreadData);
          csGetBaseStamp                   : prGetBaseStamp(Stream, ThreadData);
          csCommonImport                   : prCommonImport(Stream, ThreadData);
          csCheckWareManager               : prCheckWareManager(Stream, ThreadData);
          csModifyLink3                    : prModifyLink3(Stream, ThreadData);
          csGetWareList                    : prGetWareList(Stream, ThreadData);
          csLoadModelDataText              : prLoadModelDataText(Stream, ThreadData);
          csShowModelsWhereUsed            : prShowModelsWhereUsed(Stream, ThreadData);
          csMarkOrNum                      : prMarkOrNum(Stream, ThreadData);
          csShowCrossOE                    : prShowCrossOE(Stream, ThreadData);
          csShowCurrentOperations          : prShowCurrentOperations(Stream, ThreadData);
          csStopIEOperation                : prStopIEOperation(Stream, ThreadData);
          csShowEngineOptions              : prShowEngineOptions(Stream, ThreadData);
          csGetTop10Model                  : prGetTop10Model(Stream, ThreadData);
          csLoadEngines                    : prLoadEngines(Stream, ThreadData);
          csGetEngineTree                  : prGetEngineTree(Stream, ThreadData);
          csNewsPage                       : prNewsPage(Stream, ThreadData);
          csTestLinksLoading               : prTestLinksLoading(Stream, ThreadData);
          csGetFilterValues                : prGetFilterValues(Stream, ThreadData);
          csShowActionNews                 : prShowActionNews(Stream, ThreadData);
          csAEActionNews                   : prAEActionNews(Stream, ThreadData);
          csSaveImgForAction               : prSaveImgForAction(Stream, ThreadData);
          csUnblockWebUser                 : prUnblockWebUser(Stream, ThreadData);
          csDelActionNews                  : prDelActionNews(Stream, ThreadData);
          csShowSysOptionsPage             : prShowSysOptionsPage(Stream, ThreadData);
          csEditSysOption                  : prEditSysOption(Stream, ThreadData);
          csSaveSysOption                  : prSaveSysOption(Stream, ThreadData);
          csShowConstRoles                 : prShowConstRoles(Stream, ThreadData);
          csEditConstRoles                 : prEditConstRoles(Stream, ThreadData);
          csMarkOneDirectAnalog            : prMarkOneDirectAnalog(Stream, ThreadData);
          csAddOneDirectAnalog             : prAddOneDirectAnalog(Stream, ThreadData);
          csShowConditionPortions          : prShowConditionPortions(Stream, ThreadData);
          csGetWaresByOE                   : prCommonGetWaresByOE(Stream, ThreadData);
          csHideEmptyOE                    : prHideEmptyOE(Stream, ThreadData);
          csMarkPortions                   : prMarkPortions(Stream, ThreadData);
          csShowPortion                    : prShowPortion(Stream, ThreadData);
          csCOUPage                        : prCOUPage(Stream, ThreadData);
          csGetCateroryValues              : prGetCateroryValues(Stream, ThreadData);
          csSavePortion                    : prSavePortion(Stream, ThreadData);
          csGetSatellites                  : prGetWareSatellites(Stream, ThreadData);
//          csGetClientData                  : prWebArmGetFirmInfo(Stream, ThreadData);
          csGetRestsOfWares                : prCommonGetRestsOfWares(Stream, ThreadData);
          csLoadAccountList                : prWebArmGetFilteredAccountList(Stream, ThreadData);
          csWebArmShowAccount              : prWebArmShowAccount(Stream, ThreadData);
          csWebArmShowFirmWareRests        : prWebArmShowFirmWareRests(Stream, ThreadData);
          csWebArmEditAccountHeader        : prWebArmEditAccountHeader(Stream, ThreadData);
          csWebArmEditAccountLine          : prWebArmEditAccountLine(Stream, ThreadData);
          csWebArmGetWaresDescrView        : prWebArmGetWaresDescrView(Stream, ThreadData);
          csWebArmGetDeliviriesList        : prWebarmGetDeliveries(Stream, ThreadData);
          csCreateSubAcc                   : prWebArmMakeSecondAccount(Stream, ThreadData);
          csGetDeliveriesList              : prGetDeliveriesList(Stream, ThreadData);
          csRestorePassword                : prRestorePassword(Stream, ThreadData);
          csBlockWebArmUser                : prBlockWebArmUser(Stream, ThreadData);
          csWebArmMakeInvoiceFromAccount   : prWebArmMakeInvoiceFromAccount(Stream, ThreadData);
          csShowTransferInvoices           : prWebArmGetTransInvoicesList(Stream, ThreadData);
          csShowTransferInvoice            : prWebArmGetTransInvoice(Stream, ThreadData);
          csWebArmAddWaresFromAccToTransInv: prWebArmAddWaresFromAccToTransInv(Stream, ThreadData);
          csCheckRestsInStorageForAcc      : prCheckRestsInStorageForAcc(Stream, ThreadData);
          csAEDNotification                : prAEDNotification(Stream, ThreadData);
          csNotificationPage               : prNotificationPage(Stream, ThreadData);
          csWebArmGetNotificationsParams   : prWebArmGetNotificationsParams(Stream, ThreadData);
          csShowNotification               : prShowNotificationOrd(Stream, ThreadData);
          csShowNotificationWA             : prShowNotification(Stream, ThreadData);
          csWaresByOE                      : prSearchWaresByOE(Stream, ThreadData);
          csCheckContracts                 : prCheckContracts(Stream, ThreadData);
          csWebarmContractList             : prWebArmContractList(Stream, ThreadData);
          csManageLogotypesPage            : prManageLogotypesPage(Stream, ThreadData);
          csLogotypeEdit                   : prLogotypeEdit(Stream, ThreadData);
          csLoadOrder                      : prLoadOrder(Stream, ThreadData);
          csLampSelect                     : prGetActionsSrvMng(Stream, ThreadData);        // ???
          csGetTimeListSelfDelivery        : prGetTimeListSelfDelivery(Stream, ThreadData);    // список доступных времен самовывоза
          csGetContractDestPointsList      : prGetContractDestPointsList(Stream, ThreadData);  // список торговых точек контракта
          csGetAvailableTimeTablesList     : prGetAvailableTimeTablesList(Stream, ThreadData); // список доступных расписаний по контракту
          csGetAccountShipParams           : prGetAccountShipParams(Stream, ThreadData);       // просмотр параметров отгрузки счета
          csSetAccountShipParams           : prSetAccountShipParams(Stream, ThreadData);       // редактирование параметров отгрузки счета
          csGetDprtAvailableShipDates      : prGetDprtAvailableShipDates(Stream, ThreadData);  // список доступных дат отгрузки по складу
          csWebArmResetPassword            : prWebArmResetPassword(Stream, ThreadData);

          csGeneralNewSystemProcWebArm     : prGeneralNewSystemProcWebArm(Stream, ThreadData);  // общая процедура по новой схеме работы

          else raise EBOBError.Create('Не опознана WebArm-команда - '+IntToStr(Command));
        end; //  case Command of
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          if (Command<>csTestLinksLoading) and (AppStatus=stWork) then
            fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebArmConnect', 'Command='+IntToStr(Command), E.Message, 'ErrorPos='+ErrorPos);
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
      if Stream.Size>0 then begin
        i:= Stream.Size;
        AThread.Connection.IOHandler.Write(i);              //
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);
    end else begin // если неизвестная сигнатура
  ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end; // if i=csWebArm
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerWebArmConnect', 'Ошибка общего плана', E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerWebArmConnect', 'Аварийно завершен поток', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerWebConnect');
  prFree(Stream);
  if (AThread<>nil) and AThread.Connection.Connected then AThread.Connection.Disconnect;
end; //ServerWebArmConnect
//==============================================================================
procedure TMyClass.ServerManageConnect(AContext: TIdContext);
var i: integer;
    ThreadData: TThreadData;
    Command: word;
    ErrorPos: string;
    AThread: TIdContext;
    Stream: TBOBMemoryStream;
begin
ErrorPos:= '0';
  AThread:= AContext;
  ThreadData:= nil;
  Stream:= nil;
  try
    AThread.Connection.IOHandler.ReadTimeout:=5000;
ErrorPos:= '1';
    i:= AThread.Connection.IOHandler.ReadLongInt;    // принимаем сигнатуру
    AThread.Connection.IOHandler.ReadLongInt;   // пропускаем идентификатор сессии
ErrorPos:= '3';
    if (i=csServerManage) then begin // если это запрос управления сервером
ErrorPos:= '8';
      Command:= word(AThread.Connection.IOHandler.ReadSmallInt);   // принимаем команду
      ThreadData:= fnCreateThread(fnSignatureToThreadType(i), Integer(Command));
ErrorPos:= '8-3';
      i:= AThread.Connection.IOHandler.ReadLongInt;                // принимаем размер тела запроса
ErrorPos:= '8-6';
      Stream:= TBOBMemoryStream.Create;
ErrorPos:= '8-7';
      AThread.Connection.IOHandler.ReadStream(Stream, i);         // принимаем тело запроса
ErrorPos:= '8-8';
      try
        case Command of
          scGetStatus  : prGetFullStatus(Stream, ThreadData);
          scUpdateCache: prUpdateCacheSrvMng(Stream, ThreadData);
          scGetActions : prGetActionsSrvMng(Stream, ThreadData);
          scSuspend, scResume, scExit:
            prExecuteServerCommand(Stream, ThreadData, Command, AThread.Connection.Socket.Binding.PeerIP);
          scGetKAPhones: prGetKAPhones(Stream, ThreadData);
          else raise EBOBError.Create('Не опознана управляющая команда - '+IntToStr(Command));
        end;
      except
        on E: Exception do begin
          Stream.Clear;
          Stream.WriteInt(aeCommonError);
          fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerManageConnect', '', E.Message, '');
          Stream.WriteStr('Сервер сообщает об ошибке: '#13#10+E.Message);
        end;
      end;
ErrorPos:= '8-9';
      If Stream.Size>0 then begin
        i:= Stream.Size;
ErrorPos:= '8-10: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(i);              //
ErrorPos:= '8-11: Stream.Size='+IntToStr(i);
        AThread.Connection.IOHandler.Write(Stream);         // возвращаем ответ на запрос
ErrorPos:= '8-12';
      end;
      AThread.Connection.Disconnect;
      prFree(Stream);

    end else begin // если неизвестная сигнатура
ErrorPos:= '9';
      AThread.Connection.Disconnect;
    end;
  except
    on E: Exception do begin
      fnWriteToLog(ThreadData, lgmsSysError, 'TMyClass.ServerManageConnect', 'Ошибка общего плана', E.Message, 'ErrorPos='+ErrorPos);
      fnWriteToLog(ThreadData, lgmsInfo, 'TMyClass.ServerManageConnect', 'Аварийно завершен поток', E.Message, 'ErrorPos='+ErrorPos);
    end;
  end;
  prFree(Stream);
  if (AThread<>nil) and AThread.Connection.Connected then AThread.Connection.Disconnect;
  prDestroyThreadData(ThreadData, 'TMyClass.ServerManageConnect');
end; //ServerManageConnect
//==========================================================  TMyClass

//= Функция для пользовательской сортировки товаров в StringList с учетом бренда
function fnWareCompareByBrand(List: TStringList; Index1, Index2: Integer): Integer;
var Ware1, Ware2: TWareInfo;
begin
  Ware1:= TWareInfo(Cache.arWareInfo[integer(List.Objects[Index1])]);
  Ware2:= TWareInfo(Cache.arWareInfo[integer(List.Objects[Index2])]);
  if (Ware1.WareBrandName<Ware2.WareBrandName) then Result:= -1
  else if (Ware1.WareBrandName>Ware2.WareBrandName) then Result:= 1
  else if (Ware1.Name<Ware2.Name) then Result:= -1
  else if (Ware1.Name>Ware2.Name) then Result:= 1
  else Result:= 0;
end;
//================================ Функция получения товаров по заданному бренду
function fnGetWareListByBrand(Brand: integer; Sys: byte = 255; Sort: boolean = false): TStringList;
var i, recs: integer;
begin
  Result:= TStringList.Create;
  try
    if (not Cache.WareBrands.ItemExists(Brand)) then
      raise EBOBError.Create('Не найден бренд с кодом '+IntToStr(Brand));
    recs:= Length(Cache.arWareInfo)-1;
    for i:= 0 to recs do
      if (Cache.WareExist(i)) and ((Cache.arWareInfo[i].WareBrandID=Brand)
        and ((Sys in constAllSys) or Cache.arWareInfo[i].CheckWareTypeSys(Sys))) then
        Result.AddObject(Cache.arWareInfo[i].Name, pointer(Cache.arWareInfo[i].ID));
    if Sort then Result.Sort;
  except
    on E:Exception do raise Exception.Create('fnGetWareListByBrand: '+E.Message);
  end;
end;
//==============================================================================
function fnGetAdaptedConstValue(ConstID: integer): string;
const nmProc = 'fnGetAdaptedConstValue'; // имя процедуры/функции
var aos: Tas;
    s, ss: string;
    j, EmplCode, Code: integer;
    Item: TConstItem;
begin
  Result:= '';
  try
    if not Cache.ConstExists(ConstID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - код='+IntToStr(ConstID));

    Item:= Cache.GetConstItem(ConstID);
    s:= '';
    case ConstID of
      pcEmplID_list_Rep30, pcTestingSending1, pcTestingSending2, pcTestingSending3,
        pcEmpl_list_UnBlock, pcEmpl_list_TmpBlock, pcEmpl_list_FinalBlock, pcVINmailEmpl_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:= 0 to High(aos) do begin
          EmplCode:= StrToIntDef(aos[j], 0);
          ss:= '';
          if (EmplCode<0) then begin
            if (EmplCode>=Low(ceNames)) and (EmplCode<=High(ceNames)) then
              ss:= ceNames[EmplCode];
          end else if Cache.EmplExist(EmplCode) then
            ss:= Cache.arEmplInfo[EmplCode].EmplShortName;
          if ss<>'' then s:= s+fnIfStr(s<>'', ', ', '')+ss;
        end;
        Result:= s;
      end; // pcEmplID_list_Rep30 ...

      pcVINmailFilial_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:= 0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], 0);
          if Cache.DprtExist(Code) and Cache.arDprtInfo[Code].IsFilial then
            if s<>'' then s:=s+fnIfStr(s<>'', ', ', '')+Cache.arDprtInfo[Code].Name;
        end;
        Result:= s;
      end; // pcVINmailFilial_list

      pcVINmailFirmClass_list, pcPriceLoadFirmClasses: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:=0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], 0);
          ss:= Cache.GetFirmClassName(Code);
          if ss<>'' then begin
            if s<>'' then s:= s+', ';
            s:= s+ss;
          end;
        end;
        Result:= s;
      end; // pcVINmailFirmClass_list, pcPriceLoadFirmClasses

      pcVINmailFirmTypes_list: begin
        aos:= fnSplitString(Item.StrValue, ',');
        for j:=0 to High(aos) do begin
          Code:= StrToIntDef(aos[j], -1);
          ss:= Cache.GetFirmTypeName(Code);
          if ss<>'' then begin
            if s<>'' then s:=s+', ';
            s:= s+ss;
          end;
        end;
        Result:= s;
      end; // pcVINmailFirmTypes_list

      pcEmplSaleDirectorAuto, pcEmplSaleDirectorMoto: begin
        Code:= StrToIntDef(Item.StrValue, 0);
        if Cache.EmplExist(Code) then
          Result:= Cache.arEmplInfo[Code].EmplShortName
        else Result:= 'Неизвестный';
      end; // pcEmplSaleDirectorAuto, pcEmplSaleDirectorAuto

    else Result:= Item.StrValue;
    end; // case
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'for constID='+IntToStr(ConstID)+': '+E.Message);
    on E: Exception do raise Exception.Create(nmProc+'for constID='+IntToStr(ConstID)+': '+E.Message);
  end;
  SetLength(aos, 0);
end;  // fnGetAdaptedConstValue
{//============ используется для сортировки объектов типа TTwoCodes в TObjectList
//========================= при выводе списка типов товаров в результатах поиска
function CompareTypeNamesForTwoCodes(Item1, Item2: Pointer): Integer;
var tt1, tt2: TTwoCodes;
begin
  tt1:= TTwoCodes(Item1);
  tt2:= TTwoCodes(Item2);
  if (tt1.ID1=tt2.ID1) then Result:= 0
  else if (tt1.ID1=0) then Result:= 1
  else if (tt2.ID1=0) then Result:= -1
  else Result:= CompareText(Cache.GetWareTypeName(tt1.ID1), Cache.GetWareTypeName(tt2.ID1));
end; }
//======== используется для сортировки списка типов товаров в результатах поиска
function TypeNamesSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var i1, i2: Integer;
begin
  try
    i1:= Integer(List.Objects[Index1]);
    i2:= Integer(List.Objects[Index2]);
    if (i1=i2) then Result:= 0
    else if (i1=0) then Result:= 1
    else if (i2=0) then Result:= -1
    else Result:= AnsiCompareText(List[Index1], List[Index2]);
  except
    Result:= 0;
  end;
end;
//============ используется для сортировки объектов типа TTwoCodes в TObjectList
//====================================при выводе списка производителей авто/мото
function SortCompareManufNamesForTwoCodes(Item1, Item2: Pointer): Integer;
begin
  Result:= CompareText(Cache.FDCA.Manufacturers[TTwoCodes(Item1).ID1].Name,
    Cache.FDCA.Manufacturers[TTwoCodes(Item2).ID1].Name);
end;
//========================= используется для сортировки StringList в TObjectList
//======================================= при выводе порций условий применимости
function SortCompareConditionPortions(Item1, Item2: Pointer): Integer;
begin
  Result:= CompareText(TStringList(Item1).QuoteChar, TStringList(Item2).QuoteChar);
end;
//================= проверяет, просрочено ли время доставки, true - не просрочен
function CheckShipmentDateTime(Data: TDate; TimeCode: integer): boolean;
var Hour, Minute: double;
    st: TShipTimeItem;
begin
  Result:= not fnNotZero(Data);
  if Result then Exit;
  if TimeCode=0 then begin
    Hour:= 23;
    Minute:= 59.9999999;
  end else begin
    st:= Cache.ShipTimes[TimeCode];
    Hour:= st.Hour;
    Minute:= st.Minute;
  end;
  Result:=(Data+Hour/24+Minute/60/24)>Now();
end; // CheckShipmentDateTime
//----------------------------------------- vc

//----------------------------------------- v_CSSServerManageProcs
procedure CheckManagePassw(passw: String);
const ManageDefPassw = 'sdihhhsdohsdohsovhovhsodvhsdohsdohSDObhSDObhsdohsdohbhSbuo';
begin
  if (passw<>GetIniParam(nmIniFileBOB, 'Manage', 'ManagePass', ManageDefPassw)) then
    raise Exception.Create('Неправильный пароль');
end;
//==============================================================================
procedure prGetFullStatus(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetFullStatus'; // имя процедуры/функции
var i, Count, iState: integer;
    s, s1: string;
    Pools: array of TIBCntsPool;
begin
  try
    Stream.Position:= 0;
    s1:= Stream.ReadStr;
    CheckManagePassw(s1);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Stream.WriteInt(AppStatus);
    if AppStatus in [stSuspending, stSuspended] then begin  // если приложение спит, то отправляем список усыпивших его серверов
      s:= '';
      for i:= 0 to High(StopList) do s:= StopList[i]+', ';
      Stream.WriteStr(Copy(s, 1, length(s)-2));
    end;

    Stream.WriteByte(1);
    Stream.WriteByte(1);

    if ServerWeb=nil then iState:= sttcpsrvNone
    else if ServerWeb.Active then iState:= sttcpsrvActive
    else iState:= sttcpsrvSuspended;
    Stream.WriteInt(iState);

    if ServerWebArm=nil then iState:= sttcpsrvNone
    else if ServerWebArm.Active then iState:= sttcpsrvActive
    else iState:= sttcpsrvSuspended;
    Stream.WriteInt(iState);

    Stream.WriteInt(stthrdNone); // RespThread
    Stream.WriteInt(stthrdNone); // MailThread
    Stream.WriteInt(stthrdNone); // TestThread

    if thCheckStoppedOrders=nil then Stream.WriteInt(stthrdNone)
    else begin
      Stream.WriteInt(TCSSCyclicThread(thCheckStoppedOrders).Status);
      Stream.WriteDouble(TCSSCyclicThread(thCheckStoppedOrders).LastTime);
    end;

    if thCheckDBConnectThread=nil then Stream.WriteInt(stthrdNone)
    else begin
      Stream.WriteInt(TCSSCyclicThread(thCheckDBConnectThread).Status);
      Stream.WriteDouble(TCSSCyclicThread(thCheckDBConnectThread).LastTime);
    end;
    Stream.WriteInt(Cache.GetTestCacheIndication);
    Stream.WriteDouble(Cache.GetLastTimeCache);

    Count:= 4;
    SetLength(Pools, Count+1);
    Pools[0]:= cntsGRB;
    Pools[1]:= cntsORD;
    Pools[2]:= cntsLOG;
    Pools[3]:= cntsSUF;
    Pools[4]:= cntsTDT;

    Stream.WriteInt(Count+1);
    for i:= 0 to Count do begin
      Stream.WriteStr(Pools[i].CntsComment);
      Stream.WriteStr(Pools[i].dbPath);
      Stream.WriteBool(Pools[i].BaseConnected);
    end;
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; // prGetFullStatus
//==============================================================================
procedure prExecuteServerCommand(Stream: TBoBMemoryStream; ThreadData: TThreadData; ACommand: integer; AIP: string);
const nmProc = 'prExecuteServerCommand'; // имя процедуры/функции
var s: string;
begin
  try
    Stream.Position:= 0;
    s:= Stream.ReadStr;
    CheckManagePassw(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    while ManageCommandsLock do sleep(50);
    try
      ManageCommandsLock:= true;
      if ACommand=scExit then SetLength(arManageCommands, 1)
      else SetLength(arManageCommands, Length(arManageCommands)+1);
      arManageCommands[Length(arManageCommands)-1].Command:= ACommand;
      arManageCommands[Length(arManageCommands)-1].IP:= AIP;
    finally
      ManageCommandsLock:= false;
    end;
  except
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; // prExecuteServerCommand
//==============================================================================
procedure prUpdateCacheSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prUpdateCacheSrvMng'; // имя процедуры/функции
var s: string;
begin
  try
    Stream.Position:= 0;
    s:= Stream.ReadStr;
    CheckManagePassw(s);

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно

    with TCSSCyclicThread(thCheckDBConnectThread) do
    if ExpressFlag or Cache.WareCacheTested then
      raise EBoBError.Create('Выполняется '+fnIfStr(ExpressFlag, 'срочная', 'штатная')+' проверка кеша')
    else ExpressFlag:= True;
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
end; // prExecuteServerCommandprUpdateCacheSrvMng
//==============================================================================
procedure prGetActionsSrvMng(Stream: TBoBMemoryStream; ThreadData: TThreadData);
const nmProc = 'prGetActionsSrvMng'; // имя процедуры/функции
var Count, Pos: integer;
    ordIBD: TIBDatabase;
    OrdIBS: TIBSQL;
begin
  ordIBD:= nil;
  OrdIBS:= nil;
  try
    Stream.Position:= 0;
    ordIBD:= CntsOrd.GetFreeCnt();
    OrdIBS:= fnCreateNewIBSQL(ordIBD,'GBIBSQL_'+nmProc,ThreadData.ID, tpRead, true);
    OrdIBS.SQL.Text:= 'Select * from infoboxviews'+
      ' where "TODAY" between IBVDATEFROM and IBVDATETO and (IBVVISAUTO="T" or IBVVISMOTO="T")'+
      ' order by IBVPRIORITY desc, IBVDATEFROM desc';
    OrdIBS.ExecQuery;

    Stream.Clear;
    Stream.WriteInt(aeSuccess); // знак того, что запрос обработан корректно
    Pos:= Stream.Position;
    Stream.WriteInt(0); // заглушка под кол-во
    Count:= 0;
    while not OrdIBS.EOF do begin
      Stream.WriteInt(OrdIBS.FieldByName('IBVCODE').Asinteger);
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISAUTO'));
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISMOTO'));
      Stream.WriteBool(GetBoolGB(OrdIBS, 'IBVVISIBLE'));
      Stream.WriteInt(OrdIBS.FieldByName('IBVPRIORITY').Asinteger);
      Stream.WriteStr(OrdIBS.FieldByName('IBVTITLE').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('IBVLINKTOSITE').AsString);
      Stream.WriteStr(OrdIBS.FieldByName('IBVLINKTOPICT').AsString);
      inc(Count);
      OrdIBS.Next;
    end;
    if (Count>0) then begin
      Stream.Position:= Pos;
      Stream.WriteInt(Count);
    end;
    Stream.SaveToFile('actions.raw');
  except
    on E: EBOBError do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', True);
    on E: Exception do prSaveCommonError(Stream, ThreadData, nmProc, E.Message, '', False);
  end;
  Stream.Position:= 0;
  prFreeIBSQL(OrdIBS);
  cntsORD.SetFreeCnt(ordIBD);
end; // prGetActionsSrvMng
//----------------------------------------- v_CSSServerManageProcs

//******************************************************************************
//                     TVSMail - Vladislav Software Mail
//******************************************************************************
constructor TVSMail.Create;
begin
  inherited Create;
  CheckXstring; // def строка для вставки в заголовок письма (SysMailSend)
end;
//========================== строка для вставки в заголовок письма (SysMailSend)
procedure TVSMail.CheckXstring(section: String=''; value: String='');
var s: String;
begin
  if section<>'' then s:= section+': ' else s:= 'X-From-Prg: ';
  if value<>'' then s:= s+value else s:= s+'Vladislav Software';
  s:= s+' ('+GetAppExeName+', '+fnGetComputerName+')';
  if Xstring<>s then Xstring:= s;
end;
//===========================================
procedure TVSMail.OnInitISO(var VHeaderEncoding: Char; var VCharSet: String);
begin
  VCharSet:= IdCharsetNames[FindCharset(cCharSetWin)];
//  VHeaderEncoding:= 'B';     { base64 / quoted-printable }
end;

//******************************************************************************
//                              TWareAndAnalogs
//******************************************************************************
constructor TWareAndAnalogs.Create(pWareID: Integer; parAnalogs, parSatells: Tai);
var i: Integer;
begin
  inherited Create;
  SetLength(arAnalogs, 0);
  SetLength(arSatells, 0);
  WareID:= pWareID;
  if Assigned(parAnalogs) then try
    SetLength(arAnalogs, Length(parAnalogs));
    for i:= 0 to High(parAnalogs) do arAnalogs[i]:= parAnalogs[i];
    SetLength(parAnalogs, 0);
  except end;
  if Assigned(parSatells) then try
    SetLength(arSatells, Length(parSatells));
    for i:= 0 to High(parSatells) do arSatells[i]:= parSatells[i];
    SetLength(parSatells, 0);
  except end;
//  AutoModelsExists:= False;
//  MotoModelsExists:= False;
//  RestsExists     := False;
end;
//==============================================================================
destructor TWareAndAnalogs.Destroy;
begin
  SetLength(arAnalogs, 0);
  SetLength(arSatells, 0);
  inherited;
end;

//******************************************************************************
//                          TSearchWareOrOnum
//******************************************************************************
constructor TSearchWareOrOnum.Create(pID, pSatCount: Integer; pIsWare, pIsMarket: Boolean; parAnalogs: Tai=nil);
var i: Integer;
begin
  ID:= pID;
  if pIsMarket then RestSem:= 0 else RestSem:= -1;
  IsWare:= pIsWare;
  SatCount:= pSatCount;
  OLAnalogs:= TObjectList.Create; // (TTwoCodes - ID, sem)
  if Assigned(parAnalogs) and (Length(parAnalogs)>0) then
    for i:= 0 to High(parAnalogs) do OLAnalogs.Add(TTwoCodes.Create(parAnalogs[i], -1));
end;
//==============================================================================
destructor TSearchWareOrOnum.Destroy;
begin
  prFree(OLAnalogs);
  inherited;
end;

//******************************************************************************
//=================================================== проверка остановки системы
procedure TestCssStopException;
begin
  if AppStatus in [stSuspending, stSuspended, stExiting] then
    raise EBOBError.Create('процесс прерван из-за остановки системы');
end;
//================================ Перевести значение поля Fname ibsql в boolean
function GetBoolGB(ibsql: TIBSQL; Fname: string): boolean;
begin
  Result:= False;
  if not Assigned(ibsql) or (Fname='') or (ibsql.FieldIndex[Fname]<0) then Exit;
  Result:= ibsql.fieldByName(Fname).AsString='T';
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL): string;
// выполняет IBSQL RepeatCount попыток
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 0 to RepeatCount do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<RepeatCount) then
        Sleep(RepeatSaveInterval) // ждем немного
      else Result:= E.Message;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var StrValue: string): string;
// выполняет IBSQL RepeatCount попыток, возвращает символьное значение заданного поля
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 0 to RepeatCount do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if (Fname<>'') and not (IBS.Bof and IBS.Eof) then
      StrValue:= IBS.FieldByName(Fname).AsString;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<RepeatCount) then
        Sleep(RepeatSaveInterval) // ждем немного
      else Result:= E.Message;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; var FnamesValues: Tas): string;
// FnamesValues на входе - имена полей,
// FnamesValues на выходе - символьные значениz соответствующих полей
// выполняет IBSQL RepeatCount попыток
var i, j: integer;
    s: string;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 0 to RepeatCount do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if not (IBS.Bof and IBS.Eof) and (length(FnamesValues)>0) then
      for j:= 0 to High(FnamesValues) do begin
        s:= FnamesValues[j];
        if (s='') then Continue;
        if (IBS.FieldIndex[s]<0) then s:= '' else s:= IBS.FieldByName(s).AsString;
        FnamesValues[j]:= s;
      end; // for
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<RepeatCount) then
        Sleep(RepeatSaveInterval) // ждем немного
      else Result:= E.Message;
    end;
  end;
  IBS.Close;
end;
//==============================================================================
function RepeatExecuteIBSQL(IBS: TIBSQL; Fname: string; var IntValue: Integer): string;
// выполняет IBSQL RepeatCount попыток, возвращает числовое значение заданного поля
var i: integer;
begin
  Result:= '';
  if not Assigned(IBS) then Exit;
  for i:= 0 to RepeatCount do with IBS.Transaction do try
    Application.ProcessMessages;
    IBS.Close;
    if not InTransaction then StartTransaction;
    IBS.ExecQuery;
    if (Fname<>'') and not (IBS.Bof and IBS.Eof) then
      IntValue:= IBS.FieldByName(Fname).AsInteger;
    Commit;
    break;
  except
    on E: Exception do begin
      RollbackRetaining;
      if (Pos('lock', E.Message)>0) and (i<RepeatCount) then
        Sleep(RepeatSaveInterval) // ждем немного
      else Result:= E.Message;
    end;
  end;
  IBS.Close;
end;
//============================================= путь к рабочим файлам сотрудника
function GetEmplTmpFilePath(EmplID: Integer; var pFilePath, errmess: string): boolean;
begin
  errmess:= '';
  pFilePath:= '';
  with Cache do if not EmplExist(EmplID) then errmess:= MessText(mtkNotEmplExist)
  else begin
    pFilePath:= GetAppExePath+'TMP';
    if DirectoryExists(pFilePath) or ForceDirectories(pFilePath) then begin
      pFilePath:= fnTestDirEnd(pFilePath)+arEmplInfo[EmplID].ServerLogin;
      if not DirectoryExists(pFilePath) and not ForceDirectories(pFilePath) then
        errmess:= MessText(mtkNotCreateDir, pFilePath);
    end else errmess:= MessText(mtkNotCreateDir, pFilePath);
  end;
  Result:= errmess='';
  if Result then pFilePath:= fnTestDirEnd(pFilePath);
end;
{//====================================================== Проверить систему фирмы
function CheckNotValidFirmSys(FirmID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  if (FirmID<>isWe) and not Cache.arFirmInfo[FirmID].CheckSysType(SysID) then
    errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;     }
//====================== Проверить права сотрудника на работу с моделями системы
function CheckNotValidModelManage(UserID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  with Cache do if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else if not EmplExist(UserID) then errmess:= MessText(mtkNotEmplExist)
  else with arEmplInfo[UserId] do
    if ((SysID=constIsAuto) and not UserRoleExists(rolModelManageAuto)) or
      ((SysID=constIsMoto) and not UserRoleExists(rolModelManageMoto)) then
      errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;
//================= Проверить права сотрудника на работу с деревом узлов системы
function CheckNotValidTNAManage(UserID, SysID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  with Cache do if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else if not EmplExist(UserID) then errmess:= MessText(mtkNotEmplExist)
  else with arEmplInfo[UserId] do
    if ((SysID=constIsAuto) and not UserRoleExists(rolTNAManageAuto)) or
      ((SysID=constIsMoto) and not UserRoleExists(rolTNAManageMoto)) then
      errmess:= MessText(mtkNotRightExists);
  Result:= errmess<>'';
end;
//=============================== Получить производителя и проверить доступность
function CheckNotValidManuf(ManufID: Integer; SysID: Integer;
         var Manuf: TManufacturer; var errmess: string): boolean;
begin
  errmess:= '';
  if not CheckTypeSys(SysID) then
    errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID))
  else with Cache.FDCA do
    if not Manufacturers.ManufExists(ManufID) then
      errmess:= MessText(mtkNotFoundManuf, IntToStr(ManufID))
    else begin
      Manuf:= Manufacturers[ManufID];
      if not Manuf.CheckIsTypeSys(SysID) then
        errmess:= MessText(mtkNotSysManuf, IntToStr(SysID));
    end;
  Result:= errmess<>'';
end;
//====================== Получить модельный ряд, систему и проверить доступность
function CheckNotValidModelLine(ModelLineID: Integer; var SysID: Integer;
         var ModelLine: TModelLine; var errmess: string): boolean;
begin
  errmess:= '';
  if not Cache.FDCA.ModelLines.ModelLineExists(ModelLineID) then
    errmess:= MessText(mtkNotFoundModLine, IntToStr(ModelLineID))
  else begin
    ModelLine:= Cache.FDCA.ModelLines[ModelLineID];
    SysID:= ModelLine.TypeSys;
    if not CheckTypeSys(SysID) then
      errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID));
  end;
  Result:= errmess<>'';
end;
//============================= Получить модель, систему и проверить доступность
function CheckNotValidModel(ModelID: Integer; var SysID: Integer;
         var Model: TModelAuto; var errmess: string): boolean;
begin
  errmess:= '';
  if not Cache.FDCA.Models.ModelExists(ModelID) then
    errmess:= MessText(mtkNotFoundModel, IntToStr(ModelID))
  else begin
    Model:= Cache.FDCA.Models.GetModel(ModelID);
    SysID:= Model.TypeSys;
    if not CheckTypeSys(SysID) then
      errmess:= MessText(mtkNotFoundTypeSys, IntToStr(SysID));
  end;
  Result:= errmess<>'';
end;

//******************************************************************************
//                    функции по работе с заказами и т.п.
//******************************************************************************
//==========Уточняет статус заказа и возвращает данные по закрывающим документам
function fnGetClosingDocsOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
         var Status: integer; id: Integer=-1): string;
const nmProc = 'fnGetClosingDocsOrd'; // имя процедуры/функции
var ibsGB, ibsOrd: TIBSQL;
    ibGB, ibOrd: TIBDatabase;
    Closed, Annulated: boolean;
    i, accCode: integer;
    sid: string;
begin
  if (Cache.GetConstItem(pcClosingDocsFromOrd).IntValue=1) then begin // док-ты из Order
    Result:= fnGetClosingDocsFromOrd(ORDRCODE, Accounts, Invoices, Status, id);
    Exit;
  end;

  Result:= '';                                              // из Grossbee
  sid:= '_GCD'+fnIfStr(id<0, '', '_'+IntToStr(id))+'_'+ORDRCODE;
  ibsOrd:= nil;
  ibOrd:= nil;
  ibsGB:= nil;
  ibsGB:= nil;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  Closed:= true;
  try try
    ibOrd:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+sid, -1, tpRead, True);
    ibsOrd.SQL.Text:= 'SELECT ORDRSTATUS, ORDRGBACCCODE'+
                      ' FROM ORDERSREESTR WHERE ORDRCODE='+ORDRCODE;
    ibsOrd.ExecQuery;
    if (ibsOrd.Bof and ibsOrd.Eof) then Exit;

    Status:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger;
    accCode:= ibsOrd.FieldByName('ORDRGBACCCODE').AsInteger;
    ibsOrd.Transaction.Rollback;
    ibsOrd.Close;
    if not (Status in [orstAccepted..orstClosed]) or (accCode<1) then Exit;

    ibGB:= cntsGRB.GetFreeCnt;
    try
      ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+sid, -1, tpRead, True);
      ibsGB.SQL.Text:= 'Select d.* from Vlad_CSS_GetAllClosingDocs('+IntToStr(accCode)+
                       ') d where d.PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
      ibsGB.ExecQuery;
      i:= 0;
      while not ibsGB.Eof do begin
        SetLength(Accounts, i+1);
        SetLength(Invoices, i+1);
        with Accounts[i] do begin // заносим данные счета в структуру
          ID          := ibsGB.FieldByName('PInvCode').AsInteger;
          Number      := ibsGB.FieldByName('PInvNumber').AsString;
          Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
          Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
          CurrencyCode:= ibsGB.FieldByName('PInvCrnc').AsInteger;
          CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
          Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
          Commentary  := ibsGB.FieldByName('PINVCOMMENT').AsString;
          DprtID      := ibsGB.FieldByName('PInvDprt').AsInteger;
        end;
        with Invoices[i] do begin // заносим данные накладной в структуру
          ID:= ibsGB.FieldByName('INVCODE').AsInteger;
          if ID>0 then begin        // проверяем, закрыт ли счет
            Number      := ibsGB.FieldByName('INVNUMBER').AsString;
            Data        := ibsGB.FieldByName('INVDATE').AsDateTime;
            Summa       := ibsGB.FieldByName('INVSUMM').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('INVCRNC').AsInteger;
            CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
            DprtID      := ibsGB.FieldByName('INVDPRT').AsInteger;
          end else Number:= '';
          Closed:= Closed and (ID>0);
        end;
        inc(i);
        cntsGRB.TestSuspendException;
        ibsGB.Next;
      end;
    finally
      prFreeIBSQL(ibsGB);
      cntsGRB.SetFreeCnt(ibGB);
    end;

    Annulated:= i<1; // если не найдены счета - аннулируем заказ
    if Annulated then Closed:= False;
    i:= 0;
    if (Annulated and (Status<>orstAnnulated)) then i:= orstAnnulated   // если все счета аннулированы, аннулируем заказ
    else if (Closed and (Status<>orstClosed)) then i:= orstClosed       // если все счета закрыты, закрываем заказ
    else if (not Closed and (Status=orstClosed)) then i:= orstAccepted; // если не все счета закрыты, открываем заказ

    if i>0 then begin
      fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
      if i=orstAnnulated then begin
        ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+','+
          ' ORDRANNULATEREASON=:ORDRANNULATEREASON, ORDRANNULATEDATE="NOW" where ORDRCODE='+ORDRCODE;
        ibsOrd.ParamByName('ORDRANNULATEREASON').AsString:= 'Все '+fnGetGBDocName(docAccount, 1, 1)+' по заказу аннулированы.';
      end else
        ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+' where ORDRCODE='+ORDRCODE;

      Result:= RepeatExecuteIBSQL(ibsOrd);
      if Result='' then Status:= i;
    end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//==========Уточняет статус заказа и возвращает данные по закрывающим документам
function fnGetClosingDocsFromOrd(ORDRCODE: string; var Accounts, Invoices: TDocRecArr;
         var Status: integer; id: Integer=-1): string;
const nmProc = 'fnGetClosingDocsFromOrd'; // имя процедуры/функции
var ibsOrd: TIBSQL;
    ibOrd: TIBDatabase;
    Closed, Annulated: boolean;
    i: integer;
    sid: string;
begin
  Result:= '';
  sid:= '_GCD'+fnIfStr(id<0, '', '_'+IntToStr(id))+'_'+ORDRCODE;
  ibsOrd:= nil;
  ibOrd:= nil;
  SetLength(Accounts, 0);
  SetLength(Invoices, 0);
  Closed:= true;
  try try
    ibOrd:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+sid, -1, tpRead, True);
//    ibsOrd.SQL.Text:= 'SELECT ORDRSTATUS FROM ORDERSREESTR WHERE ORDRCODE='+ORDRCODE;
//    ibsOrd.ExecQuery;
//    if (ibsOrd.Bof and ibsOrd.Eof) then Exit;
//    Status:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger;
//    ibsOrd.Close;
    if not (Status in [orstAccepted..orstClosed]) then Exit;
    i:= 0;
    ibsOrd.SQL.Text:= 'select * from OrdersClosingDocs'+
                      ' where OCDOrderCode='+ORDRCODE+' order by OCDACCCODE';
    ibsOrd.ExecQuery;
    while not ibsOrd.Eof do begin
      SetLength(Accounts, i+1);
      SetLength(Invoices, i+1);
      with Accounts[i] do begin // заносим данные счета в структуру
        ID          := ibsOrd.FieldByName('OCDAccCode').AsInteger;
        Number      := ibsOrd.FieldByName('OCDAccNumber').AsString;
        Data        := ibsOrd.FieldByName('OCDAccDate').AsDateTime;
        Summa       := ibsOrd.FieldByName('OCDAccSumm').AsFloat;
        CurrencyCode:= ibsOrd.FieldByName('OCDAccCrnc').AsInteger;
        CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
        Processed   := GetBoolGB(ibsOrd, 'OCDAccPROCESSED');
        Commentary  := ibsOrd.FieldByName('OCDAccCOMMENT').AsString;
        DprtID      := ibsOrd.FieldByName('OCDAccDprt').AsInteger;
      end;
      with Invoices[i] do begin // заносим данные накладной в структуру
        ID:= ibsOrd.FieldByName('OCDInvCODE').AsInteger;
        if ID>0 then begin        // проверяем, закрыт ли счет
          Number      := ibsOrd.FieldByName('OCDInvNUMBER').AsString;
          Data        := ibsOrd.FieldByName('OCDInvDATE').AsDateTime;
          Summa       := ibsOrd.FieldByName('OCDInvSUMM').AsFloat;
          CurrencyCode:= ibsOrd.FieldByName('OCDInvCRNC').AsInteger;
          CurrencyName:= Cache.GetCurrName(CurrencyCode, True);
          DprtID      := ibsOrd.FieldByName('OCDInvDPRT').AsInteger;
        end else Number:= '';
        Closed:= Closed and (ID>0);
      end;
      inc(i);
      cntsORD.TestSuspendException;
      ibsOrd.Next;
    end;

    Annulated:= i<1; // если не найдены счета - аннулируем заказ
    if Annulated then Closed:= False;
    i:= 0;
    if (Annulated and (Status<>orstAnnulated)) then i:= orstAnnulated   // если все счета аннулированы, аннулируем заказ
    else if (Closed and (Status<>orstClosed)) then i:= orstClosed       // если все счета закрыты, закрываем заказ
    else if (not Closed and (Status=orstClosed)) then i:= orstAccepted; // если не все счета закрыты, открываем заказ

    if i>0 then begin
      fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
      ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(i)+
        fnIfStr(i=orstAnnulated, ', ORDRANNULATEDATE="NOW",'+
          ' ORDRANNULATEREASON="Все '+fnGetGBDocName(docAccount, 1, 1)+' по заказу аннулированы."', '')+
        ' where ORDRCODE='+ORDRCODE;
      Result:= RepeatExecuteIBSQL(ibsOrd);
      if Result='' then Status:= i;
    end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//================================ пакетная проверка закрывающие док-тов заказов
procedure CheckClosingDocsAll(CompareTime: boolean=True);
const nmProc = 'CheckClosingDocsAll'; // имя процедуры/функции
var tbegin, tend, tt: TDateTime;
    i: Integer;
begin
  if not Cache.flCheckClosingDocs then Exit;
  tt:= StrToDate('01.01.2016');
           // время последней сверки закрывающих документов заказов
  tbegin:= Cache.GetConstItem(pcCheckClosingDocsTime).DateValue;
  if (tbegin<1) then tbegin:= tt;
  tend:= Now;

  if CompareTime then begin // интервал сверки закрывающих документов заказов в мин
    i:= Cache.GetConstItem(pcCheckClosDocsInterval).IntValue;
    if IncMinute(tbegin, i)>tend then Exit; // рано проверять
  end;

  if (tbegin>tt) then tbegin:= IncMinute(tbegin, -1); // запас 1 мин.
  CheckClosingDocsByPeriod(tbegin, tend);
end;
//===================== проверка закрывающие док-тов заказов за период изменений
procedure CheckClosingDocsByPeriod(tbegin, tend: TDateTime; flSaveTime: boolean=True; flalter: boolean=True);
const nmProc = 'CheckClosingDocsByPeriod'; // имя процедуры/функции
var ibGB, ibOrd, ibOrdw: TIBDatabase;
    ibsGB, ibsOrd, ibsOrdw, ibsOrda: TIBSQL;
    LocalStart: TDateTime;
    i, OrdCount, accCount, OrdCode, accCode, invCode, accInd, j, jj, EditCount,
      Status, iOrd: Integer;
    Accounts, Invoices: TDocRecArr;
    lstBlock, lstBlockG, errmess: TStringList;
    sCode, ss, s: String;
    OrdCodes, OrdStats, OrdAccs: Tai;
begin
  ibGB:= nil;
  ibsGB:= nil;
  ibsOrd:= nil;
  ibsOrdw:= nil;
  ibsOrda:= nil;
  ibOrd:= nil;
  ibOrdw:= nil;
  LocalStart:= now();
  OrdCount:= 0;
  EditCount:= 0;
  SetLength(Accounts, 10);
  SetLength(Invoices, 10);
  SetLength(OrdCodes, 1000);
  SetLength(OrdStats, Length(OrdCodes));
  SetLength(OrdAccs, Length(OrdCodes));
  lstBlock:= TStringList.Create;
  errmess:= TStringList.Create;
  lstBlockG:= TStringList.Create;
  try try
    ibGB:= cntsGRB.GetFreeCnt;
    ibOrd:= cntsORD.GetFreeCnt;
    ibOrdw:= cntsORD.GetFreeCnt;
    ibsOrda:= fnCreateNewIBSQL(ibOrd, 'ibsOrda_'+nmProc, -1, tpRead);
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, -1, tpRead, True);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpRead, True);

    if ((Date-tbegin)>1) then begin // новый день - проверяем "зависшие" счета
      ibsOrd.SQL.Text:= 'SELECT min(ORDRGBACCTIME) FROM ORDERSREESTR'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+
        ' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2016"'+
        ' and ORDRGBACCTIME<:tbegin';
      ibsOrd.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsOrd.ExecQuery;
      if not ibsOrd.Fields[0].IsNull and (ibsOrd.Fields[0].AsDateTime>0) then
        tbegin:= ibsOrd.Fields[0].AsDateTime;
      ibsOrd.Close;
    end;

    if flalter then begin //---------- коды заказов по альтер-таблице в Grossbee
      // вынимаем список кодов заказов с изменениями за период из Grossbee
      ibsGB.SQL.Text:= 'Select rOrderCode from'+
        ' Vlad_CSS_GetChangedOrderCodes(:tbegin, :tend)'; // order by rOrderCode
      ibsGB.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsGB.ParamByName('tend').AsDateTime  := tend;
      ibsGB.ExecQuery;
      jj:= 0;
      while not ibsGB.Eof do begin
        if High(OrdCodes)<jj then SetLength(OrdCodes, jj+1000);
        OrdCodes[jj]:= ibsGB.FieldByName('rOrderCode').AsInteger; // код заказа
        inc(jj);
        TestCssStopException;
        ibsGB.Next;
      end;
      ibsGB.Close;
      if Length(OrdCodes)>jj then SetLength(OrdCodes, jj);
      SetLength(OrdStats, Length(OrdCodes));
      SetLength(OrdAccs, Length(OrdCodes));

      ibsOrda.SQL.Text:= 'select ORDRGBACCCODE, ORDRSTATUS FROM ORDERSREESTR WHERE ORDRCODE=:ord';
      ibsOrda.Prepare;

    end else begin  // коды заказов из Order за период ORDRGBACCTIME
      ibsOrd.SQL.Text:= 'SELECT ORDRCODE, ORDRGBACCCODE, ORDRSTATUS FROM ORDERSREESTR'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2016"'+
        ' and ORDRGBACCTIME between :tbegin and :tend';  //  order by ORDRCODE
      ibsOrd.ParamByName('tbegin').AsDateTime:= tbegin;
      ibsOrd.ParamByName('tend').AsDateTime  := tend;
      ibsOrd.ExecQuery;
      jj:= 0;
      while not ibsOrd.Eof do begin
        if High(OrdCodes)<jj then begin
          SetLength(OrdCodes, jj+1000);
          SetLength(OrdStats, Length(OrdCodes));
          SetLength(OrdAccs, Length(OrdCodes));
        end;
        OrdCodes[jj]:= ibsOrd.FieldByName('ORDRCODE').AsInteger; // код заказа
        OrdStats[jj]:= ibsOrd.FieldByName('ORDRSTATUS').AsInteger; // статус заказа
        OrdAccs[jj]:= ibsOrd.FieldByName('ORDRGBACCCODE').AsInteger; // код счета
        inc(jj);
        TestCssStopException;
        ibsOrd.Next;
      end;
      ibsOrd.Close;
      if Length(OrdCodes)>jj then begin
        SetLength(OrdCodes, jj);
        SetLength(OrdStats, Length(OrdCodes));
        SetLength(OrdAccs, Length(OrdCodes));
      end;
    end;
    TestCssStopException;
    OrdCount:= Length(OrdCodes);

    if OrdCount>0 then begin //------------------- если есть заказы для проверки
      ibsOrd.SQL.Text:= 'select * from OrdersClosingDocs'+
                        ' where OCDOrderCode=:ord order by OCDACCCODE';
      ibsOrd.Prepare;
      ibsGB.SQL.Text:= 'select d.*, PIAVORDCODE from Vlad_CSS_GetAllClosingDocs(:acc) d'+
        ' left join PAYINVALTER_VLAD on PIAVACCCODE=d.PInvCode'+
        ' where d.PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
      ibsGB.Prepare;

      jj:= 0;
      for iOrd:= 0 to High(OrdCodes) do begin
        OrdCode:= OrdCodes[iOrd]; // код заказа

        if flalter then begin
          TestCssStopException;
          ibsOrda.ParamByName('ord').AsInteger:= OrdCode; // код 1-го счета по заказу
          ibsOrda.ExecQuery;
          accCode:= ibsOrda.FieldByName('ORDRGBACCCODE').AsInteger;
          Status:= ibsOrda.FieldByName('ORDRSTATUS').AsInteger;
          ibsOrda.Close;
        end else begin
          accCode:= OrdAccs[iOrd];
          Status:= OrdStats[iOrd];
        end;

        TestCssStopException;
        ibsGB.ParamByName('acc').AsInteger:= accCode;
        ibsGB.ExecQuery;
        accCount:= 0; //------------------------- док-ты по 1 заказу из Grossbee
        while not ibsGB.Eof do begin
          if High(Accounts)<accCount then begin
            SetLength(Accounts, accCount+10);
            SetLength(Invoices, accCount+10);
          end;
          with Accounts[accCount] do begin // заносим данные счета в структуру
            ID          := ibsGB.FieldByName('PInvCode').AsInteger;
            Number      := ibsGB.FieldByName('PInvNumber').AsString;
            Data        := ibsGB.FieldByName('PInvDate').AsDateTime;
            Summa       := ibsGB.FieldByName('PInvSumm').AsFloat;
            CurrencyCode:= ibsGB.FieldByName('PInvCrnc').AsInteger;
            Processed   := GetBoolGB(ibsGB, 'PINVPROCESSED');
            Commentary  := CheckSpecSumbs(ibsGB.FieldByName('PINVCOMMENT').AsString);
            DprtID      := ibsGB.FieldByName('PInvDprt').AsInteger;
          end;
          with Invoices[accCount] do begin // заносим данные накладной в структуру
            ID          := ibsGB.FieldByName('INVCODE').AsInteger;
            if (ID>0) then begin
              Number      := ibsGB.FieldByName('INVNUMBER').AsString;
              Data        := ibsGB.FieldByName('INVDATE').AsDateTime;
              Summa       := ibsGB.FieldByName('INVSUMM').AsFloat;
              CurrencyCode:= ibsGB.FieldByName('INVCRNC').AsInteger;
              DprtID      := ibsGB.FieldByName('INVDPRT').AsInteger;
            end;
          end;

          if ibsGB.FieldByName('PIAVORDCODE').AsInteger<1 then // список для записи кода заказа
            lstBlockG.Add('execute procedure Vlad_CSS_SetAlterAccount('+
              ibsGB.FieldByName('PInvCode').AsString+', 0, '+IntToStr(OrdCode)+', 2);');

          Inc(accCount);
          TestCssStopException;
          ibsGB.Next;
        end; //--------------------------- док-ты по 1 заказу из Grossbee
        ibsGB.Close;

        lstBlock.Clear;  // строки изменений по 1 заказу для execute block
        ibsOrd.Close;
        ibsOrd.ParamByName('ord').AsInteger:= OrdCode;
        ibsOrd.ExecQuery;
        while not ibsOrd.Eof do begin //---- проверяем док-ты по 1 заказу из Order
          accCode:= ibsOrd.FieldByName('OCDAccCode').AsInteger;
          invCode:= ibsOrd.FieldByName('OCDInvCODE').AsInteger;
          sCode:= ' where OCDCODE='+ibsOrd.FieldByName('OCDCODE').AsString+';';
          accInd:= -1;
          if invCode>0 then for i:= 0 to accCount-1 do // сначала ищем строку с такой накладной
            if (Accounts[i].ID=accCode) and (Invoices[i].ID=invCode) then begin
              accInd:= i;
              break;
            end;
          if (accInd<0) then for i:= 0 to accCount-1 do // потом ищем строку без накладной
            if (Accounts[i].ID=accCode) and (Invoices[i].ID=0) then begin
              accInd:= i;
              break;
            end;

          if (accInd<0) then // если счета (с накладной/без накладной) в Grossbee нет
            lstBlock.Add('delete from OrdersClosingDocs'+sCode) // - удаляем строку

          else begin    // если строку нашли - сравниваем
            ss:= ''; // строка изменений по 1 счету
            with Accounts[accInd] do begin
              if Number<>ibsOrd.FieldByName('OCDAccNumber').AsString then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccNumber='+fnStrQuoted(Number);
              if Data<>ibsOrd.FieldByName('OCDAccDate').AsDateTime then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDate='+
                     fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDAccSumm').AsFloat) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccSumm='+fnSetDecSep(FloatToStr(Summa), 3);
              if CurrencyCode<>ibsOrd.FieldByName('OCDAccCrnc').AsInteger then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCrnc='+IntToStr(CurrencyCode);
              if Processed<>GetBoolGB(ibsOrd, 'OCDAccPROCESSED') then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccPROCESSED='+
                     fnStrQuoted(fnIfStr(Processed, 'T', 'F'));
              if DprtID<>ibsOrd.FieldByName('OCDAccDprt').AsInteger then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccDprt='+IntToStr(DprtID);
              if Commentary<>CheckSpecSumbs(ibsOrd.FieldByName('OCDAccCOMMENT').AsString) then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDAccCOMMENT='+fnStrQuoted(Commentary);
              ID:= 0; // счет из Grossbee проверен - обнуляем код
            end;

            with Invoices[accInd] do if (ID>0) then begin // есть есть накладная - проверяем
              if ID<>invCode then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE='+IntToStr(ID);
              if Number<>ibsOrd.FieldByName('OCDInvNUMBER').AsString then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER='+fnStrQuoted(Number);
              if Data<>ibsOrd.FieldByName('OCDInvDATE').AsDateTime then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE='+
                     fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
              if fnNotZero(Summa-ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM='+fnSetDecSep(FloatToStr(Summa), 3);
              if CurrencyCode<>ibsOrd.FieldByName('OCDInvCRNC').AsInteger then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC='+IntToStr(CurrencyCode);
              if DprtID<>ibsOrd.FieldByName('OCDInvDPRT').AsInteger then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT='+IntToStr(DprtID);

            end else if invCode>0 then begin // если нет и была накладная в Order - убираем
              ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCODE=0';
              if ibsOrd.FieldByName('OCDInvNUMBER').AsString<>'' then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvNUMBER=""';
              if not ibsOrd.FieldByName('OCDInvDATE').IsNull then
                ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDATE=null';
              if fnNotZero(ibsOrd.FieldByName('OCDInvSUMM').AsFloat) then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvSUMM=0';
              if ibsOrd.FieldByName('OCDInvCRNC').AsInteger>0 then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvCRNC=0';
              if ibsOrd.FieldByName('OCDInvDPRT').AsInteger>0 then
                 ss:= ss+fnIfStr(ss='', '', ', ')+'OCDInvDPRT=0';
            end;
            if ss<>'' then begin
              lstBlock.Add(' if (exists(select * from ordersreestr where ordrcode='+IntToStr(OrdCode)+')) then');
              lstBlock.Add('   update OrdersClosingDocs set '+ss+sCode);
            end;
          end;
          TestCssStopException;
          ibsOrd.Next;
        end; //--------------------- док-ты по 1 заказу из Order
        ibsOrd.Close;
{
        if (accCount<1) and (Status<orstAnnulated) then // если не найдены счета - аннулируем заказ
          lstBlock.Add('update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstAnnulated)+','+
            ' ORDRANNULATEREASON="Все счета по заказу аннулированы.",'+
            ' ORDRANNULATEDATE="NOW" where ORDRCODE='+IntToStr(OrdCode)+';')

         else if (accCount>0) and (Status=orstAnnulated) then // если найдены счета - восстанавливаем заказ
          lstBlock.Add('update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstClosed)+','+
            ' ORDRANNULATEREASON="", ORDRANNULATEDATE=null where ORDRCODE='+IntToStr(OrdCode)+';');
}
        for i:= 0 to accCount-1 do if Accounts[i].ID>0 then begin // ищем счета, кот.не хватает
          ss:= ' insert into OrdersClosingDocs (OCDOrderCode, OCDAccCode, OCDAccNumber,'+
            ' OCDAccDate, OCDAccCrnc, OCDAccSumm, OCDAccPROCESSED, OCDAccDprt, OCDAccCOMMENT'+
            fnIfStr(Invoices[i].ID<1, '', ', OCDInvCODE, OCDInvNUMBER,'+
              ' OCDInvDPRT, OCDInvCRNC, OCDInvSUMM, OCDInvDATE')+
            ') values ('+IntToStr(OrdCode)+', ';

          with Accounts[i] do ss:= ss+IntToStr(ID)+', '+fnStrQuoted(Number)+', '+
            fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data))+', '+
            IntToStr(CurrencyCode)+', '+fnSetDecSep(FloatToStr(Summa), 3)+', '+
            fnStrQuoted(fnIfStr(Processed, 'T', 'F'))+', '+
            IntToStr(DprtID)+', '+fnStrQuoted(Commentary);

          if Invoices[i].ID>0 then with Invoices[i] do ss:= ss+', '+IntToStr(ID)+', '+
            fnStrQuoted(Number)+', '+IntToStr(DprtID)+', '+IntToStr(CurrencyCode)+', '+
            fnSetDecSep(FloatToStr(Summa), 3)+', '+
            fnStrQuoted(FormatDateTime(cDateTimeFormatY4S, Data));
          ss:= ss+');';
          lstBlock.Add(' if (exists(select * from ordersreestr where ordrcode='+IntToStr(OrdCode)+')) then');
          lstBlock.Add(ss);
        end;
        TestCssStopException;

        if lstBlock.Count>0 then try  // вносим изменения в таблицу OrdersClosingDocs
          if not Assigned(ibsOrdw) then  // создаем только при необходимости
            ibsOrdw:= fnCreateNewIBSQL(ibOrdw, 'ibsOrdw_'+nmProc, -1, tpWrite); // для записи
          lstBlock.Insert(0, 'execute block as begin ');
          lstBlock.Add(' end');
          with ibsOrdw.Transaction do if not InTransaction then StartTransaction;
          ibsOrdw.SQL.Clear;
          ibsOrdw.SQL.AddStrings(lstBlock);
          ibsOrdw.ExecQuery;
          ibsOrdw.Transaction.Commit;
          Inc(EditCount);
        except
          on E: Exception do begin
            ibsOrdw.Transaction.Rollback;
            flSaveTime:= False;
            prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogCache, false);
            if flTestDocs then for j:= 0 to lstBlock.Count-1 do errmess.Add(lstBlock[j]);
          end;
        end;
        if Assigned(ibsOrdw) then ibsOrdw.Close;

        if jj>100 then begin // вывод процесса в лог
          jj:= 0;
          if flTestDocs then prMessageLOGS(nmProc+': '+IntToStr(iOrd+1)+
            ' зак., изм - '+IntToStr(EditCount), fLogDebug, false);
          Application.ProcessMessages;
        end else inc(jj);

        TestCssStopException;
      end; // for iOrd

      jj:= lstBlockG.Count;
      if lstBlockG.Count>0 then fnSetTransParams(ibsGB.Transaction, tpWrite, True);
      ibsGB.SQL.Clear;
      for i:= lstBlockG.Count-1 downto 0 do begin
        ibsGB.SQL.Add(lstBlockG[i]);
        lstBlockG.Delete(i);
        if (i=0) or (ibsGB.SQL.Count>99) then begin
          try  // вносим изменения в таблицу PAYINVALTER_VLAD
            with ibsGB.Transaction do if not InTransaction then StartTransaction;
            ibsGB.SQL.Insert(0, 'execute block as begin ');
            ibsGB.SQL.Add(' end');
            ibsGB.ExecQuery;
            ibsGB.Transaction.Commit;
          except
            on E: Exception do begin
              ibsGB.Transaction.Rollback;
              flSaveTime:= False;
              prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogCache, false);
              if flTestDocs then for j:= 0 to lstBlockG.Count-1 do errmess.Add(lstBlockG[j]);
            end;
          end;
          ibsGB.SQL.Clear;
        end; // if (i=0) or
        TestCssStopException;
      end; // for i:= lstBlockG.Count
      if flTestDocs then
        prMessageLOGS(nmProc+': кодов зак. в Gr - '+IntToStr(jj), fLogDebug, false);

    end else  // if OrdCount>0
    if flTestDocs then
      prMessageLOGS(nmProc+': '+MessText(mtkNotFoundOrders)+' для сверки док-тов', fLogDebug, false);
  except
    on E: Exception do begin
      flSaveTime:= False;
      if flTestDocs then prMessageLOGS(nmProc+': '+E.Message, fLogDebug, false);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
  finally
    prFreeIBSQL(ibsOrd);
    cntsOrd.SetFreeCnt(ibOrd);
    prFreeIBSQL(ibsOrdw);
    prFreeIBSQL(ibsOrda);
    cntsOrd.SetFreeCnt(ibOrdw);
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    SetLength(Accounts, 0);
    SetLength(Invoices, 0);
    SetLength(OrdCodes, 0);
    SetLength(OrdStats, 0);
    SetLength(OrdAccs, 0);
    prFree(lstBlock);
    prFree(lstBlockG);
    if flSaveTime then begin // пишем время сверки закрывающих документов
      i:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
      s:= FormatDateTime(cDateTimeFormatY4S, tend);
      Cache.SaveNewConstValue(pcCheckClosingDocsTime, i, s);
    end;
    prMessageLOGS(nmProc+': '+IntToStr(OrdCount)+
      ' зак, '+IntToStr(EditCount)+' изм - '+GetLogTimeStr(LocalStart), fLogCache, false);
    if flTestDocs then                  // если были ошибки - пишем в лог
      for j:= 0 to errmess.Count-1 do prMessageLOGS(errmess[j], fLogDebug, false);
    prFree(errmess);
  end;
  TestCssStopException;
end;
(*
//======== заполнить таблицу закр.док-тов и проставить коды заказов закр.док-там
procedure FillOrdersClosingDocs(FirstRecs: Integer=0);
const nmProc = 'FillOrdersClosingDocs'; // имя процедуры/функции
var ibGB, ibOrd, ibGBr, ibOrdr: TIBDatabase;
    ibsGB, ibsOrd, ibsGBr, ibsOrdr: TIBSQL;
    iDocs, iAcc, j, iCount, iAnul: Integer;
    flInv, flAnul: Boolean;
    lstBlock: TStringList;
    LocalStart, dLast, dAnul: TDateTime;
    sInv1, sInv2: String;
begin
  ibsGB:= nil;
  ibsOrd:= nil;
  ibsGBr:= nil;
  ibsOrdr:= nil;
//  ibGB:= nil;
//  ibOrd:= nil;
  lstBlock:= TStringList.Create;
  iDocs:= 0; // счетчик строк док-тов
  iAcc:= 0; // счетчик счетов, у кот. проставлен код заказа
  iAnul:= 0; // счетчик аннулированных заказов
  LocalStart:= now();
  try
    ibOrdr:= cntsORD.GetFreeCnt;
    try
      ibsOrdr:= fnCreateNewIBSQL(ibOrdr, 'ibsOrdr_'+nmProc, -1, tpRead, True);
      ibsOrdr.SQL.Text:= 'SELECT'+fnIfStr(FirstRecs>0, ' first '+IntToStr(FirstRecs), '')+
        ' ORDRCODE, ORDRGBACCCODE, ORDRGBACCTIME FROM ORDERSREESTR'+
        ' left join OrdersClosingDocs on OCDOrderCode=ORDRCODE'+
        ' WHERE ORDRSTATUS>'+IntToStr(orstProcessing)+' and ORDRSTATUS<'+IntToStr(orstAnnulated)+
        ' and ORDRGBACCCODE>0 and ORDRGBACCTIME>"01.01.2011" and OCDOrderCode is null'+
        ' order by ORDRCODE';
      ibsOrdr.ExecQuery;
      if (ibsOrdr.Eof and ibsOrdr.Bof) then begin
        if flTest then prMessageLOGS(nmProc+': '+MessText(mtkNotFoundOrders)+' без документов', fLogDebug, false);
        Exit;
      end;

      ibGBr:= cntsGRB.GetFreeCnt;
      ibGB:= cntsGRB.GetFreeCnt;
      ibOrd:= cntsORD.GetFreeCnt;
      try
        ibsGBr:= fnCreateNewIBSQL(ibGBr, 'ibsGBr_'+nmProc, -1, tpRead, True);
        ibsGB := fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpWrite);   // для записи
        ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, -1, tpWrite); // для записи
        j:= 0;
        while not ibsOrdr.Eof do begin //------------ идем по списку заказов
              // вынимаем список закрывающих док-тов по 1 заказу из Grossbee
          ibsGBr.SQL.Text:= 'select d.*, PIAVLASTTIME, PIAVORDCODE, IAVLASTTIME'+
            ' from Vlad_CSS_GetAllClosingDocs('+ibsOrdr.FieldByName('ORDRGBACCCODE').AsString+') d'+
            ' left join PAYINVALTER_VLAD on PIAVACCCODE=d.PInvCode'+
            ' left join INVOICEALTER_VLAD on IAVINVCODE=d.InvCODE'+
            ' where PINVANNULKEY="F" and d.PInvDprt>0'; // аннулированные счета пропускаем
          ibsGBr.ExecQuery;
          lstBlock.Clear;
          iCount:= 0; // счетчик счетов по 1 заказу
          while not ibsGBr.Eof do begin
            flInv:= ibsGBr.FieldByName('InvCODE').AsInteger>0;
                                // вычисляем последнее время изменений
            dLast:= max(ibsGBr.FieldByName('PIAVLASTTIME').AsDateTime,
                        ibsOrdr.FieldByName('ORDRGBACCTIME').AsDateTime);
            if flInv then
              dLast:= max(dLast, ibsGBr.FieldByName('IAVLASTTIME').AsDateTime);
                                   // список для записи кода заказа
            if ibsGBr.FieldByName('PIAVORDCODE').AsInteger<1 then
              lstBlock.Add('execute procedure Vlad_CSS_SetAlterAccount('+
                ibsGBr.FieldByName('PInvCode').AsString+', 0, '+
                ibsOrdr.FieldByName('ORDRCODE').AsString+', 2);');

            try     //---------------------- пишем строку с док-тами в Ord
              with ibsOrd.Transaction do if not InTransaction then StartTransaction;
              if flInv then begin
                sInv1:= ', OCDInvCODE, OCDInvNUMBER, OCDInvDPRT,'+
                        ' OCDInvCRNC, OCDInvSUMM, OCDInvDATE';
                sInv2:= ', '+ibsGBr.FieldByName('InvCODE').AsString+', :InvNUMBER, '+
                        ibsGBr.FieldByName('InvDPRT').AsString+', '+
                        ibsGBr.FieldByName('InvCRNC').AsString+', :InvSUMM, :InvDATE';
              end else begin
                sInv1:= '';
                sInv2:= '';
              end;
              ibsOrd.SQL.Text:= 'insert into OrdersClosingDocs (OCDOrderCode,'+
                ' OCDAccCode, OCDAccNumber, OCDAccDate, OCDAccCrnc, OCDAccSumm,'+
                ' OCDAccPROCESSED, OCDAccDprt, OCDAccCOMMENT, OCDTIMEADD'+sInv1+
                ') values ('+ibsOrdr.FieldByName('ORDRCODE').AsString+', '+
                ibsGBr.FieldByName('PInvCode').AsString+', :AccNumber, :AccDate, '+
                ibsGBr.FieldByName('PInvCrnc').AsString+','+' :AccSumm, :AccPROCESSED, '+
                ibsGBr.FieldByName('PInvDprt').AsString+', :AccCOMMENT, :OCDTIME'+sInv2+')';
              ibsOrd.ParamByName('AccNumber').AsString   := ibsGBr.FieldByName('PInvNumber').AsString;
              ibsOrd.ParamByName('AccDate').AsDateTime   := ibsGBr.FieldByName('PInvDate').AsDateTime;
              ibsOrd.ParamByName('AccSumm').AsFloat      := ibsGBr.FieldByName('PInvSumm').AsFloat;
              ibsOrd.ParamByName('AccPROCESSED').AsString:= ibsGBr.FieldByName('PINVPROCESSED').AsString;
              ibsOrd.ParamByName('AccCOMMENT').AsString  := ibsGBr.FieldByName('PInvCOMMENT').AsString;
              ibsOrd.ParamByName('OCDTIME').AsDateTime   := dLast;
              if flInv then begin
                ibsOrd.ParamByName('InvNUMBER').AsString := ibsGBr.FieldByName('InvNUMBER').AsString;
                ibsOrd.ParamByName('InvSUMM').AsFloat    := ibsGBr.FieldByName('InvSUMM').AsFloat;
                ibsOrd.ParamByName('InvDATE').AsDateTime := ibsGBr.FieldByName('InvDATE').AsDateTime;
              end;
              ibsOrd.ExecQuery;
              ibsOrd.Transaction.Commit;
              Inc(iCount);
              Inc(iDocs);

              if j>100 then begin // вывод процесса в лог
                j:= 0;
                if flTest then prMessageLOGS(nmProc+': '+IntToStr(iDocs)+' док., '+
                  IntToStr(iAcc+lstBlock.Count)+' сч., '+IntToStr(iAnul)+' аннул.', fLogDebug, false);
                Application.ProcessMessages;
              end else inc(j);
            except
              on E: Exception do begin
                prMessageLOGS(nmProc+': insert into OrdersClosingDocs ORDRCODE='+
                  ibsOrdr.FieldByName('ORDRCODE').AsString+#10+E.Message, fLogDebug, false);
                ibsOrd.Transaction.Rollback;
              end;
            end;
            ibsOrd.Close;

            ibsGBr.Next;
          end;
          ibsGBr.Close; // прошли список закрывающих док-тов по 1 заказу из Grossbee

          if lstBlock.Count>0 then try  // проставляем код заказа счетам в альтер-таблице Grossbee
            Inc(iAcc, lstBlock.Count);
            lstBlock.Insert(0, 'execute block as begin');
            lstBlock.Add('end');
            with ibsGB.Transaction do if not InTransaction then StartTransaction;
            ibsGB.SQL.Clear;
            ibsGB.SQL.AddStrings(lstBlock);
            ibsGB.ExecQuery;
            ibsGB.Transaction.Commit;
          except
            on E: Exception do begin
              prMessageLOGS(nmProc+': execute block '+#10+E.Message, fLogDebug, false);
              ibsGB.Transaction.Rollback;
            end;
          end;
          ibsGB.Close;

          if (iCount<1) then begin                   // если счетов не нашли
            dAnul:= Now;
            ibsGBr.SQL.Text:= 'select PInvAnnulDate, PInvAnnulKey from PAYINVOICEREESTR'+
                              ' where PInvCode='+ibsOrdr.FieldByName('ORDRGBACCCODE').AsString;
            ibsGBr.ExecQuery;        // проверяем аннуляцию связанного счета
            flAnul:= (ibsGBr.Bof and ibsGBr.Eof);
            if not flAnul and (ibsGBr.FieldByName('PInvAnnulKey').AsString='T') then begin
              flAnul:= True;
              if not ibsGBr.FieldByName('PInvAnnulDate').IsNull then begin // дата аннуляции
                dAnul:= ibsGBr.FieldByName('PInvAnnulDate').AsDateTime;
                if (YearOf(dAnul)<2000) then dAnul:= Now; // на всяк.случай
              end;
            end;
            if flAnul then try                               // аннулируем заказ
              with ibsOrd.Transaction do if not InTransaction then StartTransaction;
              ibsOrd.SQL.Text:= 'update ORDERSREESTR set ORDRSTATUS='+IntToStr(orstAnnulated)+
                ', ORDRANNULATEREASON=:anulREASON, ORDRANNULATEDATE=:anulDate'+
                ' where ORDRCODE='+ibsOrdr.FieldByName('ORDRCODE').AsString;
              ibsOrd.ParamByName('anulREASON').AsString:= 'Все счета по заказу аннулированы.';
              ibsOrd.ParamByName('anulDate').AsDateTime:= dAnul;
              ibsOrd.ExecQuery;
              ibsOrd.Transaction.Commit;
              Inc(iAnul);
            except
              on E: Exception do begin
                prMessageLOGS(nmProc+': update ORDERSREESTR '+#10+E.Message, fLogDebug, false);
                ibsOrd.Transaction.Rollback;
              end;
            end;
            ibsGBr.Close;
          end;
          cntsOrd.TestSuspendException;
          ibsOrdr.Next;
        end;
      finally
        prFreeIBSQL(ibsOrd);
        cntsOrd.SetFreeCnt(ibOrd);
        prFreeIBSQL(ibsGB);
        cntsGRB.SetFreeCnt(ibGB);
        prFreeIBSQL(ibsGBr);
        cntsGRB.SetFreeCnt(ibGBr);
      end;
    finally
      prFreeIBSQL(ibsOrdr);
      cntsOrd.SetFreeCnt(ibOrdr);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+#10+E.Message, fLogDebug, false);
  end;
  prFree(lstBlock);
  if flTest then prMessageLOGS(nmProc+': '+IntToStr(iDocs)+
    ' док-тов, '+IntToStr(iAcc)+' сч., '+IntToStr(iAnul)+' аннул. - '+GetLogTimeStr(LocalStart), fLogDebug, false);
end;
*)
//================================= сформировать счет в Grossbee (главный склад)
procedure prOrderToGBn_Ord(Stream: TBoBMemoryStream; ThreadData: TThreadData; CreateMail: boolean=false);
const nmProc = 'prOrderToGBn_Ord'; // имя процедуры/функции
      nfdeadlock = 'deadlock';
var ORDRCODE, DCACCODE, i, TryCount, ErrCount, RecCount, FirmID,
      ORDRSOURCE, recCloseDocs, contID, ContSys, deliv, DprtID,
      DestID, ttID, smID, stID, accType, currID: integer;
    s, s1, ss2, s3, ss3, sc, Currency, DCACNUMBER, ErrorStr, ErrStr, STORAGE,
      STORAGEnew, ORDRFIRM, ORDRNUM, sAccCode, sORDRCODE, ErrTypeSys, wCode,
      WaresErrMess, sSysName, accLine, ss1: String;
    Success, ChangeStorage, ErrTransGB, flSaveCont, flCheckShipParams: boolean;
    accLines: TStringList;
    ibGB, ibGBt, ibOrd, ibOrdW: TIBDatabase;
    ibsGB, ibsOrd, ibsOrdW, ibsGBt: TIBSQL;
    price, Qty, AccSumm: Double;
    Ware: TWareInfo;
    Firma: TFirmInfo;
    LocalStart, dd, pDate: TDateTime;
    Contract: TContract;
{  //-------------------------------------------
  procedure SaveToLogTransInfo(emess, dop: string);
  var i: integer;
      s, ntr: string;
  begin
    i:= pos('concurrent transaction number is ', emess);
    if i<1 then exit;
    s:= '';
    ntr:= copy(emess, i+33, length(emess));
    for i:= 1 to length(ntr) do
      if SysUtils.CharInSet(ntr[i], ['0'..'9']) then s:= s+ntr[i] else break;
    if s='' then exit;
    try
      prMessageLOGS(' ', nfdeadlock, False);
      prMessageLOGS('E.Message: '+emess, nfdeadlock, False);
      prMessageLOGS('TransInfo (id='+s+') --------------- begin', nfdeadlock, False);
      if dop<>'' then prMessageLOGS('addi_info: '+dop, nfdeadlock, False);
      with ibsGBt.Transaction do if not InTransaction then StartTransaction;
      if ibsGBt.SQL.Text='' then begin
        ibsGBt.SQL.Text:= 'select T.mon$timestamp tr_begin, '+
          ' DATEDIFF(SECOND FROM T.mon$timestamp TO current_timestamp) tr_sec, '+
          ' A.mon$user tr_user, A.mon$remote_process tr_proc, '+
          ' cast( S.mon$sql_text as varchar (2400)) tr_sql from MON$TRANSACTIONS T'+
          ' left join MON$STATEMENTS S on S.mon$transaction_id = T.mon$transaction_id'+
          ' left join MON$ATTACHMENTS A on A.mon$attachment_id = T.mon$attachment_id'+
          ' where T.mon$transaction_id = :tid';
        ibsGBt.Prepare;
      end;
      ibsGBt.ParamByName('tid').AsString:= s;
      ibsGBt.ExecQuery;
      while not ibsGBt.Eof do begin
        prMessageLOGS('tr_begin='+ibsGBt.Fields[0].AsString+
          ', tr_sec='+ibsGBt.Fields[1].AsString+
          ', tr_user='+ibsGBt.Fields[2].AsString+
          ', tr_proc='+ibsGBt.Fields[3].AsString, nfdeadlock, False);
        prMessageLOGS('tr_sql='+ibsGBt.Fields[4].AsString, nfdeadlock, False);
        ibsGBt.Next;
      end;
      prMessageLOGS('TransInfo (id='+s+') --------------- end'#10#10, nfdeadlock, False);
    except
      on E: Exception do ErrorStr:= ErrorStr+#13#10'error SaveToLogTransInfo:'+E.Message;
    end;
    if ibsGBt.Transaction.InTransaction then ibsGBt.Transaction.Rollback;
    ibsGBt.Close;
  end;  }
  //-------------------------------------------
begin
  LocalStart:= now();
  ErrorStr:= '';   // сообщение о глобальной ошибке
  ErrStr:= '';     // сообщение об ошибках записи товаров
  ErrTypeSys:= ''; // сообщение о несоответствии систем
  ErrCount:= 0;
  RecCount:= 0;
  ErrTransGB:= False;
  ibsOrd:= nil;
  ibsOrdW:= nil;
  ibGB:= nil;
  ibOrd:= nil;
  ibsGB:= nil;
  ibsGBt:= nil;
  ibGBt:= nil;
  accLines:= TStringList.Create;
  contID:= 0;
  flSaveCont:= False;
  Contract:= nil;
  try try
    Stream.Position:= 0;
    ORDRCODE:= Stream.ReadInt;
    flCheckShipParams:= Stream.ReadBool;

    ibOrd:= cntsORD.GetFreeCnt;                           // тут всякие проверки
    ibOrdW:= cntsORD.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibOrd, 'ibsOrd_'+nmProc, ThreadData.ID, tpWrite);
    ibsOrdW:= fnCreateNewIBSQL(ibOrdW, 'ibsOrdW_'+nmProc, ThreadData.ID, tpRead, True);

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.SQL.Text:= 'SELECT ORDRACCOUNTINGTYPE, ORDRNUM, ORDRCODE, ORDRFIRM,'+
      ' ORDRSOURCE, ORDRDATE, ORDRWARRANT, ORDRWARRANTPERSON, ORDRWARRANTDATE,'+
      ' ORDRSTORAGECOMMENT, ORDRDELIVERYTYPE, ORDRCONTRACT, ORDRSHIPDATE,'+
      ' ORDRDESTPOINT, ORDRTIMETIBLE, ORDRSHIPMETHOD, ORDRSHIPTIMEID, ORDRCURRENCY'+
      ' FROM ORDERSREESTR WHERE ORDRCODE='+IntToStr(ORDRCODE);
    ibsOrdW.ExecQuery;
    if (ibsOrdW.Bof and ibsOrdW.Eof) then raise Exception.Create(MessText(mtkNotValidParam));

    FirmID:= ibsOrdW.FieldByName('ORDRFIRM').AsInteger; // проверяем фирму
    if (FirmID<1) then raise Exception.Create(MessText(mtkNotFirmExists));
    Cache.TestFirms(FirmID, True);
    if not Cache.FirmExist(FirmID) then raise Exception.Create(MessText(mtkNotFirmExists));

    ORDRFIRM:= IntToStr(FirmID);
    Firma:= Cache.arFirmInfo[FirmID];
    contID:= ibsOrdW.FieldByName('ORDRCONTRACT').AsInteger;
    i:= contID;
    Contract:= Firma.GetContract(contID);
    if (Contract.Status=cstClosed) then           // проверка на доступность контракта
      raise Exception.Create('Контракт '+Contract.Name+' недоступен');

    ContSys:= 0;
    sSysName:= '';
    accType:= ibsOrdW.FieldByName('ORDRACCOUNTINGTYPE').AsInteger;

    flSaveCont:= (contID>0) and (i<>contID) and not Contract.Fictive;
    DprtID:= Contract.MainStorage;
    STORAGE:= Contract.MainStoreStr;

    currID:= ibsOrdW.FieldByName('ORDRCURRENCY').AsInteger;
    if (currID<>Cache.BonusCrncCode) then
      if (Cache.GetConstItem(pcContractCurrencyFlag).IntValue=1) then
        currID:= Contract.DutyCurrency
      else if (accType=1) then currID:= cUAHCurrency
      else currID:= cDefCurrency;
    Currency:= IntToStr(currID);

    ORDRNUM:= ibsOrdW.FieldByName('ORDRNUM').AsString;
    sORDRCODE:= ibsOrdW.FieldByName('ORDRCODE').AsString;
    ORDRSOURCE:= ibsOrdW.FieldByName('ORDRSOURCE').AsInteger;
    pDate:= ibsOrdW.FieldByName('ORDRSHIPDATE').AsDateTime;
    DestID:= ibsOrdW.FieldByName('ORDRDESTPOINT').AsInteger;
    ttID:= ibsOrdW.FieldByName('ORDRTIMETIBLE').AsInteger;
    smID:= ibsOrdW.FieldByName('ORDRSHIPMETHOD').AsInteger;
    stID:= ibsOrdW.FieldByName('ORDRSHIPTIMEID').AsInteger;
    deliv:= ibsOrdW.FieldByName('ORDRDELIVERYTYPE').AsInteger;

//-------------------------------------------------------- формируем комментарий
    s1:= '';
    if (currID=cUAHCurrency) then begin
      ss2:= ibsOrdW.FieldByName('ORDRWARRANT').AsString;
      if ss2<>'' then ss2:= ' N'+ss2;
      dd:= ibsOrdW.FieldByName('ORDRWARRANTDATE').AsDateTime;
      if (YearOf(dd)<2000) then s3:= '' else s3:= ' от '+FormatDateTime(cDateFormatY4, dd);
      ss3:= ibsOrdW.FieldByName('ORDRWARRANTPERSON').AsString;
      if ss3<>'' then ss3:= ' Выдана '+ss3;
      if (ss2<>'') or (ss3<>'') or (s3<>'') then s1:= 'Доверенность'+ss2+s3+ss3+'. ';
    end;
    case deliv of
      cDelivTimeTable: s3:= 'Доставка. ';  // Доставка по расписанию
      cDelivSelfGet  : s3:= 'Самовывоз. '; // Самовывоз
      else begin
        if (deliv<>cDelivReserve) then deliv:= cDelivReserve;
        s3:= 'Резерв. ';    // Резерв
      end;
    end;
    sc:= ibsOrdW.FieldByName('ORDRSTORAGECOMMENT').AsString;
    ss3:= fnIfStr(sc='', '', sc+'. ')+s3+s1+'Зак. '+ORDRNUM+' от '+
          FormatDateTime(cDateFormatY4, ibsOrdW.FieldByName('ORDRDATE').AsDateTime)+'.';
    s1:= Copy(ss3, 1, Cache.AccWebCommLength);
    ibsOrdW.Close;
    ss3:= '';

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.SQL.Text:= 'SELECT ORDRLNWARE, sum(ORDRLNCLIENTQTY) as ORDRLNCLIENTQTY'+
      ' FROM ORDERSLINES where ORDRLNORDER='+sORDRCODE+' and ORDRLNCLIENTQTY>:p0'+
      ' group by ORDRLNWARE';
    ibsOrdW.Prepare;
    ibsOrdW.ParamByName('p0').AsFloat:= constDeltaZero;

    ibGBt:= cntsGRB.GetFreeCnt;
    ibGB:= cntsGRB.GetFreeCnt;
    ibsGBt:= fnCreateNewIBSQL(ibGBt, 'ibsGBt_'+nmProc, ThreadData.ID);
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, ThreadData.ID, tpWrite);

    with ibsOrdW.Transaction do if not InTransaction then StartTransaction;
    ibsOrdW.ExecQuery;
    if (ibsOrdW.Bof and ibsOrdW.Eof) then // если нет строк товаров - не пишем
      raise Exception.Create(MessText(mtkNotFoundWares));

//------------------------------------------------------- запись заголовка счета
    DCACCODE:= 0;
    Success:= false;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      STORAGEnew:= STORAGE;
      Application.ProcessMessages;
      with ibsGB.Transaction do if not InTransaction then StartTransaction;

      ibsGB.SQL.Text:= 'Select NewAccCode, NewAccNumber, NewDprtCode'+
        ' from Vlad_CSS_AddAccountHeaderC('+sORDRCODE+', 0, '+
        ORDRFIRM+', '+IntToStr(contID)+', '+STORAGE+', '+Currency+', :WEBCOMMENT)';
      ibsGB.ParamByName('WEBCOMMENT').AsString:= s1;
      ibsGB.ExecQuery; //---------------- запись строки заголовка в базу

      if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('NewAccCode IsEmpty')
      else if (ibsGB.FieldByName('NewAccCode').AsInteger<1)
        or (ibsGB.FieldByName('NewAccNumber').AsString='') then
        raise Exception.Create('NewAccCode<1 or empty NewAccNumber');

      DCACCODE:= ibsGB.FieldByName('NewAccCode').AsInteger;
      DCACNUMBER:= trim(ibsGB.FieldByName('NewAccNumber').AsString);
      STORAGEnew:= ibsGB.FieldByName('NewDprtCode').AsString; // получаем склад резервирования
      ChangeStorage:= STORAGE<>STORAGEnew; // проверяем изменение склада

      if ChangeStorage then try // если склад изменен - добавляем сообщение в комментарий
        ibsGB.Close;
        ibsGB.SQL.Text:= 'execute procedure Vlad_CSS_AddCommToAcc('+
                         IntToStr(DCACCODE)+', :CLIENTCOMMENT)';
        ibsGB.ParamByName('CLIENTCOMMENT').AsString:=
          'ВНИМАНИЕ! Склад резервирования изменен на склад по умолчанию.';
        ibsGB.ExecQuery;
      except
        on E: Exception do ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                           'Ошибка записи комментария клиенту в счет '+DCACNUMBER;
      end;

      if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
      ibsGB.Close;
      if ChangeStorage then begin // новый склад, если изменен
        STORAGE:= STORAGEnew;
        DprtID:= StrToInt(STORAGE);
      end;
      Success:= true;
      break;
    except
      on E: Exception do begin
//        if (Pos('deadlock', E.Message)>0) then SaveToLogTransInfo(E.Message, '');
        if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
        ibsGB.Close;
        if ErrorStr='' then ErrorStr:= 'Ошибка записи заголовка счета по заказу '+ORDRNUM;
        if (Pos('lock', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+CutLockMess(E.Message)
        else if (Pos('NewAcc', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+E.Message
        else begin
          ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
          break;
        end;
        if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval); // если deadlock, то ждем немного
      end;
    end;
    if not Success then
      raise Exception.Create('Ошибка записи заголовка счета по заказу '+ORDRNUM);

//------------------------------------------- записываем привязку заказа к счету
    with ibsOrd.Transaction do if not InTransaction then StartTransaction;
    ibsOrd.Close;
    ibsOrd.SQL.Text:= 'UPDATE ORDERSREESTR SET ORDRSTATUS='+IntToStr(orstAccepted)+
      ', ORDRGBACCCODE='+IntToStr(DCACCODE)+', ORDRGBACCNUMBER=:ACCNUMBER,'+
      fnIfStr(flSaveCont, ' ORDRCONTRACT='+IntToStr(contID)+',', '')+
      ' ORDRGBACCTIME="NOW" WHERE ORDRCODE='+sORDRCODE;
    ibsOrd.ParamByName('ACCNUMBER').AsString:= DCACNUMBER;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      Application.ProcessMessages;
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.ExecQuery;
      ibsOrd.Transaction.Commit;
      break;
    except
      on E: Exception do begin
        with ibsOrd.Transaction do if InTransaction then Rollback;
        if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
          Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
        else begin
          ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                     'Ошибка записи статуса в заказ '+sORDRCODE;
          break;
        end;
      end;
    end;
    ibsOrd.Close;
    sAccCode:= IntToStr(DCACCODE);

//------------------------------------------------ записываем параметры отгрузки
    ss1:= '';
    if flCheckShipParams then begin
      ss1:= CheckAccountShipParams(deliv, ContID, DprtID, pDate, DestID, ttID, smID, stID, True);
      if (ss1<>'') then ErrorStr:= ErrorStr+#13#10+ss1;
    end;

    if (deliv=cDelivTimeTable) and (ttID>0) then stID:= 0;  // Доставка по расписанию - код времени не пишем - УиК

    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      with ibsGB.Transaction do if not InTransaction then StartTransaction;
      ibsGB.SQL.Text:= 'Select ErrMess from Vlad_CSS_SetAccountShipParams('+
        sAccCode+', '+fnIfStr(pDate>DateNull, ':dd', 'null')+', '+IntToStr(DestID)+', '+
        IntToStr(ttID)+', '+IntToStr(smID)+', '+IntToStr(stID)+')';
      if (pDate>DateNull) then ibsGB.ParamByName('dd').AsDate:= pDate;
      ibsGB.ExecQuery;
      if (ibsGB.Bof and ibsGB.Eof) then
        raise Exception.Create('Error Vlad_CSS_SetAccountShipParams');
      ss1:= ibsGB.FieldByName('ErrMess').AsString;
      if (ss1<>'') then raise Exception.Create(ss1);
      if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Commit;
      ibsGB.Close;
      break;
    except
      on E: Exception do begin
        if ibsGB.Transaction.InTransaction then ibsGB.Transaction.Rollback;
        ibsGB.Close;
        if ErrorStr='' then ErrorStr:= 'Ошибка записи параметров отгрузки счета по заказу '+ORDRNUM;
        if (Pos('lock', E.Message)>0) then
          ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+CutLockMess(E.Message)
        else begin
          ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
          break;
        end;
        if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval); // если deadlock, то ждем немного
      end;
    end;
    ss1:= '';
//----------------------------------------- строка закрывающих док-тов без суммы
    recCloseDocs:= 0;
    with ibsOrd.Transaction do if not InTransaction then StartTransaction;
    ibsOrd.SQL.Text:= 'insert into OrdersClosingDocs (OCDOrderCode, OCDAccCode,'+
      ' OCDAccNumber, OCDAccDate, OCDAccCrnc, OCDAccDprt) values ('+sORDRCODE+', '+
      sAccCode+', :AccNumber, "TODAY", '+Currency+', '+STORAGE+') returning OCDCODE';
    ibsOrd.ParamByName('AccNumber').AsString:= DCACNUMBER;
    for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
      Application.ProcessMessages;
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.ExecQuery;
      if not (ibsOrd.Bof and ibsOrd.Eof) then
        recCloseDocs:= ibsOrd.FieldByName('OCDCODE').AsInteger;
      ibsOrd.Transaction.Commit;
      break;
    except
      on E: Exception do begin
        with ibsOrd.Transaction do if InTransaction then Rollback;
        recCloseDocs:= 0;
        if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
          Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
        else begin
          ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                     'Ошибка записи строки док-тов, счет '+IntToStr(DCACCODE);
          break;
        end;
      end;
    end;
    ibsOrd.Close;

    if Cache.flAccTimeToLog then begin
      ss3:= 'время записи заголовка - '+GetLogTimeStr(LocalStart);
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
    end;

    accLines.Clear;
//------------------------ записали заголовок счета - пишем строки товаров счета
    with ibsGB.Transaction do if not InTransaction then StartTransaction;
    ibsGB.SQL.Text:= 'select * from Vlad_CSS_AddAccLineC('+
      sAccCode+', '+STORAGE+', :LNWARECODE, :ORDRLNCLIENTQTY)';
    ibsGB.Prepare;
    while not ibsOrdW.EOF do begin
      Success:= false;
      try                             // проверяем товар
        Ware:= Cache.GetWare(ibsOrdW.FieldByName('ORDRLNWARE').AsInteger);
        wCode:= ibsOrdW.FieldByName('ORDRLNWARE').AsString;
        Qty:= ibsOrdW.FieldByName('ORDRLNCLIENTQTY').AsFloat;
                                    // убираем из наименования длинные пробелы
        ss1:= StringReplace(Ware.Name, StringOfChar(' ', 2), StringOfChar(' ', 1), [rfReplaceAll]);

        if (Ware=NoWare) or not Ware.IsMarketWare(FirmID, contID) then
          raise Exception.Create('Ошибка записи товара в счет: '+ // сообщение в письмо
            fnIfStr(Ware=NoWare, 'код '+wCode, ss1)+', заказ - '+FormatFloat('# ##0', Qty));

        if not Ware.CheckWareTypeSys(ContSys) then begin // проверяем соответствие систем
          if ErrTypeSys='' then ErrTypeSys:= 'НЕ записаны в '+fnGetGBDocName(docAccount, 1, 0, 4)+
            ' товары, недоступные бизнес-направлению '+sSysName+':';
          ErrTypeSys:= ErrTypeSys+#13#10'  '+ss1+', заказ - '+FormatFloat('# ##0', Qty);
          raise Exception.Create('');
        end;

        with ibsGB.Transaction do if not InTransaction then StartTransaction;
        ibsGB.ParamByName('LNWARECODE').AsInteger   := Ware.ID;
        ibsGB.ParamByName('ORDRLNCLIENTQTY').AsFloat:= Qty;

        for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
          Application.ProcessMessages;
          with ibsGB.Transaction do if not InTransaction then StartTransaction;
          ibsGB.ExecQuery; // записываем строку
          if (ibsGB.Bof and ibsGB.Eof) then
            raise Exception.Create('NewLineCode IsEmpty');
          if (ibsGB.Fields[0].AsInteger<1) then
            raise Exception.Create('NewLineCode = '+ibsGB.Fields[0].AsString);

          if fnNotZero(ibsGB.FieldByName('ResQty').AsFloat-Qty) then begin // проверка пересчета кол-ва
            Qty:= ibsGB.FieldByName('ResQty').AsFloat; // фактическое кол-во
            ss3:= 'товар '+ss1+': заказ '+ibsOrdW.FieldByName('ORDRLNCLIENTQTY').AsString+
              ' пересчитан по кратности на '+ibsGB.FieldByName('ResQty').AsString;
            ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
            WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
          end;

          price:= ibsGB.FieldByName('ResPrice').AsFloat;
          if not fnNotZero(price) then // проверка 0-й цены
            ErrStr:= fnIfStr(ErrStr='', '', ErrStr+#13#10)+'товар '+ss1+' записан с 0-й ценой';

          accLine:= fnMakeAddCharStr(ss1, 40, True)+
                    fnMakeAddCharStr(ibsGB.FieldByName('ResQty').AsString, 10)+
                    fnMakeAddCharStr(FormatFloat('# ##0.00', price), 10);

          with ibsGB.Transaction do if InTransaction then Commit;
          ibsGB.Close;

          accLines.Add(accLine);
          Success:= true;
          Break;
        except
          on E: Exception do begin
//            if (Pos('deadlock', E.Message)>0) then SaveToLogTransInfo(E.Message, '');
            with ibsGB.Transaction do if InTransaction then Rollback;
            ibsGB.Close;
            if (TryCount=1) then ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
              'Ошибка записи товара счета '+DCACNUMBER+' по заказу '+trim(ORDRNUM)+
              ', код '+wCode+' заказ - '+FormatFloat('# ##0', Qty);
            ss3:= '';
            if (Pos('lock', E.Message)>0) then ss3:= CutLockMess(E.Message)
            else if (pos('Order of ware more rest', E.Message)>0)
              or (pos('NewLineCode', E.Message)>0) then ss3:= E.Message;
            if ss3='' then begin
              ErrorStr:= ErrorStr+fnIfStr(E.Message='', '', #13#10+E.Message);
              break;
            end else
              ErrorStr:= ErrorStr+#13#10'(попытка '+IntToStr(TryCount)+'): '+ss3;
                                             // если deadlock, то ждем немного
            if (TryCount<accRepeatCount) then Sleep(RepeatSaveInterval);
          end;
        end;

        if Success then begin
          i:= StrToIntDef(STORAGE, 0); // снимаем с остатка в кеше
          if i>0 then Cache.CheckWareRest(Ware.RestLinks, i, Qty, True);

        end else begin
          ss3:= 'Ошибка записи товара в '+fnGetGBDocName(docAccount, 1, 0, 4)+': '+
            fnIfStr(Ware=NoWare, 'код '+wCode, ss1)+', заказ - '+FormatFloat('# ##0', Qty);
          if Ware<>NoWare then
            WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ss3;
          raise Exception.Create(ss3); // сообщение в письмо
        end;

      except
        on E: Exception do begin
          with ibsGB.Transaction do if InTransaction then Rollback;
          if E.Message<>'' then
            ErrStr:= fnIfStr(ErrStr='', '', ErrStr+#13#10)+E.Message;
          inc(ErrCount);
        end;
      end;
      ibsOrdW.Next;
      inc(RecCount);
    end; // while not ibsOrdW.EOF
    ibsOrdW.Close;
    ibsGB.Close;

//---------------------------- записали товары - проверяем ошибки записи товаров
    Success:= true;
    if ErrCount>0 then begin
      if ErrTypeSys<>'' then begin // товары другого бизнес-направления
        ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ErrTypeSys;
        WaresErrMess:= WaresErrMess+fnIfStr(WaresErrMess='', '', #13#10)+ErrTypeSys;
      end;
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+'Ошибка записи товаров в счет '+
        DCACNUMBER+' - '+IntToStr(ErrCount)+' поз.';
      Success:= (ErrCount<RecCount);
    end;
    if not Success then try                        // если все не записались
      with ibsGB.Transaction do if not InTransaction then StartTransaction;
      ibsGB.SQL.Text:= 'execute procedure Vlad_CSS_AddCommToAcc(:CODE, :CLIENTCOMMENT)';
      ibsGB.ParamByName('CODE').AsString:= sAccCode;
      ibsGB.ParamByName('CLIENTCOMMENT').AsString:= ' - Ошибка записи товаров в '+fnGetGBDocName(docAccount, 1, 0, 4)+'.';
      ibsGB.ExecQuery;         // пишем в комментарий счета
      ibsGB.Transaction.Commit;
    except
      with ibsGB.Transaction do if InTransaction then Rollback;
    end;
    if Cache.flAccTimeToLog then begin
      ss3:= 'время записи счета     - '+GetLogTimeStr(LocalStart);
      ErrStr:= ErrStr+fnIfStr(ErrStr='', '', #13#10)+ss3;
    end;

//---------------------------------------- записали счет - проверяем сумму счета
    ibsGBt.Close;
    with ibsGBt.Transaction do if not InTransaction then StartTransaction;
    ibsGBt.SQL.Text:= 'SELECT r.PInvSumm aSUMM, r.PInvDate aDATE,'+
      ' (select sum(pinvlnprice*pinvlncount) from PAYINVOICELINES'+
      '   where pinvlndocmcode=r.PInvCode) sumlines'+
      ' from PayInvoiceReestr r where r.PInvCode='+sAccCode;
    ibsGBt.ExecQuery;
    if (ibsGB.Bof and ibsGB.Eof) then raise Exception.Create('Not found aCODE='+sAccCode);
    ss1:= ibsGBt.FieldByName('aDATE').AsString;
    AccSumm:= ibsGBt.FieldByName('aSUMM').AsFloat;
    price:= ibsGBt.FieldByName('sumlines').AsFloat;
    ibsGBt.Close;
    ibsGBt.SQL.Text:= '';

//-------------------------------- если unit-счет - добавляем к unit-резерву к/а
    if (currID=Cache.BonusCrncCode) then firma.BonusRes:= firma.BonusRes+AccSumm;

//------------------------------------- пишем сумму в строку закрывающих док-тов
    if recCloseDocs>0 then begin
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.SQL.Text:= 'update OrdersClosingDocs set OCDAccSumm=:AccSumm'+
                        ' where OCDCODE='+IntToStr(recCloseDocs);
      ibsOrd.ParamByName('AccSumm').AsFloat:= AccSumm;
      for TryCount:= 1 to accRepeatCount do try // accRepeatCount попыток
        Application.ProcessMessages;
        with ibsOrd.Transaction do if not InTransaction then StartTransaction;
        ibsOrd.ExecQuery;
        ibsOrd.Transaction.Commit;
        break;
      except
        on E: Exception do begin
          with ibsOrd.Transaction do if InTransaction then Rollback;
          if (Pos('lock', E.Message)>0) and (TryCount<accRepeatCount) then
            Sleep(RepeatSaveInterval) // если deadlock, то ждем немного
          else begin
            ErrorStr:= fnIfStr(ErrorStr='', '', ErrorStr+#13#10)+
                       'Ошибка записи суммы в строку док-тов, счет '+IntToStr(DCACCODE);
            break;
          end;
        end;
      end; // for TryCount
      ibsOrd.Close;
    end; //  if recCloseDocs>0

//--------------------------------------------- отсылаем письмо о создании счета
    if CreateMail then begin
      s:= prSendMessAboutCreateAccount(ORDRCODE, DCACCODE, ORDRSOURCE,
        FirmID, contID, StrToInt(STORAGE), currID, ThreadData.ID,
        AccSumm, price, DCACNUMBER, ORDRNUM, ss1, ErrStr, accLines);
      if s<>'' then ErrorStr:= ErrorStr+fnIfStr(ErrorStr='', '', #13#10)+s;
    end; // if CreateMail

//---------------------------------------------------------------- ответ клиенту
    Stream.Clear;
    if WaresErrMess<>'' then begin // если были ошибки при записи товаров
      Stream.WriteInt(erWareToAccount);
      Stream.WriteStr(WaresErrMess);
    end else Stream.WriteInt(aeSuccess); // признак того, что запрос обработан корректно
  except
    on E: Exception do begin
      Stream.Clear;
      Stream.WriteInt(aeCommonError);
      Stream.WriteStr('Ошибка записи документа.');
      ErrorStr:= ErrorStr+fnIfStr(ErrorStr='', '', #13#10)+E.Message;
    end;
  end;
  finally
    if (ErrorStr<>'') or (ErrStr<>'') then
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, ErrorStr, ErrStr, '', false, 'error');
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
    prFreeIBSQL(ibsGBt);
    cntsGRB.SetFreeCnt(ibGBt);
    prFreeIBSQL(ibsOrd);
    cntsORD.SetFreeCnt(ibOrd);
    prFreeIBSQL(ibsOrdW);
    cntsORD.SetFreeCnt(ibOrdW);
    prFree(accLines);
    Stream.Position:= 0;
  end;
//  if ToLog(9) then prMessageLOGS(nmProc+': '+GetLogTimeStr(LocalStart), 'OrderToGB', false); // пишем в log
end;
//============================= отправить письмо о формировании счета в Grossbee
function prSendMessAboutCreateAccount(ORDRCODE, DCACCODE, ORDRSOURCE, FirmID,
         contID, storID, crnc, IDq: Integer; SumDoc, SumLines: Double;
         DCACNUMBER, ORDRNUM, sDate, ErrStr: string; accLines: TStringList): string;
const nmProc = 'prSendMessAboutCreateAccount'; // имя процедуры/функции
var i, j, FilID: integer;
    s, ss1, ss2, AccCode, attFile, SysAdr, sacc: string;
    Strings, Attachments: TStringList;
    arDprts: Tai;
    firma: TFirmInfo;
    Contract: TContract;
begin
  Result:= '';
  Strings:= nil;
  Attachments:= nil;
  setLength(arDprts, 0);
//  if flDebug and (ErrStr='') then ErrStr:= 'test/mail';
  with Cache do try try
    if not FirmExist(FirmID) then raise Exception.Create('Not correct FirmID');
    firma:= arFirmInfo[FirmID];

    Strings:= TStringList.Create;
    AccCode:= IntToStr(DCACCODE);
    attFile:= DirFileErr+'c'+ORDRNUM+'n'+DCACNUMBER+'.txt'; // имя файла строк счета
    if CurrExists(crnc) then s:= ' '+GetCurrName(crnc, True) else s:= '';
    sacc:= ' N '+DCACNUMBER+' от '+sDate;
    if (ErrStr>'') then ss2:= 'Ошибки записи счета'+sacc else ss2:= 'Создан счет'+sacc;

    Strings.Clear;
    Strings.Add('Системой автоматического приема заказов');
    Strings.Add('для контрагента '+firma.Name);
    Strings.Add('Создан счет'+sacc+' на сумму '+FormatFloat('# ##0.00', SumDoc)+s);
    if ORDRNUM<>'' then Strings.Add('( по заказу СВК N '+ORDRNUM+' )');
    // проверяем сумму счета
    if (abs(SumDoc-SumLines)>0.03) then begin // выводим в лог проблемные счета
      prMessageLOGS('---------- некорректный счет N '+DCACNUMBER+' от '+sDate, 'err_acc', false);
      prMessageLOGS('           контрагент= '+firma.Name, 'err_acc', false);
      prMessageLOGS('   сумма в реестре= '+FormatFloat('# ##0.00', SumDoc)+
        ', сумма по строкам= '+FormatFloat('# ##0.00', SumLines)+' ('+s+')', 'err_acc', false);
    end;

    FilID:= 0;
    if DprtExist(storID) then with arDprtInfo[storID] do begin  // склад резервирования
      FilID:= FilialID; // филиал резервирования
      Strings.Add(' склад резервирования: '+MainName);
    end;
    with firma do if (FilID>0) then begin
      Contract:= GetContract(contID);
      j:= 1;
      setLength(arDprts, j);
      arDprts[0]:= FilID; // филиал резервирования
      for i:= 0 to High(Contract.ContProcDprts) do begin // определяем доп.филиалы обработки счетов
        storID:= Contract.ContProcDprts[i];
        if not DprtExist(storID) then Continue;
        FilID:= arDprtInfo[storID].FilialID;
        if (fnInIntArray(FilID, arDprts)>-1) then Continue;
        setLength(arDprts, j+1);
        arDprts[j]:= FilID;
        inc(j);
      end;
    end;
    for i:= High(arDprts) downto 0 do begin // проверяем филиалы обработки счетов
      FilID:= arDprts[i];
      if DprtExist(FilID) then with arDprtInfo[FilID] do // филиал - отправлять только письма о счетах с ошибками
        if IsFilial and IsFilOnlyErr and (ErrStr='') then prDelItemFromArray(i, arDprts);
    end;

    if (Length(arDprts)<1) then Exit; // если некуда отправлять - выходим

    if (ErrStr>'') then Strings.Add(ErrStr); // ошибки записи товаров

    if (accLines.Count>0) then try
      s:= fnMakeAddCharStr('счет N '+DCACNUMBER+': товар', 40, True)+
        fnMakeAddCharStr('заказ', 10)+fnMakeAddCharStr('цена', 10);
      accLines.Insert(0, s);
      accLines.Insert(1, '');
      fnStringsLogToFile(accLines, attFile);
      Attachments:= TStringList.Create;
      Attachments.Add(attFile);
    except
      if Assigned(Attachments) then Attachments.Clear;
    end;

    SysAdr:= fnGetSysAdresVlad(caeOnlyWorkTime); // адрес для письма в случае сбоя
    for i:= 0 to High(arDprts) do begin // рассылаем по филиалам обработки счетов
      FilID:= arDprts[i];
      ss1:= fnGetManagerMail(FilID, SysAdr); // отсылаем письмо о создании счета
      s:= n_SysMailSend(ss1, ss2+' ('+fnGetComputerName+', create account)', Strings, Attachments, '', '', true);
      if s<>'' then Result:= 'Ошибка отправки письма: '+#13#10+ss2+#13#10+s;
    end;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
  finally
    prFree(Strings);
    if Assigned(Attachments) and FileExists(attFile) then DeleteFile(attFile);
    prFree(Attachments);
    setLength(arDprts, 0);
  end;
end;
//================================ получить текущий курс валюты (def - EUR->UAH)
function GetRateCurr(crnc: Integer=cDefCurrency; crncTo: Integer=cUAHCurrency): Double;
var ibsGB: TIBSQL;
    ibGB: TIBDatabase;
begin
  Result:= 0;
  ibGB:= nil;
  ibsGB:= nil;
  try try
    ibGB:= cntsGRB.GetFreeCnt;
    ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsOrd_GetRateCurr', -1, tpRead, True);
                       // пересчитываем 1.0 из одной валюты в другую
    ibsGB.SQL.Text:= 'select resultvalue from convertmoney (1.0, '+
                     IntToStr(crnc)+', '+IntToStr(crncTo)+', "TODAY")'+
                     ' where exists(select * from RateCrnc where RateCrncCode='+IntToStr(crnc)+')';
    ibsGB.Prepare;
    ibsGB.ExecQuery;
    if not (ibsGB.Bof and ibsGB.Eof) and not ibsGB.fields[0].IsNull then
      Result:= ibsGB.fields[0].AsFloat;
    ibsGB.Transaction.Rollback;
  except
    on E: Exception do prMessageLOGS('GetRateCurr: '+E.Message);
  end;
  finally
    prFreeIBSQL(ibsGB);
    cntsGRB.SetFreeCnt(ibGB);
  end;
end;
//=============================== проверяем, не относится ли логин к запрещенным
function fnNotLockingLogin(Login: String): Boolean;
begin
  Result:= true;
  Login:= UpperCase(Login);
  if (Pos('ABUSE', Login)>0)    or (Copy(Login, 1, 3)='ADM')    or
     (Pos('EVERYONE', Login)>0) or (Pos('INPUT', Login)>0)      or
     (Pos('LIST', Login)>0)     or (Pos('MDAEMON', Login)>0)    or
     (Pos('ORDER', Login)>0)    or (Pos('POSTMASTER', Login)>0) or
     (Pos('SERVERMAIL', Login)>0) then Result:= false;
end;
//======================================== признак записи в LOG в зав-ти от вида
function ToLog(vid: Integer): Boolean;
// запись в текстовый LOG: 0- сообщения потоков, 1- содержимое ответов, 2- события,
// 3- FormVladTables, 4- форм.остатков, 5- запись заказа, 6- сообщения почтовика,
// 7- содержание запросов, 8- чистка старых ответов, 9- OrderToGB
// запись в ib_ord: соответственно 10+x
begin
  Result:= vid in SaveToLog;
end;
//============================================================= виды логирования
// если запущены почтовые потоки, можно изменить "на лету", иначе только при запуске или Resume
procedure GetLogKinds;
var pIniFile: TIniFile;
    ar: Tas;
    i, j: integer;
begin
  pIniFile:= TINIFile.Create(nmIniFileBOB);
  try
    ar:= fnSplitString(pIniFile.ReadString('Logs', 'SaveToLog', ''), ',');
    if (length(ar)>0) then for i:= Low(ar) to High(ar) do begin
      j:= StrToIntDef(ar[i], 0);
      if not (j in SaveToLog) then Include(SaveToLog, j);
    end;
  finally
    prFree(pIniFile);
    setLength(ar, 0);
  end;
end;

//******************************************************************************
//                       функции системных сообщений
//******************************************************************************
//============================================ строка "сообщение от" CSS-сервера
function GetMessageFromSelf: String;
begin
  Result:= FormatDateTime(cDateTimeFormatY2S, Now)+' Message from '+
           Application.Name+', '+fnGetComputerName+#10;
end;
//================================================ отправить системное сообщение
function n_SysMailSend(ToAdres, Subj: String; Body: TStrings=nil; Attachments: TStrings=nil;
         From: string =''; nmIniFile: string =''; flSaveToFile: boolean=False): string;
// ToAdres - адрес кому, Subj - тема, Body - строки сообщения, Attachments - список прикрепленных файлов
// From - адрес от кого, nmIniFile - имя ini-файла
var IdSMTP0: TIdSMTP;
    MsgRecive0: TIdMessage;
    pIniFile: TIniFile;
    PlugMail, fname, dir, s: string;
    i, j: integer;
    AttErrors: TStringList;
    htmpart: TIdText;   //vv
//    Attpart: TIdAttachmentFile;  //vv
begin
  Result:= '';
  AttErrors:= nil;
  if nmIniFile='' then nmIniFile:= nmIniFileBOB;
  while Cache.flMailSendSys do begin
    sleep(101); // ждем, если идет отправка сист.сообщения
    Application.ProcessMessages;
  end;
  try
    if pos('@', ToAdres)<1 then
      raise Exception.Create('Некорректное значение ToAdres='+ToAdres);
    pIniFile:= TINIFile.Create(nmIniFile);
    IdSMTP0:= TIdSMTP.Create(nil);
    MsgRecive0:= TIdMessage.Create(nil);
    Cache.flMailSendSys:= True;
    try
      IdSMTP0.AuthType:= satNone; // отключаем авторизацию
      IdSMTP0.ConnectTimeout:= 120000;
      IdSMTP0.Port:= pIniFile.ReadInteger('mail', 'SysPortTo', 0); // PortTo = 25
      if IdSMTP0.Port<1 then
        raise Exception.Create('Некорректное значение SysPortTo='+pIniFile.ReadString('mail', 'SysPortTo', ''));
      IdSMTP0.Host:= pIniFile.ReadString('mail', 'SysHost', '');  // Host = 'gatenet'
      IdSMTP0.Username:= pIniFile.ReadString('mail', 'SysServerID', ''); // логин
      IdSMTP0.Password:= pIniFile.ReadString('mail', 'SysServerPW', ''); // пароль
//      MsgRecive0.CharSet:= cCharSetUtf;
//      MsgRecive0.CharSet:= cCharSetKoi;  // переводим все в Koi-8

      MsgRecive0.ContentType:= 'multipart/mixed';              //vv
      htmpart:= TIdText.Create(MsgRecive0.MessageParts, nil);  //vv
      htmpart.ContentType:= 'text/html; charset='+LowerCase(cCharSetWin); //vv
//      if Assigned(Body) then htmpart.Body.Text:= body.Text;    //vv
      if Assigned(Body) then
        htmpart.Body.Text:= StringReplace(body.Text, #10, '<br>', [rfReplaceAll]); //vv

      MsgRecive0.CharSet:= cCharSetWin;
      MsgRecive0.OnInitializeISO:= VSMail.OnInitISO;
      PlugMail:= pIniFile.ReadString('mail', 'PlugMail', ''); // адрес-заглушка
      if PlugMail='' then begin
        MsgRecive0.Recipients.EMailAddresses:= ToAdres; // адреса "кому"
        MsgRecive0.Subject:= Subj; // тема
      end else begin
        MsgRecive0.Recipients.EMailAddresses:= PlugMail; // адреса "кому"
        MsgRecive0.Subject:= Subj+' (для '+ToAdres+')'; // тема
      end;
      if (From='') then From:= pIniFile.ReadString('mail', 'SysAdresFrom', ''); // адрес "от кого"
      i:= pos(',', From); //  если адресов у отправителя несколько - берем 1-й
      if i>0 then From:= copy(From, 1, i-1);
      MsgRecive0.From.Text:= From; // адрес "от кого"

//      if Assigned(Body) then for i:= 0 to Body.Count-1 do   //vv
//        MsgRecive0.Body.Add(Body[i]); // строки сообщения   //vv
//      MsgRecive0.Date:= Now;
      MsgRecive0.UseNowForDate:= True;
      MsgRecive0.ExtraHeaders.Add(VSMail.Xstring);  // вставка строки в заголовок

      if Assigned(Attachments) and (Attachments.Count>0) then begin  // прикрепляем файлы
        dir:= fnGetErrMailFilesDir;
        for i:= Attachments.Count-1 downto 0 do begin
          s:= Attachments[i];
          if not SysUtils.FileExists(s) then j:= -1
          else j:= GetFileSize(s) div (1024*1024);
          fname:= ExtractFileName(s);
          if (j<0) then begin                           // файл не найден
            s:= 'не найден вложенный файл '+fname;
            MsgRecive0.Body.Add(s);
            if not assigned(AttErrors) then begin
              AttErrors:= TStringList.Create;
              AttErrors.Add('При отправке письма в адрес '+ToAdres);
            end;
            AttErrors.Add(s);
            Attachments.Delete(i);
                                                        // файл слишком большой
          end else if (j>Cache.GetConstItem(pcMaxAttFileSizeMB).IntValue) then begin
            s:= ' - Не передан файл '+fname+' (более '+IntToStr(j)+' МБ).';
            MsgRecive0.Body.Add(s);
{            if not assigned(AttErrors) then begin
              AttErrors:= TStringList.Create;
              AttErrors.Add('При отправке письма в адрес '+ToAdres);
            end;
            AttErrors.Add(s);
            if RenameFile(Attachments[i], fnTestDirEnd(dir)+fname) then
              AttErrors.Add(' - файл перемещен в папку '+fnGetComputerName+':'+dir);  }
            if RenameFile(Attachments[i], fnTestDirEnd(dir)+fname) then begin
              s:= ', срок хранения файла - '+IntToStr(Cache.GetConstItem(pcMailFilesStoringDays).IntValue)+' суток.';
              MsgRecive0.Body.Add(' - Файл перемещен в папку '+fnGetComputerName+':'+dir+s);
              MsgRecive0.Body.Add(' Если Вы не получили файл из браузера, сообщите системным администраторам');
              MsgRecive0.Body.Add(' имена папки и файла из этого письма с запросом о передаче Вам файла по сети.');
            end;
            Attachments.Delete(i);

          end else begin                                // прикрепляем файл
//            Attpart:= TIdAttachmentFile.Create(MsgRecive0.MessageParts, Attachments[i]);  //vv
//            Attpart.ContentType:= ZipContentType;                                        //vv
            TIdAttachmentFile.Create(MsgRecive0.MessageParts, Attachments[i]);
            sleep(101);
          end;
        end; // for i:= Attachments.Count-1 downto 0
      end;

      for i:= 1 to RepeatCount do // RepeatCount попыток подключения
        try
          Application.ProcessMessages;
          IdSMTP0.Connect; // подключаемся к почтовому серверу
          sleep(101);
          if IdSMTP0.Connected then break else raise Exception.Create(''); // проверяем подключение
        except
          on E: Exception do
            if i<RepeatCount then sleep(997)
            else raise Exception.Create('Нет подключения к '+IdSMTP0.Host+': '+E.Message);
        end;

      IdSMTP0.Send(MsgRecive0); // отправляем письмо
      sleep(101);
    finally
      prFree(MsgRecive0);
      if Assigned(IdSMTP0) and IdSMTP0.Connected then IdSMTP0.Disconnect;
      prFree(IdSMTP0);
      prFree(pIniFile);
      Cache.flMailSendSys:= False;
    end;
  except
    on E: Exception do Result:= E.Message;
  end;

//------------------------------------------------------------------------------
  if (Result<>'') and flSaveToFile then try // запись набора строк письма в файл
    s:= '';
    if fnSaveMailStringsToFile(ToAdres, Subj, From, Body, Attachments, s) then
      Result:= Result+#13#10'  письмо записано в файл '+s
    else Result:= Result+#13#10'  '+MessText(mtkErrMailToFile)+' '+s;
  except end;
//------------------------------------------------------------------------------
  if assigned(AttErrors) then begin
    if AttErrors.Count>0 then begin
      prMessageLOGS('Error send files:');
      for i:= 0 to AttErrors.Count-1 do prMessageLOGS(AttErrors[i]);
      AttErrors.Insert(0, GetMessageFromSelf);
      s:= n_SysMailSend(fnGetSysAdresVlad(caeOnlyDayLess), 'Error send file', AttErrors, nil, '', '', flSaveToFile);
      if (s<>'') then prMessageLOGS('Error send mail to admins: '+s);  // ???
    end;
  end;
  prFree(AttErrors);
end;
//========================================== проверка незабранных файлов отчетов
procedure TestOldErrMailFiles;
var path: string;
    SearchRec: TSearchRec;
    cMailFilesStorDays: Integer;
begin
  try
    path:= fnGetErrMailFilesDir;
    if (FindFirst(path, faDirectory, SearchRec)<>0) then Exit;
    path:= path+PathDelim;
    cMailFilesStorDays:= Cache.GetConstItem(pcMailFilesStoringDays).IntValue;
    try                                       // ищем файлы rep*.zip - отчеты
      if (FindFirst(path+'rep*.zip', faAnyFile, SearchRec)=0) then repeat
        if ((Now-SearchRec.TimeStamp)>cMailFilesStorDays) then // если файл пролежал cMailFilesStorDays суток - удаляем
          DeleteFile(path+SearchRec.Name);
        Application.ProcessMessages;
      until FindNext(SearchRec)<>0;
    except
      on E: Exception do if (E.Message<>'') then prMessageLOGS('TestOldMailFiles: '+E.Message);
    end;
  finally
    FindClose(SearchRec);
  end;
end;
//=============================================================== Email филиала
function fnGetManagerMail(code: Integer; Mailelse: String): String;
begin
  if Cache.DprtExist(code) and (Cache.arDprtInfo[code].MailOrder<>'') then
    Result:= Cache.arDprtInfo[code].MailOrder
  else Result:= Mailelse;
end;
//================================================ допустимое время для операций
function fnGetActionTimeEnable(kind: integer=caeOnlyDay): Boolean;
var h, dw: integer;
begin
  Result:= True;
  h:= HourOfTheDay(Now);  // HourOfTheDay returns a value between 0 and 23
  dw:= DayOfTheWeek(Now); // DayOfTheWeek returns a value between 1 and 7, where 1 indicates Monday and 7 indicates Sunday.
  case kind of
    caeOnlyDay: Result:= (h in [8..18]);     // только днем - можно с 8 до 19
    caeOnlyDayLess:                          // только днем и по выходным поменьше
      if (dw in [DaySaturday, DaySunday]) then Result:= (h in [9..17]) // по выходным можно с 9 до 18
      else Result:= (h in [8..18]);                                     // в раб.дни можно с 8 до 19
    caeOnlyWorkDay:                          // только днем в рабочие дни
      Result:= not (dw in [DaySaturday, DaySunday]) and (h in [8..18]);
    caeOnlyWorkTime:                         // только в рабочее время - пн-пт с 9 до 18
      Result:= not (dw in [DaySaturday, DaySunday]) and (h in [9..17]);
    caeSmallWork:                            // только в периоды малой загрузки системы
//      if flDebug then Result:= True else                        // debug
      if (dw=DaySunday) then Result:= True                      // по воскресеньям
      else if (dw=DaySaturday) then Result:= not (h in [9..16]) // не по субботам с 9 до 17
      else Result:= not (h in [9..17]);                         // не в раб.дни с 9 до 18
  end;
end;
//==================================================== адреса для сист.сообщений
function fnGetSysAdresVlad(kind: integer=caeOnlyDay): string;
var s, s1: string;
    ar: Tas;
    i: integer;
begin
  Result:= '';
  s:= GetIniParam(nmIniFileBOB, 'mail', 'SysAdresVlad');
  ar:= fnSplitString(s, ',');
  for i:= Low(ar) to High(ar) do begin
    if (pos('@sms.', ar[i])<1) then s1:= ar[i]
    else if fnGetActionTimeEnable(kind) then s1:= ar[i] else s1:= ''; // отрезаем адреса для SMS
    if s1<>'' then Result:= Result+fnIfStr(Result='', '', ',')+s1;
  end;
  setLength(ar, 0);
end;

//******************************************************************************
//              функции отправки системных сообщений из файлов
//******************************************************************************
//============================================ запись набора строк письма в файл
function fnSaveMailStringsToFile(ToAdres, Subj, From: String;
         Body, Attachments: TStrings; var FileName: String): Boolean;
var FileHandle, i: integer;
    s, file_block, ex: string;
    list: TStringList;
begin
  Result:= False;
  list:= TStringList.Create; // формируем набор строк для записи в файл
  try
    if Assigned(Body) then list.AddStrings(Body); // пишем тело письма
    list.Insert(0, ToAdres);  // вставляем строку с адресом кому
    list.Insert(1, Subj);     // вставляем строку с темой
    if From='' then From:= 'no'; // не пишем пустых строк для корректного считывания
    list.Insert(2, From);     // вставляем строку с адресом от кого

    if Assigned(Attachments) and (Attachments.Count>0) then begin // если есть приложенные файлы - переименовываем
      s:= fnGetMailFilesPath+'att';                // папка прилож.файлов для писем из файлов
      if not DirectoryExists(s) then CreateDir(s); // если нет папки - создаем
      for i:= 0 to Attachments.Count-1 do begin
        file_block:= fnTestDirEnd(s)+ExtractFileName(Attachments.Strings[i]); // новое имя файла
        FileHandle:= 0;
        ex:= ExtractFileExt(file_block); // расширение файла
        while FileExists(file_block) do begin // проверяем уникальность имени файла в папке
          inc(FileHandle);
          file_block:= copy(file_block, 1, pos(ex, file_block)-1)+'_'+IntToStr(FileHandle)+ex;
        end;
        RenameFile(Attachments.Strings[i], file_block); // переносим файл ??? или копируем
        Attachments.Strings[i]:= file_block;           // переписываем в Attachments
      end;
      s:= Attachments.CommaText;
    end else s:= 'no'; // не пишем пустых строк для корректного считывания
    list.Insert(3, s);  // вставляем строку с именами приложенных файлов

    FileHandle:= -1;
    if FileName='' then s:= fnGenRandString(6) else s:= FileName;
    FileName:= PrefixMailFile+s+ExtMailFile; // имя файла письма
    s:= fnGetMailFilesPath+FileName;         // полное имя файла

    for i:= 1 to RepeatCount do try
      while FileExists(s) do begin  // проверяем уникальность имени файла
        s:= fnGenRandString(6, true);
        FileName:= PrefixMailFile+s+ExtMailFile; // имя файла для записи
        s:= fnGetMailFilesPath+FileName;         // полное имя файла
      end;

      file_block:= fnGetLockFileName(s); // файл блокировки (защита на время записи)
      try
        FileHandle:= fnTestFileCreate(file_block); // создаем файл блокировки
        Result:= fnStringsLogToFile(list, s); // запись набора строк письма в файл
      except end;

      if (FileHandle>-1) then DeleteFile(file_block); // удаляем файл блокировки
      if Result then break;
    except end;
  finally
    prFree(list);
  end;
end;
//========================================================== путь к файлам писем
function fnGetMailFilesPath: String;
begin
  Result:= GetAppExePath+DirMailFiles;     // полное имя папки
  if not DirectoryExists(Result) then CreateDir(Result); // если нет - создаем
  Result:= fnTestDirEnd(Result);                         // путь
end;
//============================================== папка с неотправленными файлами
function fnGetErrMailFilesDir: String;
begin
  Result:= fnGetMailFilesPath+'err';
  if not DirectoryExists(Result) then CreateDir(Result); // если папки нет - создаем
end;
//========================================================= имя файла блокировки
function fnGetLockFileName(FileName: String): String;
begin
  Result:= ChangeFileExt(FileName, '.lck'); // меняем расширение
end;
//======================================================= сообщения пользователю
function MessText(kind: TMessTextKind; str: string=''): String;
begin
  case kind of
    mtkNotValidLogin   : Result:= 'Логин должен иметь длину от 5 до '+fnIfStr(str='', '20', str)+' символов и состоять только из цифр и латинских букв.';
    mtkNotValidPassw   : Result:= 'Пароль должен иметь длину от 5 до '+fnIfStr(str='', '20', str)+' символов и состоять только из цифр и латинских букв.';
    mtkNotRightExists  : Result:= 'У Вас нет прав на выполнение этой операции.'; // not ...Empl...UserRoleExists
    mtkNotClientOfFirm : Result:= 'Пользователь не относится к числу должностных лиц контрагента.'; // Client...FirmID<>FirmID
    mtkErrorUserID     : Result:= 'Некорректный код пользователя.';
    mtkNotFoundWares   : Result:= 'Не найдены товары';
    mtkNotFoundRecord  : Result:= 'Не найдена строка для редактирования.';
    mtkNotFoundData    : Result:= 'Нет данных.';
    mtkEmptySysName    : Result:= 'Не задано системное наименование.';
    mtkNotParams       : Result:= 'Не заданы параметры.';
    mtkNotEnoughParams : Result:= 'Не хватает параметров';
    mtkNotValidParam   : Result:= 'Некорректный параметр';
    mtkNotChanges      : Result:= 'Нет изменений.';
    mtkErrEditRecord   : Result:= 'Ошибка изменения строки в базе данных.';
    mtkErrAddRecord    : Result:= 'Ошибка добавления строки в базу данных.';
    mtkErrDelRecord    : Result:= 'Ошибка удаления строки из базы данных.';
    mtkErrProcess      : Result:= 'Ошибка выполнения.';
    mtkErrConnectToDB  : Result:= 'Ошибка подключения к базе данных.';
    mtkModelNodeLink   : Result:= 'связь модели с узлом';
    mtkWareModNodeLink : Result:= 'связь товара с моделью и узлом';
    mtkWareAttrValue   : Result:= 'значение атрибута товара';
    mtkExitBySuspend   : Result:= 'прерываю процесс по команде Suspend';
    mtkErrCopyFile     : Result:= 'Ошибка копирования в файл ';
    mtkCommonErrorText : Result:= 'Ошибка на стороне сервера ';
    mtkFuncNotAvailabl : Result:= 'функция недоступна';
    mtkWareModNodeUse  : Result:= 'условие применения товара к модели и узлу';
    mtkWareModNodeUses : Result:= 'набор условий применения товара к модели и узлу';
    mtkWareArticleLink : Result:= 'связь товара с артикулом';
    mtkWareOrNumLink   : Result:= 'связь товара с оригинальным номером';
    mtkWareModNodeText : Result:= 'связь текста с товаром, моделью и узлом';
    mtkWareModNodeTexts: Result:= 'набор связей текстов с товаром, моделью и узлом';
    mtkRegOrdAddOrAnn  : Result:= 'Заявка уже принята или аннулирована.';
    mtkRegOrdNotYourFil: Result:= 'Заявка не относится к Вашему филиалу.';
    mtkNotFoundRegOrd  : Result:= 'Не найдена заявка.';
    mtkNotSetLogin     : Result:= 'Не задан логин.';
    mtkErrFormTmpPass  : Result:= 'Ошибка формирования временного пароля.';
    mtkNotSetRegion    : Result:= 'Не задан регион.';
    mtkNotFoundNodes   : Result:= 'Не найдены узлы.';
    mtkErrMailToFile   : Result:= 'Ошибка записи письма в файл';
    mtkMailWillSend    : Result:= '!!!  Сообщение записано и будет отправлено позже.';
    mtkLockingLogin    : Result:= 'Логин `'+str+'` уже зарегистрирован в системе.';        // not fnNotLockingLogin
    mtkNotFoundFile    : Result:= 'Не найден файл ';
    mtkNotFoundOrNum   : Result:= 'Не найден оригинальный номер';
    mtkNotEmplExist    : Result:= 'Не найден сотрудник'+fnIfStr(str='', '.', ', код - '+str);         // not EmplExist(
    mtkNotFoundEmplMail: Result:= 'Не найден E-mail сотрудника '+str;
    mtkNotClientExist  : Result:= 'Не найден пользователь'+fnIfStr(str='', '.', ', код - '+str);      // not ClientExist(
    mtkNotFirmExists   : Result:= 'Не найден контрагент'+fnIfStr(str='', '.', ', код - '+str);        // not FirmExist(
    mtkNotFoundFirmCont: Result:= 'Не найден контракт контрагента'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundFirms   : Result:= 'Не найдены контрагенты.';
    mtkNotDprtExists   : Result:= 'Не найдено подразделение'+fnIfStr(str='', '.', ', код - '+str);    // not DprtExist(
    mtkNotFoundTypeSys : Result:= 'Не найдена система учета'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundModel   : Result:= 'Не найдена модель'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundModLine : Result:= 'Не найден модельный ряд'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundManuf   : Result:= 'Не найден производитель'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundNode    : Result:= 'Не найден узел'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundWare    : Result:= 'Не найден товар'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundAttGr   : Result:= 'Не найдена группа атрибутов'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundOrder   : Result:= 'Не найден заказ'+fnIfStr(str='', '', ', код - '+str);
    mtkNotFoundOrders  : Result:= 'Не найдены заказы';
    mtkNotFoundCont    : Result:= 'Не найден контракт'+fnIfStr(str='', '', ', код - '+str);
    mtkContNotAvailable: Result:= 'Контракт недоступен'+fnIfStr(str='', '', ', код - '+str);
    mtkNotFoundAvaiCont: Result:= 'Не найден доступный контракт';
    mtkEmptyName       : Result:= 'Не задано наименование'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotEditOrder    : Result:= 'Заказ нельзя редактировать'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotProcOrder    : Result:= 'Заказ нельзя отправить на обработку'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotSysManuf     : Result:= 'Производитель не относится к системе'+fnIfStr(str='', '.', ', код - '+str);
    mtkDuplicateName   : Result:= 'В системе уже есть наименование '+fnIfStr(str='', '', QuotedStr(str));
    mtkDuplicateSysNm  : Result:= 'В системе уже есть системное наименование '+fnIfStr(str='', '', QuotedStr(str));
    mtkNotFirmProcess  : Result:= 'Обработка запросов по контрагенту '+str+' заблокирована.';
    mtkNotLoginProcess : Result:= 'Обработка запросов по логину '+str+' заблокирована.';
    mtkBlockCountLogin : Result:= 'Обработка запросов по логину '+str+' заблокирована из-за превышения лимита запросов.';
    mtkErrSendMess     : Result:= 'Ошибка передачи сообщения'+fnIfStr(str='', '.', ' '+str);
    mtkSpecifyInquiry  : Result:= 'По Вашему запросу найдено слишком много товаров. Пожалуйста, уточните запрос.';
    mtkNotFoundEngine  : Result:= 'Не найден двигатель'+fnIfStr(str='', '.', ', код - '+str);
    mtkFuncNotEnable   : Result:= 'Функция временно недоступна.';
    mtkNotManagerMail  : Result:= 'Не найден адрес менеджера '+fnIfStr(str='', '.', ' '+str);
    mtkNotCreateDir    : Result:= 'Невозможно создать папку'+fnIfStr(str='', '', ' '+str)+'.';
    mtkNotDelPrevFile  : Result:= 'Невозможно удалить предыдущий файл.';
    mtkEndDateMoreBegin: Result:= 'Начальная дата больше конечной!';
    mtkNotEndDateMore  : Result:= 'Конечная дата отчета не может быть дальше чем '+str;
    mtkNotFoundBrand   : Result:= 'Не найден бренд'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundBrandWar: Result:= 'Не найдены товары этого бренда.';
    mtkImportError     : Result:= 'При импорте были обнаружены ошибки. Смотрите отчет!';
    mtkImportSuccess   : Result:= 'Все данные загружены.';
    mtkNotFoundDataUse : Result:= 'Нет данных по выбранным условиям.';
    mtkWareAnalogLink  : Result:= 'связь товара с аналогом';
    mtkWareSatelLink   : Result:= 'связь товара с сопутствующим товаром';
    mtkOnlyFormingOrd  : Result:= 'Операция доступна только для заказов со статусом '+arOrderStatusNames[orstForming];
    mtkUnknownSysType  : Result:= 'Неизвестный тип системы'+fnIfStr(str='', '.', ', код - '+str);
    mtkNotFoundDocum   : Result:= 'Не найден документ'+fnIfStr(str='', '.', ', код - '+str);
  end;
end;                                     // MessText(mtkNotValidParam)
{//=================================================== адрес директора по системе
function FindAdressSysSaleDirector(SysID: Integer; var eml: string): Boolean;
var EmplID: Integer;
begin
  Result:= False;
  eml:= '';
  with Cache do try
    case SysID of
      constIsAuto: begin // eml = 'dmitriy.voloshin@vladislav.ua';
          EmplID:= Cache.GetConstItem(pcEmplSaleDirectorAuto).IntValue;
          if not EmplExist(EmplID) then TestEmpls(EmplID);
          if EmplExist(EmplID) then eml:= arEmplInfo[EmplID].Mail;
          Result:= (eml<>'');
        end;
      constIsMoto: begin // eml = 'valeriy.nestjurin@motogorodok.com';
          EmplID:= Cache.GetConstItem(pcEmplSaleDirectorMoto).IntValue;
          if not EmplExist(EmplID) then TestEmpls(EmplID);
          if EmplExist(EmplID) then eml:= arEmplInfo[EmplID].Mail;
          Result:= (eml<>'');
        end;
      else eml:= MessText(mtkUnknownSysType, IntToStr(SysID));
    end;
  finally
    if not Result and (eml='') then
      eml:= 'Не найден адрес директора по системе учета '+IntToStr(SysID);
  end;
end;  }

//================================================ запись в Stream инфо о товаре
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;
          ffp: TForFirmParams; WareID: integer; AnalogsCount: integer=0;
          SatellsCount: integer=0; RestSem: integer=-1; ModelsEx: Boolean=True);
const nmProc = 'prSaveShortWareInfoToStream'; // имя процедуры/функции
var ware: TWareInfo;
    sMargin, sBonus, ActTitle, ActText: string;
    bon: double;
    prices: TDoubleDynArray;
    i, iCode, aCode: Integer;
    flag: Boolean;
    wa: TWareAction;
begin
  try
    ware:= Cache.GetWare(WareID);
    Stream.WriteInt(WareID);             // код товара

    iCode:= ware.AttrGroupID;
    if (iCode<1) then begin
      iCode:= ware.GBAttGroup;
      if (iCode>0) then iCode:= iCode+cGBattDelta;
    end;
    Stream.WriteInt(iCode);   // группа атрибутов

    Stream.WriteInt(AnalogsCount);       // кол-во аналогов
    Stream.WriteInt(SatellsCount);       // кол-во сопут.товаров
    Stream.WriteStr(ware.WareBrandName); // бренд
    Stream.WriteStr(ware.BrandNameWWW);  // бренд для файла логотипа
    Stream.WriteStr(ware.BrandAdrWWW);   // адрес ссылки на сайт бренда
    Stream.WriteStr(ware.Name);          // наименование
    Stream.WriteBool(ware.IsSale);       // признак распродажи
    Stream.WriteBool(ware.IsNonReturn);  // признак невозврата
    Stream.WriteBool(ware.IsCutPrice);   // признак уценки
    Stream.WriteStr(Ware.PrDirectName);   // название направления по продуктам
    Stream.WriteStr(ware.MeasName);      // ед.изм.

if flWareAction then begin
    aCode:= 0;
    ActTitle:= '';
    ActText:= '';
    if Cache.WareActions.ItemExists(ware.ActionID) then begin
      wa:= Cache.WareActions[ware.ActionID];
      if wa.EndDate>Date() then begin
        aCode:= wa.ID;
        ActTitle:= wa.Name;
        ActText:= wa.Comment;
//        ActText:= wa.Comment+fnIfStr(wa.Comment='', '', '\n')+
//          'Акция действует до '+FormatDateTime(cDateFormatY4, wa.EndDate);
      end;
    end;
    Stream.WriteInt(aCode);         // код акции
    Stream.WriteStr(ActTitle);      // заголовок
    Stream.WriteStr(ActText);       // текст
end;

if flNewSearchLine then begin
    Stream.WriteInt(RestSem); // семафор остатков: 0- красный, 2- зеленый, другое - нет
    Stream.WriteInt(Length(ffp.arSys)); // кол-во систем учета
    for i:= 0 to High(ffp.arSys) do begin
      iCode:= ffp.arSys[i];
      flag:= ModelsEx and ware.CheckWareTypeSys(iCode)
                      and ware.SysModelsExists(iCode);
      Stream.WriteInt(iCode); // код системы учета
      Stream.WriteBool(flag); // признак наличия моделей
    end;
end; // flNewSearchLine

//----------------- цены Гроссби (0- Розница, 1- со скидкой, 2- со след.скидкой)
    prices:= ware.CalcFirmPrices(ffp);
    for i:= 0 to High(prices) do
      Stream.WriteStr(trim(FormatFloat('# ##0.00', prices[i])));
//------------------------------------------------- цены Гроссби
    sMargin:= '0';
    sBonus:= '0';
    if (ffp.currID>0) then begin
      if ffp.ForClient and (ffp.currID<>Cache.BonusCrncCode) then // цена товара с наценкой (% к продажной) для клиента
        sMargin:= trim(FormatFloat('# ##0.00', ware.MarginPrice(ffp)));

      if not fnNotZero(ffp.rate) then
        prices:= ware.CalcFirmPrices(ffp.ForFirmID, cDefCurrency, ffp.contID);
      bon:= prices[1]*Cache.GetPriceBonusCoeff(ffp.currID);
      sBonus:= trim(FormatFloat('# ##0.00', bon)); // баллы (не unit-заказ)
    end;
    Stream.WriteStr(sMargin);         // цена с наценкой
    Stream.WriteStr(sBonus);          // бонусы (не unit-заказ)
    Stream.WriteStr(ware.CommentWWW); // описание товара для Web с учетом типа товара
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  SetLength(prices, 0);
end;
//================================================ запись в Stream инфо о товаре
procedure prSaveShortWareInfoToStream(Stream: TBoBMemoryStream;
          WareID, FirmID, UserID: integer; AnalogsCount: integer=0;
          currID: Integer=0; ForFirmID: integer=0; SatellsCount: integer=0;
          contID: integer=0; RestSem: integer=-1; ModelsEx: Boolean=True);
const nmProc = 'prSaveShortWareInfoToStream'; // имя процедуры/функции
var ware: TWareInfo;
    sMargin, sBonus, ActTitle, ActText: string;
    rate, bon: double;
    prices: TDoubleDynArray;
    i, iCode, aCode: Integer;
    arSys: Tai;
    flag: Boolean;
    wa: TWareAction;
begin
  try
    ware:= Cache.GetWare(WareID);
    Stream.WriteInt(WareID);             // код товара

    iCode:= ware.AttrGroupID;
    if (iCode<1) then begin
      iCode:= ware.GBAttGroup;
      if (iCode>0) then iCode:= iCode+cGBattDelta;
    end;
    Stream.WriteInt(iCode);   // группа атрибутов

    Stream.WriteInt(AnalogsCount);       // кол-во аналогов
    Stream.WriteInt(SatellsCount);       // кол-во сопут.товаров
    Stream.WriteStr(ware.WareBrandName); // бренд
    Stream.WriteStr(ware.BrandNameWWW);  // бренд для файла логотипа
    Stream.WriteStr(ware.BrandAdrWWW);   // адрес ссылки на сайт бренда
    Stream.WriteStr(ware.Name);          // наименование
    Stream.WriteBool(ware.IsSale);       // признак распродажи
    Stream.WriteBool(ware.IsNonReturn);  // признак невозврата
    Stream.WriteBool(ware.IsCutPrice);   // признак уценки
    Stream.WriteStr(Ware.PrDirectName);   // название направления по продуктам
    Stream.WriteStr(ware.MeasName);      // ед.изм.
if flWareAction then begin
    aCode:= 0;
    ActTitle:= '';
    ActText:= '';
    if Cache.WareActions.ItemExists(ware.ActionID) then begin
      wa:= Cache.WareActions[ware.ActionID];
      if wa.EndDate>Date() then begin
        aCode:= wa.ID;
        ActTitle:= wa.Name;
        ActText:= wa.Comment;
//        ActText:= wa.Comment+fnIfStr(wa.Comment='', '', '\n')+
//          'Акция действует до '+FormatDateTime(cDateFormatY4, wa.EndDate);
      end;
    end;
    Stream.WriteInt(aCode);         // код акции
    Stream.WriteStr(ActTitle);      // заголовок
    Stream.WriteStr(ActText);       // текст
end;

if flNewSearchLine then begin
    Stream.WriteInt(RestSem); // семафор остатков: 0- красный, 2- зеленый, другое - нет

    arSys:= SysTypes.GetDirCodes; // коды систем учета
    for i:= 0 to High(arSys) do begin
      iCode:= arSys[i];
      flag:= ModelsEx and ware.CheckWareTypeSys(iCode)
                      and ware.SysModelsExists(iCode);
      Stream.WriteInt(iCode); // код системы учета
      Stream.WriteBool(flag); // признак наличия моделей
    end;
end; // flNewSearchLine

    if not Cache.CurrExists(currID) then // определяем валюту, если она не задана
      if (FirmId=IsWe) then currID:= 0
      else if CheckNotValidUser(UserID, FirmID, sBonus) then currID:= 0
      else currID:= Cache.arClientInfo[UserID].SEARCHCURRENCYID; // берем валюту из настроек пользователя

    if (FirmId<>IsWe) or (ForFirmID<1) then ForFirmID:= FirmID; // к/а для скидок
//------------------------------------------------- цены Гроссби
    prices:= ware.CalcFirmPrices(ForFirmID, currID, contID); // цены (0- Розница, 1- со скидкой, 2- со след.скидкой)
    for i:= 0 to High(prices) do Stream.WriteStr(trim(FormatFloat('# ##0.00', prices[i])));
//------------------------------------------------- цены Гроссби
    sMargin:= '0';
    sBonus:= '0';
    if (currID>0) then begin
                           // цена товара с наценкой (% к продажной) для клиента
      if (FirmId<>IsWe) and (currID<>Cache.BonusCrncCode) then
        sMargin:= trim(FormatFloat('# ##0.00', ware.MarginPrice(ForFirmID, UserID, currID, contID)));

      rate:= Cache.Currencies.GetCurrRate(currID);    // ???
      if not fnNotZero(rate) then prices:= ware.CalcFirmPrices(ForFirmID, cDefCurrency, contID);
      bon:= prices[1]*Cache.GetPriceBonusCoeff(currID);
      sBonus:= trim(FormatFloat('# ##0.00', bon)); // баллы (не unit-заказ)
    end;
    Stream.WriteStr(sMargin);         // цена с наценкой
    Stream.WriteStr(sBonus);          // бонусы (не unit-заказ)
    Stream.WriteStr(ware.CommentWWW); // описание товара для Web с учетом типа товара

  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  SetLength(prices, 0);
  SetLength(arSys, 0);          // чистим массивы
end;
//==== запись в Stream блока инфы о наличии привязанных моделей по всем системам
procedure prSaveWaresModelsExists(Stream: TBoBMemoryStream; FirmSys: Integer; wCodes: Tai);
const nmProc = 'prSaveWaresModelsExists'; // имя процедуры/функции
var iWare, sysID, iSys, j: Integer;
    arSys, arWareCounts: Tai;
    arSysWares: arTai;
    ware: TWareInfo;
begin
  try try
    arSys:= SysTypes.GetDirCodes; // коды систем учета
    j:= Length(arSys);
                                       //----------- готовим массивы для фасовки
    if not Assigned(wCodes) then SetLength(wCodes, 0);
    SetLength(arSysWares, j);     // коды товаров по системам
    SetLength(arWareCounts, j);   // счетчики кол-ва товаров по системам
    iWare:= Length(wCodes);
    for iSys:= 0 to j-1 do begin
      arWareCounts[iSys]:= 0;
      SetLength(arSysWares[iSys], iWare); // место для кодов товаров - по максимуму
    end;

    for j:= 0 to High(wCodes) do begin //------- фасуем коды товаров по системам
      if not Cache.WareExist(wCodes[j]) then Continue;
      ware:= Cache.GetWare(wCodes[j]);
      for iSys:= 0 to High(arSys) do begin
        sysID:= arSys[iSys];
        if not (FirmSys in [0, sysID])
          or not ware.CheckWareTypeSys(sysID)
          or not ware.SysModelsExists(sysID) then Continue;
        iWare:= arWareCounts[iSys];
        arSysWares[iSys, iWare]:= wCodes[j];
        arWareCounts[iSys]:= iWare+1; // счетчик кол-ва товаров по системе
      end;
    end;

    for iSys:= 0 to High(arSys) do begin //---------------------------- передаем
      j:= arWareCounts[iSys];
      Stream.WriteInt(j);        // кол-во товаров по системе
      for iWare:= 0 to j-1 do Stream.WriteInt(arSysWares[iSys, iWare]); // коды товаров
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    SetLength(arSys, 0);          // чистим массивы
    SetLength(arWareCounts, 0);
    for iSys:= 0 to High(arSysWares) do SetLength(arSysWares[iSys], 0);
    SetLength(arSysWares, 0);
  end;
end;
//==== запись в Stream блока инфы о наличии привязанных моделей по всем системам
procedure prSaveWaresModelsExists(Stream: TBoBMemoryStream; OLmarkets: TObjectList);
const nmProc = 'prSaveWaresModelsExists'; // имя процедуры/функции
var iWare, sysID, iSys, j: Integer;
    arSys, arWareCounts: Tai;
    arSysWares: arTai;
    ware: TWareInfo;
    tc: TTwoCodes;
begin
  try try
    arSys:= SysTypes.GetDirCodes; // коды систем учета
    j:= Length(arSys);
                                       //----------- готовим массивы для фасовки
    SetLength(arSysWares, j);     // коды товаров по системам
    SetLength(arWareCounts, j);   // счетчики кол-ва товаров по системам
    iWare:= OLmarkets.Count;
    for iSys:= 0 to j-1 do begin
      arWareCounts[iSys]:= 0;
      SetLength(arSysWares[iSys], iWare); // место для кодов товаров - по максимуму
    end;

    for j:= 0 to OLmarkets.Count-1 do begin //------- фасуем коды товаров по системам
      tc:= TTwoCodes(OLmarkets[j]);
      if not Cache.WareExist(tc.ID1) then Continue;
      ware:= Cache.GetWare(tc.ID1);
      for iSys:= 0 to High(arSys) do begin
        sysID:= arSys[iSys];
        if not ware.CheckWareTypeSys(sysID)
          or not ware.SysModelsExists(sysID) then Continue;
        iWare:= arWareCounts[iSys];
        arSysWares[iSys, iWare]:= tc.ID1;
        arWareCounts[iSys]:= iWare+1; // счетчик кол-ва товаров по системе
      end;
    end;

    for iSys:= 0 to High(arSys) do begin //---------------------------- передаем
      j:= arWareCounts[iSys];
      Stream.WriteInt(j);        // кол-во товаров по системе
      for iWare:= 0 to j-1 do Stream.WriteInt(arSysWares[iSys, iWare]); // коды товаров
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    SetLength(arSys, 0);          // чистим массивы
    SetLength(arWareCounts, 0);
    for iSys:= 0 to High(arSysWares) do SetLength(arSysWares[iSys], 0);
    SetLength(arSysWares, 0);
  end;
end;
//=============== запись в Stream блока семафоров наличия товаров (Web & WebArm)
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; ForFirmID, ContID: Integer; wCodes: Tai);
const nmProc = 'prSaveWareRestsExists'; // имя процедуры/функции
var iCount, i, j, iSem, iPos: integer;
    Second, StorageCodes: Tai;
    Contract: TContract;
    flAdd: boolean;
    OList: TObjectList;
begin
  if not Assigned(wCodes) then SetLength(wCodes, 0);
  SetLength(Second, 0);
  SetLength(StorageCodes, 0);
  OList:= nil;
  try try
    iCount:= 0;
    iPos:= Stream.Position;
    Stream.WriteInt(iCount);

    if (ForFirmID<1) or not Cache.FirmExist(ForFirmID) or // не надо передавать при ForFirmID<1
      not Assigned(wCodes) or (Length(wCodes)<1) then Exit; // нет товаров

    Contract:= Cache.arFirmInfo[ForFirmID].GetContract(ContID);
    flAdd:= flClientStoragesView_add and Contract.HasAddVis;

    for i:= 0 to High(wCodes) do // выбираем товары для семафоров
      if (wCodes[i]>0) and Cache.WareExist(wCodes[i]) then
        if Cache.GetWare(wCodes[i]).IsMarketWare(ForFirmID, contID) then
          prAddItemToIntArray(wCodes[i], Second);

    if (Length(Second)<1) then Exit;

    for i:= 0  to High(Contract.ContStorages) do with Contract.ContStorages[i] do
      if IsVisible or (flAdd and IsAddVis) then prAddItemToIntArray(DprtId, StorageCodes);

    for i:= 0 to High(Second) do begin
      iSem:= 0;
      OList:= Cache.GetWareRestsByStores(Second[i]);
      try
        for j:= 0 to OList.Count-1 do with TCodeAndQty(OList[j]) do
          if (fnInIntArray(ID, StorageCodes)>-1) and (Qty>constDeltaZero) then begin
            iSem:= 2;
            break;
          end;
      finally
        prFree(OList);
      end;
      Stream.Writeint(Second[i]);
      Stream.Writeint(iSem);
      Inc(iCount);
    end;
    if iCount>0 then begin
      Stream.Position:= iPos;
      Stream.Writeint(iCount);
      Stream.Position:= Stream.Size;
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    SetLength(Second, 0);
    SetLength(StorageCodes, 0);
  end;
end;
//=============== запись в Stream блока семафоров наличия товаров (Web & WebArm)
procedure prSaveWareRestsExists(Stream: TBoBMemoryStream; OLmarkets: TObjectList);
const nmProc = 'prSaveWareRestsExists'; // имя процедуры/функции
var i: integer;
    tc: TTwoCodes;
begin
  try
    if not Assigned(OLmarkets) or (OLmarkets.Count<1) then begin
      Stream.WriteInt(0);
      Exit; // нет товаров
    end;
    Stream.WriteInt(OLmarkets.Count);
    for i:= 0 to OLmarkets.Count-1 do begin
      tc:= TTwoCodes(OLmarkets[i]);
      Stream.Writeint(tc.ID1);
      Stream.Writeint(tc.ID2);
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
end;
//============================ проверка семафоров наличия товаров (Web & WebArm)
procedure prCheckWareRestsExists(FirmID, ContID: Integer; var OLmarkets: TObjectList; var RestCount: Integer);
const nmProc = 'prCheckWareRestsExists'; // имя процедуры/функции
var i, j: integer;
    StorageCodes: Tai;
    Contract: TContract;
    flAdd: boolean;
    OList: TObjectList;
    tc: TTwoCodes;
begin
  if not Assigned(OLmarkets) then Exit;
  SetLength(StorageCodes, 0);
  OList:= nil;
  RestCount:= 0;
  try try
    if (FirmID<1) or not Cache.FirmExist(FirmID) or // не надо передавать при FirmID<1
      (OLmarkets.Count<1) then Exit; // нет товаров

    Contract:= Cache.arFirmInfo[FirmID].GetContract(ContID);
    flAdd:= flClientStoragesView_add and Contract.HasAddVis;

    for i:= 0 to High(Contract.ContStorages) do with Contract.ContStorages[i] do
      if IsVisible or (flAdd and IsAddVis) then prAddItemToIntArray(DprtId, StorageCodes);

    for i:= 0 to OLmarkets.Count-1 do begin
      tc:= TTwoCodes(OLmarkets[i]);
      OList:= Cache.GetWareRestsByStores(tc.ID1);
      try
        for j:= 0 to OList.Count-1 do with TCodeAndQty(OList[j]) do
          if (fnInIntArray(ID, StorageCodes)>-1) and (Qty>constDeltaZero) then begin
            tc.ID2:= 2;
            Inc(RestCount);
            break;
          end;
      finally
        prFree(OList);
      end;
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    SetLength(StorageCodes, 0);
  end;
end;
//============================ проверка семафоров наличия товаров (Web & WebArm)
procedure prCheckWareRestsExists(ffp: TForFirmParams; var OLmarkets: TObjectList; var RestCount: Integer);
const nmProc = 'prCheckWareRestsExists'; // имя процедуры/функции
var i, j: integer;
    StorageCodes: Tai;
    Contract: TContract;
    flAdd: boolean;
    OList: TObjectList;
    tc: TTwoCodes;
begin
  if not Assigned(OLmarkets) then Exit;
  SetLength(StorageCodes, 0);
  OList:= nil;
  RestCount:= 0;
  try try
    if (ffp.ForFirmID<1) or not Cache.FirmExist(ffp.ForFirmID) // не надо передавать при FirmID<1
      or (OLmarkets.Count<1) then Exit; // нет товаров

    Contract:= Cache.arFirmInfo[ffp.ForFirmID].GetContract(ffp.ContID);
    flAdd:= flClientStoragesView_add and Contract.HasAddVis;

    for i:= 0 to High(Contract.ContStorages) do with Contract.ContStorages[i] do
      if IsVisible or (flAdd and IsAddVis) then prAddItemToIntArray(DprtId, StorageCodes);

    for i:= 0 to OLmarkets.Count-1 do begin
      tc:= TTwoCodes(OLmarkets[i]);
      OList:= Cache.GetWareRestsByStores(tc.ID1);
      try
        for j:= 0 to OList.Count-1 do with TCodeAndQty(OList[j]) do
          if (fnInIntArray(ID, StorageCodes)>-1) and (Qty>constDeltaZero) then begin
            tc.ID2:= 2;
            Inc(RestCount);
            break;
          end;
      finally
        prFree(OList);
      end;
    end;
  except
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    SetLength(StorageCodes, 0);
  end;
end;
//============ запись в Stream списка видимых сотруднику к/а для выбора (WebArm)
procedure prSaveEmplFirmsChoiceList(Stream: TBoBMemoryStream; EmplID: Integer);
const nmProc = 'prSaveEmplFirmsChoiceList'; // имя процедуры/функции
var i, j, k, jj, ind0: integer;
    firm: TFirmInfo;
    lst: TList;  // not Free !!! список всех доступных фирм
    arLst: array of TList;
    lstf: TStringList; // список филиалов
begin
  if not Cache.EmplExist(EmplID) then raise EBOBError.Create(MessText(mtkNotEmplExist));
  lst:= Cache.GetEmplVisFirmLinkList(EmplID);  // not Free !!! здесь фирмы уже отсортированы по наименованию
  if lst.Count<1 then raise EBOBError.Create(MessText(mtkNotFoundFirms));

  SetLength(arLst, 0);
  try try
    lstf:= Cache.GetFilialList(False);   // False - полные наименования
    lstf.Sort;          // сортируем филиалы по наименованию

    ind0:= lstf.Count;
    SetLength(arLst, ind0+1); // готовим листы фасовки (+1 для неопознанных)
    for i:= 0 to High(arLst) do arLst[i]:= TList.Create;
    k:= 0;  // код филиала
    j:= -1; // индекс листа филиала
    for i:= 0 to lst.Count-1 do begin // фасуем доступные фирмы по филиалам
      firm:= GetLinkPtr(lst[i]);
      jj:= firm.GetDefContract.Filial;
      if (k<>jj) then begin
        k:= jj;
        j:= lstf.IndexOfObject(Pointer(k));
      end;
      if (j>-1) then arLst[j].Add(firm)  // заносим ссылку на фирму в лист филиала
      else arLst[ind0].Add(firm);        // заносим ссылку на фирму в лист неопознанных
{if flDebug then
      if (pos('Ремтехкомплект', firm.Name)>0) then begin
        prMessageLOGS('---------- firm.Name  : '+firm.Name, fLogCache);
        prMessageLOGS('---------- firm.ID    : '+IntToStr(firm.ID), fLogCache);
        prMessageLOGS('---------- firm.Filial: '+IntToStr(jj), fLogCache);
        prMessageLOGS('---------- index      : '+IntToStr(j), fLogCache);
      end;  }
    end;

    if (arLst[ind0].Count>0) then begin // добавляем фиктивный филиал
      lstf.AddObject('Филиал не определен', Pointer(0));
    end else begin
      arLst[ind0].Free;
      SetLength(arLst, ind0); // убираем лист для неопознанных
    end;

    Stream.WriteInt(lstf.Count);    // передаем список всех филиалов
    for i:= 0 to lstf.Count-1 do begin
      Stream.WriteInt(Integer(lstf.Objects[i]));  // код филиала
      Stream.WriteStr(lstf[i]);                   // наимен.
    end;

    k:= Stream.Position;
    Stream.WriteInt(lst.Count); // кол-во фирм
    jj:= 0; // счетчик (для надежности)
    for i:= 0 to lstf.Count-1 do for j:= 0 to arLst[i].Count-1 do begin // передаем фирмы
      firm:= arLst[i][j];
      Stream.WriteInt(firm.ID);             // код фирмы
      Stream.WriteInt(firm.GetDefContract.Filial);       // филиал
      Stream.WriteStr(firm.UPPERSHORTNAME); // краткое наимен.
      Stream.WriteStr(firm.Name);           // полное наимен.
      inc(jj);
    end;
    if jj<>lst.Count then begin // если случаем кол-во не то
      Stream.Position:= k;
      Stream.WriteInt(jj); // передаем кол-во
      Stream.Position:= Stream.Size;
    end;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
  finally
    for i:= 0 to High(arLst) do prFree(arLst[i]);
    SetLength(arLst, 0);
    prFree(lstf);
  end;
end;
//====================================== запись в Stream списка складов(+путей),
//======================================= видимых сотруднику для выбора (WebArm)
procedure prSaveEmplStoresChoiceList(Stream: TBoBMemoryStream; EmplID: Integer; flWithRoad: Boolean=False);
const nmProc = 'prSaveEmplStoresChoiceList'; // имя процедуры/функции
// flWithRoad=False - только склады, flWithRoad=True - склады + пути
var i, k, jj: integer;
    store: TDprtInfo;
    lst: TList;  // not Free !!! список всех видимых сотруднику складов
begin
  if not Cache.EmplExist(EmplID) then raise EBOBError.Create(MessText(mtkNotEmplExist));

  lst:= Cache.GetEmplVisStoreLinkList(EmplID);  // not Free !!!
  if lst.Count<1 then raise EBOBError.Create(MessText(mtkNotFoundFirms));
  // здесь склады уже отсортированы по филиалам
  try
    k:= Stream.Position;
    Stream.WriteInt(0); // кол-во складов
    jj:= 0; // счетчик
    for i:= 0 to lst.Count-1 do begin // передаем склады
      store:= GetLinkPtr(Lst[i]);
      if not (store.IsStoreHouse or (flWithRoad and store.IsStoreRoad)) then Continue;
      Stream.WriteInt(store.ID);             // код склада
//      Stream.WriteInt(store.FilialID);       // филиал
//      Stream.WriteStr(store.ShortName);      // краткое наимен.
      Stream.WriteStr(store.MainName);       // полное наимен.
      Stream.WriteStr(store.ColumnName);     // наимен. колонки
      Stream.WriteBool(store.IsStoreRoad);   // признак пути
      inc(jj);
    end;
    Stream.Position:= k;
    Stream.WriteInt(jj); // передаем кол-во
    Stream.Position:= Stream.Size;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message);
  end;
end;
//========================================== запись в Stream сообщения об ошибке
procedure prSaveCommonError(Stream: TBoBMemoryStream; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
var s: String;
begin
  if flEBOB then begin
    Stream.Clear;
    Stream.WriteInt(aeCommonError);
    Stream.WriteStr(fnReplaceQuotedForWeb(Emess));
    fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', Emess, MyText);
  end else begin
    Stream.Clear;
    Stream.WriteInt(aeCommonError);
    s:= '';
    if flPRS then s:= CutPRSmess(Emess);
    if s='' then s:= MessText(mtkErrProcess);
    Stream.WriteStr(s);
    fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', Emess, MyText);
  end;
end;
//========================================== запись в строку сообщения об ошибке
procedure prSaveCommonErrorStr(var errStr: String; ThreadData: TThreadData;
          nmProc, Emess, MyText: String; flEBOB: Boolean; flPRS: Boolean=False);
begin
  if flEBOB then begin
    errStr:= fnReplaceQuotedForWeb(Emess);
    fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', Emess, MyText);
  end else begin
    errStr:= '';
    if flPRS then errStr:= CutPRSmess(Emess);
    if errStr='' then errStr:= MessText(mtkErrProcess);
    fnWriteToLog(ThreadData, lgmsSysError, nmProc, '', Emess, MyText);
  end;
end;
//=========================================== обрезка сообщений от exception ORD
function CutEMess(Emess: String): String;
var i, j: Integer;
begin
  Result:= Emess;
  for j:= Low(arExceptNames) to High(arExceptNames) do begin
    i:= pos(arExceptNames[j], Result);
    if i>0 then begin
      Result:= copy(Result, i, length(Result));
      i:= pos('At procedure', Result);
      if i>0 then Result:= copy(Result, 1, i-1);
      Exit;
    end;
  end;
end;
//============================ обрезка сообщений от exception ORD + resDoNothing
function CutEMess(Emess: String; var ResCode: Integer): String;
begin
  Result:= CutEMess(Emess);
  if pos(arExceptNames[0], Result)>0 then ResCode:= resDoNothing;
end;
//=========================================== обрезать сообщение deadlock и т.п.
function CutLockMess(mess: String): String;
begin
  if (Pos('deadlock', mess)>0) then Result:= 'deadlock ...'
  else if (Pos('another user', mess)>0) or (Pos('lock conflict', mess)>0) then
    Result:= 'lock conflict ...'
  else Result:= mess;
end;
//====================================================== обрезать сообщение PRS.
function CutPRSmess(mess: String): String;
var i: Integer;
begin
  i:= pos('PRS.', mess);
  if i>0 then begin
    Result:= copy(mess, i+4);
    i:= pos(#13#10, Result);
    if i>0 then Result:= copy(Result, 1, i-1);
  end else Result:= mess;
end;
//======================================== Проверить пользователя (Web & WebArm)
function CheckNotValidUser(pUserID, pFirmID: Integer; var errmess: string): boolean;
begin
  errmess:= '';
  if pFirmID=isWe then begin                    // проверки WebArm
    if not Cache.EmplExist(pUserID) then errmess:= MessText(mtkNotEmplExist);
  end else                                      // проверки Web
    if not Cache.FirmExist(pFirmID) then errmess:= MessText(mtkNotFirmExists)
    else if Cache.arFirmInfo[pFirmID].Blocked then errmess:= MessText(mtkNotFirmProcess)
    else if not Cache.ClientExist(pUserID) then errmess:= MessText(mtkNotClientExist)
    else with Cache.arClientInfo[pUserID] do
      if Blocked then errmess:= MessText(mtkBlockCountLogin, Login)
      else if FirmID<>pFirmID then errmess:= MessText(mtkNotClientOfFirm);
  Result:= errmess<>'';
end;
//===================================== Получить систему и валюту (Web & WebArm)
procedure prCheckUserForFirmAndGetSysCurr(UserID, FirmID: Integer;
          var ForFirmID, Sys, CurrID: Integer; PriceInUah: Boolean=False; contID: Integer=0);
var errmess: String;
begin
  Sys:= 0;
  CurrID:= 0;
  if CheckNotValidUser(UserID, FirmID, errmess) then raise EBOBError.Create(errmess);
  if FirmID=isWe then begin                    //------------- WebArm
    if (ForFirmID>0) and (not Cache.FirmExist(ForFirmID)  // если задан к/а
      or not Cache.CheckEmplVisFirm(UserID, ForFirmID)) then ForFirmID:= 0;
    currID:= fnIfInt(PriceInUah, 1, cDefCurrency);
  end else begin                                //------------- Web
    currID:= Cache.arClientInfo[UserID].SearchCurrencyID;
  end;
  if not Cache.CurrExists(currID) then currID:= cDefCurrency;
end;
//======================================================== проверка сумм док-тов
procedure CheckDocSum;
const nmProc='CheckDocSum';
var GB_IBS: TIBSQL;
    GB_IBD: TIBDatabase;
    i, j, iType, iDocm: integer;
    mess, adr: string;
    curdocs: array of TTwoCodes;
    curdoc: TTwoCodes;
    fl: boolean;
    Body: TStringList;
begin
  if not Assigned(Cache) then Exit;
  if not Cache.flCheckDocSum then exit;
  if not fnGetActionTimeEnable(caeOnlyWorkTime) then Exit; // только в рабочее время
  if (dLastCheckDocTime<>DateNull) and
    (Now<IncMinute(dLastCheckDocTime, Cache.GetConstItem(pcCheckDocInterval).IntValue)) then exit;
  GB_IBS:= nil;
  GB_IBD:= nil;
  Body:= TStringList.Create;
  setlength(curdocs, 0);
  try try
    GB_IBD:= cntsGRB.GetFreeCnt;
    GB_IBS:= fnCreateNewIBSQL(GB_IBD, 'GB_IBS_'+nmProc, -1, tpRead, true);
    iType:= 102; //------------------------------------------------------- счета
    GB_IBS.SQL.Text:= 'select pinvcode, pinvnumber, pinvdate, delta,'+
      ' firmcode, firmmainname, crncshortname'+
      ' from (select rr.pinvcode, rr.pinvnumber, rr.pinvdate, f.firmcode, f.firmmainname,'+
      '  rr.pinvsumm-(1-rr.disc/100)*Lsum delta, cur.crncshortname, rr.Lsum, rr.LCount'+
      '  from (select r.pinvcode, r.pinvnumber, r.pinvdate, r.pinvwarelinecount LCount,'+
      '   r.pinvsumm, r.pinvdiscount disc, r.PInvRecipientCode, r.pinvcrnccode,'+
      '   (select sum(l.pinvlnprice*l.pinvlncount) from PAYINVOICELINES l'+
      '    where l.pinvlndocmcode=r.pinvcode) Lsum from PAYINVOICEREESTR r'+
      '  inner join userpsevdonimreestr on userfirmcode=r.PInvRecipientCode and (usercode<>1)'+
      '  where r.pinvdate>:From order by r.PInvRecipientCode, r.pinvdate) rr'+
      ' left join firms f on f.firmcode = rr.PINVRECIPIENTCODE'+
      ' left join currency cur on cur.crnccode = rr.pinvcrnccode)'+
      ' where ABS(delta)>:Delta or (Lsum>0 and LCount=0)';
    GB_IBS.ParamByName('From').AsDate:= Cache.GetConstItem(pcCheckDocFromDate).DateValue;
    GB_IBS.ParamByName('Delta').AsFloat:= Cache.GetConstItem(pcCheckDocSumDelta).DoubValue;
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iDocm:= GB_IBS.FieldByName('pinvcode').AsInteger;
      j:= length(curdocs); // запоминаем все док-ты
      setlength(curdocs, j+1);
      curdocs[j]:= TTwoCodes.Create(iType, iDocm);
      fl:= False;
      if CheckDocsList.Count>0 then for i:= 0 to CheckDocsList.Count-1 do begin
        with TTwoCodes(CheckDocsList.objects[i]) do fl:= (ID1=iType) and (ID2=iDocm);
        if fl then break;
      end;
      if not fl then begin // если такого док-та в списке нет - дописываем
        mess:= '  счет N '+GB_IBS.FieldByName('pinvnumber').AsString+' от '+
          FormatDateTime(cDateFormatY4, GB_IBS.FieldByName('pinvdate').AsDate)+
          ' - разница = '+FormatFloat('# ##0.000', GB_IBS.FieldByName('delta').AsFloat)+
          ' '+GB_IBS.FieldByName('crncshortname').AsString+
          '   к/а '+GB_IBS.FieldByName('firmmainname').AsString;
        CheckDocsList.AddObject(mess, TTwoCodes.Create(iType, iDocm));
      end;
      TestCssStopException;
      GB_IBS.Next;
    end;
    GB_IBS.Close;


    iType:= -1; //----------------------------------------- контракты без валюты
    GB_IBS.SQL.Text:= 'select f.firmmainname, c.contnumber, c.contcode from contract c'+
      ' left join firms f on f.firmcode=c.contsecondparty'+
      ' where c.contendingdate>"today" and (c.contdutycrnccode is null or c.contdutycrnccode < 1)'+
//      ' and c.contfirstparty=(select userfirmcode from userpsevdonimreestr where usercode=1)'+
      '  and f.firmchildcount=0 and f.firmarchivedkey="F" and f.firmservicefirm="F"';
    if flDebug then GB_IBS.SQL.Text:= GB_IBS.SQL.Text+' and c.contcode<200';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iDocm:= GB_IBS.FieldByName('contcode').AsInteger;
      j:= length(curdocs); // запоминаем все док-ты
      setlength(curdocs, j+1);
      curdocs[j]:= TTwoCodes.Create(iType, iDocm);
      fl:= False;
      if CheckDocsList.Count>0 then for i:= 0 to CheckDocsList.Count-1 do begin
        with TTwoCodes(CheckDocsList.objects[i]) do fl:= (ID1=iType) and (ID2=iDocm);
        if fl then break;
      end;
      if not fl then begin // если такого док-та в списке нет - дописываем
        mess:= 'к/а - '+fnMakeAddCharStr(GB_IBS.FieldByName('firmmainname').AsString, 40, True)+
               ' - контракт '+GB_IBS.FieldByName('contnumber').AsString;
        CheckDocsList.AddObject(mess, TTwoCodes.Create(iType, iDocm));
      end;
      TestCssStopException;
      GB_IBS.Next;
    end;

    for i:= CheckDocsList.Count-1 downto 0 do begin // удаляем те, что ушли
      curdoc:= TTwoCodes(CheckDocsList.Objects[i]);
      fl:= False;
      for j:= 0 to High(curdocs) do begin
        fl:= (curdoc.ID1=curdocs[j].ID1) and (curdoc.ID2=curdocs[j].ID2);
        if fl then break;
      end;
      if fl then Continue;
      prFree(curdoc);
      CheckDocsList.Delete(i);
    end;

    fl:= False;
    for i:= 0 to CheckDocsList.Count-1 do begin // сначала счета
      if (CheckDocsList[i]='') then Continue;
      if (TTwoCodes(CheckDocsList.Objects[i]).ID1<0) then begin
        fl:= True;     // признак, что есть контракты
        Continue;      // контракты пропускаем
      end;
      Body.Add(CheckDocsList[i]);
    end;  // for

    if fl then begin // есть контракты
      Body.Add(' ');
      Body.Add('------------------------------------------------');
      Body.Add('   не задана валюта контракта / задолженности');
      Body.Add('------------------------------------------------');
      for i:= 0 to CheckDocsList.Count-1 do begin
        if (CheckDocsList[i]='') then Continue;
        if (TTwoCodes(CheckDocsList.Objects[i]).ID1>0) then Continue; // счета пропускаем
        Body.Add(CheckDocsList[i]);
      end;  // for
    end;

    if Body.Count>0 then begin
      adr:= Cache.GetConstItem(pcCheckDocMail).StrValue;
      if adr='' then adr:= fnGetSysAdresVlad(caeOnlyWorkDay);
      mess:= n_SysMailSend(adr, 'Проблемные документы', Body, nil, '', '', True);
      if (mess<>'') and (Pos(MessText(mtkErrMailToFile), mess)>0) then
        raise Exception.Create('Ошибка отправки письма о проблемных док-тах')
      else begin
        prMessageLOGS(nmProc+': Отправлено письмо о проблемных док-тах в адрес '+adr, 'system');
        for i:= 0 to CheckDocsList.Count-1 do
          if (CheckDocsList[i]<>'') then CheckDocsList[i]:= '';
      end;
    end;
    dLastCheckDocTime:= Now;
  finally
    prFreeIBSQL(GB_IBS);
    cntsGRB.SetFreeCnt(GB_IBD);
    prFree(Body);
    for i:= 0 to High(curdocs) do prFree(curdocs[i]);
    setlength(curdocs, 0);
  end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;
//============================================================= проверка адресов
procedure CheckClientsEmails;
const nmProc='CheckClientsEmails';
var GB_IBS: TIBSQL;
    GB_IBD: TIBDatabase;
    i, iFirm: integer;
    mess, adr, sFirm, s: string;
    fl: boolean;
    Body: TStringList;
  //------------------------------------
  procedure SaveFirm;
  begin
    Body.Add('');
    Body.Add('---------- '+sFirm);
    fl:= False;
  end;
  //------------------------------------
begin
  if not Assigned(Cache) then Exit;
  if not Cache.flCheckCliEmails then exit;
  if not fnGetActionTimeEnable(caeOnlyWorkTime) then Exit; // только в рабочее время
  if (dLastCheckCliEmails<>DateNull) and    // если не прошел заданный интервал
    (Now<IncHour(dLastCheckCliEmails, Cache.GetConstItem(pcZeroPricesIntHour).IntValue)) then exit;
  GB_IBS:= nil;
  GB_IBD:= nil;
  Body:= TStringList.Create;
  try try
    GB_IBD:= cntsGRB.GetFreeCnt;
    GB_IBS:= fnCreateNewIBSQL(GB_IBD, 'GB_IBS_'+nmProc, -1, tpRead, true);

    GB_IBS.SQL.Text:= 'select * from (select f.firmmastercode, f.firmcode,'+
      '  f.firmmainname, f.firmemail, null contcode,  null contnumber,'+
      '  null contsecondemail, null prsncode, null prsnpost, null prsnname,'+
      '  null prsnlogin, null peemail from firms f where f.firmarchivedkey="F"'+
      '  and f.firmservicefirm="F" and f.firmchildcount=0 and (f.firmemail is not null)'+
      ' union select f2.firmmastercode, f2.firmcode, f2.firmmainname, null firmemail, c.contcode,'+
      '  c.contnumber||"-"||RIGHT(cast(EXTRACT(YEAR FROM CONTBEGININGDATE) as varchar(4)), 2) contnumber,'+
      '  c.contsecondemail, null prsncode, null prsnpost, null prsnname,'+
      '  null prsnlogin, null peemail from firms f2'+
      '  left join contract c on c.contsecondparty=f2.firmcode where f2.firmarchivedkey="F"'+
      '  and f2.firmservicefirm="F" and f2.firmchildcount=0 and c.contfirstparty='+
      '  (select u.userfirmcode from userpsevdonimreestr u where u.usercode=1)'+
      '  and c.contendingdate>"today" and (c.contsecondemail is not null)'+
      ' union select f1.firmmastercode, f1.firmcode, f1.firmmainname, null firmemail, null contcode,'+
      '  null contnumber, null contsecondemail, pr.prsncode, pr.prsnpost, pr.prsnname,'+
      '  pr.prsnlogin, pm.peemail from firms f1 left join persons pr on pr.prsnfirmcode=f1.firmcode'+
      '  left join personemails pm on pm.pepersoncode=pr.prsncode where f1.firmarchivedkey="F"'+
      '  and f1.firmservicefirm="F" and f1.firmchildcount=0 and pr.prsnarchivedkey="F"'+
      '  and pm.pearchivedkey="F" and (pm.peemail is not null))'+
      '  order by firmmastercode, firmcode, firmemail nulls last, contcode nulls last, prsncode nulls last';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      iFirm:= GB_IBS.FieldByName('firmcode').AsInteger;
      fl:= True;
      sFirm:= 'к/а '+GB_IBS.FieldByName('firmmainname').AsString;
      adr:= GB_IBS.FieldByName('firmemail').AsString;
      if (adr<>'') and not fnCheckEmail(adr) then begin
        if fl then SaveFirm;
        Body.Add('к/а - E-mail: '+adr);
      end;
      while not GB_IBS.Eof and (iFirm=GB_IBS.FieldByName('firmcode').AsInteger) do begin
        i:= GB_IBS.FieldByName('contcode').AsInteger;
        if (i>0) then begin
          s:= 'контракт '+GB_IBS.FieldByName('contnumber').AsString;
          adr:= GB_IBS.FieldByName('contsecondemail').AsString;
          if (adr<>'') and not fnCheckEmail(adr) then begin
            if fl then SaveFirm;
            Body.Add(s+' - E-mail: '+adr);
          end;
        end;
        i:= GB_IBS.FieldByName('prsncode').AsInteger;
        if (i>0) then begin
          s:= 'польз. '+GB_IBS.FieldByName('prsnpost').AsString+', '+GB_IBS.FieldByName('prsnname').AsString;
          adr:= GB_IBS.FieldByName('peemail').AsString;
          if (adr<>'') and not fnCheckEmail(adr) then begin
            if fl then SaveFirm;
            Body.Add(s+' - E-mail: '+adr);
          end;
        end;
        GB_IBS.Next;
      end;
      TestCssStopException;
    end;
    GB_IBS.Close;

    fl:= True;
    GB_IBS.SQL.Text:='Select EMPLCODE, EMPLMANCODE,'+
      ' MANLASTNAME, MANNAME, MANPATRONYMICNAME, MANWORKEMAIL'+
      ' FROM EMPLOYEES inner join MANS on EMPLMANCODE=MANCODE'+
      ' where EMPLARCHIVE="F" and MANARCHIVE="F"';
    GB_IBS.ExecQuery;
    while not GB_IBS.Eof do begin
      adr:= GB_IBS.FieldByName('MANWORKEMAIL').AsString;
      if (adr<>'') and not fnCheckEmail(adr) then begin
        if fl then begin
          Body.Add('');
          Body.Add('');
          Body.Add('---------- сотрудники Компании');
          fl:= False;
        end;
        s:= GB_IBS.FieldByName('MANLASTNAME').AsString+' '+
            GB_IBS.FieldByName('MANNAME').AsString+' '+
            GB_IBS.FieldByName('MANPATRONYMICNAME').AsString;
        Body.Add(s+' - E-mail: '+adr);
      end;
      GB_IBS.Next;
      TestCssStopException;
    end;
    GB_IBS.Close;

    if Body.Count>0 then begin
      Body.Insert(0, 'Правила написания адресов E-mail:');
      Body.Insert(1, '- формат адреса (имя)@(домен)');
      Body.Insert(2, '- (имя) может содержать только англ.буквы, цифры, точку, тире, подчеркивание');
      Body.Insert(3, '- (домен) может содержать только англ.буквы, цифры, точку, тире');
      Body.Insert(4, '- (имя) и (домен) не должны начинаться и заканчиваться точкой');
      Body.Insert(5, '- (домен) должен содержать не менее 1-й точки');
      Body.Insert(6, '- (домен) должен содержать не менее 2-х символов после последней точки');
      Body.Insert(7, '- несколько адресов E-mail в строке разделяются только запятыми.');
      Body.Insert(8, '');
      Body.Insert(9, 'Перечень адресов E-mail, не соответствующих правилам:');

      adr:= Cache.GetConstItem(pcUIKdepartmentMail).StrValue; // общий Email отдела УИК
      if adr='' then adr:= fnGetSysAdresVlad(caeOnlyWorkDay);
      mess:= n_SysMailSend(adr, 'Проблемные E-mail', Body, nil, '', '', True);
      if (mess<>'') and (Pos(MessText(mtkErrMailToFile), mess)>0) then
        raise Exception.Create('Ошибка отправки письма о проблемных E-mail')
      else
        prMessageLOGS(nmProc+': Отправлено письмо о проблемных E-mail в адрес '+adr, 'system');
    end;
    dLastCheckCliEmails:= Now;
  finally
    prFreeIBSQL(GB_IBS);
    cntsGRB.SetFreeCnt(GB_IBD);
    prFree(Body);
  end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;
//=========== Формирование списка префиксов для добавления к артикулу при поиске
function GetLstPrefixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // must Free Result
// UseOnlyBrand = True. вынимать код бренда. False - если по ID необходим конроль группы
var BID: Integer;
begin
  Result:= TStringList.Create;
  if UseOnlyBrand then BID:= Cache.GetGrpID(pBrandID) else BID:= pBrandID;
  case BID of
    85413: Result.Append('AVX');  // CONTITECH
  end;
end;
//=========== Формирование списка суффиксов для добавления к артикулу при поиске
function GetLstSufixAddon(pBrandID: Integer; UseOnlyBrand: Boolean=True): TStringList; // must Free Result
// UseOnlyBrand = True. вынимать код бренда. False - если по ID необходим конроль группы
var BID: Integer;
begin
  Result:= TStringList.Create;
  if UseOnlyBrand then BID:= Cache.GetGrpID(pBrandID) else BID:= pBrandID;
  case BID of
    85413: Result.Append('LD');   // CONTITECH
  end;
end;
//============= сортировка TStringList по наименованию товара, если ID в Objects
function ObjWareNameSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var s1, s2: String;
begin
  with Cache do try
    s1:= GetWare(Integer(List.Objects[Index1]), True).Name;
    s2:= GetWare(Integer(List.Objects[Index2]), True).Name;
    Result:= AnsiCompareText(s1, s2);
  except
    Result:= 0;
  end;
end;
//-- свернуть ноды дерева узлов с 1 ребенком, TreeList[i] - Pointer(TSecondLink)
procedure prHideTreeNodes(var ListNodes, listParCodes: TList; flOnlySameName, flOnlyOneLevel: boolean);
const nmProc = 'prHideTreeNodes'; // имя процедуры/функции
var i, j, jj, ii, NodeIndex, levelCount, iDel, iDel1: Integer;
    flHide, flNotFound: boolean;
    NodeName: String;
    link: TSecondLink;
    Node: TAutoTreeNode;
    arNodeCodes, arParCodes, arNodes1, arNodes2, arParIn: Tai;
    arNodeNames: Tas;
  //----------------------------------------------
  procedure FillNodeCodes(var arNodes: Tai; ParCode: Integer);
  var i: integer;
  begin
    setLength(arNodes, 0); // массив кодов конечных главных нод в ветке
    setLength(arParIn, 0);  // массив кодов внутренних неконечных нод в ветке
    with ListNodes do for i:= 0 to Count-1 do begin
      link:= Items[i];
      Node:= link.LinkPtr;
      if Node.ID=ParCode then prAddItemToIntArray(ParCode, arParIn);
      if (Length(arParIn)<1) or // не дошли до родителя
        (fnInIntArray(Integer(listParCodes[i]), arParIn)<0) then Continue; // не тот родитель
      if Node.IsEnding then
        prAddItemToIntArray(Node.MainCode, arNodes) // конечная нода
      else prAddItemToIntArray(Node.ID, arParIn); // неконечная нода
    end;
  end;
  //----------------------------------------------
  procedure HideNodesWithOneChild;
  var i, jj, ChildCount: integer;
  begin
    NodeIndex:= -1;
    NodeName:= '';
    levelCount:= 0;  // счетчик уровней спрятанных нод
    with ListNodes do for i:= Count-1 downto 0 do begin //-- чистим ненужные ноды - идем снизу
      ChildCount:= 0;
      link:= Items[i];
      Node:= link.LinkPtr;
      ii:= Integer(listParCodes[i]); // код родителя текущей ноды
      flHide:= not Node.IsEnding and (ii>0) and (NodeIndex=(i+1)) // нода не конечная и не 1-й уровень
        and (Node.ID=Integer(listParCodes[NodeIndex]));           // и родитель стоит перед ребенком
      if flHide and flOnlySameName then flHide:= (Node.Name=NodeName);
      if flHide and flOnlyOneLevel then flHide:= (levelCount<1);
      if flHide then begin
        for jj:= NodeIndex+1 to listParCodes.Count-1 do
          if Node.ID=Integer(listParCodes[jj]) then begin
            flHide:= False;
            break;
          end;                   // если у текущей ноды были дети раньше
        if not flHide then begin // проверяем, есть ли еще дети у верхней ноды
          for jj:= 0 to listParCodes.Count-1 do begin
            if ii=Integer(listParCodes[jj]) then inc(ChildCount);
          end;
          flHide:= ChildCount<2;
        end;
      end; // if flHide
      if flHide then begin // ноду прячем
        for jj:= i+1 to listParCodes.Count-1 do // переназначаем родителя всем детям текущей ноды
          if (Integer(listParCodes[jj])=Node.ID) then listParCodes[jj]:= listParCodes[i];
        Delete(i);
        listParCodes.Delete(i);
        inc(iDel);
        Dec(NodeIndex);
        inc(levelCount);
      end else begin
        NodeName:= Node.Name; // запоминаем последнюю неспрятанную ноду
        NodeIndex:= i;
        levelCount:= 0;               // сбрасываем счетчик уровней
      end;
    end; // for i:= Count-1 downto 0
  end;
  //----------------------------------------------
begin
  setLength(arNodeCodes, 0);
  setLength(arNodeNames, 0);
  setLength(arParCodes, 0);
  setLength(arNodes1, 0);
  setLength(arNodes2, 0);
  setLength(arParIn, 0);
  with ListNodes do try // список нод дерева
    repeat
      iDel:= 0;
//---------------------------------- сворачиваем ноды с 1-м ребенком
      HideNodesWithOneChild;
//---------------------------------- ищем дубликаты конечных нод у 1-го родителя
      iDel1:= 0;
      setLength(arParCodes, 0);     // массив родит.кодов конечных нод
      for i:= 0 to Count-1 do begin
        link:= Items[i];
        Node:= link.LinkPtr;
        if Node.IsEnding then prAddItemToIntArray(Integer(listParCodes[i]), arParCodes);
      end;
      for j:= High(arParCodes) downto 0 do begin
        setLength(arNodeCodes, 0);
        for i:= Count-1 downto 0 do begin // проверяем ноды 1-го родителя - идем снизу
          link:= Items[i];
          Node:= link.LinkPtr;
          if Node.ID=arParCodes[j] then break; // дошли до родителя
          if not Node.IsEnding then Continue; // не конечная нода
          if (Integer(listParCodes[i])<>arParCodes[j]) then Continue; // не тот родитель
          if (fnInIntArray(Node.MainCode, arNodeCodes)>-1) then begin // нашли дубликат
            Delete(i);
            listParCodes.Delete(i);
            inc(iDel);
            inc(iDel1);
          end else prAddItemToIntArray(Node.MainCode, arNodeCodes);
        end;
      end; // for j:= High(arParCodes) downto 0

//--------------------------- если были дубликаты конечных нод - еще сворачиваем
      if iDel1>0 then HideNodesWithOneChild;

//----------------------------------------- ищем дубликаты веток у 1-го родителя
      setLength(arParCodes, 0);  // массив кодов родителей родителей конечных нод
      setLength(arParIn, 0);     // массив кодов родителей конечных нод
      for i:= Count-1 downto 0 do begin
        link:= Items[i];
        Node:= link.LinkPtr;
        jj:= Integer(listParCodes[i]);
        if Node.IsEnding then prAddItemToIntArray(jj, arParIn)
        else if (jj>0) and (fnInIntArray(Node.ID, arParIn)>-1) then
          prAddItemToIntArray(jj, arParCodes);
      end;

      for j:= 0 to High(arParCodes) do begin
        setLength(arNodeCodes, 0);     // здесь - массив кодов не конечных нод (веток)
        setLength(arNodeNames, 0);     // массив наименований не конечных нод (веток)
        for i:= Count-1 downto 0 do begin // заполняем массив кодов веток
          link:= Items[i];
          Node:= link.LinkPtr;
          if Node.ID=arParCodes[j] then break; // дошли до родителя
          if Node.IsEnding then Continue; // конечная нода
          if (Integer(listParCodes[i])<>arParCodes[j]) then Continue; // не тот родитель
          if fnInIntArray(Node.ID, arNodeCodes)<0 then begin
            jj:= Length(arNodeCodes);
            setLength(arNodeCodes, jj+1);
            arNodeCodes[jj]:= Node.ID;
            setLength(arNodeNames, jj+1);
            arNodeNames[jj]:= Node.Name;
          end;
        end; // for i:= Count-1 downto 0

        while (Length(arNodeCodes)>1) do begin // ищем дубликаты, если не менее 2-х веток
          NodeName:= arNodeNames[0];  // наименование род.ноды 1-й ветки
          FillNodeCodes(arNodes1, arNodeCodes[0]); // заполняем массив главных кодов конечных нод 1-й ветки
   //--------------------------------------------- сверяем остальные ветки с 1-й
          if Length(arNodes1)>0 then for jj:= 1 to High(arNodeCodes) do begin
            if flOnlySameName and (arNodeNames[jj]<>NodeName) then Continue; // не совп.наименование

            FillNodeCodes(arNodes2, arNodeCodes[jj]); // заполняем массив главных кодов конечных нод jj-й ветки
            if (Length(arNodes2)<1) then Continue;
            if Length(arNodes2)<>Length(arNodes1) then Continue; // не совп.кол-во нод

            flNotFound:= False;
            for ii:= 0 to High(arNodes2) do begin // сверяем массивы кодов конечных нод
              flNotFound:= fnInIntArray(arNodes2[ii], arNodes1)<0;
              if flNotFound then break;
            end;
            if flNotFound then Continue; // jj-ветка <> 1-й ветке
   //---------------------------------------------------- убираем дубликат ветки
            setLength(arNodes2, 0); // здесь - коды нод ветки для удаления
            setLength(arParIn, 0); // массив кодов родительских нод в ветке
            levelCount:= -1;
            for i:= 0 to Count-1 do begin
              link:= Items[i];
              Node:= link.LinkPtr;
              if Node.ID=arNodeCodes[jj] then begin // ищем род.ноду jj-й ветки и ее индекс
                levelCount:= i; // индекс, от которого перебирать ноды
                prAddItemToIntArray(Node.ID, arNodes2);
                prAddItemToIntArray(Node.ID, arParIn);
                arNodeCodes[jj]:= 0;  // удаляем код род.ноды jj-й ветки из массива
              end;
              if levelCount<0 then Continue; // не дошли до род.ноды jj-й ветки
              if fnInIntArray(Integer(listParCodes[i]), arParIn)<0 then Continue; // не тот родитель
              if not Node.IsEnding then
                prAddItemToIntArray(Node.ID, arParIn); // неконечные ноды запоминаем
              prAddItemToIntArray(Node.ID, arNodes2);  // коды детей ветки
            end;

            for i:= Count-1 downto levelCount do begin // удаляем ноды ветки
              link:= Items[i];
              Node:= link.LinkPtr;
              if fnInIntArray(Node.ID, arNodes2)<0 then Continue;
              Delete(i);
              listParCodes.Delete(i);
              inc(iDel);
            end;
   //----------------------------------------------------- убрали дубликат ветки
          end; // for jj:= 1 to High(arNodeCodes)
          arNodeCodes[0]:= 0; // удаляем код род.ноды проверенной ветки из массива
          ii:= 0;
          while Length(arNodeCodes)>ii do
            if arNodeCodes[ii]<1 then begin
              prDelItemFromArray(ii, arNodeCodes);
              prDelItemFromArray(ii, arNodeNames);
            end else Inc(ii);
        end; // while (Length(arNodeCodes)>1)
      end; // for j:= 0 to High(arParCodes)
    until (iDel<1);
//--------------------------- еще раз сворачиваем для надежности
    HideNodesWithOneChild;
  finally
    setLength(arNodeCodes, 0);
    setLength(arNodeNames, 0);
    setLength(arParCodes, 0);
    setLength(arNodes1, 0);
    setLength(arNodes2, 0);
    setLength(arParIn, 0);
  end;
end;

//=================================================== формируем имя файла отчета
function fnFormRepFileName(pSubName, pNameOrExt: string; pOpKind: integer): string;
// возвращает имя файла без пути !!!
// pSubName - строка-идентификатор отчета ("26", "30_1", ...)
// pNameOrExt (Экспорт) - расширение файла отчета, можно без точки - добавит
// pNameOrExt (Импорт)  - имя исх.файла импорта с расширением, можно с путем - отрежет
// pOpKind - вид операции [constOpExport, constOpImport]
var pFileExt, MidName: String;
begin
  Result:= '';
  MidName:= '';
  pFileExt:= '';
  if (pSubName='') then
    raise EBOBError.Create(MessText(mtkNotValidParam)+' - пустой идентификатор файла');
  case pOpKind of
    constOpImport: begin // Импорт
        if (length(pNameOrExt)<5) then
          raise EBOBError.Create(MessText(mtkNotValidParam)+' - имя файла импорта '+pNameOrExt);

        MidName:= ExtractFileName(pNameOrExt);                // убираем путь
        pFileExt:= ExtractFileExt(MidName);                   // вынимаем расширение
        MidName:= copy(MidName, 1, pos(pFileExt, MidName)-1); // вынимаем имя до расширения

        MidName:= MidName+'_import_'+pSubName;                // добавляем идентификатор импорта
      end; // constOpImport

    constOpExport: begin // Экспорт/отчет
        if length(pNameOrExt)<3 then            // расширение
          raise EBOBError.Create(MessText(mtkNotValidParam)+' - расширение файла '+pNameOrExt);

        if (copy(pNameOrExt, 1, 1)='.') then pFileExt:= pNameOrExt
        else begin // если в начале расширения нет точки
          if pos('.', pNameOrExt)>0 then // если есть точка дальше
            raise EBOBError.Create(MessText(mtkNotValidParam)+' - расширение файла '+pNameOrExt);
          pFileExt:= '.'+pNameOrExt;      // добавляем точку
        end;

        MidName:= 'report_'+pSubName;     // формируем начало имени файла - идентификатор отчета
      end; // constOpExport

    else raise EBOBError.Create(MessText(mtkNotValidParam)+' операции '+IntToStr(pOpKind));
  end; // case
  if (MidName='') or (length(pFileExt)<3) then // на всяк.случай
    raise EBOBError.Create(MessText(mtkNotValidParam)+' - имя файла '+MidName+pFileExt);

  Result:= MidName+FormatDateTime('_yy.mm.dd_(hh.nn)', Now)+pFileExt;
end;
//================================== отправляет сообщение пользователя об ошибке
function fnSendErrorMes(FirmID, UserID, MesType, WareId, AnalogId, OrNumId, ModelId, NodeId: Integer;
         SenderMess, AttrMess: String; ThreadData: TThreadData): String;
const nmProc = 'fnSendErrorMes'; // имя процедуры/функции
// Exception передает наружу, возвращает сообщение для пользователя
var OrdIBD: TIBDatabase;
    OrdIBS: TIBSQL;
    Body, SENDERCOMM, MessForSender: TStringList;
    Employee: TEmplInfoItem;
    Client: TClientInfo;
    Model: TModelAuto;
    Node: TAutoTreeNode;
    Eng: TEngine;
    Ware, Analog: TWareInfo;
    ONum: TOriginalNumInfo;
    email, emailM, s, s1, sErr, sMonitoring: string;
    SysID, ManagerID, i, EmplID: integer;
    Monitorings: Tai;
  //-------------------------------------
  procedure AddEmployeeMail(eid: Integer);
  begin
    if fnInIntArray(eid, Monitorings)>-1 then exit;
    if not Cache.EmplExist(eid) then Cache.TestEmpls(eid);
    if not Cache.EmplExist(eid) then begin
      sErr:= sErr+fnIfStr(sErr='', '', #10)+
        MessText(mtkNotEmplExist, IntToStr(eid));
      exit;
    end;
    Employee:= Cache.arEmplInfo[eid];
    if Employee.Mail='' then
      sErr:= sErr+fnIfStr(sErr='', '', #10)+
        MessText(mtkNotManagerMail, Employee.EmplShortName)
    else begin
      email:= email+fnIfStr(email='', '', ',')+Employee.Mail;
      sMonitoring:= sMonitoring+fnIfStr(sMonitoring='', '', #10)+
        Employee.Mail+' ('+Employee.EmplShortName+')';
    end;
  end;
  //-------------------------------------
begin
  Result:= '';
  OrdIBD:= nil;
  OrdIBS:= nil;
  Body:= TStringList.Create;
  SENDERCOMM:= TStringList.Create;
  MessForSender:= TStringList.Create;
  email:= '';
  emailM:= '';
  s:= '';
  s1:= '';
  sErr:= '';
  sMonitoring:= '';
  SetLength(Monitorings, 0);
  try try
    if (FirmID=isWe) then begin
      if not Cache.EmplExist(UserId) then raise EBOBError.Create(MessText(mtkNotEmplExist));
      Employee:= Cache.arEmplInfo[UserId];
      Body.Add('Сотрудник Компании '+Employee.EmplLongName+
        #10'(E-mail: '+fnIfStr(Employee.Mail='', 'не найден', Employee.Mail)+') сообщает:'#10);

    end else begin
      if CheckNotValidUser(UserID, FirmID, s) then raise EBOBError.Create(s);
      Client:= Cache.arClientInfo[UserId];
      Body.Add('Представитель контрагента '+Client.FirmName+' - '+Client.Name+', '+Client.Post+
        #10+'(E-mail: '+fnIfStr(Client.Mail='', 'не найден', Client.Mail)+') сообщает:'#10);
    end;

    Ware:= Cache.GetWare(WareId);
    if not Assigned(Ware) or (Ware=NoWare) then
      raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareId)));

    Monitorings:= Cache.GetConstEmpls(pcErrMessMonitoringEmpl);

//------------------------------------------- формируем тексты и адреса рассылки
    case MesType of // case 1
      constWrongAttribute: begin //---------------------- атрибуты - только мото ???
        SysID:= constIsMoto;
        EmplID:= GetSysTypeEmpl(SysID);
//        EmplID:= Ware.ManagerID; // менеджер товара   ???
        AddEmployeeMail(EmplID);

        SENDERCOMM.Add('Ошибка параметров товара '+Ware.Name+': '+AttrMess); // формирум текст для базы
        Body.Add('--- Ошибка параметров товара.');                           // формирум текст для письма
        Body.Add('Товар: '+Ware.Name);
        Body.Add(AttrMess);
      end; // constWrongAttribute

      constWrongEngineNode: begin //-------------------- двигатели - только авто
        SysID:= constIsAuto;
        if not Cache.FDCA.Engines.ItemExists(ModelId) then
          raise EBOBError.Create(MessText(mtkNotFoundEngine, IntToStr(ModelId)));
        Eng:= Cache.FDCA.Engines.GetEngine(ModelId);
        if not Cache.FDCA.AutoTreeNodesSys[SysID].NodeGet(NodeId, Node) then
          raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeId)));

        EmplID:= GetSysTypeEmpl(SysID);
        AddEmployeeMail(EmplID);

        SENDERCOMM.Add('Товар '+Ware.Name+' не соответствует узлу '+  // формирум текст для базы
          Node.Name+' двигателя '+Eng.WebName);
        Body.Add('--- Ошибка соответствия товара двигателю и узлу.'); // формирум текст для письма
        Body.Add('Двигатель: '+Eng.WebName);
        Body.Add('Узел: '+Node.Name);
        Body.Add('Товар: '+Ware.Name);
      end; // constWrongEngineNode

      constWrongModelNode: begin //---------------------- модели - авто или мото
        if not Cache.FDCA.Models.ModelExists(ModelId) then
          raise EBOBError.Create(MessText(mtkNotFoundModel, IntToStr(ModelId)));
        Model:= Cache.FDCA.Models.GetModel(ModelId);
        SysID:= Model.TypeSys;
        if not Cache.FDCA.AutoTreeNodesSys[SysID].NodeGet(NodeId, Node) then      // NodeID=-1 ???
          raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeId)));

        EmplID:= GetSysTypeEmpl(SysID);
        AddEmployeeMail(EmplID);

        SENDERCOMM.Add('Товар '+Ware.Name+' не соответствует узлу '+ // формирум текст для базы
          Node.Name+' модели '+Model.WebName);
        Body.Add('--- Ошибка соответствия товара модели и узлу.');   // формирум текст для письма
        Body.Add('Модель: '+Model.WebName);
        Body.Add('Узел: '+Node.Name);
        Body.Add('Товар: '+Ware.Name);
      end; // constWrongModelNode

      constWrongAnalog..constWrongOrNum: begin
        EmplID:= Ware.ManagerID; // менеджер товара
        AddEmployeeMail(EmplID);

        case MesType of // case 2
          constWrongAnalog: begin
            if not Cache.WareExist(AnalogId) then
              raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(AnalogId)));
            Analog:= Cache.GetWare(AnalogId);

            ManagerID:= Analog.ManagerID;  // менеджер аналога
            if (ManagerID<>EmplID) then   // если менеджер другой - добавляем его адрес
              AddEmployeeMail(ManagerID);

            SENDERCOMM.Add('Товар '+Analog.Name+       // формирум текст для базы
              ' не является аналогом товара '+Ware.Name);
            Body.Add('--- Ошибка указания аналога.');  // формирум текст для письма
            Body.Add('Товар: '+Ware.Name);
            Body.Add('Аналог: '+Analog.Name);
          end; // constWrongAnalog

          constWrongDescription: begin
            SENDERCOMM.Add('Ошибка в описании товара '+Ware.Name); // формирум текст для базы
            Body.Add('--- Ошибка в описании товара.');
            Body.Add('Товар: '+Ware.Name);
          end; // constWrongDescription

          constWrongOrNum: begin
            if not Cache.FDCA.OrigNumExist(OrNumId) then
              raise EBOBError.Create('Не найден оригинальный номер');
            ONum:= Cache.FDCA.GetOriginalNum(OrNumId);

            SENDERCOMM.Add('Товару '+Ware.Name+                        // формирум текст для базы
              ' не соответствует оригинальный номер '+ONum.Name+' ('+ONum.ManufName+')');
            Body.Add('--- Ошибка соответствия оригинального номера.'); // формирум текст для письма
            Body.Add('Товар: '+Ware.Name);
            Body.Add('Оригинальный номер: '+ONum.Name+' ('+ONum.ManufName+')');
          end; // constWrongOrNum
        end; // case 2
      end; // constWrongAnalog..constWrongOrNum

      else raise EBOBError.Create('Неопознанный тип ошибки, код '+IntToStr(MesType));
    end; // case 1

    s:= '--- Причина (текст отправителя): ';
    SENDERCOMM.Add(s);          // формирум текст для базы
    SENDERCOMM.Add(SenderMess);
    Body.Add(s);                // формирум текст для письма
    Body.Add(SenderMess);

//---------------------------------------------------------------- формируем SQL
    s:= 'CEMSCEMKCODE, CEMSWARECODE';
    s1:= IntToStr(MesType)+', '+IntToStr(WareId);
    if (ModelId>0) then begin
      s := s +', CEMSMODELCODE';
      s1:= s1+', '+IntToStr(ModelId);
    end;
    if (NodeId>0) then begin
      s := s +', CEMSNODECODE';
      s1:= s1+', '+IntToStr(NodeId);
    end;
    if (AnalogId>0) then begin
      s := s +', CEMSANALOGCODE';
      s1:= s1+', '+IntToStr(AnalogId);
    end;
    if (OrNumId>0) then begin
      s := s +', CEMSONUMCODE';
      s1:= s1+', '+IntToStr(OrNumId);
    end;
    if (FirmID>0) and (FirmID<>isWe) then begin
      s := s +', CEMSFIRMCODE';
      s1:= s1+', '+IntToStr(FirmID);
    end;
    if (EmplID>0) then begin
      s := s +', CEMSWORKERCODE';
      s1:= s1+', '+IntToStr(EmplID);
    end;
    s := s +', CEMSSENDERCODE, CEMSSENDTIME, CEMSSENDERCOMM';
    s1:= s1+', '+IntToStr(UserID)+', "NOW", :CEMSSENDERCOMM';

//----------------------------------------------------------------- пишем в базу
    try
      OrdIBD:= CntsOrd.GetFreeCnt();
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBSQL_'+nmProc, ThreadData.ID, tpWrite, True);
      OrdIBS.SQL.Text:= 'INSERT INTO CLIENTERRMESSAGES ('+s+') VALUES ('+s1+')';
      OrdIBS.ParamByName('CEMSSENDERCOMM').AsString:= SENDERCOMM.Text;
      OrdIBS.ExecQuery;
      OrdIBS.Transaction.Commit;
    finally
      prFreeIBSQL(OrdIBS);
      cntsORD.SetFreeCnt(OrdIBD);
    end;

//--------------------------------------------------- отсылаем письмо менеджерам
    s:= '';
    s1:= '';
    if email<>'' then begin
      s:= n_SysMailSend(email , 'Уведомление об ошибке данных товара', Body, nil,  '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then begin // если письмо не записано в файл
        prMessageLOGS(nmProc+'(send mail to managers): '+s);
        if sMonitoring<>'' then sMonitoring:= '  Ошибка отправки уведомления об ошибке в адреса:'#10+sMonitoring;
      end else if sMonitoring<>'' then sMonitoring:= '  Уведомление об ошибке выслано в адреса:'#10+sMonitoring;
      if sMonitoring<>'' then Body.Add(#10+sMonitoring);
    end;

//----------------------------------------------------- отсылаем письмо контролю
    if sErr<>'' then Body.Add(#10+sErr);
    emailM:= Cache.GetEmplEmails(Monitorings);
    if (emailM='') then s1:= 'Не найдены адреса рассылки'
    else begin
      s1:= n_SysMailSend(emailM, 'Уведомление об ошибке данных товара', Body, nil,  '', '', True);
      if (s1<>'') and (Pos(MessText(mtkErrMailToFile), s1)<1) then s1:= ''; // если письмо записано в файл
    end;
    if (s1<>'') then prMessageLOGS(nmProc+'(send mail to monitoring): '+s1);

//------------------------------------------------- формируем ответ пользователю
    if (s='') or (s1='') then begin // если отправлено хоть кому-нибудь
      MessForSender.Add('Ваше сообщение об ошибке принято.');
    end else begin
      MessForSender.Add(MessText(mtkErrSendMess));
      MessForSender.Add(MessText(mtkMailWillSend));
      if (Pos(MessText(mtkErrMailToFile), s)>0) // если письмо не записано в файл, т.е. запись в базу прошла,
        and (Pos(MessText(mtkErrMailToFile), s1)>0) then begin // а письмо никому не ушло - пишем в лог
        prMessageLOGS(nmProc+': Ошибка отправки уведомления в адреса: '+fnIfStr(email='', '', '('+email+')')+emailM);
        for i:= 0 to Body.Count-1 do prMessageLOGS('  '+Body[i]);
      end;
    end;
    MessForSender.Add('Благодарим за сотрудничество.');

    Result:= MessForSender.Text;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do raise Exception.Create(nmProc+': '+E.Message+
      #10'FirmID='+IntToStr(FirmID)+', UserID='+IntToStr(UserID)+
      ', MesType='+IntToStr(MesType)+', WareId='+IntToStr(WareId)+#10+
      fnIfStr(AnalogId>-1, ' AnalogId='+IntToStr(AnalogId), '')+
      fnIfStr(OrNumId>-1, ' OrNumId='+IntToStr(OrNumId), '')+
      fnIfStr(ModelId>-1, ' ModelId='+IntToStr(ModelId), '')+
      fnIfStr(NodeId>-1, ' NodeId='+IntToStr(NodeId), '')+#10+
      fnIfStr(SenderMess<>'', ' SenderMess='+SenderMess, '')+
      fnIfStr(AttrMess<>'', ' AttrMess='+AttrMess, ''));
  end;
  finally
    prFree(MessForSender);
    prFree(Body);
    prFree(SENDERCOMM);
    SetLength(Monitorings, 0);
  end;
end;
{//================================== отправляет сообщение пользователя менеджеру
function fnSendClientMes(FirmID, UserID, Source: Integer; SenderMess: String;
                         ThreadData: TThreadData; var Response: String; ContID: Integer=0): Boolean;
const nmProc = 'fnSendClientMes'; // имя процедуры/функции
// в Result возвращает признак успешной отправки сообщения,
// ошибки записывает в лог, в Response возвращает сообщение для пользователя
var Filial, EmplID, i: integer;
    s, To_, ToAdm, Delim, nm: string;
    Strings: TStringList;
    Client : TClientInfo;
    Firm   : TFirmInfo;
    ar: Tai;
begin
  Result:= False;
  Response:= '';
  nm:= '';
  Strings:= nil;
  SetLength(ar, 0);
  try
    if not (Source in [cosByVlad, cosByWeb]) then Source:= cosByWeb;
    if Source=cosByVlad then Delim:= cStrVladDelim else Delim:= ''; // разделитель для Vlad

    if (trim(SenderMess)='') then
      raise EBOBError.Create('Нельзя отправить пустое сообщение');
    if not Cache.ClientExist(UserID) then
      raise Exception.Create(MessText(mtkNotClientExist, IntToStr(UserID)));

    Client:= Cache.arClientInfo[UserID];
    if not Cache.FirmExist(FirmID) then FirmID:= Client.FirmID
    else if (FirmID<>Client.FirmID) then raise Exception.Create(MessText(mtkNotClientOfFirm));

    if not Cache.FirmExist(FirmID) then
      raise Exception.Create(MessText(mtkNotFirmExists, IntToStr(FirmID)));

    Firm:= Cache.arFirmInfo[FirmID];
    Filial:= Firm.GetDefContract.Filial;
    if not Cache.DprtExist(Filial) then
      raise Exception.Create(MessText(mtkNotDprtExists, IntToStr(Filial)));

    if Client.Mail='' then raise EBOBError.Create(
      'Нельзя отправить сообщение, '+Delim+'т.к. Вашего E-mail нет в базе данных. '+Delim+
      'Сообщите свои логин и E-mail '+Delim+'торговому представителю Компании.');
                                       // добавляем подпись и Email пользователя
    nm:= Client.Name+', '+Firm.Name;
    s:= StringOfChar('-', 40);
    SenderMess:= SenderMess+#10#10+s+#10'Пользователь: '+nm+
      #10#10'E-mail пользователя: '+Client.Mail;
    if (ContID>0) then begin

      prAddItemToIntArray(Firm.GetContract(ContID).Manager, ar)
    end else for i:= 0 to Firm.FirmManagers.Count-1 do
      prAddItemToIntArray(Firm.FirmManagers[i], ar);

    if (Length(ar)<1) then
      SenderMess:= SenderMess+#10#10'Менеджер контрагента не найден.'
    else for i:= 0 to High(ar) do begin            // добавляем менеджеров
      EmplID:= ar[i];
      if not Cache.EmplExist(EmplID) then Cache.TestEmpls(EmplID);
      if Cache.EmplExist(EmplID) then with Cache.arEmplInfo[EmplID] do
        SenderMess:= SenderMess+#10#10'Менеджер контрагента: '+EmplShortName+
                     ' ( E-mail: '+fnIfStr(Mail<>'', Mail, 'не найден')+' )';
    end;

    Strings:= TStringList.Create;
    Strings.Text:= SenderMess;     // вставляем в начало шапку
    Strings.Insert(0, 'ВНИМАНИЕ! Письмо создано сервером системы заказов, '+
      'адрес пользователя для ответа указан в письме.'#10#10+
      'Текст сообщения:'#10+StringOfChar('-', 40)+#10);

    ToAdm:= Cache.GetConstEmails(pcEmplORDERAUTO);
    if (ToAdm='') then ToAdm:= fnGetSysAdresVlad(caeOnlyWorkDay);
    To_:= fnGetManagerMail(Filial, ToAdm);
    if (To_=ToAdm) then ToAdm:= '';
                                                    // отправляем от CSS-сервера
    s:= n_SysMailSend(To_, 'Сообщение от пользователя системы приема заказов', Strings, nil, '', '', true);

    if (s<>'') then begin
      if Pos(MessText(mtkErrMailToFile), s)<1 then begin // если записали в файл
        Response:= MessText(mtkErrSendMess, 'от пользователя')+Delim+MessText(mtkMailWillSend);
        raise EBOBError.Create(s);

      end else begin  // если не записали в файл
        Strings.Insert(0, GetMessageFromSelf);
        if ToAdm<>'' then begin
          Strings.Add(#10'Текст ошибки:'#10+s); // добавляем Текст ошибки 1-й отправки
                                            // отправляем от CSS-сервера админам
          ToAdm:= n_SysMailSend(ToAdm, MessText(mtkErrSendMess, 'от пользователя'), Strings, nil, '', '', true);
          if ToAdm<>'' then s:= s+#10+MessText(mtkErrSendMess, 'админам')+#10+ToAdm+
                                #10'Текст письма: '+Strings.Text;
        end;
        raise Exception.Create(s);
      end;
    end;

    Response:= 'Ваше сообщение отправлено от имени:'+Delim+'  '+nm+'. '+Delim+
               'Ответ будет направлен на Ваш E-mail:'+Delim+'  '+Client.Mail+'. '+Delim+
               'Если эта информация не является корректной, '+Delim+
               ' сообщите свой логин и правильные данные '+Delim+
               ' торговому представителю Компании.';
    Result:= True;
  except
    on E: EBOBError do begin
      if Response='' then Response:= E.Message;
      fnWriteToLogPlus(ThreadData, lgmsUserError, nmProc, E.Message);
    end;
    on E: Exception do begin
      if Response='' then Response:= MessText(mtkErrSendMess, 'от пользователя');
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, E.Message);
    end;
  end;
  prFree(Strings);
  SetLength(ar, 0);
end; }
//============================ формирование отчета по запросам клиента за период
function fnRepClientRequests(UserID: integer; StartTime, EndTime: TDateTime; var FName: string): string;
const nmProc = 'fnRepClientRequests'; // имя процедуры/функции  // возвращает имя файла отчета
var Pool: TIBCntsPool;
    LogIBD: TIBDatabase;
    LogIBS: TIBSQL;
    MiddleFileName, FNameZip, Content, s: string;
    file_csv: textfile;
    iCount: integer;
    Client: TClientInfo;
begin
  FName:= '';
  iCount:= 0;
  LogIBD:= nil;
  LogIBS:= nil;
  try
    if not Cache.ClientExist(UserID) then
      raise EBOBError.Create(MessText(mtkNotClientExist, IntToStr(UserID)));
    if (EndTime<Date) and cntsSufLOG.BaseConnected then Pool:= cntsSufLOG else Pool:= cntsLOG;
    if not Assigned(Pool) then raise EBOBError.Create(MessText(mtkErrConnectToDB));


    Client:= Cache.arClientInfo[UserID];
    MiddleFileName:= DirFileErr+'Requests_'+Client.Login+'_'+
               FormatDateTime('_dd.mm_(hh.nn.ss)', EndTime);
    FName:= MiddleFileName+'.csv';
    if FileExists(FName) and not SysUtils.DeleteFile(FName) then begin
      FName:= '';
      raise EBOBError.Create(MessText(mtkNotDelPrevFile));
    end;

    AssignFile(file_csv, FName);
    try
      filemode:= fmOpenReadWrite; //назначаем файл
      if FileExists(FName) then Reset(file_csv) else ReWrite(file_csv);
      Append(file_csv);                            // Добавляем шапку:
      Content:= 'Запросы пользователя с логином <'+Client.Login+'>, контрагент '+
                Client.FirmName+' к системе заказов с '+
                FormatDateTime(cDateTimeFormatY2S, StartTime)+
                ' по '+FormatDateTime(cDateTimeFormatY2S, EndTime);
      WriteLn(file_csv, Content);
      Content:= 'Код команды;Дата;Команда;Параметры команды';
      WriteLn(file_csv, Content);                  // шапка добавлена
      try
        LogIBD:= Pool.GetFreeCnt;
        LogIBS:= fnCreateNewIBSQL(LogIBD, 'LogIBS_'+nmProc, -1, tpRead, true);
        LogIBS.SQL.Text:= 'SELECT THLGBEGINTIME, LCCOMMAND, LCCOMMDESCR,'+
          ' cast(THLGPARAMS as varchar(2400)) THLGPARAMS FROM LOGTHREADS'+
          ' left outer join LOGCOMMANDS on LCCOMMAND=THLGCOMMAND'+
          ' where THLGTYPE in ('+IntToStr(thtpWeb)+', '+IntToStr(thtpMail)+
          ') and not (THLGCOMMAND in ('+IntToStr(csWebAutentication)+', '+
          IntToStr(csBackJobAutentication)+')) and THLGUSERID='+IntToStr(UserID)+
          ' and THLGBEGINTIME between :DateStart and :DateEnd order by THLGBEGINTIME';
        LogIBS.ParamByName('DateStart').AsDateTime:= StartTime;    // Начальное время
        LogIBS.ParamByName('DateEnd').AsDateTime  := EndTime;      // Конечное время
        LogIBS.ExecQuery;
        while not LogIBS.EOF do begin
          try
            s:= StringReplace(LogIBS.FieldByName('THLGPARAMS').AsString, #13#10,' ', [rfReplaceAll]);
            Content:= LogIBS.FieldByName('LCCOMMAND').AsString+';'+
              // добавляем перед датой пробел, чтобы Excel не обрезал сек
              FormatDateTime(' '+cDateTimeFormatY2S, LogIBS.FieldByName('THLGBEGINTIME').AsDateTime)+';'+
              LogIBS.FieldByName('LCCOMMDESCR').AsString+';'+s+';';
            WriteLn(file_csv, Content);
            inc(iCount);
          except
            on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
          end;
          TestCssStopException;
          LogIBS.Next;
        end;
      finally
        prFreeIBSQL(LogIBS);
        Pool.SetFreeCnt(LogIBD, True);
      end;
    finally
      CloseFile(file_csv);
    end;
    if iCount=0 then raise EBOBError.Create(MessText(mtkNotFoundDataUse));

    FNameZip:= MiddleFileName+'.zip';
    s:= ZipAddFiles(FNameZip, FName);
    if (s<>'') then raise Exception.Create(s);

    SysUtils.DeleteFile(FName);
    FName:= FNameZip;
  except
    on E: Exception do begin
      if FName<>'' then begin
        if FileExists(FName) then SysUtils.DeleteFile(FName);
        FName:= '';
      end;
      Result:= nmProc+': '+E.Message;
    end;
  end;
end;
//===================================== блокировка/разблокировка клиента в базе
function SaveClientBlockType(BlockType, UserID: Integer; var BlockTime: TDateTime; EmplID: Integer=0): Boolean;
const nmProc = 'SaveClientBlockType';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    ss: String;
    command, cliType: Integer;
begin
  Result:= False;
  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
    if (EmplID<1) then EmplID:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue
    else if not Cache.EmplExist(EmplID) then
      raise EBOBError.Create(MessText(mtkNotEmplExist, IntToStr(EmplID)));

    case BlockType of
    cbBlockedBySearchLimit, cbBlockedTmpByConnLimit, cbBlockedByConnectLimit, cbBlockedByEmpl: begin // блокировка
        command:= csBlockWebUser;
        cliType:= BlockType;
        case BlockType of
        cbBlockedBySearchLimit:  // автоматически в CSSweb из-за превышения лимита поисковых запросов за день
            ss:= 'блокировка системой заказов по лимиту запросов';
        cbBlockedTmpByConnLimit: // автоматически в CSSweb из-за превышения лимита коннектов в ед.времени
            ss:= 'блокировка системой заказов по лимиту запросов временно';
        cbBlockedByConnectLimit: // автоматически в CSSweb из-за превышения лимита коннектов в ед.времени
            ss:= 'блокировка системой заказов по лимиту запросов повторно';
        cbBlockedByEmpl:         // сотрудником в WebArm
            ss:= 'блокировка сотрудником '+Cache.arEmplInfo[EmplID].EmplShortName;
        end;
      end; // блокировка

    cbUnBlockedTmpByCSS, cbUnBlockedByEmpl: begin // разблокировка
        command:= csUnblockWebUser;
        cliType:= cbNotBlocked;
        case BlockType of
        cbUnBlockedTmpByCSS:     // автоматически в CSSweb
            ss:= 'разблокировка системой заказов временной блокировки';
        cbUnBlockedByEmpl:       // сотрудником в WebArm
            ss:= 'разблокировка сотрудником '+Cache.arEmplInfo[EmplID].EmplShortName;
        end;
      end; // разблокировка

    else raise EBOBError.Create('Неизвестная команда');
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt;   // блокировка/разблокировка клиента
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      ORD_IBS.SQL.Text:= 'select rTIME from SetClientBlockMark('+IntToStr(command)+', '+
        IntToStr(BlockType)+', '+IntToStr(cliType)+', '+IntToStr(UserID)+', '+IntToStr(EmplID)+', :comm)';
      ORD_IBS.ParamByName('comm').AsString:= ss;
      ORD_IBS.ExecQuery;
      if not (ORD_IBS.Bof and ORD_IBS.Eof) then BlockTime:= ORD_IBS.Fields[0].AsDateTime;
      ORD_IBS.Transaction.Commit;
      Result:= True;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+'('+IntToStr(UserID)+'): '+E.Message);
  end;
end;
//=============== установить флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
function SetLongProcessFlag(cdlpKind: Integer; NotCheck: Boolean=False): Boolean;
// NotCheck=True - без проверки других флагов
const nmProc = 'SetLongProcessFlag';
var //ORD_IBD: TIBDatabase;
    //ORD_IBS: TIBSQL;
    s: String;
begin
  Result:= False;
  if not (cdlpKind in [cdlpFillCache..cdlpForeignPr]) then Exit;
  s:= '';
//  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
{
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'select rOtherFlag from CheckLongProcessFlag('+IntToStr(ServerID)+', :ftxt)';
      ORD_IBS.ParamByName('ftxt').AsString:= cdlpNames[cdlpKind];
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Eof and ORD_IBS.Bof) then raise Exception.Create('Empty');
      s:= ORD_IBS.Fields[0].AsString;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    Result:= (s='');
}
    Result:= NotCheck;   // временно
    with Cache do begin
      if not Result then begin
{        Result:= (LongProcessFlag=cdlpNotLongPr);
        if Result then
        if AllowWebArm then begin
//          Result:= (ImpCheck.CheckList.Count<1);
          if (LongProcessFlag=cdlpNotLongPr) // выполняется отчет или импорт
            and (ImpCheck.CheckList.Count>0) then LongProcessFlag:= cdlpRepOrImp
          else if (LongProcessFlag=cdlpRepOrImp)
            and (ImpCheck.CheckList.Count<1) then LongProcessFlag:= cdlpNotLongPr;
        end; }
        Result:= (LongProcessFlag=cdlpNotLongPr);
      end;

      if Result then begin
        LongProcessFlag:= cdlpKind;
  //    end else begin
  //      LongProcessFlag:= cdlpForeignPr;
  //      cdlpNames[cdlpForeignPr]:= s;
      end;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  if flTest then prMessageLOGS(nmProc+': LongProcessFlag='+cdlpNames[Cache.LongProcessFlag]);
end;
//==================== снять флаг длительного процесса (тестирования кеша и т.п)  !!! заготовка
function SetNotLongProcessFlag(cdlpKind: Integer): Boolean;
// снять можно только такой же флаг
const nmProc = 'SetNotLongProcessFlag';
var //ORD_IBD: TIBDatabase;
    //ORD_IBS: TIBSQL;
    s: String;
begin
  Result:= False;
  if not (cdlpKind in [cdlpFillCache..cdlpForeignPr]) then Exit;
  s:= '';
//  ORD_IBS:= nil;
//  ORD_IBD:= nil;
  try
{
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'select rOtherFlag from CheckLongProcessFlag('+IntToStr(ServerID)+', :ftxt)';
      ORD_IBS.ParamByName('ftxt').AsString:= cdlpNames[cdlpKind];
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Eof and ORD_IBS.Bof) then raise Exception.Create('Empty');
      s:= ORD_IBS.Fields[0].AsString;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    Result:= (s='');
}

    Result:= (Cache.LongProcessFlag=cdlpKind); // временно

    with Cache do if Result then begin
      LongProcessFlag:= cdlpNotLongPr;
//    end else begin
//      LongProcessFlag:= cdlpForeignPr;
//      cdlpNames[cdlpForeignPr]:= s;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  if flTest then prMessageLOGS(nmProc+': LongProcessFlag='+cdlpNames[Cache.LongProcessFlag]);
end;
{//=================================================== склады клиента (контракты)
function fnGetStoragesArray(pUserID, pFirmID: integer; ReservedOnly: boolean=false; contID: integer=0): TasD;
var i, j, k, index, StoreID: integer;
    codes: Tai;
    firma: TFirmInfo;
    store: TStoreInfo;
    Contract: TContract;
    s: String;
begin
  SetLength(Result, 0);
  j:= 0;
  SetLength(codes, 0);
  with Cache do try
    if CheckNotValidUser(pUserID, pFirmID, s) then Exit;
    firma:= arFirmInfo[pFirmID];
    Contract:= firma.GetContract(contID);

    with arClientInfo[pUserID].GetContStoreCodes(contID) do for i:= 0 to Count-1 do begin
      StoreID:= Items[i];
      index:= fnInIntArray(StoreID, codes);
      if index>-1 then Continue;

      k:= Length(codes);
      SetLength(codes, k+1);
      codes[k]:= StoreID;
      index:= Contract.GetСontStoreIndex(StoreID);
      if (index<0) then Continue;

      store:= Contract.ContStorages[index];
      if (ReservedOnly and not store.IsReserve) then Continue;

      if (High(Result)<j) then SetLength(Result, j+10);
      Result[j].Code     := IntToStr(StoreID);
      Result[j].FullName := GetDprtMainName(StoreID);
      Result[j].ShortName:= GetDprtColName(StoreID);
      Result[j].IsVisible:= store.IsVisible;
      Result[j].IsReserve:= store.IsReserve;
      Result[j].IsSale   := store.IsSale;
      inc(j);
    end;
  finally
    if (Length(Result)>j) then SetLength(Result, j);
    SetLength(codes, 0);
  end;
end; }
//============================== must Free, поиск товаров по наименованию в кэше
function SearchWareNames(Template: string; IgnoreSpec: Integer=0;
         ManagID: Integer=-1; ByComments: boolean=False): Tai;
const nmProc = 'SearchWareNames';
// возвращает массив кодов товаров, отсортированных по наименованию
var list: TStringList;
    i, j: integer;
    fl: boolean;
    s, ss, mess: String;
begin
  SetLength(Result, 0);
  if not Assigned(Cache) or (Template='') then Exit;
  list:= fnCreateStringList(False, 100);
  mess:= '';
  with Cache do try
    s:= AnsiUpperCase(Template);
    ss:= fnDelSpcAndSumb(s);
    if ByComments and (IgnoreSpec=3) then ByComments:= False;
    j:= High(arWareInfo);

    for i:= 1 to j do try
      if not WareExist(i) then Continue;
      with Cache.arWareInfo[i] do begin
        if IsArchive or (PgrID<1) then Continue;                                           // отсев по архивности
        if (PgrID=Cache.pgrDeliv) then Continue;                                           // пропускаем доставки
        if (ManagID>-1) and (ManagID<>ManagerID) then Continue;                            // отсев по менеджеру
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, Name)>0;
          1: fl:= pos(ss, NameBS)>0;
          2: fl:= (pos(s, Name)>0) or (pos(ss, NameBS)>0);
          3: if (Name=s) then begin // полное совпадение
               list.AddObject(Name, pointer(i));
               break;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, CommentUP)>0);
        if not fl then Continue;
        if list.Capacity=list.Count then list.Capacity:= list.Count+100;
        list.AddObject(Name, pointer(i));
      end; // with arWareInfo[i]
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(i)+': '+E.Message;
    end; // for

    if list.Count<1 then Exit else if list.Count>1 then list.Sort;
    SetLength(Result, list.Count);
    for i:= 0 to list.Count-1 do Result[i]:= integer(list.Objects[i]);
  finally
    prFree(list);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;
//========== возвращает отсортированный массив кодов всех аналогов товара WareID
function fnGetAllAnalogs(WareID: integer; ManufID: integer=-1; sysID: integer=0): Tai; // must Free
// sysID=0 - и авто, и мото
var i, Counter, ShowKind: integer;
    a1, a2, anw: Tai;
    ErrorPos: string;
    Ware: TWareInfo;
    list: TStringList;
begin
  ErrorPos:= '0';
  SetLength(Result, 0);
  list:= nil;
  try try
    if not Cache.WareExist(WareID) then
        raise Exception.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));
    Ware:= Cache.arWareInfo[WareId];
    if Ware.IsArchive then exit;

    ShowKind:= Cache.GetConstItem(pcAnalogsShowKind).IntValue; // режим вывода аналогов
    ErrorPos:= '1';           // получаю максимальное кол-во аналогов через OН
    if (sysID in [0, constIsAUTO]) and (ShowKind in [ca_OE, ca_GR_OE, ca_Ex_OE,
      ca_TD_OE, ca_GR_Ex_OE, ca_GR_TD_OE, ca_Ex_TD_OE, ca_GR_Ex_TD_OE]) then begin
      Counter:= Cache.FDCA.fnGetListAnalogsWithManufacturer(WareID, ManufID, a1, a2);
      if (Counter<0) then Counter:= 0;
    end else Counter:= 0;

    ErrorPos:= '2';
    anw:= Ware.analogs; // аналоги из кеша
    Counter:= Counter+Length(anw);
    if (Counter<1) then exit;

    list:= TStringList.Create; // общий список для сортировки
    list.Capacity:= Counter;

    for i:= 0 to High(anw) do if Cache.WareExist(anw[i]) then begin
      Ware:= Cache.arWareInfo[anw[i]];            // аналоги из кеша
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    for i:= 0 to High(a1) do if Cache.WareExist(a1[i]) and (fnInIntArray(a1[i], anw)<0) then begin
      Ware:= Cache.arWareInfo[a1[i]];             // аналоги через OН ManufID
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    for i:= 0 to High(a2) do if Cache.WareExist(a2[i]) and (fnInIntArray(a2[i], anw)<0)
                            and (fnInIntArray(a2[i], a1)<0) then begin
      Ware:= Cache.arWareInfo[a2[i]];             // аналоги через OН
      if Ware.IsMarketWare then list.AddObject(Ware.Name, Pointer(Ware.ID));
    end;
    if list.Count>1 then list.Sort; // сортировка общего списка

    SetLength(Result, list.Count);
    for i:= 0 to list.Count-1 do Result[i]:= Integer(list.Objects[i]);
  except
    on E: Exception do
      raise Exception.Create('fnGetAllAnalogs (ErrorPos='+ErrorPos+'): '+E.Message);
  end;
  finally
    SetLength(a1, 0);
    SetLength(a2, 0);
    SetLength(anw, 0);
    prFree(list);
  end;
end;
//====== используется для сортировки объектов типа TWareAndAnalogs в TObjectList
function WareAndAnalogsSortCompare(Item1, Item2: Pointer): Integer;
var Ware1, Ware2: TWareInfo;
begin
  with Cache do try
    Ware1:= GetWare(TWareAndAnalogs(Item1).WareID, True);
    Ware2:= GetWare(TWareAndAnalogs(Item2).WareID, True);
    Result:= AnsiCompareText(Ware1.Name, Ware2.Name);
  except
    Result:= 0;
  end;
end;
{//================== поиск товаров (с типами и аналогами) по наименованию в кэше
function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer=0;
         ManagID: Integer=-1; ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
         flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList; // must Free
const nmProc = 'SearchWaresTypesAnalogs';
// возвращает TObjectList, отсортированный по наименованию товара, в Objects - TWareAndAnalogs
// если TypeCodes пустой - в TypeCodes собираем типы
// если TypeCodes не пустой - отсев рез-тов поиска по типам
var iWare, j, pType: integer;
    flTypeSelection, flSelecting, flContaining, fl, flBreak: boolean;
    s, ss, mess: String;
    ware: TWareInfo;
    arAnalogs, arTypes: Tai;
begin
  Result:= TObjectList.Create;
  if not Assigned(TypeCodes) then SetLength(TypeCodes, 0);
  if not Assigned(Cache) or (Template='') then Exit;
  SetLength(arAnalogs, 0);
  SetLength(arTypes, 0);

  mess:= '';
  flTypeSelection:= (Length(TypeCodes)>0); // признак - отсеивать по TypeCodes или собирать типы в TypeCodes

  flBreak:= False; // для полного совпадения
  with Cache do try
    s:= AnsiUpperCase(Template);

    if not (flSale or flCutPrice or flLamp) then begin
      if (IgnoreSpec in [1, 2]) then ss:= fnDelSpcAndSumb(s);
      if ByComments and (IgnoreSpec=3) then ByComments:= False;
    end;

    for iWare:= 1 to High(arWareInfo) do try
      if not WareExist(iWare) then Continue;
      ware:= Cache.GetWare(iWare, True);
      if not Assigned(ware) or (ware=NoWare) then Continue; // отсев по наличию
      if ware.IsArchive or (ware.PgrID<1) then Continue;    // отсев по архивности
      if ware.IsPrize then Continue;                        // отсев призов
      if (ware.PgrID=Cache.pgrDeliv) then Continue;         // отсев доставок
      if (ManagID>0) and (ManagID<>ware.ManagerID) then Continue;         // отсев по менеджеру

//------------------------------------------------------------- спец.виды поиска
      if flSale then fl:= ware.IsSale              //------- отсев по распродаже
      else if flCutPrice then fl:= ware.IsCutPrice //----------- отсев по уценке
      else if flLamp then fl:= (pos(s, ware.CommentUP)>0) //---- отсев по лампам

      else begin //----------------------------------- отсев по ключу поиска
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, ware.Name)>0;
          1: fl:= pos(ss, ware.NameBS)>0;
          2: fl:= (pos(s, ware.Name)>0) or (pos(ss, ware.NameBS)>0);
          3: begin // полное совпадение
               fl:= (ware.Name=s);
               flBreak:= fl;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, ware.CommentUP)>0);
      end;
      if not fl then Continue;

      SetLength(arAnalogs, 0);
      arAnalogs:= fnGetAllAnalogs(iWare, -1);
      //---------------------- отсев по наличию цены, аналогов или сопут.товаров
      if OnlyWithPriceOrAnalogs and not ware.IsMarketWare
        and (Length(arAnalogs)<1) and not ware.SatelliteExists() then Continue;

      //-------------------------------------------------- отсев по типам товара
      flSelecting:= not flTypeSelection; // True для первичного поиска, False для отсева

      if not ware.IsInfoGr or ware.HasFixedType then begin // товары с типом - по собственному типу
        pType:= ware.TypeID;
        flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
        if not flContaining then
          if flTypeSelection then Continue // отсев товаров
          else prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы

      end else try // инфо-товары без типа - по аналогам (как оригинальные номера)
        arTypes:= ware.GetAnalogTypes; // массив кодов типов аналогов (с нулевым)
        for j:= 0 to High(arTypes) do begin // перебираем типы аналогов
          pType:= arTypes[j];
          flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
          if flTypeSelection and flContaining then begin
            flSelecting:= True;                    // отсев и тип есть в массиве типов
            break;
          end else if not flTypeSelection and not flContaining then
            prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы
        end;
        if not flSelecting then Continue; // если не подходит по типам при отсеве
      finally
        SetLength(arTypes, 0);
      end;

      if Result.Capacity=Result.Count then Result.Capacity:= Result.Count+100;
      Result.Add(TWareAndAnalogs.Create(iWare, arAnalogs, ware.GetSatellites()));

      if flBreak then Break; // полное совпадение
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(iWare)+': '+E.Message;
    end; // for

    if Result.Count>1 then Result.Sort(WareAndAnalogsSortCompare);
  finally
    SetLength(arAnalogs, 0);
    SetLength(arTypes, 0);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;  }
//================== поиск товаров (с типами и аналогами) по наименованию в кэше
function SearchWaresTypesAnalogs(Template: string; var TypeCodes: Tai; IgnoreSpec: Integer=0;
         ManagID: Integer=-1; ByComments: boolean=False; OnlyWithPriceOrAnalogs: boolean=False;
         flSale: boolean=False; flCutPrice: boolean=False; flLamp: boolean=False): TObjectList; // must Free
const nmProc = 'SearchWaresTypesAnalogs';
// возвращает TObjectList, отсортированный по наименованию товара, в Objects - TWareAndAnalogs
// если TypeCodes пустой - в TypeCodes собираем типы
// если TypeCodes не пустой - отсев рез-тов поиска по типам
var iWare, j, pType: integer;
    flTypeSelection, flSelecting, flContaining, fl, flBreak, flMarket: boolean;
    s, ss, mess: String;
    ware: TWareInfo;
    arAnalogs, arTypes, ar: Tai;
begin
  Result:= TObjectList.Create;
  if not Assigned(TypeCodes) then SetLength(TypeCodes, 0);
  if not Assigned(Cache) or (Template='') then Exit;
//  SetLength(arAnalogs, 0);
  SetLength(arTypes, 0);
//  SetLength(ar, 0);

  mess:= '';
  flTypeSelection:= (Length(TypeCodes)>0); // признак - отсеивать по TypeCodes или собирать типы в TypeCodes

  flBreak:= False; // для полного совпадения
  with Cache do try
    s:= AnsiUpperCase(Template);

    if not (flSale or flCutPrice or flLamp) then begin
      if (IgnoreSpec in [1, 2]) then ss:= fnDelSpcAndSumb(s);
      if ByComments and (IgnoreSpec=3) then ByComments:= False;
    end;

    for iWare:= 1 to High(arWareInfo) do try
      if not WareExist(iWare) then Continue;
      ware:= Cache.GetWare(iWare, True);
      if not Assigned(ware) or (ware=NoWare) then Continue; // отсев по наличию
      if ware.IsArchive or (ware.PgrID<1) then Continue;    // отсев по архивности
      if ware.IsPrize then Continue;                        // отсев призов
      if (ware.PgrID=Cache.pgrDeliv) then Continue;         // отсев доставок
      if (ManagID>0) and (ManagID<>ware.ManagerID) then Continue;         // отсев по менеджеру

//------------------------------------------------------------- спец.виды поиска
      if flSale then fl:= ware.IsSale              //------- отсев по распродаже
      else if flCutPrice then fl:= ware.IsCutPrice //----------- отсев по уценке
      else if flLamp then fl:= (pos(s, ware.CommentUP)>0) //---- отсев по лампам

      else begin //----------------------------------- отсев по ключу поиска
        fl:= False;
        case IgnoreSpec of
          0: fl:= pos(s, ware.Name)>0;
          1: fl:= pos(ss, ware.NameBS)>0;
          2: fl:= (pos(s, ware.Name)>0) or (pos(ss, ware.NameBS)>0);
          3: begin // полное совпадение
               fl:= (ware.Name=s);
               flBreak:= fl;
             end;
        end;
        if not fl and ByComments then fl:= (pos(s, ware.CommentUP)>0);
      end;
      if not fl then Continue;

      SetLength(arAnalogs, 0);
      SetLength(ar, 0);
      try
        arAnalogs:= fnGetAllAnalogs(iWare);
        //---------------------- отсев по наличию цены, аналогов или сопут.товаров
        flMarket:= ware.IsMarketWare;
        if OnlyWithPriceOrAnalogs and not flMarket
          and (Length(arAnalogs)<1) and not ware.SatelliteExists() then Continue;

        //-------------------------------------------------- отсев по типам товара
        flSelecting:= not flTypeSelection; // True для первичного поиска, False для отсева

        if not ware.IsInfoGr or ware.HasFixedType then begin // товары с типом - по собственному типу
          pType:= ware.TypeID;
          flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
          if not flContaining then
            if flTypeSelection then Continue // отсев товаров
            else prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы

        end else try // инфо-товары без типа - по аналогам (как оригинальные номера)
          arTypes:= ware.GetAnalogTypes; // массив кодов типов аналогов (с нулевым)
          for j:= 0 to High(arTypes) do begin // перебираем типы аналогов
            pType:= arTypes[j];
            flContaining:= (fnInIntArray(pType, TypeCodes)>-1);
            if flTypeSelection and flContaining then begin
              flSelecting:= True;                    // отсев и тип есть в массиве типов
              break;
            end else if not flTypeSelection and not flContaining then
              prAddItemToIntArray(pType, TypeCodes); // первичный поиск - собираем типы
          end;
          if not flSelecting then Continue; // если не подходит по типам при отсеве
        finally
          SetLength(arTypes, 0);
        end;

        if Result.Capacity=Result.Count then Result.Capacity:= Result.Count+100;
        ar:= ware.GetSatellites;
        Result.Add(TSearchWareOrOnum.Create(iWare, Length(ar), True, flMarket, arAnalogs));
      finally
        SetLength(ar, 0);
        SetLength(arAnalogs, 0);
      end;

      if flBreak then Break; // полное совпадение
    except
      on E: Exception do
        mess:= mess+fnIfStr(mess='', '', #10)+'wareID='+IntToStr(iWare)+': '+E.Message;
    end; // for

//    if Result.Count>1 then Result.Sort(WareAndAnalogsSortCompare);
  finally
//    SetLength(arAnalogs, 0);
    SetLength(arTypes, 0);
//    SetLength(ar, 0);
    if mess<>'' then prMessageLOGS(nmProc+':'#10+Mess);
  end;
end;

{//======================= простановка признака WareSemafor всем клиентам системы
function SetSemMarkForClients(pSysID: Integer; SemMark: String='T'): String;
const nmProc='SetSemMarkForClients';
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    i, j, ii: integer;
    Client: TClientInfo;
    Firma: TFirmInfo;
begin
  Result:= '';
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  try
    ORD_IBD:= cntsORD.GetFreeCnt;
    ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'GB_IBS_'+nmProc, -1, tpWrite, True);
    ORD_IBS.SQL.Text:= 'UPDATE WEBORDERCLIENTS SET'+
      ' WOCLWARERESTSEMAFOR="'+SemMark+'" where WOCLCODE=:user';
    for i:= 1 to High(Cache.arFirmInfo) do begin
      if not Cache.FirmExist(i) then Continue;
      Firma:= Cache.arFirmInfo[i];
      if not (pSysID in [constIsAuto, constIsMoto]) then Continue;
      if not Firma.CheckSysType(pSysID) then Continue;
      for j:= 1 to High(Firma.FirmClients) do begin
        ii:= Firma.FirmClients[j];
        if not Cache.ClientExist(ii) then Continue;
        Client:= Cache.arClientInfo[ii];
        if (Client.WareSemafor=(SemMark='T')) then Continue;
        try
          with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
          ORD_IBS.ParamByName('user').AsInteger:= ii;
          ORD_IBS.ExecQuery;
          with ORD_IBS.Transaction do if InTransaction then Commit;
          Client.WareSemafor:= (SemMark='T');
        except
          on E: Exception do begin
            with ORD_IBS.Transaction do if InTransaction then Rollback;
            prMessageLOGS(nmProc+': id='+IntToStr(i)+' '+E.Message, fLogCache);
          end;
        end;
        ORD_IBS.Close;
      end;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  prFreeIBSQL(ORD_IBS);
  cntsORD.SetFreeCnt(ORD_IBD);
end;  }
//===================== список порций текстов и условий к связке 3 для просмотра
function GetModelNodeWareUsesAndTextsPartsView(ModelID, NodeID, WareID: Integer): TObjectList; // must Free Result
// в TObjectList[i] - TStringList, в TStringList - Delimiter=Char(iPart), QuoteChar=Char(iSrc) (если неправильная: +cWrongPart)
const nmProc = 'GetModelNodeWareUsesAndTextsPartsView';
var iType, iSrc, iPart, iWrong: integer;
    s, TypeName, str: String;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    lst: TStringList;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    Model: TModelAuto;
    flNewLst: Boolean;
begin
  Result:= TObjectList.Create;
  flNewLst:= True;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  lst:= nil;
  with Cache do begin
    with FDCA do begin
      if not Models.ModelExists(ModelID) then
        raise EBOBError.Create(MessText(mtkNotFoundModel, IntToStr(ModelID)));
      Model:= Models[ModelID];
      nodes:= AutoTreeNodesSys[Model.TypeSys];
    end;
    if not nodes.NodeExists(NodeID) then
      raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeID)));
    if not Model.NodeLinks.LinkExists(NodeID) then
      raise EBOBError.Create('Не найдена связка модели с узлом');
    node:= nodes[NodeID];
    if not node.IsEnding then raise EBOBError.Create('Узел не конечный');
    if NodeID<>node.MainCode then begin
      NodeID:= node.MainCode;
      if not nodes.NodeExists(NodeID) then
        raise EBOBError.Create(MessText(mtkNotFoundNode, IntToStr(NodeID))+' (главный)');
      if not Model.NodeLinks.LinkExists(NodeID) then
        raise EBOBError.Create('Не найдена связка модели с главным узлом');
//      node:= nodes[NodeID];
    end;
    if not Model.NodeLinks.DoubleLinkExists(NodeID, WareID) then
      raise EBOBError.Create('Не найдена связка модели и узла с товаром');
    try
      ORD_IBD:= cntsOrd.GetFreeCnt;
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
      ORD_IBS.SQL.Text:= 'select * from GetModelNodeWareUsesPartsView_n('+
        IntToStr(ModelID)+', '+IntToStr(NodeID)+', '+IntToStr(WareID)+')';
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // номер порции
        if (iPart<1) then begin // пропускаем специальные порции (если есть)
          while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do ORD_IBS.Next;
          Continue;
        end;
        iSrc:= ORD_IBS.FieldByName('rSrc').AsInteger; // источник
        iWrong:= ORD_IBS.FieldByName('rWrong').AsInteger; // признак неправильной
        if flNewLst then begin
          lst:= TStringList.Create;
          flNewLst:= False;
        end;
        while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
          iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
          TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
          s:= '';
          while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
            and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
            s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
            cntsORD.TestSuspendException;
            ORD_IBS.Next;
          end;
          s:= str+TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
          lst.Add(s);
        end; // while not ORD_IBS.Eof and (iPart=

        if lst.Count>0 then begin
          lst.Delimiter:= Char(iPart);
          if iWrong>0 then iSrc:= iSrc+cWrongPart; // если неправильная - +cWrongPart
          lst.QuoteChar:= Char(iSrc);
          Result.Add(lst);
          flNewLst:= True;
        end;
      end; //  while not ORD_IBS.Eof
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
      if not flNewLst then prFree(lst);
    end;
  end;
end;
//===================== установить/убрать признак WRONG порции условий и текстов
function SetUsageTextPartWrongMark(pModelID, pNodeID, pWareID, pPart, pUserID: Integer; flWrong: Boolean): String;
const nmProc = 'SetUsageTextPartWrongMark';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
begin
  Result:= '';
  ORD_IBS:= nil;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if (pPart<1)    then raise EBOBError.Create(MessText(mtkNotValidParam)+' номера порции');
    if (pUserID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' пользователя');
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'execute procedure SetUsageTextPartWrongMark('+IntToStr(pModelID)+
        ', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+IntToStr(pPart)+', '+
        IntToStr(pUserID)+', "'+fnIfStr(flWrong, 'T', 'F')+'")';
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrEditRecord);
      prMessageLOGS(nmProc+': '+E.Message);
    end;
  end;
end;
{//=========================== сверка TD->link_supplier_brand и ORD->BrandReplace
procedure CheckSuppliersBrandsLinks;
const nmProc = 'CheckSuppliersBrandsLinks'; // имя процедуры/функции
      maxStrLen = 1200;
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    pMainNode, lenS, lenGaStr, iCount, startCount, pUserID: Integer;
    s, sTime, GaStr: String;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('GaStr').AsString:= GaStr;
    tdtIBS.ExecQuery;
    tdtIBS.Close;
    GaStr:= '';
    lenGaStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
                                                  // проверка необходимости сверки
      ordIBS.SQL.Text:= 'select BRRPGBCODE, BRRPTDCODE from BRANDREPLACE order by BRRPGBCODE, BRRPTDCODE';
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) and
        (ordIBS.Fields[0].AsDateTime<=GetConstItem(pcCheckGAMainNodeTime).DateValue) then Exit;
      ordIBS.Close;

// if (exists(select * from data_suppliers where ds_mf_id = 501)) then insert into link_supplier_brand (lsbSupplier, lsbBrand) values ((select ds_id from data_suppliers where ds_mf_id = 501),35);

      sTime:= FormatDateTime(cDateTimeFormatY4S, Now);
      pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;

      tdtIBD:= cntsTDT.GetFreeCnt;
      try
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpWrite, true);
        tdtIBS.SQL.Text:= 'update link_GA_MainNode set lgm_Check=0'; // сбрасываем флажки проверки
        tdtIBS.ExecQuery;
        startCount:= tdtIBS.RowsAffected; // запоминаем кол-во записей
        tdtIBS.Close;
        tdtIBS.SQL.Text:= 'execute procedure check_ga_MainNode_Links(:GaStr)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select TRNAMAINCODE, TRNATDCODE from TREENODESAUTO'+
          ' where TRNATDGA="T" group by TRNAMAINCODE, TRNATDCODE order by TRNAMAINCODE';
        ordIBS.ExecQuery;
        iCount:= 0;
        GaStr:= '';
        lenGaStr:= 0;
        while not ordIBS.Eof do begin
          pMainNode:= ordIBS.fieldByName('TRNAMAINCODE').AsInteger;
          s:= '';
          while not ordIBS.Eof and (pMainNode=ordIBS.fieldByName('TRNAMAINCODE').AsInteger) do begin
            s:= s+fnIfStr(s='', '', ',')+ordIBS.fieldByName('TRNATDCODE').AsString; // собираем порцию кодов GA по pMainNode
            inc(iCount);
            TestCssStopException;
            ordIBS.Next;
          end;
          s:= ordIBS.fieldByName('TRNAMAINCODE').AsString+'='+s; // строка по pMainNode
          lenS:= length(s);

          if (lenGaStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          GaStr:= GaStr+fnIfStr(GaStr='', '', ';')+s;
          lenGaStr:= length(GaStr);
        end;
        ordIBS.Close;
        if GaStr<>'' then CheckPortion; // последняя порция - обрабатываем

        if (iCount<startCount) then begin             // удаляем непроверенные
          tdtIBS.SQL.Text:= 'delete from link_GA_MainNode where lgm_Check=0';
          tdtIBS.ExecQuery;
          tdtIBS.Close;
        end;
        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    s:= SaveNewConstValue(pcCheckGAMainNodeTime, pUserID, sTime);
    if s<>'' then prMessageLOGS(nmProc+': '+s);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  TestCssStopException;
end;  }

//====================================== проверка логина в списке поиска логинов
procedure CheckWorkLogins(userID: Integer; Login: String);
var i, j: Integer;
begin
  with Cache.arClientInfo.WorkLogins do begin // проверка логина в списке поиска логинов
    i:= IndexOf(Login);
    if (i<0) then AddObject(Login, Pointer(userID))
    else begin
      j:= Integer(Objects[i]);
      if (j<>userID) then Objects[i]:= Pointer(userID);
    end;
  end;
end;
//============================================== проверка клонов/блоков клиентов
procedure CheckClonedOrBlockedClients(LogFile: String='');
const nmProc = 'CheckClonedOrBlockedClients'; // имя процедуры/функции
var ordIBD: TIBDatabase;
    ordIBS: TIBSQL;
//    iCount,
    pUserID: Integer;
    s, sTime: String;
    tbegin, tend, tt: TDateTime;
begin
  ordIBS:= nil;
//  iCount:= 0;
  tend:= 0;
  tt:= Date;
  tbegin:= Cache.GetConstItem(pcCheckClonBlockClients).DateValue; // время последней проверки
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBD.Close;  // нужно "свежее" соединение
      ordIBD.Open;
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
      s:= IntToStr(csWebCreateUser)+', '+IntToStr(csUnblockWebUser)+', '+IntToStr(csBlockWebUser);
      ordIBS.SQL.Text:= 'select c1.WOCLCODE user1, c1.WOCLLOGIN log1, c1.WOCLBLOCK block1,'+
        ' c2.WOCLCODE user2, c2.WOCLLOGIN log2, c2.WOCLBLOCK block2, s.PROTTIME'+
        ' from (select PROTWOCL, max(PROTTIME) PROTTIME from PROTOCOL'+
        '   where PROTCOMMAND in ('+s+') and PROTTIME>=:tbegin'+
        '     and PROTWOCL is not null group by PROTWOCL) s'+
        ' left join WEBORDERCLIENTS c1 on c1.WOCLCODE=s.PROTWOCL'+
        ' left join WEBORDERCLIENTS c2 on c2.WOCLCODE=c1.WOCLCLONEFROM order by PROTTIME';
      ordIBS.ParamByName('tbegin').AsDateTime:= max(tbegin, tt);
      ordIBS.ExecQuery;
      while not ordIBS.Eof do begin
        pUserID:= ordIBS.FieldByName('user1').AsInteger;
        s:= ordIBS.FieldByName('log1').AsString;
        if (pUserID>0) and (s<>'') then begin
          CheckWorkLogins(pUserID, s);
//          inc(iCount);
          if Cache.ClientExist(pUserID) then with Cache.arClientInfo[pUserID] do begin
            Login:= s;
            Blocked:= (ordIBS.FieldByName('block1').AsInteger<1);
          end;
        end;
        pUserID:= ordIBS.FieldByName('user2').AsInteger;
        s:= ordIBS.FieldByName('log2').AsString;
        if (pUserID>0) and (s<>'') then begin
          CheckWorkLogins(pUserID, s);
//          inc(iCount);
          if Cache.ClientExist(pUserID) then with Cache.arClientInfo[pUserID] do begin
            Login:= s;
            Blocked:= (ordIBS.FieldByName('block2').AsInteger<1);
          end;
        end;
        if (ordIBS.FieldByName('PROTTIME').AsDateTime>tend) then
          tend:= ordIBS.FieldByName('PROTTIME').AsDateTime;
        TestCssStopException;
        ordIBS.Next;
      end;
                   // ничего не нашли и новый день - переписываем время проверки
      if (tend=0) and (tbegin<=tt) then tend:= IncSecond(tt, 1);
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
      if (tend>0) then begin
        pUserID:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
        sTime:= FormatDateTime(cDateTimeFormatY4S, tend);
        s:= Cache.SaveNewConstValue(pcCheckClonBlockClients, pUserID, sTime);
        if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile, (LogFile<>''));
      end;
    end;
//    if flDebug then prMessageLOGS(nmProc+': '+IntToStr(iCount), fLogDebug, False);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile, (LogFile<>''));
  end;
//  TestCssStopException;
end;

//====================================== сверка TD->GA и TreeNodesAuto->MainNode
procedure CheckGAMainNodesLinks(LogFile: String='');
const nmProc = 'CheckGAMainNodesLinks'; // имя процедуры/функции
      maxStrLen = 1200;
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    pMainNode, lenS, lenGaStr, pUserID: Integer;
    s, sTime, GaStr, sMain: String;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('GaStr').AsString:= GaStr;
    tdtIBS.ExecQuery;
    if tdtIBS.Fields[0].AsString<>'' then
      prMessageLOGS(nmProc+': Ошибка проверки: '+tdtIBS.Fields[0].AsString);
    tdtIBS.Close;
    GaStr:= '';
    lenGaStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  with Cache do try
    ordIBD:= cntsOrd.GetFreeCnt;
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
                                                  // проверка необходимости сверки
      ordIBS.SQL.Text:= 'select max(TRNATIMEADD) from TREENODESAUTO where TRNADTSYCODE='+IntToStr(constIsAuto);
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) and
        (ordIBS.Fields[0].AsDateTime<=GetConstItem(pcCheckGAMainNodeTime).DateValue) then Exit;
      ordIBS.Close;

      sTime:= FormatDateTime(cDateTimeFormatY4S, Now);
      pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;

      tdtIBD:= cntsTDT.GetFreeCnt;
      try
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpWrite, true);
        tdtIBS.SQL.Text:= 'update link_GA_MainNode set lgm_Check=0'; // сбрасываем флажки проверки
        tdtIBS.ExecQuery;
        tdtIBS.Close;
        tdtIBS.SQL.Text:= 'select rErrorStr from check_ga_MainNode_Links(:GaStr)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select TRNAMAINCODE, TRNATDCODE from TREENODESAUTO'+
          ' where TRNATDGA="T" group by TRNAMAINCODE, TRNATDCODE order by TRNAMAINCODE';
        ordIBS.ExecQuery;
        GaStr:= '';
        lenGaStr:= 0;
        while not ordIBS.Eof do begin
          pMainNode:= ordIBS.fieldByName('TRNAMAINCODE').AsInteger;
          sMain:= ordIBS.fieldByName('TRNAMAINCODE').AsString;
          s:= '';
          while not ordIBS.Eof and (pMainNode=ordIBS.fieldByName('TRNAMAINCODE').AsInteger) do begin
            s:= s+fnIfStr(s='', '', ',')+ordIBS.fieldByName('TRNATDCODE').AsString; // собираем порцию кодов GA по pMainNode
            TestCssStopException;
            ordIBS.Next;
          end;
          s:= sMain+'='+s; // строка по pMainNode
          lenS:= length(s);

          if (lenGaStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          GaStr:= GaStr+fnIfStr(GaStr='', '', ';')+s;
          lenGaStr:= length(GaStr);
        end;
        ordIBS.Close;
        if GaStr<>'' then CheckPortion; // последняя порция - обрабатываем

        tdtIBS.SQL.Text:= 'delete from link_GA_MainNode where lgm_Check=0'; // удаляем непроверенные
        tdtIBS.ExecQuery;
        tdtIBS.Close;

        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    s:= SaveNewConstValue(pcCheckGAMainNodeTime, pUserID, sTime);
    if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile, (LogFile<>''));
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile, (LogFile<>''));
  end;
  TestCssStopException;
end;
//===================== проверить наличие товаров у артикулов в TDT (по запросу)
procedure CheckArticleWareMarks(LogFile: String=''; maxStrLen: Integer = 3000);
const nmProc = 'CheckArticleWareMarks'; // имя процедуры/функции
var ordIBD, tdtIBD: TIBDatabase;
    ordIBS, tdtIBS: TIBSQL;
    lenS, lenStr, pUserID, pIdent, iCount: Integer;
    s, Str: String;
    TimeProc: TDateTime;
  //---------------------------------
  procedure CheckPortion;
  begin
    tdtIBS.ParamByName('Str').AsString:= Str;
    tdtIBS.ExecQuery;
    tdtIBS.Close;
    Str:= '';
    lenStr:= 0;
  end;
  //---------------------------------
begin
  ordIBS:= nil;
//  tdtIBD:= nil;
  tdtIBS:= nil;
  iCount:= 0;
  TimeProc:= Now;
  with Cache do try
    if GetConstItem(pcNeedArticleWareMarks).IntValue<1 then Exit; // проверка необходимости
    ordIBD:= cntsOrd.GetFreeCnt;
    pUserID:= GetConstItem(pcEmplORDERAUTO).IntValue;
    try
      tdtIBD:= cntsTDT.GetFreeCnt;
      try                                // определяем идентификатор проверки
        ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
        tdtIBS:= fnCreateNewIBSQL(tdtIBD, 'tdtIBS_'+nmProc, -1, tpRead, true);
        tdtIBS.SQL.Text:= 'select Ident from GetCheckArticleWareMarksIdent';
        tdtIBS.ExecQuery;
        if (ordIBS.Eof and ordIBS.Bof) then begin
          Randomize;
          pIdent:= Random(maxStrLen+1);
        end else pIdent:= tdtIBS.Fields[0].AsInteger;
        tdtIBS.Close;

        fnSetTransParams(tdtIBS.Transaction, tpWrite);
        tdtIBS.Transaction.StartTransaction;
        tdtIBS.SQL.Text:= 'execute procedure check_ArticleWareMarks('+IntToStr(pIdent)+', :Str)';
        tdtIBS.Prepare;

        ordIBS.SQL.Text:= 'select WATDARTICLE, WATDARTSUP, count(WATDWARECODE) wareCount'+
          ' from WAREARTICLETD where WATDWRONG="F" group by WATDARTICLE, WATDARTSUP';
        ordIBS.ExecQuery;
        Str:= '';
        lenStr:= 0;
        s:= '';
        while not ordIBS.Eof do begin
          s:= ordIBS.fieldByName('wareCount').AsString+'<'+
              ordIBS.fieldByName('WATDARTSUP').AsString+'>'+
              ordIBS.fieldByName('WATDARTICLE').AsString; // строка по WATDARTICLE
          lenS:= length(s);

          if (lenStr+lenS+1)>maxStrLen then CheckPortion;  // если порция заполнена - обрабатываем и чистим

          Str:= Str+fnIfStr(Str='', '', ';')+s;
          lenStr:= length(Str);
          Inc(iCount);
          TestCssStopException;
          ordIBS.Next;
        end;
        ordIBS.Close;
        if Str<>'' then CheckPortion; // последняя порция - обрабатываем

                          // сбрасываем признаки наличия товаров у непроверенных
        tdtIBS.SQL.Text:= 'update articles set art_warecode=0 where ART_CheckWARE<>'+
                          IntToStr(pIdent)+' and art_warecode>0';
        tdtIBS.ExecQuery;
        tdtIBS.Close;
        tdtIBS.Transaction.Commit;
      finally
        prFreeIBSQL(tdtIBS);
        cntsTDT.SetFreeCnt(tdtIBD);
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsOrd.SetFreeCnt(ordIBD);
    end;

    prMessageLOGS(nmProc+': '+IntToStr(iCount)+' articles - '+GetLogTimeStr(TimeProc), LogFile);
                                       // сбрасываем признак проверки
    s:= SaveNewConstValue(pcNeedArticleWareMarks, pUserID, '0');
    if s<>'' then prMessageLOGS(nmProc+': '+s, LogFile);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, LogFile);
  end;
  TestCssStopException;
end;
//============================== проверка фирм, активных последние DecHour часов
procedure TestLastFirms(DecHour: Integer=1);
const nmProc = 'TestLastFirms'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    FirmID, UserID, fCount: Integer;
    LocalStart, dd: TDateTime;
begin
  if DecHour<1 then Exit;
  ibs:= nil;
  LocalStart:= now();
  fCount:= 0;
  try
    ibd:= cntsORD.GetFreeCnt('', '', '', True); // IgnoreTimer=True - не закрывать по времени
    try
      dd:= Now;
      if DecHour>0 then dd:= incHour(dd, -DecHour);
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
      ibs.SQL.Text:= 'select woclfirmcode from weborderclients'+
                     ' where wocllastactiontime>:dd group by woclfirmcode';
      ibs.ParamByName('dd').AsDateTime:= dd;
      ibs.ExecQuery;
      while not ibs.Eof do begin
        FirmID:= ibs.fields[0].AsInteger;
        Cache.TestFirms(FirmID, True, True);
        if Cache.FirmExist(FirmID) then begin
          UserID:= Cache.arFirmInfo[FirmID].SUPERVISOR;
          Cache.TestClients(UserID, True, True); // сотрудники фирмы
        end;
        ibs.Next;
        Inc(fCount);
      end;
    finally
      prFreeIBSQL(ibs);
      cntsORD.SetFreeCnt(ibd, True);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  prMessageLOGS(nmProc+': '+IntToStr(fCount)+' к/а - '+
    GetLogTimeStr(LocalStart), fLogCache, false);
end;
//================================ проверка наименований фирм в базе логирования
procedure TestLogFirmNames;
const nmProc = 'TestLogFirmNames'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    pFirmID, iCount, i, len: Integer;
    LocalStart: TDateTime;
    lst: TStringList;
    fName, s: String;
begin
  ibs:= nil;
  ibd:= nil;
  LocalStart:= now();
  iCount:= 0;
  len:= 40;
  try
    for i:= High(Cache.arFirmInfo) downto 1 do
      if Assigned(Cache.arFirmInfo[i]) then Cache.arFirmInfo[i].State:= False;

    lst:= TStringList.Create;
    try
      ibd:= cntsLog.GetFreeCnt('', '', '', True); // IgnoreTimer=True - не закрывать по времени
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);

      ibs.SQL.Text:= 'select ff.RDB$FIELD_LENGTH fsize'+
        ' from rdb$relation_fields f, rdb$fields ff'+
        ' where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE'+
        '   and f.RDB$RELATION_NAME=:table and f.RDB$FIELD_NAME=:fname';
        ibs.ParamByName('table').AsString:= 'LOGFIRMNAMES';
        ibs.ParamByName('fname').AsString:= 'LFNFIRMNAME';
      ibs.ExecQuery;
      if not (ibs.Eof and ibs.Bof) and (ibs.FieldByName('fsize').AsInteger>0) then
        len:= ibs.FieldByName('fsize').AsInteger;
      ibs.Close;

      ibs.SQL.Text:= 'select LFNFIRMCODE, LFNFIRMNAME from LOGFIRMNAMES';
      ibs.ExecQuery; // проверяем те фирмы, кот.уже есть в базе логирования
      while not ibs.Eof do begin
        pFirmID:= ibs.fields[0].AsInteger;
        fName:=  ibs.fields[1].AsString;
        if Cache.FirmExist(pFirmID) then with Cache.arFirmInfo[pFirmID] do begin
          s:= copy(Name, 1, len);
          if (fName<>s) then lst.AddObject(s, Pointer(pFirmID)); // в список на проверку
          State:= True;
        end;
        ibs.Next;
      end;
      ibs.Close;

      for i:= High(Cache.arFirmInfo) downto 1 do if Assigned(Cache.arFirmInfo[i]) then
        with Cache.arFirmInfo[i] do begin    // ищем фирмы, кот.не проверяли
          if State then State:= False
          else if not Arhived and (FirmContracts.count>0) then
            lst.AddObject(copy(Name, 1, len), Pointer(ID));
        end;

      iCount:= lst.Count;
      if (iCount>0) then begin
        fnSetTransParams(ibs.Transaction, tpWrite, True);
        ibS.SQL.Text:= 'execute procedure CheckLogFirmName(:aFirm, :aFName)';
        for i:= 0 to lst.Count-1 do begin
          ibS.ParamByName('aFirm').AsInteger:= Integer(lst.Objects[i]);
          ibS.ParamByName('aFName').AsString:= lst[i];
          ibs.ExecQuery;
        end;
        ibs.Transaction.Commit;
      end;
    finally
      prFreeIBSQL(ibs);
      cntsLog.SetFreeCnt(ibd, True);
      prFree(lst);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  prMessageLOGS(nmProc+': '+IntToStr(iCount)+' к/а - '+
    GetLogTimeStr(LocalStart), fLogCache, false);
end;
//================= проверка соответствия к/а условиям фильтрации (Web & WebArm)
function CheckFirmFilterConditions(FirmID: Integer; flFirmsAdd, flAuto, flMoto: Boolean;
         Filials, Classes, Types, Firms: TIntegerList): Boolean;
const nmProc = 'CheckFirmFilterConditions'; // имя процедуры/функции
var j: Integer;
    flNot: Boolean;
    firm: TFirmInfo;
begin
  Result:= False;
  if not Cache.FirmExist(FirmID) then Exit;
  try
    firm:= Cache.arFirmInfo[FirmID];
    if firm.Arhived or firm.Blocked or (firm.SUPERVISOR<1) then Exit;

//    if not ((flAuto and firm.IsAUTOFirm) or (flMoto and firm.IsMOTOFirm)) then Exit;

    if (Firms.Count>0) then begin  // проверяем коды
      flNot:= (Firms.IndexOf(FirmID)<0);
      if flFirmsAdd then begin  //------------------------------ флаг добавления
        if not flNot then begin // есть в списке - дальше не проверяем
          Result:= True; // фирма подходит
          Exit;                            // нет в списке + нет др.условий - не подходит
        end else if (Types.Count<1) and (Classes.Count<1) and (Filials.Count<1) then Exit;
      end else                  //------------------------------ флаг исключения
        if not flNot then Exit; // есть в списке - не подходит
    end;
                                         // проверяем тип
    if (Types.Count>0) and (Types.IndexOf(firm.FirmType)<0) then Exit;
                                         // проверяем филиал
    if (Filials.Count>0) and (Filials.IndexOf(firm.GetDefContract.Filial)<0) then Exit;

    if (Classes.Count>0) then begin      // проверяем категории
      flNot:= True;
      for j:= 0 to Classes.Count-1 do begin
        flNot:= (firm.FirmClasses.IndexOf(Classes[j])<0);
        if not flNot then break;
      end;
      if flNot then Exit;
    end;

    Result:= True; // фирма подходит
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;

//-------------------------------------- проверка остановки процесса или системы
procedure CheckStopExecute(pUserID: Integer; ThreadData: TThreadData);
begin
  if Assigned(ThreadData) then
    prStopProcess(pUserID, ThreadData.ID) // проверка остановки процесса
  else TestCssStopException; // проверка остановки системы
end;
//--------------------------------------------- отображение процентов выполнения
procedure SetExecutePercent(pUserID: Integer; ThreadData: TThreadData; Percent: Double);
begin
  if Assigned(ThreadData) then
    ImpCheck.SetProcessPercent(pUserID, ThreadData.ID, Percent);
end;
//======================================== перемещаем файл nf из dirold в dirnew
function RenameErrFile(nf, dirold, dirnew: string; flPutOff: Boolean=False): string;
const nmProc = 'RenameErrFile'; // имя процедуры/функции
var i: Integer;
    list: TStringList;
    nfile, s, prefix: String;
begin
  list:= TStringList.Create;
  try
    if flPutOff then prefix:= 'p' // помечаем отложенный файл
    else prefix:= 'e';            // помечаем сбойный файл
    nfile:= fnTestDirEnd(dirnew)+prefix+'_'+nf; // новое имя файла
    i:= 0;
    Result:= '';
    if not DirectoryExists(dirnew) then CreateDir(dirnew); // если папки нет - создаем
    while FileExists(nfile) do begin
      Inc(i);
      nfile:= fnTestDirEnd(dirnew)+prefix+IntToStr(i)+'_'+nf;
    end;
    if RenameFile(fnTestDirEnd(dirold)+nf, nfile) then
      prMessageLOGS(nmProc+': Файл '+nf+' перемещен в папку '+dirnew) // пишем в log
    else Result:= Result+fnIfStr(Result='', '', #13#10)+'Файл '+nf+' не удалось переместить в папку '+dirnew;
    if not flPutOff then begin
      list.Add('Error processing file '+nf); // отправить сообщение админу пр-мы Vlad
      s:= fnGetSysAdresVlad(caeOnlyWorkDay);
      list.Insert(0, GetMessageFromSelf);
      s:= n_SysMailSend(s, 'Error processing file', list, nil, '', '', true);
      if (s<>'') then
        Result:= Result+fnIfStr(Result='', '', #13#10)+'Ошибка отправки письма об Ошибке обработки файла '+nf;
    end;
  finally
    prFree(list);
  end;
end;
//=========================================== отправить письмо с паролем клиенту
function prSendMailWithClientPassw(Kind: TKindCliMail; Login, Password, Mail: String;
                                   ThreadData: TThreadData; FirmName: String=''): string;
//  TKindCliMail = (kcmSetMainUser, kcmRegister, kcmCreateUser);
const nmProc = 'prSendMailWithClientPassw'; // имя процедуры/функции
var Strings: TStringList;
    errmess, subj: string;
begin
  Result:= '';
  try
    Strings:= TStringList.Create;
    Strings.Add('Здравствуйте!');
    Strings.Add('');
    if (Kind=kcmRemindPass) then begin
      subj:= 'Восстановление пароля на сайте ';
      Strings.Add('Ваш логин: '+Login);
      Strings.Add('Ваш пароль: '+Password);
      Strings.Add('Учетная запись принадлежит организации '+FirmName);
      Strings.Add('');
      Strings.Add('Если Вы не запрашивали восстановление пароля,'+
        ' перешлите это письмо в службу поддержки support@vladislav.ua .');
    end else begin
      subj:= 'Доступ к сайту ';
      Strings.Add('Вам предоставлен доступ к сайту http://order.vladislav.ua.');
      Strings.Add('Ваш логин: '+Login);
      Strings.Add('Ваш пароль: '+Password);
    end;
    Strings.Add('');
    Strings.Add('С уважением,');
    Strings.Add('Команда ВЛАДИСЛАВ');

//    errmess:= n_SysMailSend(Mail, subj+'order.vladislav.ua', Strings, nil, '', '', true);
    errmess:= n_SysMailSend(Mail, subj+'order.vladislav.ua', Strings, nil, cNoReplayEmail, '', true);

    if errmess<>'' then begin
      fnWriteToLog(ThreadData, lgmsUserError, nmProc, '', errmess, '');
      case Kind of
       kcmSetMainUser:
         Result:= 'Учетная запись создана успешно, но при отправке письма клиенту произошла ошибка.'+
                  ' Сообщите клиенту его логин и предложите получить пароль для входа через систему восстановления пароля';
       kcmRegister:
         Result:= 'произошла ошибка при отправке клиенту письма с паролем.'+
                  ' Сообщите клиенту логин, пароль можно получить через систему восстановления пароля';
       kcmCreateUser:
         Result:= 'Учетная запись создана успешно, но при отправке письма с паролем произошла ошибка.'+
                  ' Сообщите своему сотруднику его логин и предложите получить пароль для входа через систему восстановления пароля';
       kcmRemindPass:
         Result:= 'Произошла ошибка отправки письма с напоминанием пароля.'+
                  ' Попробуйте повторить запрос через некоторое время. '+
                  'Если такая ошибка происходит регулярно, то сообщите еще раз'+
                  ' обслуживающему Вашу организацию менеджеру Ваш e-mail - '+
                  'возможно ранее данные были внесены в базу неправильно.';
      else Result:= 'произошла ошибка при отправке клиенту письма с паролем';
      end;
    end;
  finally
    prFree(Strings);
  end;
end;
(*//=================================== проверка заглавной буквы и пробелов текста
function CheckTextFirstUpAndSpaces(txt: String): String;
var xChar, xCharU: String;
begin
  Result:= txt;
  if (Result<>'') then Result:= trim(Result);               // убираем крайние пробелы
  if (Result<>'') then Result:= StringReplace(Result, '  ', ' ', [rfReplaceAll]); // убираем двойные пробелы
  if (Result<>'') then begin
    xChar:= copy(Result, 1, 1);
    xCharU:= AnsiUpperCase(xChar);                 // текст - с заглавной буквы
    if (xChar<>xCharU) then Result:= xCharU+copy(Result, 2);
  end
end;    *)


//******************************************************************************
//                          расписания отгрузки
//******************************************************************************
//=========================== список доступных времен самовывоза по складу, дате
function GetAvailableSelfGetTimesList(DprtID: Integer; pDate: TDateTime;
         var stID: Integer; var SL: TStringList; flWithSVKDelay: Boolean=False): String;
// String- время отгрузки, Object- код времени отгрузки
// если stID>0 и недоступно - меняем знак
const nmProc = 'GetAvailableSelfGetTimesList'; // имя процедуры/функции
var i, TestTime, TimeMin, TimeMax: Integer;
    s: String;
    st: TShipTimeItem;
    flFound: Boolean;
    lst: TList;
    dprt: TDprtInfo;
begin
  Result:= '';
  if not Assigned(SL) then SL:= TStringList.Create;
  flFound:= (stID<1);
  lst:= TList.Create;
  try
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад отгрузки');
    dprt:= Cache.arDprtInfo[DprtID];

    s:= dprt.CheckShipAvailable(pDate);
    if (s<>'') then raise EBOBError.Create(s);
                                              // границы времен отгрузки на дату
    s:= dprt.GetShipTimeLimits(pDate, TimeMin, TimeMax, flWithSVKDelay);
    if (s<>'') then raise EBOBError.Create(s);

    for i:= 0 to Cache.ShipTimes.ItemsList.Count-1 do begin
      st:= Cache.ShipTimes.ItemsList[i];
      TestTime:= (st.Hour*60+st.Minute)*60;
      if (TestTime<TimeMin) or (TestTime>TimeMax) then Continue; // проверяем время
      lst.Add(st);  // если подходит - добавляем в список
      flFound:= flFound or (st.ID=stID);
    end;
    if not flFound then // старое время не попало в список
      if Cache.ShipTimes.ItemExists(stID) then begin // старое время есть
        st:= Cache.ShipTimes[stID];
        lst.Add(st);                          // добавляем в список старое время
        stID:= -stID;                         // меняем знак у кода -> недоступно
      end else      // старое время не найдено
        stID:= 0;                             // обнуляем код
    if (lst.Count>1) then lst.Sort(ShipTimesSortCompare); // сортируем
    for i:= 0 to lst.Count-1 do begin
      st:= lst[i];
      SL.AddObject(st.Name, Pointer(st.ID)); // время отгрузки, код
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
  prFree(lst);
end;
//====================================== список доступных дат отгрузки по складу
function GetAvailableShipDatesList(DprtID, iDate: Integer;
         var SL: TStringList; flWithSVKDelay: Boolean=False): String;
// String- строка даты отгрузки, Object- целое значение даты отгрузки (вместо кода)
// если iDate>0 и дата недоступна - меняем знак
const nmProc = 'GetAvailableShipDatesList'; // имя процедуры/функции
var i, TestTime, DateInt, DayCount: Integer;
    iHour, iMinute, iSec, iMsec: Word;
    s: String;
    flFound: Boolean;
    dprt: TDprtInfo;
    pDate: TDateTime;
    sch: TTwoCodes;
begin
  Result:= '';
  if not Assigned(SL) then SL:= TStringList.Create;
  try
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад отгрузки');
    dprt:= Cache.arDprtInfo[DprtID];

    DecodeTime(Now, iHour, iMinute, iSec, iMsec); // сегодня проверяем текущее время
    TestTime:= iHour*60+iMinute+dprt.DelayTime;  // запаздывание склада
    if flWithSVKDelay then                       // запаздывание СВК
      TestTime:= TestTime+Cache.GetConstItem(pcSVKShipDelayMinutes).IntValue;
    TestTime:= TestTime*60;

{    DayCount:= 1; // вычисляем кол-во дней для показа
    with fnSplit(',', Cache.GetConstItem(pcAccountStorageDays).StrValue) do try  // TStringList
      for i:= 0 to Count-1 do begin
        DateInt:= StrToIntDef(Strings[i], 0);
        if (DayCount<DateInt) then DayCount:= DateInt;
      end;
    finally
      Free;
    end;  }
    DayCount:= Cache.GetConstItem(pcShipChoiceDays).IntValue; // кол-во дней для показа

    for i:= 0 to dprt.Schedule.Count-1 do begin
      pDate:= Date()+i;
      DateInt:= Trunc(pDate);
      flFound:= (iDate>0) and (DateInt=iDate);
      sch:= TTwoCodes(dprt.Schedule[i]);

      if ((sch.ID1<1) and (sch.ID2<1))         // дата недоступна
        or ((i=0) and (TestTime>sch.ID2)) then // сегодня проверяем текущее время
        if flFound then DateInt:= -DateInt else Continue;

      s:= FormatDateTime(cDateFormatY4, pDate);
      case DayOfTheWeek(pDate) of
        1: s:= s+' - Пн';
        2: s:= s+' - Вт';
        3: s:= s+' - Ср';
        4: s:= s+' - Чт';
        5: s:= s+' - Пт';
        6: s:= s+' - Сб';
        7: s:= s+' - Вс';
      end;
      if (i=0) then s:= s+', сегодня';
      if (i=1) then s:= s+', завтра';
      SL.AddObject(s, Pointer(DateInt)); // если подходит - добавляем в список
      if (SL.Count>=DayCount) then break; // DayCount раб.дней
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//======================================= проверка параметров отгрузки для счета
function CheckAccountShipParams(delivType, ContID, DprtID: Integer; var pShipDate: TDateTime;
         var DestID, ttID, smID, stID: Integer; flWithSVKDelay: Boolean=False): String;
const nmProc = 'CheckAccountShipParams'; // имя процедуры/функции
var ibd: TIBDatabase;
    ibs: TIBSQL;
    s, strErr: String;
    dprt: TDprtInfo;
begin
  ibs:= nil;
  ibd:= nil;
  Result:= '';
  s:= '';
  try
    if not (DelivType in [cDelivTimeTable, cDelivReserve, cDelivSelfGet, cDelivClientNow]) then
      raise EBOBError.Create('Неизвестный вид доставки - '+IntToStr(DelivType));
    if not Cache.Contracts.ItemExists(ContID) then
      raise EBOBError.Create('Не найден контракт, код - '+IntToStr(ContID));
    if not Cache.DprtExist(DprtID) then
      raise EBOBError.Create('Не найден склад, код - '+IntToStr(DprtID));

    dprt:= Cache.arDprtInfo[DprtID];
    case delivType of
      cDelivReserve: begin // резерв
        pShipDate:= 0;
        DestID:= 0;
        ttID:= 0;
        smID:= 0;
        stID:= 0;
      end; // cDelivReserve

      cDelivClientNow: begin // клиент на складе - только сегодня  ???
        strErr:= dprt.CheckShipAvailable(pShipDate);
        if (strErr<>'') then raise EBOBError.Create(strErr);
        DestID:= 0;
        ttID:= 0;
        smID:= Cache.GetConstItem(pcCliNowShipMethodCode).IntValue;
        stID:= 0;
      end; // cDelivClientNow

      cDelivSelfGet: begin // Самовывоз
        DestID:= 0;
        ttID:= 0;
        smID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
        try // проверяем время
          if (stID<1) then raise EBOBError.Create('Отсутствует время отгрузки');
          strErr:= dprt.CheckShipAvailable(pShipDate, stID, flWithSVKDelay, True);
          if (strErr<>'') then raise EBOBError.Create(strErr);
        except
          on E: Exception do begin
            stID:= 0;
            raise EBOBError.Create(E.Message);
          end;
        end;
      end; // cDelivSelfGet

      cDelivTimeTable: try // доставка
        if (DestID<1) then raise EBOBError.Create('Отсутствует торговая точка');
        if (ttID<1) then raise EBOBError.Create('Отсутствует расписание');
        try
          ibd:= cntsGRB.GetFreeCnt;
          ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
          ibs.SQL.Text:= 'select rSMethodID, rSTimeID'+
            ' from Vlad_CSS_GetContDestTimeTables('+IntToStr(contID)+', '+
            IntToStr(DestID)+', '+IntToStr(DprtID)+', :pDate) where RttID='+IntToStr(ttID);
          IBS.ParamByName('pDate').AsDate:= pShipDate;
          IBS.ExecQuery;
          if (IBS.Bof and IBS.Eof) then begin
            DestID:= 0;
            raise EBOBError.Create('Заданная торговая точка недоступна');
          end;
          smID:= IBS.FieldByName('rSMethodID').AsInteger;
          stID:= IBS.FieldByName('rSTimeID').AsInteger;
          strErr:= 'Заданное расписание отгрузки недоступно';
          if not Cache.ShipMethods.ItemExists(smID) then raise EBOBError.Create(strErr);
          strErr:= dprt.CheckShipAvailable(pShipDate, stID, flWithSVKDelay);
          if (strErr<>'') then raise EBOBError.Create(strErr);
        finally
          prFreeIBSQL(ibs);
          cntsGRB.SetFreeCnt(ibd);
        end;
      except
        on E: Exception do begin
          ttID:= 0;
          smID:= 0;
          stID:= 0;
          raise EBOBError.Create(E.Message);
        end;
      end; // cDelivTimeTable
    end; // case
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//============================================= параметры отгрузки для просмотра
function fnGetShipParamsView(contID, DprtID, DestID, ShipTableID: Integer; ShipDate: double;
         var DelivType, ShipMetID, ShipTimeID: Integer; var sDestName, sDestAdr, sArrive: String;
         var sShipMet, sShipTime, sView: String; GBdirection: Boolean=False): String;
const nmProc = 'fnGetShipParamsView'; // имя процедуры/функции
var grbIBD: TIBDatabase;
    grbIBS: TIBSQL;
    pDate: double;
    dest: TDestPoint;
    Contract: TContract;
begin
  Result:= '';
  sDestName:= '';
  sDestAdr:= '';
  sArrive:= '';
  sShipMet:= '';
  sShipTime:= '';
  sView:= '';
  grbIBD:= nil;
  grbIBS:= nil;
  try
    if not (DelivType in [cDelivTimeTable, cDelivReserve, cDelivSelfGet]) then
      DelivType:= cDelivReserve; // резерв

    if not Cache.Contracts.ItemExists(contID) then Exit;
    Contract:= Cache.Contracts[contID];

    case DelivType of
      cDelivTimeTable: begin //------------------------ Доставка по расписанию
        if (ShipDate<DateNull) then ShipDate:= 0;
        if (contID<1) or (DestID<1) or (ShipTableID<1) or (DprtID<1) then begin
          ShipMetID:= 0;
          ShipTimeID:= 0;
        end;
        if (ContID>0) and (DestID>0) then try
          grbIBD:= cntsGRB.GetFreeCnt;
          grbIBS:= fnCreateNewIBSQL(grbIBD, 'IBS_'+nmProc, -1, tpRead, True);
          dest:= Contract.GetContDestPoint(destID);
          if Assigned(dest) then begin
            sDestName:= dest.Name;
            sDestAdr:= dest.Adress;
          end else begin
            grbibs.SQL.Text:= 'select rDestName, rDestAdr'+
              ' from Vlad_CSS_GetContDestPoints('+IntToStr(ContID)+', '+
              fnIfStr(GBdirection, '1', '0')+') where RDestID='+IntToStr(DestID);
            grbIBS.ExecQuery;
            if not (grbIBS.Bof and grbIBS.Eof) then begin
              sDestName:= grbIBS.FieldByName('rDestName').AsString;
              sDestAdr:= grbIBS.FieldByName('rDestAdr').AsString;
            end;
            grbIBS.Close;
          end;
          if (DprtID>0) and (ShipDate>0) and (ShipTableID>0) then begin
            grbIBS.SQL.Text:= 'select rSMethodID, rSTimeID, rArrive'+
              ' from Vlad_CSS_GetContDestTimeTables('+IntToStr(contID)+', '+
              IntToStr(DestID)+', '+IntToStr(DprtID)+', :pDate)'+
              ' where RttID='+IntToStr(ShipTableID);
            grbIBS.ParamByName('pDate').AsDate:= ShipDate;
            grbIBS.ExecQuery;
            if not (grbIBS.Bof and grbIBS.Eof) then begin
              ShipMetID:= grbIBS.FieldByName('rSMethodID').AsInteger;
              ShipTimeID:= grbIBS.FieldByName('rSTimeID').AsInteger;
              pDate:= grbIBS.FieldByName('rArrive').AsDateTime;
              if (pDate>DateNull) then sArrive:= FormatDateTime(cDateTimeFormatY2N, pDate);
            end;
          end;
        finally
          prFreeIBSQL(grbIBS);
          cntsGRB.SetFreeCnt(grbIBD);
        end;

        if Cache.ShipMethods.ItemExists(ShipMetID) then
          sShipMet:= TShipMethodItem(Cache.ShipMethods[ShipMetID]).Name;
        if Cache.ShipTimes.ItemExists(ShipTimeID) then
          sShipTime:= TShipTimeItem(Cache.ShipTimes[ShipTimeID]).Name;

        if (ShipDate>0) then sView:= sView+FormatDateTime(cDateFormatY2, ShipDate);
        if (sShipTime<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipTime;
        if (sShipMet<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipMet;
        if (sDestName<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sDestName;
        if (sDestAdr<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sDestAdr;
        if (sArrive<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+'План.приб.'+sArrive;
        if (sView<>'') then sView:= 'Отгрузка: '+sView else sView:= 'Доставка';
      end; // cDelivTimeTable

      cDelivReserve: begin // Резерв
        ShipMetID:= 0;
        ShipTimeID:= 0;
        sView:= 'Резервировать';
      end; // cDelivReserve

      cDelivSelfGet: begin //--------------------------------------- Самовывоз
        if (ShipDate<DateNull) then ShipDate:= 0;
        ShipMetID:= Cache.GetConstItem(pcSelfGetShipMethodCode).IntValue;
        if Cache.ShipMethods.ItemExists(ShipMetID) then
          sShipMet:= TShipMethodItem(Cache.ShipMethods[ShipMetID]).Name;
        if Cache.ShipTimes.ItemExists(ShipTimeID) then
          sShipTime:= TShipTimeItem(Cache.ShipTimes[ShipTimeID]).Name;

        if (ShipDate>0) then sView:= sView+FormatDateTime(cDateFormatY2, ShipDate);
        if (sShipTime<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipTime;
        if (sShipMet<>'') then sView:= sView+fnIfStr(sView='', '', ', ')+sShipMet;
        if (sView<>'') then sView:= 'Отгрузка: '+sView else sView:= 'Самовывоз';
      end; // cDelivSelfGet
    end; // case
  except
    on E: Exception do Result:= E.Message;
  end;
end;
//========================================== запись глав.пользователя в Grossbee
function SetMainUserToGB(FirmID, UserID: Integer; pDate: TDateTime; ibsGBw: TIBSQL=nil): String;
const nmProc = 'SetMainUserToGB'; // имя процедуры/функции
var ibsGB: TIBSQL;
    ibdGB: TIBDatabase;
begin
  Result:= '';
  ibdGB:= nil;
  ibsGB:= nil;
  if (pDate<=DateNull) then pDate:= Date();
  try try
    if Assigned(ibsGBw) then begin
      ibsGB:= ibsGBw;
      ibsGB.Close;
      with ibsGB.Transaction do if not InTransaction then StartTransaction;
    end else begin
      ibdGB:= cntsGRB.GetFreeCnt;
      ibsGB:= fnCreateNewIBSQL(ibdGB, 'ibsGB_'+nmProc, -1, tpWrite, True);
    end;
    ibsGB.SQL.Text:= 'UPDATE OR INSERT INTO GeneralPerson'+
                     ' (GnPrDate, GnPrFirmCode, GnPrPersonCode)'+
                     ' VALUES (:dd, '+IntToStr(firmID)+', '+IntToStr(UserID)+
                     ') MATCHING (GnPrFirmCode, GnPrDate)';
    ibsGB.ParamByName('dd').AsDate:= pDate;
    ibsGB.ExecQuery;
    ibsGB.Transaction.Commit;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
  finally
    if not Assigned(ibsGBw) then begin
      prFreeIBSQL(ibsGB);     // отпускаем коннект Grossbee
      cntsGRB.SetFreeCnt(ibdGB);
    end;
  end;
end;
// tmp_Check_Recode_err
//======================================= регулярная проверка в базе логирования
procedure TmpCheckRecode;
const nmProc = 'TmpCheckRecode'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    TimeProc: TDateTime;
begin
  ibd:= nil;
  ibs:= nil;
  TimeProc:= Now;
  try try
    ibd:= cntsLOG.GetFreeCnt;                                         // ib_css
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.SQL.Text:= 'select rCount from tmp_Check_Recode_err';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    i:= ibs.FieldByName('rCount').AsInteger;
    ibs.Transaction.Commit;
    prMessageLOGS(nmProc+': обработано '+IntToStr(i)+' записей, '+GetLogTimeStr(TimeProc), fLogCache, False);
  except
    on E: Exception do prMessageLOGS(nmProc+'_stop: '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsLOG.SetFreeCnt(ibd);
  end;
end;
//===================================== фоновая перекодировка в базе логирования
procedure TmpRecodeCSS;
const nmProc = 'TmpRecodeCSS'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    flStop: Boolean;
    TimeProc: TDateTime;
begin
  ibd:= nil;
  ibs:= nil;
  if not flTmpRecodeCSS then Exit;
  if not flDebug and not fnGetActionTimeEnable(caeSmallWork) then Exit; // только в периоды малой загрузки системы
  flStop:= False;
  TimeProc:= Now;
  try try
    ibd:= cntsLOG.GetFreeCnt;                                         // ib_css
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, True);
    ibs.SQL.Text:= 'select rCount from tmp_Recode';
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then raise Exception.Create('Empty ibs');
    i:= ibs.FieldByName('rCount').AsInteger;
    ibs.Transaction.Commit;
    flStop:= (i<1); // все перекодировали - выключаем
    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+IntToStr(i)+' записей, '+GetLogTimeStr(TimeProc), nmProc, False);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+'_stop: '+E.Message, nmProc);
//      flStop:= True;
    end;
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsLOG.SetFreeCnt(ibd);
    if flStop then SetIniParam(nmIniFileBOB, 'Options', 'flTmpRecodeCSS', '0');
  end;
end;
//============================================= фоновая перекодировка в базе ORD
procedure TmpRecodeORD;
// скриптами в базе удалены:
//  - заголовки старых заказов без товаров со статусами "Формируется", "Аннулирован"
// 1. удаляем "левые" товары из бонусных заказов
// 2. удаляем старые заказы со статусом "Удален"
const nmProc = 'TmpRecodeORD'; // имя процедуры/функции
var ibs: TIBSQL;
    ibd: TIBDatabase;
    i: Integer;
    flStop: Boolean;
    TimeProc: TDateTime;
    ilst: TIntegerList;
    s: String;
begin
  ibd:= nil;
  ibs:= nil;
  if not flTmpRecodeORD then Exit;
  if not flDebug and not fnGetActionTimeEnable(caeSmallWork) then Exit; // только в периоды малой загрузки системы
  flStop:= False;
  TimeProc:= Now;
  ilst:= TIntegerList.Create;
  try try
    ibd:= cntsORD.GetFreeCnt;                                         // ib_ord
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
//    ibs.SQL.Text:= 'select ordrlncode lncode, ordrlnware from ordersreestr'+        // 1
//      ' left join orderslines on ordrlnorder=ordrcode where ordrdate>"01.04.2016"'+ // 1
//      ' and ordrcurrency=22 and ordrstatus='+IntToStr(orstForming);                 // 1
    ibs.SQL.Text:= 'select first 1000 ordrcode lncode from ordersreestr'+   // 2
      ' where ordrdate<"01.01.2016" and ordrstatus='+IntToStr(orstDeleted); // 2
    ibs.ExecQuery;
    while not ibs.Eof do begin
//      i:= ibs.FieldByName('ordrlnware').AsInteger;                 // 1
//      if Cache.WareExist(i) and not Cache.GetWare(i).IsPrize then  // 1
      ilst.Add(ibs.FieldByName('lncode').AsInteger);       // 2
      TestCssStopException; // проверка остановки системы
      ibs.Next;
    end;
    ibs.Close;
    if (ilst.Count>0) then begin
      fnSetTransParams(IBS.Transaction, tpWrite, True);
//      IBS.SQL.Text:= 'execute procedure DelOrderLine(:LineID)'; // 1
      IBS.SQL.Text:= 'delete from ordersreestr where ordrcode=:LineID'; // 2
//      s:= 'LineID=';                                            // 1
      s:= 'orderID=';                                                   // 2
      for i:= 0 to ilst.Count-1 do begin
        try
          with IBS.Transaction do if not InTransaction then StartTransaction;
          IBS.ParamByName('LineID').AsInteger:= ilst[i];
          IBS.ExecQuery;
          IBS.Transaction.Commit;
        except
          on E: Exception do prMessageLOGS(nmProc+': del error '+s+
                             IntToStr(ilst[i])+': '+E.Message, nmProc, False);
        end;
        TestCssStopException; // проверка остановки системы
      end;
    end;
    flStop:= (ilst.Count<1); // все перекодировали - выключаем

    if flStop then prMessageLOGS(nmProc+': нет данных для обработки - выключаем', nmProc, False)
    else prMessageLOGS(nmProc+': обработано '+IntToStr(ilst.Count)+' записей, '+
      GetLogTimeStr(TimeProc), nmProc, False);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+'_stop: '+E.Message, nmProc);
//      flStop:= True;
    end;
  end;
  finally
    prFreeIBSQL(ibs);     // отпускаем коннект
    cntsORD.SetFreeCnt(ibd);
    if flStop then SetIniParam(nmIniFileBOB, 'Options', 'flTmpRecodeORD', '0');
    prFree(ilst);     // отпускаем коннект
  end;
end;
//========================================== проверка мобильного номера телефона
function CheckMobileNumber(num: String): Boolean;
const opCodes: array[0..15] of String = ('039'{Golden Telecom}, '050'{MTC},
 '063'{Life}, '066'{Джинс}, '067'{Киевстар/Djuice}, '068'{Beeline/WellCOM/МОБI},
 '073'{Life}, '091'{Utel}, '092'{PEOPLEnet}, '093'{Life}, '094'{Интертелеком},
 '095'{МТС/Джинс}, '096'{Киевстар/Djuice}, '097'{Киевстар/Djuice/Мобилыч},
 '098'{Киевстар/Djuice/Мобилыч}, '099'{Экотел(1..6)/Джинс});
var pref: String;
    i: Integer;
    c: Char;
begin
  Result:= False;
  if (num='') then Exit; // пустой номер
  i:= 1;
  repeat // ищем позицию кода оператора
    c:= num[i];
    if SysUtils.CharInSet(c, ['(', '+', '3', '8', ' ']) then Inc(i)
    else c:= '~'; // маркер выхода их цикла
  until (c='~');
  pref:= copy(num, i, 10);
  if (length(pref)<10) then Exit; // некорректная длина номера

  pref:= copy(num, i, 3); // код оператора
  for i:= Low(opCodes) to High(opCodes) do begin // ищем в массиве кодов
    Result:= (pref=opCodes[i]);
    if Result then Exit;
  end;
{  Result:= (pref='050') or (pref='066') or (pref='095') or (pref='099')  // MTC
        or (pref='067') or (pref='096') or (pref='097') or (pref='098')  // Kyivstar
        or (pref='068') or (pref='063') or (pref='093') or (pref='073')  // Beeline, Life
        or (pref='091') or (pref='092') or (pref='094') or (pref='039'); // Utel, PEOPLEnet, Интертелеком, Golden Telecom
}
end;

//******************************************************************************
//                           TForFirmParams
//******************************************************************************
constructor TForFirmParams.Create(pFirmID, pUserID, pForFirmID, pcurrID, pcontID: Integer);
var s: String;
begin
  FirmId:= pFirmID;
  UserID:= pUserID;
  ForFirmID:= pForFirmID;
  currID:= pcurrID;
  contID:= pcontID;
  ForClient:= (FirmId<>IsWe);
  if not Cache.CurrExists(currID) then // определяем валюту, если она не задана
    if not ForClient then currID:= 0
    else if CheckNotValidUser(UserID, FirmID, s) then currID:= 0
    else currID:= Cache.arClientInfo[UserID].SEARCHCURRENCYID; // берем валюту из настроек пользователя
  if ForClient and (ForFirmID<1) then ForFirmID:= FirmID; // к/а для скидок
  if (currID>0) then rate:= Cache.Currencies.GetCurrRate(currID) else rate:= 0;    // ???
  arSys:= SysTypes.GetDirCodes;   // коды систем учета
end;
//==============================================================================
destructor TForFirmParams.Destroy;
begin
  SetLength(arSys, 0); // чистим массив
  inherited;
end;

//******************************************************************************
//                          TFirmPhoneParams
//******************************************************************************
constructor TFirmPhoneParams.Create(pNames: String; pSMScount: Integer);
begin
  Names:= pNames;
  SetLength(arSMSind, pSMScount);
end;
//==============================================================================
destructor TFirmPhoneParams.Destroy;
begin
  SetLength(arSMSind, 0);
  inherited;
end;

//******************************************************************************
initialization
begin
  SaveToLog:= [];
  CheckDocsList:= TStringList.Create;
  dLastCheckDocTime:= DateNull;
  dLastCheckCliEmails:= DateNull;
  VSMail:= TVSMail.Create;
  brcWebDelim         := fnCodeBracketsForWeb(cWebDelim);
  brcWebBoldBlackBegin:= fnCodeBracketsForWeb(cWebBoldBlackBegin);
  brcWebBoldEnd       := fnCodeBracketsForWeb(cWebBoldEnd);
  brcWebColorRedBegin := fnCodeBracketsForWeb(cWebColorRedBegin);
  brcWebColorBlueBegin:= fnCodeBracketsForWeb(cWebColorBlueBegin);
  brcWebColorEnd      := fnCodeBracketsForWeb(cWebColorEnd);
//  brcWebItalBegin     := fnCodeBracketsForWeb(cWebItalBegin);
//  brcWebItalEnd       := fnCodeBracketsForWeb(cWebItalEnd);
  flDebug:= False;
  flTest:= False;
  flTestDocs:= False;
  SleepFillLinksInt:= 10;
end;
finalization
begin
  prFree(VSMail);
  prFree(CheckDocsList);
  SaveToLog:= [];
end;
//******************************************************************************

end.

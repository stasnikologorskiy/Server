unit n_DataCacheInMemory;

interface

uses Windows, Classes, Types, SysUtils, Math, DateUtils, IniFiles, Forms, SyncObjs, Variants, Contnrs,
     IBDataBase, IBSQL, n_free_functions, v_constants, n_DataCacheAddition,
     n_constants, n_Functions, n_DataSetsManager, n_server_common, n_DataCacheObjects;

type                                            // проверяем длину массивов
  TArrayKind = (taWare, taDprt, taEmpl, taFirm, taClie, taCurr, taFtyp, taFcls);
// признаки TWareInfo - группа, подгруппа, товар, тип товара, признак заданного типа товара (1 байт)
  TKindBoolOptW = (ikwGrp, ikwPgr, ikwWare, ikwType, ikwTop, ikwFixT, ikwMod1, ikwMod2,
    ikwNRet, ikwCatP, ikwPriz{, ikwAuto, ikwMoto, ikwMotul});
  TFirmManagerParam = (fmpCode, fmpName, fmpEmail, fmpShort, fmpPref, fmpFacc);
  TFirmManagerParams = set of TFirmManagerParam;
  //---------------------------------------------------------- линк для аналогов
  TAnalogLink = Class (TLink)
  public
    constructor Create(pSrcID: Integer; pWarePtr: Pointer; pAnalog, pCross: Boolean);
    property IsOldAnalog: boolean index ik8_3 read GetLinkBool write SetLinkBool; // признак аналога Гроссби
    property IsCross : boolean index ik8_4 read GetLinkBool write SetLinkBool; // признак аналога Гроссби
  end;

//---------------------------------------------------------------- система учета
  TSysItem = Class (TBaseDirItem)
  private
    FSysEmplID: Integer;
    FSysMail  : String;
    FSysSuffix: String;
  public
    constructor Create(pID: Integer; pName, pSysMail: String);
    property SysEmplID: Integer read FSysEmplID write FSysEmplID; // EmplID ответственного по системе учета
    property SysMail  : String  read FSysMail   write FSysMail;   // Email для сообщений по системе учета
    property SysSuffix: String  read FSysSuffix write FSysSuffix; // суффикс для файлов Влад по системам
  end;

//------------------------------------------------------------------------ бренд
  TBrandItem = Class (TBaseDirItem)
  private
    FWarePrefix, FNameWWW, FadressWWW: String;
    FTDMFcodes: Tai;
  public
    constructor Create(pID: Integer; pName: String);
    destructor Destroy; override;
    property WarePrefix: String read FWarePrefix write FWarePrefix; // префикс бренда у товаров Grossbee
    property NameWWW   : String read FNameWWW    write FNameWWW;    // Наименование для файла логотипа
    property adressWWW : String read FadressWWW  write FadressWWW;  // адрес - ссылка на сайт
    property TDMFcodes : Tai    read FTDMFcodes; // список кодов TecDoc (TDT -> DATA_SUPPLIERS.DS_MF_ID)
    property DownLoadExclude: boolean index ik8_2 read GetDirBool write SetDirBool;
  end;

//----------------------------------------------------------------------- валюты
  TCurrency = Class (TBaseDirItem) // FName - shortname
  private
    FCurrRate: Single;
    FCliName : String;
  public
    constructor Create(pID: Integer; pName, pCliName: String; pRate: Single; pArh: Boolean);
    property Arhived  : boolean index ik8_3 read GetDirBool write SetDirBool; // признак архивности
//    property Available: boolean index ik8_4 read GetDirBool write SetDirBool; // признак применимости
    property CurrRate : Single read FCurrRate write FCurrRate;                // курс к гривне
    property CliName  : String read FCliName  write FCliName;                 // наименование в СВК для клиентов
  end;

  TCurrencies = Class (TDirItems)  // справочник валют
  private
    function GetCurrency(pCurrID: Integer): TCurrency; // получить элемент справочника по коду
  public
    function GetCurrRate(pCurrID: Integer): Single;                         // получить курс валюты к гривне
    property DirItems[index: Integer]: TCurrency read GetCurrency; default; // получить элемент справочника по коду
  end;

//------------------------------------------------------------- группы атрибутов
  TAttrGroupItem = Class (TDirItem) // 1 группа атрибутов
  private // в Links -  Список атрибутов группы
    FTypeSys : Byte;   // Тип системы 1 - Авто, 2 - Мото and etc.
    FOrderNum: Word;   // порядковый номер группы для вывода
  public
    constructor Create(pID, pTypeSys: Integer; pName: String; pOrderNum: Word=0);
    property TypeSys : Byte read FTypeSys;  // Тип системы 1 - Авто, 2 - Мото and etc.
    property OrderNum: Word read FOrderNum; // порядковый номер
    function GetListGroupAttrs: TList;      // must Free, Список ссылок на атрибуты группы, сортир. по порядк.№ +наимен.
  end;

  TAttrGroupItems = Class (TDirItems)  // справочник групп атрибутов
  private
    FTypeSysLists: TArraySysTypeLists; // набор сортированных списков групп по системам
  public
    constructor Create(LengthStep: Integer=10);
    destructor Destroy; override;
    procedure SortTypeSysList(SysID: Word=0);                   // сортируем список групп атрибутов (SysID=0 - все)
    function GetListAttrGroups(pTypeSys: Integer): TStringList; // Получить Список групп системы, сортированный по наименованию
    function GetAttrGroup(grpID: Integer): TAttrGroupItem;      // Получить группу  по коду
  end;

//--------------------------------------------------------------------- атрибуты
  TAttributeItem = Class (TSubDirItem) // 1 атрибут
  private // FSubCode - Код группы, FOrderNum - порядковый номер атрибута для вывода
    FTypeAttr  : Byte;        // Тип
    FPrecision : Byte;        // кол-во знаков после запятой в типе Double
    FListValues: TStringList; // Список доступных значений атрибута
//    function GetAttrTypeSys: Byte; // получить систему атрибута
  public
    constructor Create(pID, pGroupID: Integer; pPrecision, pType: Byte;
                pOrderNum: Word; pName: String; pSrcID: Integer=0);
    destructor Destroy; override;
    property TypeAttr  : Byte        read FTypeAttr;   // Тип
    property Precision : Byte        read FPrecision;  // кол-во знаков после запятой в типе Double
    property ListValues: TStringList read FListValues; // Список значений атрибута с сортировкой в зав-ти от типа
    procedure CheckAttrStrValue(var pValue: String);   // проверяем корректность значения для атрибута
  end;

  TAttributeItems = Class (TDirItems)  // Справочник атрибутов
  private
    FAttrValues: TDirItems; // Справочник значений атрибутов
  public
    constructor Create(LengthStep: Integer=10);
    destructor Destroy; override;
    function GetListAttrsOfGroup(pGrpID: Integer): TStringList; // must Free, Список ссылок на атрибуты группы, сортир. по порядк.№ +наимен.
    function GetAttr(attrID: Integer): TAttributeItem;          // получить атрибут по коду
  end;

//------------------------------------------------------------------ склад фирмы
  TStoreInfo = class (TBaseDirItem)
  private // FID - код склада
    function GetDprtCode: string; // код склада символьный
  public
    property DprtID   : Integer read FID write FID;
    property DprtCode : string  read GetDprtCode; // код склада символьный
    property IsVisible: boolean index ik8_2 read GetDirBool write SetDirBool;
    property IsReserve: boolean index ik8_3 read GetDirBool write SetDirBool;
    property IsSale   : boolean index ik8_4 read GetDirBool write SetDirBool;
    property IsDefault: boolean index ik8_5 read GetDirBool write SetDirBool;
    property IsAddVis : boolean index ik8_6 read GetDirBool write SetDirBool;
//    property IsAccProc: boolean index ik8_6 read GetDirBool write SetDirBool;
  end;
  TarStoreInfo = array of TStoreInfo;

//--------------------------------------------------------------- метод отгрузки
  TShipMethodItem = Class (TBaseDirItem)
  private // FID - Код, State- Статус проверки, FName - Наименование
  public
    constructor Create(pID: Integer; pName: String; pTimeKey: Boolean=False; pLabelKey: Boolean=False);
    property TimeKey : boolean index ik8_2 read GetDirBool write SetDirBool; // признак наличия времени отгрузки
    property LabelKey: boolean index ik8_3 read GetDirBool write SetDirBool; // признак наличия наклейки
  end;

//--------------------------------------------------------------- время отгрузки
  TShipTimeItem = Class (TBaseDirItem)
  private // FID - Код, State- Статус проверки, FName - Наименование
    FHour, FMinute: Byte;   // часы, минуты
  public
    constructor Create(pID: Integer; pName: String; pHour: Byte=0; pMinute: Byte=0);
    property Hour  : Byte read FHour   write FHour;   // часы
    property Minute: Byte read FMinute write FMinute; // минуты
//    property SelfGetAllow: boolean index ik8_2 read GetDirBool write SetDirBool; // признак доступности самовывоза
  end;

//------------------------------------------------------------------ уведомление
  TNotificationItem = Class (TBaseDirItem)
  private // FID - Код, FName - текст, State- Статус проверки
    FBegDate, FEndDate: TDateTime;
    FFirmFilials, FFirmClasses, FFirmTypes, FFirms: TIntegerList;
    function GetDateN(const ik: T8InfoKinds): TDateTime;         // получить дату
    procedure SetDateN(const ik: T8InfoKinds; Value: TDateTime); // записать дату
    function GetIntListN(const ik: T8InfoKinds): TIntegerList;   // получить список кодов
  public
    constructor Create(pID: Integer; pText: String);
    destructor Destroy; override;
    procedure CheckConditions(sFil, sClas, sTyp, sFirm: String); // проверить условия фильтрации
    property BegDate: TDateTime index ik8_1 read GetDateN write SetDateN; // дата начала
    property EndDate: TDateTime index ik8_2 read GetDateN write SetDateN; // дата окончания
    property FirmFilials: TIntegerList index ik8_1 read GetIntListN;      // коды филиалов к/а
    property FirmClasses: TIntegerList index ik8_2 read GetIntListN;      // коды категорий к/а
    property FirmTypes  : TIntegerList index ik8_3 read GetIntListN;      // коды типов к/а
    property Firms      : TIntegerList index ik8_4 read GetIntListN;      // коды к/а
    property flFirmAdd  : boolean index ik8_3 read GetDirBool write SetDirBool; // флаг - добавлять/исключать коды arFirms
    property flFirmAuto : boolean index ik8_4 read GetDirBool write SetDirBool; // флаг рассылки к/а с авто-контрактами
    property flFirmMoto : boolean index ik8_5 read GetDirBool write SetDirBool; // флаг рассылки к/а с мото-контрактами
  end;

  TNotifications = Class (TDirItems)  // Справочник уведомлений
    function GetNotification(pID: integer): TNotificationItem;
  public
    function GetFirmNotifications(FirmID: integer): TIntegerList; // must Free, список уведомлений фирмы
    property Items[pID: integer]: TNotificationItem read GetNotification; default;
  end;

//---------------------------------------------------------------- подразделение
  TDprtInfo = class (TSubDirItem)
  private // FID, FName, State - код и наименование подразделения, признак проверки
          // FOrderNum - MasterCode, FSubCode - код филиала, FLinks - список связок с методами отгрузки
    FDelayTime: Integer;
    FShort   : string;
    FSubName : string;   // Email счетов (на филиале) или заголовок колонки (на складе)
    FSchedule: TObjectList; // графики работы на заданное кол-во дней, 0- Date(), 1- Date()+1 и т.д.
                            // Object - TTwoCodes, время начала и окончания в сек
    function GetStrD(const ik: T8InfoKinds): String;         // получить строку
    procedure SetStrD(const ik: T8InfoKinds; Value: String); // записать строку
    function GetIntD(const ik: T8InfoKinds): integer;         // получить число
    procedure SetIntD(const ik: T8InfoKinds; Value: integer); // записать число
    procedure SetFilialID(pID: integer);
  public
    constructor Create(pID, pSubCode, pOrderNum: Integer; pName: String;
                       pSrcID: Integer=0; WithLinks: Boolean=False);
    destructor Destroy; override;
    function IsInGroup(pGroup: Integer): Boolean; // признак вхождения в заданную группу
    function CheckShipAvailable(pShipDate: TDateTime; stID: Integer=0;  // признак доступности отгрузки
             WithSVKDelay: Boolean=False; WithSchedule: Boolean=False): String;
    function GetShipTimeLimits(pShipDate: TDateTime; var TimeMin, TimeMax: Integer; // границы времен отгрузки на дату
                                flWithSVKDelay: Boolean=False): String;
    property ParentID    : Integer index ik8_1 read GetIntD    write SetIntD;    // MasterCode
    property FilialID    : Integer index ik8_2 read GetIntD    write SetIntD;    // код филиала
    property DelayTime   : Integer index ik8_3 read GetIntD    write SetIntD;    // время запаздывания в мин
    property MainName    : string  index ik8_1 read GetStrD    write SetStrD;
    property ShortName   : string  index ik8_2 read GetStrD    write SetStrD;
    property ColumnName  : string  index ik8_3 read GetStrD    write SetStrD;    // заголовок колонки (на складе)
    property MailOrder   : string  index ik8_4 read GetStrD    write SetStrD;    // Email счетов (на филиале)
    property FilialName  : string  index ik8_5 read GetStrD;
    property IsStoreHouse: boolean index ik8_3 read GetDirBool write SetDirBool; // признак склада
    property IsFilial    : boolean index ik8_4 read GetDirBool write SetDirBool; // признак филиала
    property IsStoreRoad : boolean index ik8_5 read GetDirBool write SetDirBool; // признак - склад-путь
    property IsFilOnlyErr: boolean index ik8_6 read GetDirBool write SetDirBool; // признак - филиал - отправлять только письма о счетах с ошибками
    property ShipLinks   : TLinks read FLinks;  // список связок с методами отгрузки
    property Schedule    : TObjectList read FSchedule; // графики работы на заданное кол-во дней
  end;

//--------------------------------------------------- товар / группа / подгруппа
  TInfoWareOpts = class (TObject) // параметры собственно товара (нужны для всех, в т.ч. ИНФО-группы)
    FManagerID  : Integer; // код менеджера (EMPLCODE)
    FTypeID     : Integer; // код типа товара
    FProdDirect : Integer; // Направление по продуктам
    FmeasID     : Byte;    // код ед.изм.
    FNameBS     : String;  // наименование товара б/спецсимволов
    FCommentUP  : String;  // описание товара в верхнем регистре
    FWareSupName: String;  // Наименование товара от поставщика
    FArticleTD  : String;  // Article TecDoc
    FMainName   : String;  // WAREMAINNAME
    FAnalogLinks: TLinks;  // связки с аналогами
    FONumLinks  : TLinkList; // связки с оригинальными номерами
    constructor Create(CS: TCriticalSection);
    destructor Destroy; override;
  end;

  TWareOpts = class (TObject) // параметры собственно товара (не нужны для ИНФО-группы)
    Fdivis     : Single;          // кратность
    FPrices    : TSingleDynArray; // массив розн.цен в евро в соотвествии с PriceTypes
//    FSLASHCODE : String;        // WARESLASHCODE
    FModelLinks: TLinkList;       // связки с моделями
//    FAutoVisModelsManufs, FMotoVisModelsManufs: TIntegerList; // коды произв.авто/мото из FModelLinks
    FFileLinks : TLinks;          // связки с файлами рисунков
    FAttrLinks : TLinks;          // связки с атрибутами и их значениями
    FRestLinks : TLinks;          // связки с остатками по складам
    FSatelLinks: TLinks;          // связки с сопутствующими товарами

//    FArSysAttrs: array of TLinkList; // связки с атрибутами и их значениями по системам
//    FAttrGrCodes: TIntegerList;       // коды групп атрибутов
//    FGrAttrLinks: array of TLinkList; // связки с атрибутами и их значениями по группам

    constructor Create(CS: TCriticalSection);
    destructor Destroy; override;
  end;

  TWareInfo = class (TSubVisDirItem)
  private // FID, FName - код и наименование товара/группы/подгруппы, FOrderNum - код бренда товара
          // State - признак проверки параметров, FSubCode - SupID TecDoc (DS_MF_ID !!!)
          // FParCode - код верхнего уровня товара/группы/подгруппы
    FComment     : String;               // описание товара/группы/подгруппы
    FWareBoolOpts: set of TKindBoolOptW; // признаки товара/группы/подгруппы
    FInfoWareOpts: TInfoWareOpts;        // параметры собственно товара (нужны для всех товаров, в т.ч. ИНФО-группы)
    FWareOpts    : TWareOpts;            // параметры собственно товара (не нужны для ИНФО-группы)
    FDiscModLinks: TLinkList;            // связки с шаблонами скидок
    function GetIntW(const ik: T16InfoKinds): Integer;              // получить код
    procedure SetIntW(const ik: T16InfoKinds; Value: Integer);      // записать код
    function GetStrW(const ik: T16InfoKinds): String;               // получить строку
    procedure SetStrW(const ik: T16InfoKinds; Value: String);       // записать строку
    function GetBoolW(const Index: TKindBoolOptW): boolean;         // получить признак
    procedure SetBoolW(const Index: TKindBoolOptW; Value: boolean); // записать признак
    function GetDoubW(const ik: T8InfoKinds): Single;              // получить вещ.значение
    procedure SetDoubW(const ik: T8InfoKinds; Value: Single);      // записать вещ.значение
    function GetWareLinks(const ik: T8InfoKinds): TLinks;        // получить связки
    function GetWareLinkList(const ik: T8InfoKinds): TLinkList;  // получить связки
    procedure CheckPrice(price: Single; pTypeInd: Integer); // записать / проверить розничную цену товара в евро по прайсу

  protected
    procedure SetName(const Value: String); override; // записать FName, FNameBS
  public
    CS_wlinks: TCriticalSection;     // для изменения линков и аналогов
    constructor Create(pID, ParentID: Integer; pName: String);
    destructor Destroy; override;
    function RetailTypePrice(pTypeInd: Integer; currcode: Integer=cDefCurrency): double; // розничная цена товара по прайсу
    procedure GetFirmDiscAndPriceIndex(FirmID: Integer; var ind: Integer; // получить скидки и индекс прайса фирмы
              var disc, disNext: double; contID: Integer=0);
    function RetailPrice(FirmID: Integer=IsWe; currcode: Integer=cDefCurrency; contID: Integer=0): double;  // розничная цена товара для фирмы
    function SellingPrice(FirmID: Integer=IsWe; currcode: Integer=cDefCurrency; contID: Integer=0): double; // продажная цена товара для фирмы
    function MarginPrice(FirmID: Integer=IsWe; UserID: Integer=0;  // цена товара с наценкой (% к продажной) для клиента
             currcode: Integer=cDefCurrency; contID: Integer=0): double;
    function CalcFirmPrices(FirmID: Integer=IsWe; currID: Integer=cDefCurrency; // must Free, цены товара по фирме, контракту
                           contID: Integer=0): TDoubleDynArray;

    function CheckWareTypeSys(TypeSysID: Integer): Boolean;               // Проверка принадлежности к системе AUTO / MOTO
//    procedure SetWareTypeSys(pTypeSys: Integer; IsSys: Boolean=False);    // Установить / снять принадлежность системе
    procedure SetWareParams(pPgrID: Integer; ibs: TIBSQL; fromGW: Boolean=False); // заполнить параметры товара из Grossbee
    function GetSysModels(pSys: Integer; pMfau: Integer=0): TList; // must Free, TList видим.моделей системы по товару (Object - TModelAuto), сортировка - произв. + м.р. + порядк.№ + наименование
    function SysModelsExists(pSys: Integer): Boolean;              // признак наличия видим.моделей системы по товару
    function CheckHasModels(pSys: Integer): Boolean;               // проверка признака наличия видим.моделей системы по товару
    function GetWareAttrValuesView: TStringList;                   // must Free, список значений атрибутов товара для просмотра
    function GetWareAttrValuesByCodes(AttCodes: Tai): TStringList; // must Free, список значений атрибутов товара по кодам в нужном порядке
    function GetWareCriValuesView(SysID: Integer=0): TStringList;  // must Free, список значений критериев товара для просмотра
    procedure ClearOpts;                                           // очистка связей (удаление при проверке)
    function CheckArticleLink(pArticle: String; pSupID: Integer;   // Установить / снять связь с артиклем TecDoc
             var ResCode: Integer; userID: Integer=0; flDelInfo: Boolean=True): String;
    function GetWareFiles: TarWareFileOpts;                        // набор параметров файлов рисунков товара
    function CheckAnalogLink(AnalogID: Integer;   // добавить линк с аналогом/кроссом (def - аналог Гроссби)
             pSrcID: Integer=soGrossBee; pCross: Boolean=True): Boolean;
    procedure DelAnalogLink(AnalogID: Integer;  pCross: Boolean=False); // удалить из кеша линк с аналогом/кроссом (def - аналог Гроссби)
    procedure SetAnalogLinkSrc(AnalogID, src: Integer);                 // заменить в кеше источник линка с аналогом/кроссом
    procedure DelNotTestedAnalogs(pCross: Boolean=False; pDel: Boolean=False); // удалить из кеша непроверенные линки с аналогами/кроссами
    procedure SortAnalogsByName;  // сортировка аналогов по наименованию
    function GetSrcAnalogs(ShowKind: Integer=-1): TObjectList; // must Free, список кодов аналогов с источниками, Objects - TTwoCodes(wareID, link.SrcID)
    function Analogs: Tai;                                     // must Free, массив кодов аналогов товара
    function FindOriginalNum(ONumID, mfauID: Integer; OrigNum: String): Boolean; // Поиск оригинального номера в списке ор.номеров товара
    procedure SortOrigNumsWithSrc(var arCodes, arSrc: Tai);
    function IsMarketWare(FirmID: Integer=IsWe; contID: Integer=0): Boolean; // признак товара для продажи с проверкой сответствия бизнес-направлению фирмы
    function IsSysMarketWare(sysID: Integer=0): Boolean;  // признак товара для продажи с проверкой сответствия бизнес-направлению
    function GetAnalogTypes(WithoutEmpty: Boolean=False): Tai; // must Free, массив кодов типов аналогов
    function GetSatellites(pTypeSys: Integer=0): Tai;          // must Free, массив кодов сопут.товаров
    function SatelliteExists(pTypeSys: Integer=0): Boolean;    // признак наличия сопут.товаров

    property GrpID        : Integer index ik16_1   read GetIntW;                     // код группы
    property AttrGroupID  : Integer index ik16_2   read GetIntW;                     // код группы атрибутов
    property ManagerID    : Integer index ik16_3   read GetIntW    write SetIntW;    // код менеджера (EMPLCODE)
    property ArtSupTD     : Integer index ik16_4   read GetIntW    write SetIntW;    // SupID TecDoc (DS_MF_ID !!!)
    property PgrID        : Integer index ik16_5   read GetIntW    write SetIntW;    // код подгруппы
    property WareBrandID  : Integer index ik16_6   read GetIntW    write SetIntW;    // код бренда товара
    property measID       : Integer index ik16_7   read GetIntW    write SetIntW;    // код ед.изм.
    property TypeID       : Integer index ik16_8   read GetIntW    write SetIntW;    // код типа товара
    property ProdDirect   : Integer index ik16_9   read GetIntW    write SetIntW;    // Направление по продуктам

    property IsGrp        : boolean index ikwGrp  read GetBoolW   write SetBoolW;   // признак группы
    property IsPgr        : boolean index ikwPgr  read GetBoolW   write SetBoolW;   // признак подгруппы
    property IsWare       : boolean index ikwWare read GetBoolW   write SetBoolW;   // признак товара
    property IsType       : boolean index ikwType read GetBoolW   write SetBoolW;   // признак типа товара
    property IsTop        : boolean index ikwTop  read GetBoolW   write SetBoolW;   // признак ТОП-товара
    property HasFixedType : boolean index ikwFixT read GetBoolW;                    // признак заданного типа товара
    property HasModelAuto : boolean index ikwMod1 read GetBoolW   write SetBoolW;   // признак применимости к моделям Auto
    property HasModelMoto : boolean index ikwMod2 read GetBoolW   write SetBoolW;   // признак применимости к моделям Moto
    property IsNonReturn  : boolean index ikwNRet read GetBoolW   write SetBoolW;   // признак невозврата
    property IsCutPrice   : boolean index ikwCatP read GetBoolW   write SetBoolW;   // признак уценки
    property IsPrize      : boolean index ikwPriz read GetBoolW   write SetBoolW;   // признак можно ли продавать за бонусы
    property ModelsSorting: boolean index ik8_3   read GetDirBool write SetDirBool; // признак сортировки моделей
    property IsArchive    : boolean index ik8_4   read GetDirBool write SetDirBool; // признак архивного товара
    property IsSale       : boolean index ik8_5   read GetDirBool write SetDirBool; // признак распродажи
    property IsINFOgr     : boolean index ik8_6   read GetDirBool write SetDirBool; // признак ИНФО-группы
    property IsAUTOWare   : boolean index ik8_7   read GetDirBool write SetDirBool; // признак товара AUTO
    property IsMOTOWare   : boolean index ik8_8   read GetDirBool write SetDirBool; // признак товара MOTO
//    property IsPrDirAUTO  : boolean index ikwAuto  read GetBoolW; // признак товара AUTO
//    property IsPrDirMOTO  : boolean index ikwMoto  read GetBoolW; // признак товара MOTO
//    property IsPrDirMOTUL : boolean index ikwMotul read GetBoolW; // признак товара MOTUL

    property divis        : Single  index ik8_1   read GetDoubW  write SetDoubW; // кратность
//    property SLASHCODE    : string  index ik16_1  read GetStrW  write SetStrW;   // WARESLASHCODE
    property WareSupName  : String  index ik16_2  read GetStrW   write SetStrW;  // Наименование товара от поставщика
    property Comment      : string  index ik16_4  read GetStrW   write SetStrW;  // описание товара
    property ArticleTD    : string  index ik16_10 read GetStrW   write SetStrW;  // Article TecDoc
    property MainName     : string  index ik16_15 read GetStrW   write SetStrW;  // WAREMAINNAME
    property NameBS       : string  index ik16_3  read GetStrW;                  // наименование товара б/спецсимволов
    property CommentUP    : string  index ik16_5  read GetStrW;                  // описание товара в верхнем регистре
    property BrandNameWWW : String  index ik16_6  read GetStrW;                  // наименование для файла логотипа бренда
    property BrandAdrWWW  : String  index ik16_14 read GetStrW;                  // адрес для ссылки на сайт бренда
    property WareBrandName: string  index ik16_7  read GetStrW;                  // наименование бренда товара
    property MeasName     : string  index ik16_8  read GetStrW;                  // наименование ед.изм.
    property PgrName      : string  index ik16_9  read GetStrW;                  // наименование подгруппы
    property GrpName      : string  index ik16_11 read GetStrW;                  // наименование группы
    property TypeName     : string  index ik16_12 read GetStrW;                  // наименование типа товара
    property CommentWWW   : string  index ik16_13 read GetStrW;                  // описание товара для Web с учетом типа товара
    property PrDirectName : string  index ik16_16 read GetStrW;                  // наименование направления по продуктам

    property ONumLinks    : TLinkList index ik8_1 read GetWareLinkList;          // связки с оригинальными номерами (товар)
    property ModelLinks   : TLinkList index ik8_2 read GetWareLinkList;          // связки с моделями
    property DiscModLinks : TLinkList index ik8_3 read GetWareLinkList;          // связки с шаблонами скидок (группа/подгруппа)
    property FileLinks    : TLinks    index ik8_1 read GetWareLinks;             // связки с файлами рисунков
    property AttrLinks    : TLinks    index ik8_2 read GetWareLinks;             // связки с атрибутами и их значениями
    property RestLinks    : TLinks    index ik8_3 read GetWareLinks;             // связки со складами и остатками
    property AnalogLinks  : TLinks    index ik8_4 read GetWareLinks;             // связки с аналогами        (товар)
    property SatelLinks   : TLinks    index ik8_5 read GetWareLinks;             // связки с сопутствующими товарами
  end;

//----------------------------------------------------- группы/подгруппы наценок
// в TLinks - TLinkLink: LinkPtr- ссылка на группу(TWareInfo), State- признак проверки группы,
// в DoubleLinks - TLink: LinkPtr- ссылка на подгруппу(TWareInfo), State- признак проверки подгруппы
  TMarginGroups = class (TLinkLinks)
  private
  public
    function GetWareGroup(grID: integer): TWareInfo;                 // получить TWareInfo группы
    function GetWareSubGroup(grID, pgrID: integer): TWareInfo;       // получить TWareInfo подгруппы
    function GroupExists(grID: integer): Boolean;                    // проверка существования группы
    function SubGroupExists(grID, pgrID: integer): Boolean;          // проверка существования подгруппы в группе
    function CheckGroup(grID: integer; SortAdd: Boolean=False): Boolean;           // проверить/добавить группу
    function CheckSubGroup(grID, pgrID: integer; SortAdd: Boolean=False): Boolean; // проверить/добавить подгруппу
    function GetGroupList(TypeSys: Integer=constIsAuto): TList;                   // must Free, список ссылок на группы по системе
    function GetSubGroupList(grID: integer; TypeSys: Integer=constIsAuto): TList; // must Free, список ссылок на подгруппы в группе по системе
    procedure SortByName(grID: integer=0);                                        // сортирует связк с группами/подгруппами по имени
    procedure SetLinkStatesAll(pState: Boolean);                                  // устанавливает флаг проверки всем связкам
    procedure DelNotTestedLinksAll;                                               // удаляет все связки с State=False
  end;

//--------------------------------------- ЦФУ (Grossbee->FISCALACCOUNTINGCENTER)
  TFiscalCenter = class (TBaseDirItem)
  private // FID - FACCCODE, FName - FACCNAME, State - признак проверки
    FParent: Integer; // FACCMASTERCODE
    function GetRegion: Integer;   // номер округа (вычисляется по наименованию)
    function GetSaleType: Integer; // продажи AUTO/MOTO
    function GetROPfacc: Integer; // код ЦФУ РОП-а округа
    function CheckIsROPFacc: Boolean;  // признак ЦФУ РОП-а округа (вычисляется по наименованию)
  public
    BKEempls: TIntegerList;        // сотрудники
    constructor Create(pID, pParent: Integer; pName: String);
    destructor Destroy; override;
    property Parent    : Integer read FParent write FParent;
    property Region    : Integer read GetRegion;
    property ROPfacc   : Integer read GetROPfacc;
    property LastLevel : boolean index ik8_2 read GetDirBool write SetDirBool; // признак нижнего уровня
    property IsAutoSale: boolean index ik8_3 read GetDirBool write SetDirBool; // ветка продажи AUTO
    property IsMotoSale: boolean index ik8_4 read GetDirBool write SetDirBool; // ветка продажи MOTO
  end;

  TEmplInfoItem = class;

//----------------------------------------------------- торговая точка контракта
  TDestPoint = class (TBaseDirItem)
  private // FID - id, FName - название, State - признак проверки
    FAdress: String; // адрес
  public
    constructor Create(pID: Integer; pName, pAdress: String);
    property Adress: String read FAdress write FAdress; // адрес
  end;

//------------------------------------------------ контракт (Grossbee->CONTRACT)
  TContract = class (TSubDirItem)
  private // FID - CONTCODE, FName - CONTNUMBER, State - признак проверки,
          // FSubCode - CONTSECONDPARTY  (CONTFIRSTPARTY - ?)
          // FOrderNum - код склада по умолчанию, // FSrcID - ContBusinessTypeCode - убрать
    FContSumm, FCredLimit, FDebtSum, FOrderSum, FPlanOutSum: Single; // CONTSUMM, ContCreditLimit ...
    FContEmail, FWarnMessage: String;                 // ContSecondEMAIL
    // ..., CONTCRNCCODE, ContCreditCrncCode, ContContDelay, CONTDUTYCRNCCODE
    FWhenBlocked, FCurrency, FCredCurrency, FCredDelay, FDutyCurrency, FPayType: Word;
    FContManager, FFacCenter, FContPriceType, FLegalEntity: Integer;
    function GetIntFC(const ik: T16InfoKinds): Integer;          // получить код
    procedure SetIntFC(const ik: T16InfoKinds; Value: Integer);  // записать код
    function GetDoubFC(const ik: T8InfoKinds): Single;           // получить вещ.значение
    procedure SetDoubFC(const ik: T8InfoKinds; Value: Single);   // записать вещ.значение
    function GetStrFC(const ik: T8InfoKinds): String;            // получить строку
    procedure SetStrFC(const ik: T8InfoKinds; Value: String);    // записать строку
    function GetContManager: Integer;                            // код первого менеджера контракта
    function GetContFaccName: String;                            // наименование ЦФУ
    function GetContFaccParent: Integer;                         // код верхнего ЦФУ
    function GetContFaccParentName: String;                      // наименование верхнего ЦФУ
  public
    ContProcDprts : Tai;                 // коды складов обработки счетов контракта // PartiallyFilled
    ContStorages  : TarStoreInfo;        // склады контракта                        // PartiallyFilled
    ContDestPoints: TObjectList;         // торговые точки контракта, Object - TDestPoint
    CS_cont       : TCriticalSection;    // для изменения параметров
    constructor Create(pID, pFirmCode, pSysID: Integer; pNumber: String);
    destructor Destroy; override;
    procedure TestStoreArrayLength(kind: TArrayKind; len: integer; // проверяем длину массивов складов
              ChangeOnlyLess: boolean=True; inCS: boolean=True);
    function FindContManager(var Empl: TEmplInfoItem): boolean;  // поиск менеджера контракта
    function CheckContManager(emplID: Integer): Boolean;         // проверка менеджера контракта
    function GetContBKEempls: TIntegerList; // not Free !!!, коды менеджеров контракта по ЦФУ
    function GetСontStoreIndex(StorageID: integer): integer; // возвращает индекс склада в массиве ContStorages
    function GetContDestPoint(destID: integer): TDestPoint;  // получить торг.точку по коду

    property ContFirm      : integer index ik16_1  read GetIntFC   write SetIntFC;
    property ContCurrency  : integer index ik16_2  read GetIntFC   write SetIntFC;   // валюта контракта
    property DutyCurrency  : integer index ik16_3  read GetIntFC   write SetIntFC;
//    property SysID         : integer index ik16_4  read GetIntFC   write SetIntFC;   // система учета
    property WhenBlocked   : integer index ik16_5  read GetIntFC   write SetIntFC;
    property CredDelay     : integer index ik16_6  read GetIntFC   write SetIntFC;
    property CredCurrency  : integer index ik16_7  read GetIntFC   write SetIntFC;
    property MainStorage   : integer index ik16_8  read GetIntFC   write SetIntFC;   // код склада по умолчанию   // PartiallyFilled
    property Manager       : integer index ik16_9  read GetIntFC;                    // код первого менеджера     // PartiallyFilled
    property Filial        : integer index ik16_10 read GetIntFC;                    // код филиала (по главному складу)
    property FacCenter     : integer index ik16_11 read GetIntFC   write SetIntFC;   // код ЦФУ                   // PartiallyFilled
    property PayType       : integer index ik16_12 read GetIntFC   write SetIntFC;   // тип оплаты: 0- нал, 1- безнал, 2- по вал.док-та                  // PartiallyFilled
    property FaccParent    : integer index ik16_13 read GetIntFC;                    // код верхнего ЦФУ          // PartiallyFilled
    property ContPriceType : integer index ik16_14 read GetIntFC   write SetIntFC;   // код прайса
    property LegalEntity   : integer index ik16_15 read GetIntFC   write SetIntFC;   // код юрид.фирмы            // PartiallyFilled

    property ContSumm      : Single  index ik8_1   read GetDoubFC  write SetDoubFC;
    property CredLimit     : Single  index ik8_2   read GetDoubFC  write SetDoubFC;
    property DebtSum       : Single  index ik8_3   read GetDoubFC  write SetDoubFC;
    property OrderSum      : Single  index ik8_4   read GetDoubFC  write SetDoubFC;
    property PlanOutSum    : Single  index ik8_5   read GetDoubFC  write SetDoubFC;
    property ContDefault   : boolean index ik8_2   read GetDirBool write SetDirBool; // CONTUSEBYDEFAULT
    property EmptyInvoice  : boolean index ik8_3   read GetDirBool write SetDirBool; // накладные без цен
    property HasSubPrice   : boolean index ik8_4   read GetDirBool write SetDirBool; // признак наличия доп.прайса
    property SaleBlocked   : boolean index ik8_5   read GetDirBool write SetDirBool; // признак - отгрузка запрещена
    property Fictive       : boolean index ik8_6   read GetDirBool write SetDirBool; // признак - фиктивный
    property Disable       : boolean index ik8_7   read GetDirBool write SetDirBool; // признак - недоступен
    property HasAddVis     : boolean index ik8_8   read GetDirBool write SetDirBool; // признак - имеет склады доп.видимости
    property ContEmail     : string  index ik8_2   read GetStrFC   write SetStrFC;   // EMAIL (если нет - из arFirmInfo)
    property WarnMessage   : string  index ik8_3   read GetStrFC   write SetStrFC;
    property MainStoreStr  : string  index ik8_4   read GetStrFC;                    // код склада по умолчанию символьный
//    property SysName       : string  index ik8_5   read GetStrFC;                    // название системы учета
    property LegalFirmName : string  index ik8_5   read GetStrFC;                    // юрид.фирма
    property CredCurrStr   : string  index ik8_6   read GetStrFC;                    // CredCurrency символьный
    property FaccName      : string  index ik8_7   read GetStrFC;                    // наименование ЦФУ
    property FaccParentName: string  index ik8_8   read GetStrFC;                    // наименование верхнего ЦФУ
  end;

  TContracts = class (TDirItems)       //
  private
    function GetContract(pID: integer): TContract;
  public
    property Items[pID: integer]: TContract read GetContract; default;
  end;

//--------------------------------------------------------------- шаблоны скидок
  TDiscModel = Class (TBaseDirItem)
  private
    FDirectInd, FRating: Word;
    FSales: Integer;
    function GetIntDM(const ik: T8InfoKinds): Integer;          // целое значение
    procedure SetIntDM(const ik: T8InfoKinds; pValue: Integer); // записать целое значение
  public
    constructor Create(pID, pDirect, pRate, pSales: Integer; pName: String);
    destructor Destroy; override;
    property DirectInd: Integer   index ik8_1 read GetIntDM write SetIntDM; // индекс направления в FProdDirects
    property Rating   : Integer   index ik8_2 read GetIntDM write SetIntDM; // рейтинг
    property Sales    : Integer   index ik8_3 read GetIntDM write SetIntDM; // мин.оборот
  End;

  TDiscModels = Class (TObject)
  private
    FProdDirects: TStringList;
    FDiscModels: TObjectList;
    function GetDiscModel(pID: Integer): TDiscModel;          // шаблон
  public
    CS_DiscModels: TCriticalSection;
    EmptyModel: TDiscModel;
    constructor Create;
    destructor Destroy; override;
    property DmItems[index: Integer]: TDiscModel read GetDiscModel; default; // ссылка на элемент справочника по коду
    property ProdDirectList: TStringList read FProdDirects;   // направления
    property DiscModels    : TObjectList read FDiscModels;    // шаблоны
    procedure CheckProdDirect(pdID: Integer; pdName: String); // добавить/проверить направление
    procedure CheckDiscModel(dmID, pdID, pRate, pSales: Integer; dmName: String); // добавить/проверить шаблон
    procedure DelProdDirect(pdID: Integer);                   // удалить направление
    procedure DelDiscModel(dmID: Integer);                    // удалить шаблон
    procedure DelNotTestedDiscModels;                         // удалить лишние шаблоны
    function GetDirectModelsList(pdID: Integer): TList;       // список шаблонов направления
    function GetDirectModelsCount(pdID: Integer): Integer;    // кол-во шаблонов направления
    procedure SortDiscModels;                                 // сортировать шаблоны
    function GetDirectIndex(pdID: Integer): Integer;          // индекс направления
    function GetNextDirectModel(dmID: Integer): Integer;      // код следующего шаблона направления
  End;

//------------------------------------------------------------------------ фирма
  TFirmInfo = class (TSubDirItem)
  private // FID - FIRMCODE, FName - FIRMMAINNAME, State - признак проверки,
          // FSubCode - код , FLinks - , FOrderNum -  // PartiallyFilled
    FSUPERVISOR, FFirmType, FHostCode: integer;       // код гл.пользо., код типа, код для связи с наклейками // PartiallyFilled
    FContUnitOrd: integer;       // код контракта unit-заказа // PartiallyFilled
    FNUMPREFIX, FUPPERMAINNAME, FUPPERSHORTNAME, FActionText: string; // префикс фирмы клиента, ... // PartiallyFilled
    FFirmBoolOpts: set of T8InfoKinds; // признаки, которые не поместились в FDirBoolOpts
    FBonusQty: single; // кол-во бонусов контрагента
//    FLabelLinks: TLinks; // связки с наклейками
    function CheckFirmVINmail: boolean;         // проверка наличия WIN-запросов
    function CheckFirmPriceLoadEnable: boolean; // проверка разрешения скачивания прайса
    function GetStrF(const ik: T8InfoKinds): String;           // получить строку
    procedure SetStrF(const ik: T8InfoKinds; Value: String);   // записать строку
    function GetIntF(const ik: T8InfoKinds): Integer;          // получить код
    procedure SetIntF(const ik: T8InfoKinds; Value: Integer);  // записать код
    function GetBoolF(const ik: T8InfoKinds): boolean;         // получить признак
    function GetRegional: Integer;                             // получить код менеджера по def-контракту  // временно
  public
    LastTestTime, LastDebtTime: TDateTime;
    FirmClients  : Tai;                 // коды сотрудников фирмы               // PartiallyFilled
    FirmClasses  : TIntegerList;        // коды категорий фирмы                 // PartiallyFilled
    FirmContracts: TIntegerList;        // контракты фирмы                      // PartiallyFilled
    FirmManagers : TIntegerList;        // менеджеры фирмы                      // PartiallyFilled
//    FirmSysTypes : TIntegerList;        // системы учета фирмы                  // PartiallyFilled
    FirmDiscModels: TObjectList;        // действующие шаблоны скидок фирмы, Object - TTwoCodes:
                                        // код направления, код шаблона, текущий оборот к/а
    LegalEntities: TObjectList;         // юрид.фирмы к/а, Object - TBaseDirItem
    CS_firm      : TCriticalSection;    // для изменения параметров
    constructor Create(pID: Integer; pName: String);
    destructor Destroy; override;
//    function CheckSysType(pSysID: Integer): boolean;                         // проверка системы
    procedure TestFirmClients(codes: Tai; j: integer=0; inCS: boolean=True); // проверяем список сотрудников фирмы

    function CheckContract(contID: Integer): boolean;  // проверка принадлежности контракта фирме
    procedure SetContUnitOrd(contID: Integer);         // проверка/изменение контракта unit-заказа
    function GetContract(var contID: Integer): TContract; // получить контракт фирмы по коду
    function GetContracts: TStringList;                // must Free, получить список контрактов

    function GetDefContractID: Integer;                // получить код def-контракта
    function GetDefContract: TContract;                // получить def-контракт

    function CheckFirmManager(emplID: Integer): Boolean;         // проверка менеджера фирмы
    function CheckFirmRegion(regNum: Integer): Boolean;          // проверка региона фирмы
    function GetFirmManagersString(params: TFirmManagerParams=[fmpName, fmpShort]): String; // список систем/кодов/ФИО/Email-ов менеджеров фирмы (через запятую)

    function GetCurrentDiscModel(direct: Integer; var firmSales: Integer): TDiscModel; // текущие шаблон скидок и оборот по направлению

    property SUPERVISOR       : integer index ik8_2 read GetIntF    write SetIntF;    // код главного пользователя // PartiallyFilled
    property FirmType         : integer index ik8_3 read GetIntF    write SetIntF;
    property HostCode         : integer index ik8_4 read GetIntF    write SetIntF;    // код для связи с наклейками
    property ContUnitOrd      : integer index ik8_5 read GetIntF    write SetIntF;    // код контракта unit-заказа
    property Arhived          : boolean index ik8_2 read GetDirBool write SetDirBool;
    property PartiallyFilled  : boolean index ik8_3 read GetDirBool write SetDirBool;
    property HasVINmail       : boolean index ik8_4 read GetDirBool write SetDirBool; // признак наличия WIN-запросов
    property EnablePriceLoad  : boolean index ik8_5 read GetDirBool write SetDirBool; // признак разрешения скачивания прайса
    property SKIPPROCESSING   : boolean index ik8_6 read GetDirBool write SetDirBool; // сразу формировать счет // PartiallyFilled
    property Blocked          : boolean index ik8_7 read GetDirBool write SetDirBool; // признак блокировки фирмы в Weborderfirms
    property UPPERSHORTNAME   : string  index ik8_1 read GetStrF    write SetStrF;    // FIRMUPPERSHORTNAME     // PartiallyFilled
    property UPPERMAINNAME    : string  index ik8_2 read GetStrF    write SetStrF;    // FIRMUPPERMAINNAME      // PartiallyFilled
    property NUMPREFIX        : string  index ik8_3 read GetStrF    write SetStrF;    // префикс фирмы клиента  // PartiallyFilled
    property ActionText       : string  index ik8_4 read GetStrF    write SetStrF;    // состояние участия в акции
    property FirmTypeName     : string  index ik8_5 read GetStrF;                     // название типа фирмы
//    property LabelLinks       : TLinks read FLabelLinks;                            // связки с наклейками
    property BonusQty         : single  read FBonusQty write FBonusQty;               // кол-во бонусов контрагента

    property Regional         : integer read GetRegional;  // код менеджера по def-контракту // временно  fnRepWebArmSystemStatistic
    property IsAUTOFirm       : boolean index ik8_5 read GetBoolF;                    // признак фирмы АВТО  // ???
    property IsMOTOFirm       : boolean index ik8_6 read GetBoolF;                    // признак фирмы МОТО  // ???
/////////////////////////////////////////////
  end;

  TFirms = class (Tobject)       // заготовка
  private
    FarFirmInfo: Array of TFirmInfo;
    function GetFirm(pID: integer): TFirmInfo;
  public
    CS_firms: TCriticalSection; // для изменения параметров
    constructor Create;
    destructor Destroy; override;
    procedure CutEmptyCode;
    procedure AddFirm(pID: integer);
    function FirmExists(pID: Integer): Boolean;
    property Items[pID: integer]: TFirmInfo read GetFirm; default;
  end;

//-------------------------------------------------------- пользователь - клиент
  TClientInfo = class (TSubDirItem)  // FOrderNum - SearchCurrency, FSrcID - MaxRowShowAnalogs
  private // FID - PRSNCODE, FName - ФИО, State - признак проверки, FSubCode - код фирмы
    FCountSearch, FCountQty, FCountConnect, FLastContract, FBlockKind: integer;
    FDEFACCOUNTINGTYPE, FDEFDELIVERYTYPE: Byte;
    FLogin, FPassword, FSid, FPost: string; // логин, пароль, sid, должность // PartiallyFilled
//    FMail, FPhone: string;                 // Email, телефоны // PartiallyFilled
    function GetStrC(const ik: T8InfoKinds): String;               // получить строку
    procedure SetStrC(const ik: T8InfoKinds; Value: String);       // записать строку
    function GetIntC(const ik: T16InfoKinds): Integer;              // получить код
    procedure SetIntC(const ik: T16InfoKinds; Value: Integer);      // записать код
    procedure UpdateStorageOrderC; // проверяет соответствие набора складов клиента набору видимых складов контракта
  public
    TestSearchCountDay, LastTestTime, LastCountQtyTime, LastCountConnectTime,
      LastBaseAutorize, LastAct: TDateTime;
//    LastPriceLoadTime: TDateTime; // время последнего скачивания прайса
    TmpBlockTime: TDateTime;          // время окончания временной блокировки
    CliContracts: TIntegerList;       // коды контрактов клиента                      // PartiallyFilled
//    CliContStores: TObjectList;       // склады клиента по контрактам (TIntegerList) в соотв.с CliContracts
    CliContMargins: TObjectList;      // наценки клиента по контрактам (TLinkList) в соотв.с CliContracts
    CliContDefs: TObjectList;         // настройки клиента по контрактам (TTwoCodes) в соотв.с CliContracts
    CliMails, CliPhones: TStringList; // Email-ы, телефоны
    CS_client: TCriticalSection;      // для изменения параметров клиента
    constructor Create(pID: Integer; pName: String);
    destructor Destroy; override;

    function AddCliContract(contID: Integer; OnlyCache: Boolean=False): Integer; // добавляем контракт в список (в базу)
    procedure DelCliContract(contID: Integer; OnlyCache: Boolean=False);         // удаляем контракт из списка (из базы)
//    procedure AddCliStoreCode(contID, StoreID: Integer);          // добавляем склад в список по контракту
//    procedure DelCliStoreCode(contID, StoreID: Integer);          // удаляем склад из списка по контракту
//    function GetCliStoreIndex(contID, StoreID: Integer): Integer; // индекс склада в списке по контракту
//    function GetContStoreCodes(contID: Integer): TIntegerList;    // not Free, склады по контракту
    function SetLastContract(contID: Integer): String;            // изменить последний контракт клиента
    function GetCliCurrContID: Integer;                           // получить код текущего/доступного контракта клиента
    function GetCliContract(var contID: Integer; ChangeNotFound: Boolean=False): TContract;      // получить контракт клиента
    function CheckContract(contID: Integer): boolean;             // проверка доступности контракта клиенту

    function GetContMarginLinks(contID: Integer): TLinkList;      // not Free !!! ссылки на наценкы по контракту
    function GetContCacheGrpMargin(contID, grID: Integer): Double;      // наценка по группе/подгруппе по контракту
    function GetContMarginListAll(contID: Integer; // must Free !!! список групп/подгрупп с наценками по контракту (TCodeAndQty)
             WithPgr: Boolean=False; OnlyNotZero: Boolean=False): TList;
    function CheckCliContMargin(contID, grID: Integer; marg: Double): String; // проверяем/меняем наценку по группе/подгуппе в базе
    function GetCliContDefs(contID: Integer=0): TTwoCodes; // not Free !!! ссылка на настройки по контракту
    procedure CheckCliContDefs(contID, deliv, dest: Integer); // проверка настроек по контракту

    procedure CheckQtyCount;     // проверяет счетчик запросов наличия
    procedure CheckConnectCount; // проверяет счетчик коннектов
    function CheckBlocked(inCS: Boolean=False; mess: Boolean=False; Source: Integer=0): String; // проверка блокировки
    property FirmID            : Integer index ik16_1  read GetIntC    write SetIntC;    // код фирмы // PartiallyFilled
    property MaxRowShowAnalogs : integer index ik16_2  read GetIntC    write SetIntC;
    property SearchCurrencyID  : integer index ik16_3  read GetIntC    write SetIntC;
    property DEFACCOUNTINGTYPE : integer index ik16_4  read GetIntC    write SetIntC;
    property DEFDELIVERYTYPE   : integer index ik16_5  read GetIntC    write SetIntC;
    property CountSearch       : integer index ik16_6  read GetIntC    write SetIntC;    // кол-во поисковых запросов за день
    property CountQty          : integer index ik16_7  read GetIntC    write SetIntC;    // кол-во запросов наличия за период в мин
    property CountConnect      : integer index ik16_8  read GetIntC    write SetIntC;    // кол-во коннектов за период в мин
    property LastContract      : integer index ik16_9  read GetIntC    write SetIntC;    // последний выбранный контракт
    property BlockKind         : integer index ik16_10 read GetIntC    write SetIntC;    // тип блокировки
    property Login             : string  index ik8_1   read GetStrC    write SetStrC;    // логин     // PartiallyFilled
    property Password          : string  index ik8_2   read GetStrC    write SetStrC;    // пароль    // PartiallyFilled
    property Mail              : string  index ik8_3   read GetStrC;                     // Email     // PartiallyFilled
//    property Mail              : string  index ik8_3   read GetStrC    write SetStrC;    // Email     // PartiallyFilled
//    property Phone             : String  index ik8_4   read GetStrC    write SetStrC;    // телефоны  // PartiallyFilled
    property Phone             : String  index ik8_4   read GetStrC;                     // телефоны  // PartiallyFilled
    property Post              : string  index ik8_5   read GetStrC    write SetStrC;    // должность // PartiallyFilled
    property SearchCurrencyCode: string  index ik8_6   read GetStrC;                     // SearchCurrencyID символьный
    property FirmName          : string  index ik8_7   read GetStrC;                     // наименование фирмы
    property Sid               : string  index ik8_8   read GetStrC    write SetStrC;    // sid       // PartiallyFilled
    property NOTREMINDCOMMENT  : boolean index ik8_2   read GetDirBool write SetDirBool; //
    property PartiallyFilled   : boolean index ik8_3   read GetDirBool write SetDirBool; // признак частичного заполнения
    property Arhived           : boolean index ik8_4   read GetDirBool write SetDirBool; // признак архивности
    property WareSemafor       : boolean index ik8_5   read GetDirBool write SetDirBool; // Признак вывода семафора наличия в списке товаров
    property Blocked           : boolean index ik8_6   read GetDirBool write SetDirBool; // признак блокировки клиента в Weborderclients
    property DocsByCurrContr   : boolean index ik8_7   read GetDirBool write SetDirBool; // признак показывать документы только по тек.контакту
    property resetPW           : boolean index ik8_8   read GetDirBool write SetDirBool; // признак временного пароля
  end;

  TClients = class (Tobject)
  private
    FarClientInfo: Array of TClientInfo;
    FcalcStart, FcalcDelta: Integer;
    FWorkLogins: TStringList;
    function GetClient(pID: integer): TClientInfo;
    function GetIndex(pID: integer): integer;
    function GetMaxIndex: integer;
  public
    CS_clients: TCriticalSection; // для изменения параметров
    constructor Create;
    destructor Destroy; override;
    procedure TestMaxCode(MaxCode: Integer);
    procedure CutEmptyCode;
    procedure AddClient(pID: integer);
    procedure SetCalcBounds(iStart, iEnd: integer);
    function ClientExists(pID: Integer): Boolean;
    property Items[pID: integer]: TClientInfo read GetClient; default;
    property MaxIndex: integer read GetMaxIndex;
    property WorkLogins: TStringList read FWorkLogins;
  end;

//----------------------------------------------------- пользователь - сотрудник
  TEmplInfoItem = class (TSubDirItem)
  private // FName - имя из MANS, FID - EMPLCODE(GB), FSubCode - EMPLMANCODE(GB), 
          // FOrderNum - код подразделения из EMPLDPRTCODE(ORD, EMPLOYEES)
          // FLinks - связки с видимыми складами
    FSurname    : string;           // фамилия из MANS
    FPatron     : string;           // отчество из MANS
    FServerLog  : string;           // логин из EMPLLOGIN(ORD, EMPLOYEES)
    FPASSFORSERV: string;           // пароль из EMPLPASS(ORD, EMPLOYEES)
    FGBLogin    : string;           // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTCODE
    FGBRepLogin : string;           // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTREPORTCODE
    FMail       : string;           // Email
    FSession    : string;
    FVisRule, FFaccReg: Integer;
    function GetStrE(const ik: T16InfoKinds): String;          // получить строку
    procedure SetStrE(const ik: T16InfoKinds; Value: String);  // записать строку
    function GetIntE(const ik: T8InfoKinds): Integer;          // получить код
    procedure SetIntE(const ik: T8InfoKinds; Value: Integer);  // записать код
    procedure TestUserRolesLength(len: integer; ChangeOnlyLess: boolean=True; inCS: boolean=True);
    procedure TestVisRuleNeeds(ruleID: Integer); // проверяем, нужны ли права видимости
  public
    LastTestTime     : TDateTime;        // время последней проверки
    LastActionTime   : TDateTime;        // время последнего действия
    UserRoles        : Tai;              // список ролей из (ORD, ROLES)
    constructor Create(pID, pManID, pDprtID: Integer; pName: String);
    destructor Destroy; override;
    procedure TestUserRoles(roles: Tai);             // проверяем список ролей
    procedure AddUserRole(role: Integer);            // добавляем роль
    procedure DelUserRole(role: Integer);            // удаляем роль
    function UserRoleExists(role: Integer): boolean; // проверяем наличие роли
    property Arhived          : boolean index ik8_5   read GetDirBool write SetDirBool; // признак архивности из EMPLARCHIVED(GB, EMPLOYEES)
    property RESETPASSWORD    : boolean index ik8_2   read GetDirBool write SetDirBool; // признак временного пароля
    property Blocked          : boolean index ik8_3   read GetDirBool write SetDirBool; // признак блокировки
    property DisableOut       : boolean index ik8_4   read GetDirBool write SetDirBool; // признак запрета доступа снаружи
    property EmplID           : integer index ik8_1   read GetIntE  write SetIntE; // = EMPLCODE(GB)
    property ManID            : integer index ik8_2   read GetIntE  write SetIntE; // = EMPLMANCODE(GB)
    property EmplDprtID       : integer index ik8_3   read GetIntE  write SetIntE; // код подразделения из EMPLDPRTCODE(ORD, EMPLOYEES)
    property VisRule          : integer index ik8_4   read GetIntE  write SetIntE; // код схемы видимости из VMPERMISSIONGROUP
    property FaccRegion       : integer index ik8_5   read GetIntE  write SetIntE; // номер региона ЦФУ
    property Surname          : string  index ik16_1  read GetStrE  write SetStrE; // фамилия из MANS
    property Name             : string  index ik16_2  read GetStrE  write SetStrE; // имя из MANS
    property Patronymic       : string  index ik16_3  read GetStrE  write SetStrE; // отчество из MANS
    property ServerLogin      : string  index ik16_4  read GetStrE  write SetStrE; // логин из EMPLLOGIN(ORD, EMPLOYEES)
    property USERPASSFORSERVER: string  index ik16_5  read GetStrE  write SetStrE; // пароль из EMPLPASS(ORD, EMPLOYEES)
    property GBLogin          : string  index ik16_6  read GetStrE  write SetStrE; // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTCODE
    property GBReportLogin    : string  index ik16_7  read GetStrE  write SetStrE; // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTREPORTCODE
    property Mail             : string  index ik16_8  read GetStrE  write SetStrE; // Email
    property Session          : string  index ik16_9  read GetStrE  write SetStrE;
    property EmplLongName     : string  index ik16_11 read GetStrE;
    property EmplShortName    : string  index ik16_10 read GetStrE;
    property VisStoreLinks    : TLinks read FLinks;                                // связки с видимыми складами
  end;

//---------------------------------------- файлы рисунков/документов для товаров
  TWareFile = Class (TSubDirItem)  // файл
  private // FSubCode - WGFSupTD (supID TecDoc !!!), FOrderNum - WGFHeadID, FName - WGFFileName
    function GetWFHeadName: String; // Получить текст заголовка
  public
    property supID   : Integer read FSubCode;      // SupID TecDoc (DS_ID !!!)
    property HeadID  : Integer read FOrderNum;     // код заголовка
    property FileName: String  read FName;         // имя файла
    property HeadName: String  read GetWFHeadName; // текст заголовка
  end;

//-------------------------------------------------------------------- инфо-блок
  TInfoBoxItem = Class (TSubDirItem)
  private
    FLinkToPict: String;
    FLinkToSite: String;
    FDateFrom  : TDateTime;
    FDateTo    : TDateTime;
    function GetStrI(const ik: T8InfoKinds): String;         // получить строку
    procedure SetStrI(const ik: T8InfoKinds; Value: String); // записать строку
  public
    property Title     : String  index ik8_1 read GetStrI    write SetStrI;    // заголовок
    property LinkToPict: String  index ik8_2 read GetStrI    write SetStrI;    // ссылка на рисунок
    property LinkToSite: String  index ik8_3 read GetStrI    write SetStrI;    // ссылка на сайт / окно описания
    property InWindow  : boolean index ik8_2 read GetDirBool write SetDirBool; // показывать в окне
    property VisAuto   : boolean index ik8_3 read GetDirBool write SetDirBool; // видимость для системы авто
    property VisMoto   : boolean index ik8_4 read GetDirBool write SetDirBool; // видимость для системы мото
    property DateFrom  : TDateTime read FDateFrom  write FDateFrom;            // дата начала
    property DateTo    : TDateTime read FDateTo    write FDateTo;              // дата окончания
    property Priority  : Integer   read FOrderNum  write FOrderNum;            // приоритет
  end;

  TEmplRole = class (TDirItem)
  private
    FConstLinks: TLinks;
  public
    constructor Create(pID: Integer; pName: String);
    destructor Destroy; override;
    property ImpLinks  : TLinks read FLinks;                        // связки с импортами
    property ConstLinks: TLinks read FConstLinks write FConstLinks; // связки с константами
  end;

//------------------------------------------------------------- вид импорта
  TImportType = Class (TDirItem)
  private
  public
    constructor Create(pID: Integer; pName: String; pReport, pImport: Boolean);
    property RoleLinks  : TLinks  read FLinks;                                  // связки с ролями
    property ApplyReport: boolean index ik8_3 read GetDirBool write SetDirBool; // признак наличия отчета
    property ApplyImport: boolean index ik8_4 read GetDirBool write SetDirBool; // признак наличия импорта
  end;

  TConstItem = Class (TSubDirItem) // элемент справочника констант
    // Name - наименование константы, OrderNum - кол-во знаков после запятой в Double
  private // SubCode - код юзера посл.изменений, SrcID - Тип, Links - список связок с ролями
    FLastTime: TDateTime; // время посл.изменения
    FValue   : String;    // значение в строковом виде
    FMaxValue: String;    // Max значение в строковом виде
    FMinValue: String;    // Min значение в строковом виде
    FGrouping: String;    // идентификатор группировки
    function GetStrCI(const ik: T8InfoKinds): String;              // строковое значение
    procedure SetStrCI(const ik: T8InfoKinds; pValue: String);     // записать строковое значение
    function GetIntCI(const ik: T8InfoKinds): Integer;             // целое значение
    procedure SetIntCI(const ik: T8InfoKinds; pValue: Integer);    // записать целое значение
    function GetDoubCI(const ik: T8InfoKinds): Double;             // вещ. значение
    function GetDateCI(const ik: T8InfoKinds): TDateTime;          // значение даты
    procedure SetDateCI(const ik: T8InfoKinds; pValue: TDateTime); // записать значение даты
  public
    constructor Create(pID: Integer; pName: String; pType: Integer=1;
                pUserID: Integer=0; pPrecision: Integer=0; WithLinks: Boolean=False);
    function CheckConstValue(var pValue: String): String;                          // проверяем корректность значения
    property NotEmpty    : boolean   index ik8_3 read GetDirBool write SetDirBool; // признак запрета пустого значения
    property StrValue    : String    index ik8_1 read GetStrCI   write SetStrCI;   // значение в строковом виде
    property MaxStrValue : String    index ik8_2 read GetStrCI   write SetStrCI;   // Max значение в строковом виде
    property MinStrValue : String    index ik8_3 read GetStrCI   write SetStrCI;   // Min значение в строковом виде
    property Grouping    : String    index ik8_4 read GetStrCI   write SetStrCI;   // идентификатор группировки
    property ItemType    : Integer   index ik8_4 read GetIntCI   write SetIntCI;   // Тип
    property Precision   : Integer   index ik8_5 read GetIntCI   write SetIntCI;   // кол-во знаков после запятой в Double
    property LastUser    : Integer   index ik8_6 read GetIntCI   write SetIntCI;   // код юзера посл.изменений
    property IntValue    : Integer   index ik8_1 read GetIntCI;                    // целое значение
    property MaxIntValue : Integer   index ik8_2 read GetIntCI;                    // Max целое значение
    property MinIntValue : Integer   index ik8_3 read GetIntCI;                    // Min целое значение
    property DoubValue   : Double    index ik8_1 read GetDoubCI;                   // вещ. значение
    property MaxDoubValue: Double    index ik8_2 read GetDoubCI;                   // Max вещ. значение
    property MinDoubValue: Double    index ik8_3 read GetDoubCI;                   // Min вещ. значение
    property DateValue   : TDateTime index ik8_1 read GetDateCI;                   // значение даты
    property MaxDateValue: TDateTime index ik8_2 read GetDateCI;                   // Max значение даты
    property MinDateValue: TDateTime index ik8_3 read GetDateCI;                   // Min значение даты
    property LastTime    : TDateTime index ik8_4 read GetDateCI  write SetDateCI;  // время посл.изменения
  end;

//-------------------------------------------------------------- схема видимости
  TEmplVisRule = Class (TDirItem)
  private
    FStoreLinks: TLinks; // набор связок со складами
  public
    constructor Create(pID: Integer; pName: String);
    destructor Destroy; override;
    procedure CheckVisRules(rName, rules: String; flnew: Boolean=False); // заполняем/проверяем набор прав видимости
    property FirmLinks : TLinks  read FLinks;      // набор связок с контрагентами
    property StoreLinks: TLinks  read FStoreLinks; // набор связок со складами
  End;

//-------------------------------------------------------------------- общий кэш
  TDataCache = class
  private
    FMeasNames    : TDirItems;   // справочник ед.изм.
    FEmplRoles    : TDirItems;   // справочник ролей
    FWareFiles    : TDirItems;   // справочник файлов рисунков/документов
    FImportTypes  : TDirItems;   // справочник видов импорта ( FLinks - набор ролей)
    FParConstants : TDirItems;   // справочник констант ( FLinks - набор ролей)
    FCacheBoolOpts: set of T16InfoKinds;
     function GetBoolDC(ik: T16InfoKinds): boolean;        // получить признак
    procedure SetBoolDC(ik: T16InfoKinds; Value: boolean); // записать признак
    procedure SetWaresNotTested; // сбросить флажки тестирования кэша товаров
    procedure DelNotTestedItems; // убираем непроверенные элементы кэша товаров
    procedure TestParConstants(flFill: Boolean=True; alter: boolean=False);       // проверка кэша констант
    procedure TestSmallDirectories(flFill: Boolean=True; alter: boolean=False); // заполнение/проверка малых справочников
     function TestCacheArrayItemExist(kind: TArrayKind; pID: integer; var flnew: boolean): boolean; // проверяем существование элемента массива кэша
    procedure TestCacheArrayLength(kind: TArrayKind; len: integer; ChangeOnlyLess: boolean=True);   // проверяем длину массива кэша
    procedure TestWares(flFill: Boolean=True);          // заполнение/проверка товаров
    procedure TestWareRests(CompareTime: boolean=True); // заполнение/проверка связок с остатками товаров
    procedure FillWareTypes(GBIBS: TIBSQL);
    procedure FillWareFiles(fFill: Boolean=True); // Загрузка / обновление файлов товаров
    procedure FillInfoNews(flFill: Boolean=True); // Заполнение / проверка инфо-блока
     function FillBrandTDList: TStringList;       // Возвращает список брендов TecDoc
    procedure FillAttributes;                     // Заполнение атрибутов
    procedure FillNotifications(fFill: Boolean=True); // Заполнение / проверка уведомлений
//    procedure CheckAttributes;                    // Проверка атрибутов
//     function GetFilialROPcodes(var filials: Tai): Tai;        // коды РОП-ов филиалов
  public
//    TestCacheAlterInterval: Integer;   // интервал проверки кэша по alter-таблицам в мин (без фирм и клиентов)
    CliLoginLength        : Byte;      // длина поля логина
    CliPasswLength        : Byte;      // длина поля пароля
    OrdWarrNumLength      : Byte;      // длина поля заказа Номер доверенности
    OrdWarrPersLength     : Byte;      // длина поля заказа ФИО (доверенности)
    OrdCommentLength      : Word;      // длина поля заказа Комментарий
    OrdSelfCommLength     : Word;      // длина поля заказа Личный комментарий
    AccEmpCommLength      : Word;      // длина поля счета Комментарий сотрудника
    AccCliCommLength      : Word;      // длина поля счета Комментарий клиента
    AccWebCommLength      : Word;      // длина поля счета Комментарий Web

    TestCacheInterval     : Word;      // интервал полной проверки кэша в мин (без фирм и клиентов)
    TestCacheNightInt     : Word;      // ночной интервал полной проверки кэша в мин (без фирм и клиентов)
    ClientActualInterval  : Word;      // интервал актуальности кэша клиента в мин
    FirmActualInterval    : Word;      // интервал актуальности кэша фирмы в мин (кроме долгов)
//    FirmDebtActualInterval: Word;      // интервал актуальности долгов в кэше фирмы в мин
    DefCurrRate, CreditPercent: Single;  // курс EURO к грн, DTZNCREDITPERCENT (DUTYZONES)

//    BonusCrncRate	        : Single;   // курс бонуса
//    BonusVolumePercent    : Single;   // процент отчислений на бонусы
    BonusVolumeCoeff      : Single;   // коэффициент расчета бонусов к cDefCurrency

    BonusCrncCode	        : integer;   // код валюты бонусов
    LongProcessFlag       : Integer;   // флаг длительного процесса в кеше
    pgrDeliv              : Integer;   // подгруппа наценки
    LastTimeCache         : TDateTime;   // время последней полной проверки кэша
    LastTestRestTime      : TDateTime;   // время последнего обновления связок с остатками
    DocmMinDate           : TDate;       // минимальная дата док-тов Grossbee
//    LastTimeCacheAlter    : TDateTime; // время последней проверки кэша по alter-таблицам
//    LastTimeMemUsed       : TDateTime;   // время последней проверки занимаемой памяти

    arWareInfo      : array of TWareInfo;
    arDprtInfo      : array of TDprtInfo;
    arEmplInfo      : array of TEmplInfoItem;
    arFirmInfo      : array of TFirmInfo;
    arClientInfo    : TClients;
    CScache         : TCriticalSection; // для изменения длин массивов и замены файлов Влад
    CS_Empls        : TCriticalSection; // для изменения параметров сотрудников
    CS_wares        : TCriticalSection; // для изменения товаров
    FDCA            : TDataCacheAdditionASON;
    AttrGroups      : TAttrGroupItems;  // справочник групп атрибутов
    Attributes      : TAttributeItems;  // справочник атрибутов
    Contracts       : TContracts;       // справочник контрактов
    Notifications   : TNotifications;   // Справочник уведомлений
    WareBrands      : TDirItems;        // справочник брендов
    InfoNews        : TDirItems;        // инфо-блок
    EmplVisRules    : TDirItems;        // справочник схем видимости
    ShipMethods     : TDirItems;        // справочник методов отгрузки
    ShipTimes       : TDirItems;        // справочник времен отгрузки
    FiscalCenters   : TDirItems;        // справочник FISCALACCOUNTINGCENTER
    Currencies      : TCurrencies;      // справочник валют
//    FirmLabels      : TDirItems;        // справочник наклеек
    BrandTDList     : TStringList;      // список брендов TecDoc
    BrandLaximoList : TStringList;      // список брендов Laximo
    NoTDPictBrandCodes: TIntegerList;     // коды брендов без показа рисунков TD
    DeliveriesList  : TStringList;      // список доставок
    arFirmTypesNames: Tas;
    arFirmClassNames: Tas;
    arRegionROPFacc : Tai; // коды ЦФУ РОП-а по номеру региона
    PriceTypes      : Tai; // коды используемых прайсов
//    PriceTypesList  : TIntegerList; // коды используемых прайсов
    arFictiveEmpl   : Tai; // массив кодов фиктивных менеджеров (ИНФО, ЯяяАРХИВ и т.п.)
    MarginGroups    : TMarginGroups; // группы/подгруппы наценок
    DiscountModels  : TDiscModels;   // справочник шаблонов скидок

    constructor Create;
    destructor Destroy; override;
    property WareCacheUnLocked : boolean index ik16_1  read GetBoolDC write SetBoolDC; // признак начального заполнения кеша
    property WareLinksUnLocked : boolean index ik16_2  read GetBoolDC write SetBoolDC; // признак начального заполнения связок
    property WebAutoLinks      : boolean index ik16_3  read GetBoolDC write SetBoolDC; // признак заполнения связок AUTO (Web)
    property WareCacheTested   : boolean index ik16_4  read GetBoolDC write SetBoolDC; // признак текущего заполнения/проверки кеша
    property flCheckClosingDocs: boolean index ik16_5  read GetBoolDC write SetBoolDC; // флаг - пакетная проверка закрывающих док-тов заказов
    property HideOnlyOneLevel  : boolean index ik16_6  read GetBoolDC write SetBoolDC; // признак - сворачивать только 1 уровень дерева
    property HideOnlySameName  : boolean index ik16_7  read GetBoolDC write SetBoolDC; // признак - сворачивать ноды только при совпадении имен
    property flCheckDocSum     : boolean index ik16_8  read GetBoolDC write SetBoolDC; // признак - проверять суммы док-тов
    property flSendZeroPrices  : boolean index ik16_9  read GetBoolDC write SetBoolDC; // признак - отсылать письмо о нулевых ценах
    property flMailSendSys     : boolean index ik16_11 read GetBoolDC write SetBoolDC; // флаг - идет отправка сист.сообщения (для неодновременного подключения к почт.серверу)
    property flAccTimeToLog    : Boolean index ik16_12 read GetBoolDC write SetBoolDC; // флаг - писать в лог время записи счета (исп.в CSSvlad)
    property flCheckCliEmails  : boolean index ik16_10 read GetBoolDC write SetBoolDC; // флаг - проверять Email-ы
    property AllowWeb          : boolean index ik16_13 read GetBoolDC write SetBoolDC; // флаг - запущен CSSWeb
    property AllowWebArm       : boolean index ik16_14 read GetBoolDC write SetBoolDC; // флаг - запущен CSSWebarm
    property AllowCheckStopOrds: boolean index ik16_15 read GetBoolDC write SetBoolDC;
    property SingleThreadExists: boolean index ik16_16 read GetBoolDC write SetBoolDC;

    function WareExist(pID: Integer): Boolean;
    function GrpExists(pID: Integer): Boolean;
    function PgrExists(pID: Integer): Boolean;
    function GrPgrExists(grID: integer): Boolean; // проверка существования группы/подгруппы для скидок/наценок
    function TypeExists(pID: Integer): Boolean;
    function DprtExist(pID: Integer): Boolean;
    function FirmExist(pID: Integer): Boolean;
    function ClientExist(pID: Integer): Boolean;
    function EmplExist(pID: Integer): Boolean;
    function MeasExists(pID: Integer): Boolean;
    function CurrExists(pID: Integer): Boolean;
    function FaccExists(pID: Integer): Boolean;
    function RoleExists(pID: Integer): Boolean;
    function ImpTypeExists(pID: Integer): Boolean;
    function ConstExists(pID: Integer): Boolean;
    function FirmTypeExists(pID: Integer): Boolean;
    function FirmClassExists(pID: Integer): Boolean;

    function GetWare(WareID: integer; OnlyCache: Boolean=False): TWareInfo; // возвращает параметры товара (если в кэше его нет и OnlyCache=False - заносит в кэш с PgrID=0)
    function GetEmplIDByLogin(login: string): Integer;
    function GetEmplIDByGBLogin(Login: string): Integer;
    function GetEmplIDBySession(pSession: string): Integer;
    function GetRegFirmCodes(RegID: Integer=0; Search: string=''; NotArchived: boolean=True): Tai; // must Free, RegID - код регионала (0-все), Search - ключ поиска по наименованию, NotArchived - только неархивные
    function GetEmplCodesByShortName(DprtID: Integer=0; role: Integer=0): Tai; // must Free, список кодов регионалов, сортировка по коду филиала и ФИО
    function GetGrpID(ID: Integer): Integer;         // код группы
    function GetPgrID(ID: Integer): Integer;         // код подгруппы
    function GetDprtMainName(pID: Integer): string;  // наименование подразделения
    function GetDprtShortName(pID: Integer): string; // кр.наименование подразделения
    function GetDprtColName(pID: Integer): string;   // заголовок колонки подразделения
    function GetImpTypeName(pID: Integer): string;   // наименование импорта
    function GetMeasName(pID: Integer): string;      // наименование ед.изм.
    function GetCurrName(pID: Integer; ForClient: Boolean): string; // наименование валюты
    function GetFaccName(pID: Integer): string;      // наименование ЦФУ
    function GetWareTypeName(typeID: Integer): string;   // наименование типа товара
    function GetFirmTypeName(typeID: Integer): string;   // наименование типа фирмы
    function GetFirmClassName(classID: Integer): string; // наименование категории фирмы
    function GetLastTimeCache: Double;               // время последнего обн.кеша для коммандера
    function GetTestCacheIndication: Integer;        // индикатор своевременности проверки кеша
    function GetRoleName(pID: Integer): string;      // наименование роли
    function GetAllRoleCodes: Tai;                   // must Free, коды всех ролей
    function GetEmplEmails(empls: Tai; pFirm: Integer=0; pWare: Integer=0; // список адресов сотрудников
             pSys: Integer=0; pRegion: Integer=0): String; overload;
    function GetEmplEmails(empls: Tai; var mess: String; pFirm: Integer=0;
             pWare: Integer=0; pSys: Integer=0; pRegion: Integer=0): String; overload;
    function GetConstItem(csID: Integer): TConstItem;  // элемент справочника констант
    function GetConstEmpls(pc: Integer): Tai;          // must Free, список кодов сотрудников из константы-списка
    function GetConstEmails(pc: Integer; pFirm: Integer=0; pWare: Integer=0): String; overload; // список адресов константы-списка кодов сотрудников
    function GetConstEmails(pc: Integer; var mess: String; pFirm: Integer=0; pWare: Integer=0): String; overload;
    function GetEmplConstants(pEmplID: Integer): TStringList;  // must Free, доступные константы сотрудника (Object - ID)
    function GetEmplConstantsCount(pEmplID: Integer): Integer; // кол-во доступных констант сотрудника
    function GetRepOrImpRoles(ImpID: Integer; flReport: Boolean=True): Tai; // must Free, доступные роли для отчета/импорта
    function GetEmplAllowRepImp(pEmplID: Integer): boolean;  // признак наличия разрешенных отчетов/импортов у сотрудника
    function GetEmplAllowRepOrImpList(pEmplID: Integer; flReport: Boolean=True): TStringList; // must Free, список доступных отчетов/импортов сотрудника
    function GetDownLoadExcludeBrands: Tai;                  // коды запрещенных для загрузки прайса брендов, must Free
//---------------------------- потом убрать
//    function GetEmplImports(pEmplID: Integer): TStringList;    // must Free, доступные виды отчетов/импортов сотрудника (Object - ID)
//---------------------------- потом убрать

    function GetSysManagerWares(SysID: Integer=0; ManID: Integer=0; // must Free, сортированный список товаров (Object-ID) по системе и/или менеджеру и/или бренду
             Brand: integer=0; Sort: boolean=True): TStringList;
    function GetWaresModelNodeUsesAndTextsView(ModelID, NodeID: Integer; // must Free, список текстов и условий к связкам 3, Objects - WareID
             WareCodes: Tai; var sFilters: String): TStringList;
    function GetModelNodeWaresWithUsesByFilters(ModelID, NodeID: Integer; // фильтр.список товаров с текстами и условиями к связкам 3, Objects - WareID
             withChildNodes: boolean; var sFilters: String): TStringList;  // must Free, sFilters - коды значений критериев через запятую

    function GetWareModelUsesAndTextsView(WareID, ModelID: Integer): TStringList; // must Free, список текстов и условий к связкам 3 товара по моделям, Objects - ModelID

    function GetWareRestsByStores(pWareID: Integer; WithNegative: Boolean=False): TObjectList; // must Free, получить остатки товара по складам
    function GetGroupDprts(pDprtGroup: Integer=0; StoreAndRoad: Boolean=False): Tai; // must Free, список подразделений в заданной группе
    function GetEmplVisFirmLinkList(EmplID: Integer): TList;  // not Free !!! список связок с к/а по схеме видимости сотрудника
    function GetEmplVisStoreLinkList(EmplID: Integer): TList; // not Free !!! список связок со складами по схеме видимости сотрудника
//--------------------------------------------------------------------
    function GetFilialList(flShortName: Boolean=False): TStringList; // must Free, список филиалов (Objects - ID)
    function GetFirmTypesList: TStringList;                          // must Free, список типов к/агентов (Objects - ID)
    function GetFirmClassesList: TStringList;                        // must Free, список категорий к/агентов (Objects - ID)
    function GetShipMethodName(smID: Integer): string;               // наименование метода отгрузки
    function GetShipMethodNotTime(smID: Integer): Boolean;           // признак запрета времени у метода отгрузки
    function GetShipMethodNotLabel(smID: Integer): Boolean;          // признак запрета наклейки у метода отгрузки
    function GetShipTimeName(stID: Integer): string;                 // наименование времени отгрузки
    function GetShipMethodsList(dprt: Integer=0): TStringList;       // must Free, список методов отгрузки по складу или всех (Objects - ID)
    function GetShipTimesList: TStringList;                          // must Free, сортированный список времен отгрузки (Objects - ID)
//--------------------------------------------------------------------

    function SearchWaresByAttrValues(attCodes, valCodes: Tai): Tai;             // must Free, поиск товаров по набору значений атрибутов
    function SearchWareFileBySupAndName(pSup: Integer; pFileName: String): Integer;
    function SearchWaresByTDSupAndArticle(pSup: Integer; pArticle: String;      // must Free - поиск товаров по артикулу TD
             notInfo: Boolean=False): TStringList;

    procedure TestDataCache(CompareTime: boolean=True; alter: boolean=False);   // заполнение/проверка кэша
    procedure TestEmpls(pEmplID: Integer; FillNew: boolean=True;                // заполнение/проверка сотрудников
              CompareTime: boolean=True; TestEmplFirms: boolean=False);
    procedure TestFirms(pID: Integer; FillNew: boolean=False;                   // заполнение/проверка фирм
              CompareTime: boolean=True; Partially: boolean=False; RegID: Integer=0);
    procedure TestClients(pID: Integer; FillNew: boolean=False;                 // заполнение/проверка клиентов
              CompareTime: boolean=True; Partially: boolean=False; pFirm: Integer=0);
    procedure TestGrPgrDiscModelLinks;                                          // заполнение/проверка линков групп/подгрупп с шаблонами скидок

    function SaveNewConstValue(csID, pUserID: Integer; pValue: String): String; // новое значение константы
    function CheckRoleConstLink(csID, roleID, UserID: Integer;                  // проверить связь роли с константой
             flWrite: Boolean; var ResCode: Integer): String;
//    function CheckRoleImportLink(impID, roleID, UserID: Integer; flWrite: Boolean; var ResCode: Integer): String; // проверить связь роли с импортом
    function CheckWareBrandReplace(brID, brTD, userID: Integer; var ResCode: Integer): String; // добавление / удаление связки производителей Grossbe и Tecdoc
//    function CheckWareAndFirmEqualSys(WareID, FirmID: Integer; contID: Integer=0): Boolean;    // проверка соответствия систем фирмы и товара
    function CheckWaresEqualSys(WareID1, WareID2: Integer): Boolean;            // проверка ссответствия систем двух товаров
    function CheckEmplIsFictive(pEmplID: Integer): Boolean;                     // проверка кодов фиктивных менеджеров (ИНФО, ЯяяАРХИВ и т.п.)
    function CheckEmplImpType(pEmplID, impID: Integer; flReport: Boolean=False): Boolean; // проверка доступности отчета/импорта сотруднику
    function CheckEmplConstant(pEmplID, constID: Integer; var errmess: string;  // проверка доступности константы сотруднику
             CheckWrite: Boolean=False): Boolean;
    function CheckEmplVisFirm(pEmplID, pFirmID: Integer): Boolean;              // проверка видимости к/а сотруднику
    function CheckEmplVisStore(pEmplID, pDprtID: Integer): Boolean;             // проверка видимости склада сотруднику
    function CheckLinkAllowDelete(srcID: Integer): Boolean;                     // проверка доступности удаления по источнику
    function CheckLinkAllowWrong(srcID: Integer): Boolean;                      // проверка доступности пометки неверной связки по источнику

    function CheckLinkMainAndDupNodes(NodeID, MainNodeID, userID: Integer;      // добавление / удаление связки нод - главная, дублирующая
             var ResCode: Integer): String;
    function CheckWareAttrValue(WareID, AttrID, srcID, userID: Integer;         // проверка атрибутов товара
             Value: String; var ResCode: Integer): String;
    function CheckWareCriValueLink(pWareID, criTD, UserID, srcID: Integer;
             CriName, CriValue: String; ORD_IBS: TIBSQL=nil): String; // добавить линк товара со значением критерия в базу
    function CheckModelNodeWareTextLink(var ResCode: Integer; pModelID, pNodeID, pWareID: Integer; // добавить линк связки 3 с текстом в базу (порция 1 - загрузка из Excel)
             TextValue: String; TypeID: Integer=0; TypeName: String=''; UserID: Integer=0; srcID: Integer=0): String;
    function CheckWareCrossLink(pWareID, pCrossID: Integer;                               // добавить/удалить линк товара с аналогом
             var ResCode: Integer; srcID: Integer; UserID: Integer=0): String;            //          (Excel, вручную)
    function CheckWareArtCrossLinks(pWareID: Integer; CrossArt: String; crossMF: Integer; // добавить/удалить линки товара с аналогами по 1 артикулу
             var ResCode: Integer; srcID: Integer; UserID: Integer=0; ibsORD: TIBSQL=nil): String;          //          (загрузка из TDT)
   procedure CheckWareRest(wrLinks: TLinks; dprtID: Integer;          // установить / уменьшить значение остатка товара
                           pQty: Double; dec: Boolean=False);
    function CheckWareSatelliteLink(pWareID, pSatelID: Integer;       // добавить/удалить линк товара с сопут.товаром (Excel, вручную)
             var ResCode: Integer; srcID: Integer=0; UserID: Integer=0): String;
//---------- UseList - список строк <критерий>=<значение>, в Object - <код TecDoc критерия>
//----------- при посадке из Excel <код TecDoc критерия>=0
    function GetModelNodeWareUseListNumber(pModelID, pNodeID, pWareID: Integer; // номер порции условий связки 3 (заготовка)
             UseList: TStringList): Integer;
    function AddModelNodeWareUseListLinks(pModelID, pNodeID, pWareID,   // добавить линки связки 3 с новой порцией условий в базу
             UserID, srcID: Integer; var UseList: TStringList; var pPart: Integer): String;
    function DelModelNodeWareUseListLinks(pModelID, pNodeID, pWareID, iUseList: Integer): String; // удалить линки связки 3 с порцией условий из базы
    function ChangeModelNodeWareUsesPart(pModelID, pNodeID, pWareID,    // заменить линки связки 3 с порцией значений условий в базе
             UserID, srcID: Integer; UseList: TStringList; var pPart: Integer): String;
//----- TxtList - список, в Object - <код supTD текста>
//----- GetModelNodeWareTextListNumber: String -
//-----   <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
//----- CheckModelNodeWareTextListLinks: String -
//-----   <IntToStr(код типа текста)>+cSpecDelim+<название типа>=<идентификатор TecDoc>+cSpecDelim+<текст>
//-----   если задан  <IntToStr(код типа текста)> - <название типа> может быть ''
//----- при посадке из Excel  <идентификатор TecDoc>='', <код supTD текста>=0
    function GetModelNodeWareTextListNumber(pModelID, pNodeID, pWareID: Integer; // номер порции текстов связки 3 (заготовка)
             TxtList: TStringList; nTxtList: Integer=0; ORD_IBSr: TIBSQL=nil): Integer;
    function CheckModelNodeWareTextListLinks(var ResCode: Integer; // добавить / удалить линки связки 3 с порцией текстов
             pModelID, pNodeID, pWareID: Integer; TxtList: TStringList;
             UserID: Integer=0; srcID: Integer=0; PartID: Integer=0): String;
    function FindModelNodeWareUseAndTextListNumbers(pModelID, pNodeID, pWareID: Integer; // номера порций условий и текстов связки 3
             var UseLists: TASL; var TxtLists: TASL; var ListNumbers: Tai; var ErrUseNums: Tai;
             var ErrTxtNums: Tai; FromTDT: Boolean=False; CheckTexts: Boolean=False): String;
    function AddWareFile(var fID: Integer; pFname: String;             // добавить файл в базу и кеш
             pSup, pHeadID, pUserID, pSrcID: Integer): String;
    function CheckWareFileLink(var ResCode: Integer; pFileID, pWareID: Integer;  // добавить/удалить линк товара с файлом (toCache=True - и в кеше)
             pSrcID: Integer=0; UserID: Integer=0; toCache: Boolean=True; linkURL: Boolean=True): String;
    function CheckWareFiles(var delCount: Integer): String; // удаление неиспользуемых файлов

    function GetNotificationText(noteID: Integer): String;                 // получить текст уведомления
    function SetClientNotifiedKind(userID, noteID, kind: Integer): String; // записать время показа/ознакомления уведомления пользователю
    function CheckBrandAdditionData(pBrandID, UserID: Integer;             // добавить/редактировать доп.параметры бренда
             pNameWWW, pPrefix, pAdressWWW: String; pDownLoadEx: Boolean): String;

    function GetPriceBonusCoeff(currID: Integer): Single;
  end;

var
  NoWare: TWareInfo;
  Cache: TDataCache;
  SysTypes: TDirItems; // контролируемые системы учета
//  CachePath: String; // def =..\

//                              независимые функции
  procedure FillSysTypes;                               // определить контролируемые системы учета
  function CheckTypeSys(pTypeSys: Integer): Boolean;    // Проверка корректности кода системы Авто/ Мото
  function GetSysTypeMail(pTypeSys: Integer): String;   // Email для сообщений по системе учета
  function GetSysTypeName(pTypeSys: Integer): String;   // название системы учета
  function GetSysTypeSuffix(pTypeSys: Integer): String; // суффикс для файлов Влад по системам
  function GetSysTypeEmpl(pTypeSys: Integer): Integer;  // EmplID ответственного по системе учета
  function WareModelsSortCompare(Item1, Item2: Pointer): Integer; // сортировка TList моделей - произв. + м.р. + порядк.№ + наименование
  function ShipTimesSortCompare(Item1, Item2: Pointer): Integer; // используется для сортировки TList справочника ShipTimes
//  function CheckCacheTestAvailable: Boolean;
  function GetRepImpAllowFromLinkSrc(srcID: Integer; flReport: Boolean=False): Boolean; // получить признак доступности отчета/импорта из srcID линка
  function GetLinkSrcFromRepImpAllow(RepAllow, ImpAllow: Boolean): Integer; // получить srcID линка из признаков доступности отчета/импорта

implementation
uses n_IBCntsPool;
//******************************************************************************
//                              независимые функции
//******************************************************************************
//====================================== определить контролируемые системы учета
procedure FillSysTypes;
const nmProc = 'FillSysTypes'; // имя процедуры/функции
var OrdIBD: TIBDatabase;
    OrdSql: TIBSQL;
    i, pEmplID: integer;
    s, n: string;
    Item: Pointer;
begin
//  OrdIBD:= nil;
  OrdSql:= nil;
  with Cache do try
    if not Assigned(cntsORD) then raise Exception.Create('not Assigned(cntsORD)');
    if not cntsORD.BaseConnected then cntsORD.CheckBaseConnection(30);
    OrdIBD:= cntsORD.GetFreeCnt;
    try
      OrdSql:= fnCreateNewIBSQL(OrdIBD, 'OrdIBSQL_'+nmProc, -1, tpRead, True);
      OrdSql.SQL.Text:= 'select * from DIRTYPESYSTEM order by DTSYCODE';
      OrdSql.ExecQuery;
      while not OrdSql.Eof do begin
        i:= OrdSql.FieldByName('DTSYCODE').AsInteger;
        n:= OrdSql.FieldByName('DTSYNAME').AsString;
        s:= OrdSql.FieldByName('DTSYMAIL').AsString;
        Item:= TSysItem.Create(i, n, s);
        if SysTypes.CheckItem(Item) then
          with TSysItem(SysTypes[i]) do begin
            if SysMail<>s then SysMail:= s;
            if (OrdSql.FieldIndex['DTSYEMPL']<0) then pEmplID:= 0
            else pEmplID:=OrdSql.FieldByName('DTSYEMPL').AsInteger;
            if SysEmplID<>pEmplID then SysEmplID:= pEmplID;
          end;
        cntsORD.TestSuspendException;
        OrdSql.Next;
      end;
      OrdSql.Close;
      OrdSql.SQL.Text:= 'select f.RDB$FIELD_NAME fname, ff.RDB$FIELD_LENGTH fsize'+
      ' from rdb$relation_fields f, rdb$fields ff where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE'+
      ' and (f.RDB$RELATION_NAME=:table1 or f.RDB$RELATION_NAME=:table2)';
      OrdSql.ParamByName('table1').AsString:= 'WEBORDERCLIENTS';
      OrdSql.ParamByName('table2').AsString:= 'ORDERSREESTR';
      OrdSql.ExecQuery;
      while not OrdSql.Eof do begin
        i:= OrdSql.FieldByName('fsize').AsInteger;
        s:= OrdSql.FieldByName('fname').AsString;
        if      (s='WOCLLOGIN')          and (CliLoginLength<>i)    then CliLoginLength:= i
        else if (s='WOCLPASSWORD')       and (CliPasswLength<>i)    then CliPasswLength:= i
        else if (s='ORDRWARRANT')        and (OrdWarrNumLength<>i)  then OrdWarrNumLength:= i
        else if (s='ORDRWARRANTPERSON')  and (OrdWarrPersLength<>i) then OrdWarrPersLength:= i
        else if (s='ORDRSTORAGECOMMENT') and (OrdCommentLength<>i)  then OrdCommentLength:= i
        else if (s='ORDRSELFCOMMENT')    and (OrdSelfCommLength<>i) then OrdSelfCommLength:= i;
        cntsORD.TestSuspendException;
        OrdSql.Next;
      end;
      OrdSql.Close;
    finally
      prFreeIBSQL(OrdSql);
      cntsOrd.SetFreeCnt(OrdIBD);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;

  if SysTypes.Count<1 then try // системы учета должны быть заполнены обязательно !!!
    prMessageLOGS(nmProc+': заполняю системы учета default-значениями', fLogCache);
    Item:= TSysItem.Create(constIsAuto, IntToStr(constIsAuto), '');
    SysTypes.CheckItem(Item);
    Item:= TSysItem.Create(constIsMoto, IntToStr(constIsMoto), '');
    SysTypes.CheckItem(Item);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;
//===================================== Проверка корректности кода системы учета
function CheckTypeSys(pTypeSys: Integer): Boolean;
begin
  Result:= SysTypes.ItemExists(pTypeSys);
end;
//========================================= Email для сообщений по системе учета
function GetSysTypeMail(pTypeSys: Integer): String;
begin
  if SysTypes.ItemExists(pTypeSys) then
    Result:= TSysItem(SysTypes[pTypeSys]).SysMail
  else Result:= '';
end;
//======================================= EmplID ответственного по системе учета
function GetSysTypeEmpl(pTypeSys: Integer): Integer;
begin
  if SysTypes.ItemExists(pTypeSys) then
    Result:= TSysItem(SysTypes[pTypeSys]).SysEmplID
  else Result:= 0;
end;
//========================================== суффикс для файлов Влад по системам
function GetSysTypeSuffix(pTypeSys: Integer): String;
begin
  if SysTypes.ItemExists(pTypeSys) then
    Result:= TSysItem(SysTypes[pTypeSys]).SysSuffix
  else Result:= '';
end;
//======================================================= название системы учета
function GetSysTypeName(pTypeSys: Integer): String;
begin
  if SysTypes.ItemExists(pTypeSys) then
    Result:= AnsiUpperCase(TSysItem(SysTypes[pTypeSys]).Name)
  else Result:= '';
end;

//******************************************************************************
//                              TBrandItem
//******************************************************************************
constructor TBrandItem.Create(pID: Integer; pName: String);
begin
  inherited Create(pID, pName);
  FNameWWW:= '';
  FWarePrefix:= '';
  FadressWWW:= '';
  DownLoadExclude:= False;
  SetLength(FTDMFcodes, 0);
end;
//==============================================================================
destructor TBrandItem.Destroy;
begin
  if not Assigned(self) then Exit;
  SetLength(FTDMFcodes, 0);
  inherited Destroy;
end;

//******************************************************************************
//                              TSysItem
//******************************************************************************
constructor TSysItem.Create(pID: Integer; pName, pSysMail: String);
begin
  inherited Create(pID, pName);
  FSysMail:= pSysMail;
  case pID of
    constIsAuto: FSysSuffix:= 'a';
    constIsMoto: FSysSuffix:= 'm';
  else FSysSuffix:= IntToStr(pID);
  end;
end;

//******************************************************************************
//                                 TAttrGroupItem
//******************************************************************************
constructor TAttrGroupItem.Create(pID, pTypeSys: Integer; pName: String; pOrderNum: Word=0);
begin
  inherited Create(pID, pName, True);
  FTypeSys:= pTypeSys;
  FOrderNum:= pOrderNum;
end;
//=============== Список ссылок на атрибуты группы, сортир. по порядк.№ +наимен.
function TAttrGroupItem.GetListGroupAttrs: TList; // must Free
var i: Integer;
begin
  Result:= TList.Create;
  if not Assigned(self) then Exit;
  with Links do begin
    Result.Capacity:= Result.Capacity+LinkCount;
    for i:= 0 to ListLinks.Count-1 do Result.Add(GetLinkPtr(ListLinks[i]));
  end;
  Result.Sort(DirNumNameSortCompare); // сортировка атрибутов (порядк.№ +наимен.)
end;


//******************************************************************************
//                                 TAttrGroupItems
//******************************************************************************
//============= сортировка TStringList групп атрибутов - порядк.№ + наименование
function AttrGroupsSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var i1, i2: integer;
begin
  with Cache.AttrGroups do try
    i1:= GetAttrGroup(Integer(List.Objects[Index1])).OrderNum;
    i2:= GetAttrGroup(Integer(List.Objects[Index2])).OrderNum;
    if i1<i2 then Result:= -1 else if i1>i2 then Result:= 1
    else Result:= AnsiCompareText(List.Strings[Index1], List.Strings[Index2]);
  except
    Result:= 0;
  end;
end;
//==============================================================================
constructor TAttrGroupItems.Create(LengthStep: Integer=10);
begin
  inherited Create(LengthStep);
  FTypeSysLists:= TArraySysTypeLists.Create(False); // сортированные списки по системам
end;
//==============================================================================
destructor TAttrGroupItems.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FTypeSysLists);
  inherited Destroy;
end;
//===== Список групп атрибутов системы, сортированный по порядк.№ + наименованию
function TAttrGroupItems.GetListAttrGroups(pTypeSys: Integer): TStringList;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  Result:= FTypeSysLists[pTypeSys];
end;
//====================================================== Получить группу по коду
function TAttrGroupItems.GetAttrGroup(grpID: Integer): TAttrGroupItem;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  Result:= TAttrGroupItem(DirItems[grpID]);
end;
//============================= сортируем список групп атрибутов (SysID=0 - все)
procedure TAttrGroupItems.SortTypeSysList(SysID: Word=0);
var i, j: integer;
begin
  if not Assigned(self) then Exit;
  if SysID>0 then FTypeSysLists[SysID].CustomSort(AttrGroupsSortCompare)
  else with FTypeSysLists.ListTypes do for i:= 0 to Count-1 do begin
    j:= Integer(Objects[i]);
    FTypeSysLists[j].CustomSort(AttrGroupsSortCompare);
  end;
end;

//******************************************************************************
//                              TAttributeItem
//******************************************************************************
//=================== сортировка TStringList значений атрибутов в зав-ти от типа
function AttrValuesSortCompare(List: TStringList; Index1, Index2: Integer): Integer;
var d1, d2: Double;
    i, i1, i2: integer;
begin
  Result:= 0;
  with List do try
    i:= Ord(Delimiter);
    if i=constInteger then begin
      i1:= StrToIntDef(Strings[Index1], 0);
      i2:= StrToIntDef(Strings[Index2], 0);
      if i1<i2 then Result:= -1 else if i1>i2 then Result:= 1;
    end else if i=constDouble then begin
      d1:= StrToFloatDef(Strings[Index1], 0);
      d2:= StrToFloatDef(Strings[Index2], 0);
      if fnNotZero(d1-d2) then if d1<d2 then Result:= -1 else Result:= 1;
    end else Result:= AnsiCompareText(Strings[Index1], Strings[Index2]);
  except
    Result:= 0;
  end;
end;
//==============================================================================
constructor TAttributeItem.Create(pID, pGroupID: Integer; pPrecision, pType: Byte;
            pOrderNum: Word; pName: String; pSrcID: Integer=0);
begin
  inherited Create(pID, pGroupID, pOrderNum, pName, pSrcID);
  FTypeAttr := pType;       // Тип
  FPrecision:= pPrecision;  // кол-во знаков после запятой в типе Double
  FListValues:= fnCreateStringList(False, Char(pType), dupIgnore); // Список доступных значений атрибута
  FListValues.CaseSensitive:= True;
end;
//==============================================================================
destructor TAttributeItem.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FListValues);
  inherited Destroy;
end;
//================================= проверяем корректность значения для атрибута
procedure TAttributeItem.CheckAttrStrValue(var pValue: String);
var d: double;
    i: integer;
begin
  if not Assigned(self) then Exit;
  pValue:= trim(pValue);
  if pValue=''  then Exit;
  if (TypeAttr=constDouble) then begin
    pValue:= StrWithFloatDec(pValue); // проверяем DecimalSeparator
    try
      d:= StrToFloat(pValue);
      i:= Round(d);
      if (d>15) and not fnNotZero(d-i) then pValue:= FormatFloat('#0', d) //FloatToStr(d)
      else pValue:= FormatFloat('#0.'+StringOfChar('0', Precision), d);
    except
    end;
  end;
end;
{//==================================================== получить систему атрибута
function TAttributeItem.GetAttrTypeSys: Byte;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  if Cache.AttrGroups.ItemExists(FGroupID) then
    Result:= Cache.AttrGroups.GetAttrGroup(FGroupID).TypeSys;
end; }

//******************************************************************************
//                              TAttributeItems
//******************************************************************************
constructor TAttributeItems.Create(LengthStep: Integer=10);
begin
  inherited Create(LengthStep);
  FAttrValues:= TDirItems.Create; // Справочник значений атрибутов
end;
//==============================================================================
destructor TAttributeItems.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FAttrValues);
  inherited Destroy;
end;
//================= Список атрибутов группы (сортированный по порядк.№ +наимен.)
function TAttributeItems.GetListAttrsOfGroup(pGrpID: Integer): TStringList; // must Free
var i: Integer;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  with GetListSubCodeItems(pGrpID) do try
    Result.Capacity:= Result.Capacity+Count;
    for i:= 0 to Count-1 do Result.AddObject(GetDirItemName(Items[i]), Items[i]);
  finally Free; end;
//  Result.Capacity:= Result.Capacity+ItemsList.Count;
//  for i:= 0 to ItemsList.Count-1 do
//    if TAttributeItem(ItemsList[i]).SubCode=pGrpID then
  if Result.Count>1 then Result.CustomSort(DirNumNameSortCompareSL); // сортировка атрибутов (порядк.№ +наимен.)
end;
//===================================================== получить атрибут по коду
function TAttributeItems.GetAttr(attrID: Integer): TAttributeItem;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  Result:= TAttributeItem(DirItems[attrID]);
end;

//******************************************************************************
//                               TStoreInfo
//******************************************************************************
//==============================================================================
function TStoreInfo.GetDprtCode: string; // код склада символьный
begin
  if not Assigned(self) then Result:= '0' else Result:= IntToStr(DprtID);
end;

//******************************************************************************
//                               TDprtInfo
//******************************************************************************
constructor TDprtInfo.Create(pID, pSubCode, pOrderNum: Integer; pName: String;
  pSrcID: Integer; WithLinks: Boolean);
begin
  inherited Create(pID, pSubCode, pOrderNum, pName, pSrcID, WithLinks);
  FSchedule:= TObjectList.Create; // графики работы на заданное кол-во дней, 0- Date(), 1- Date()+1 и т.д.
end;
//==============================================================================
destructor TDprtInfo.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FSchedule);
  inherited Destroy;
end;
//============================================================== получить строку
function TDprtInfo.GetStrD(const ik: T8InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FName;                            //
    ik8_2: Result:= FShort;                           //
    ik8_3: if IsStoreHouse then Result:= FSubName;    // заголовок колонки (на складе)
    ik8_4: if IsFilial     then Result:= FSubName;    // Email счетов (на филиале)
    ik8_5: if not Cache.DprtExist(FilialID) then Result:= 'Нет филиала'
           else Result:= Cache.GetDprtMainName(FilialID);
  end;
end;
//==============================================================================
procedure TDprtInfo.SetStrD(const ik: T8InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
   ik8_1: if (FName <>Value) then FName := Value;  //
   ik8_2: if (FShort<>Value) then FShort:= Value;  //
   ik8_3: if IsStoreHouse and (FSubName<>Value) then FSubName:= Value;  // заголовок колонки (на складе)
   ik8_4: if IsFilial     and (FSubName<>Value) then FSubName:= Value;  // Email счетов (на филиале)
  end;
end;
//============================================================== получить строку
function TDprtInfo.GetIntD(const ik: T8InfoKinds): integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FOrderNum;  // MasterCode
    ik8_2: Result:= FSubCode;   // код филиала
    ik8_3: Result:= FDelayTime; // время запаздывания в мин
  end;
end;
//==============================================================================
procedure TDprtInfo.SetIntD(const ik: T8InfoKinds; Value: integer);
begin
  if not Assigned(self) then Exit;
  case ik of
   ik8_1: if (FOrderNum <>Value) then FOrderNum := Value;  // MasterCode
   ik8_2: if (FSubCode  <>Value) then FSubCode  := Value;  // код филиала
   ik8_3: if (FDelayTime<>Value) then FDelayTime:= Value;  // время запаздывания в мин
  end;
end;
//==============================================================================
procedure TDprtInfo.SetFilialID(pID: integer);
var Filial: integer;
begin
  if not Assigned(self) then Exit;
  if IsFilial then begin
    FilialID:= pID;
    Exit;
  end;
  FilialID:= 0;
  Filial:= ParentID;
  repeat
    if not Cache.DprtExist(Filial) then Filial:= -1
    else if Cache.arDprtInfo[Filial].IsFilial then begin
      FilialID:= Filial;
      Filial:= -1;
    end else Filial:= Cache.arDprtInfo[Filial].ParentID;
  until Filial<0;
//  prMessageLOGS('SetFilialID: id='+IntToStr(id)+' FilialID='+IntToStr(FilialID), fLogCache, false);
end;
//========================================== признак вхождения в заданную группу
function TDprtInfo.IsInGroup(pGroup: Integer): Boolean;
var parID: Integer;
    Dprt: TDprtInfo;
begin
  Result:= False;
  if not Assigned(self) or not Cache.DprtExist(pGroup) then Exit;
  parID:= ParentID;
  Result:= (ID=pGroup) or (parID=pGroup);
  while not Result and Cache.DprtExist(parID) do begin
    Dprt:= Cache.arDprtInfo[parID];
    parID:= Dprt.ParentID;
    Result:= (Dprt.ID=pGroup) or (parID=pGroup);
  end;
end;
//============================== проверка доступности отгрузки по графику работы
function TDprtInfo.CheckShipAvailable(pShipDate: TDateTime; stID: Integer=0;
         WithSVKDelay: Boolean=False; WithSchedule: Boolean=False): String;
// если stID не задан - время не проверяем !!!
var compDate, DayIndex, TestDayTime1, TestDayTime2: Integer;
    iHour, iMinute, iSec, iMsec: Word;
    st: TShipTimeItem;
    sch: TTwoCodes;
    strErr: String;
begin
  Result:= '';
  sch:= nil;
  try
    if (pShipDate<DateNull) then raise EBOBError.Create('Отсутствует дата отгрузки');
    compDate:= CompareDate(pShipDate, Date);
    strErr:= 'Заданная дата отгрузки недоступна';
    if (compDate<0) then raise EBOBError.Create(strErr); // дата меньше сегодняшней

    if WithSchedule then begin // проверяем дату по графику работы склада
      DayIndex:= trunc(pShipDate-Date);
      if (Schedule.Count<(DayIndex+1)) then raise EBOBError.Create(strErr);
      sch:= TTwoCodes(Schedule[DayIndex]); // проверяем дату по графику работы склада
      if (sch.ID1<1) and (sch.ID2<1) then raise EBOBError.Create(strErr);
    end;

    if (stID<1) then Exit; // время не задано - выходим
//    if (stID<1) then raise EBOBError.Create('Отсутствует время отгрузки');

    strErr:= 'Заданное время отгрузки недоступно';
    if not Cache.ShipTimes.ItemExists(stID) then raise EBOBError.Create(strErr);
    st:= Cache.ShipTimes[stID];
    TestDayTime1:= (st.Hour*60+st.Minute);

    if WithSchedule then begin // проверяем время по графику работы склада
      TestDayTime2:= TestDayTime1*60;
      if (TestDayTime2<sch.ID1) or (TestDayTime2>sch.ID2) then raise EBOBError.Create(strErr);
    end;

    if (compDate>0) then Exit; // если не сегодня - выходим

    DecodeTime(Now, iHour, iMinute, iSec, iMsec); // сегодня проверяем текущее время
    TestDayTime2:= iHour*60+iMinute+DelayTime;    // + запаздывание склада
    if WithSVKDelay then                        // + запаздывание СВК
      TestDayTime2:= TestDayTime2+Cache.GetConstItem(pcSVKShipDelayMinutes).IntValue;
    if (TestDayTime1<TestDayTime2) then raise EBOBError.Create(strErr);
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS('CheckShipAvailable: '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//============================================== границы времен отгрузки на дату
function TDprtInfo.GetShipTimeLimits(pShipDate: TDateTime; var TimeMin, TimeMax: Integer;
                           flWithSVKDelay: Boolean=False): String;
// вызывать только после проверки даты отгрузки !!!
var compDate, DayIndex, TestDayTime: Integer;
    iHour, iMinute, iSec, iMsec: Word;
    strErr: String;
    sch: TTwoCodes;
begin
  Result:= '';
  try
    compDate:= CompareDate(pShipDate, Date);
    strErr:= 'Заданная дата отгрузки недоступна';
    if (compDate<0) then raise EBOBError.Create(strErr); // дата меньше сегодняшней

    DayIndex:= trunc(pShipDate-Date);
    if (Schedule.Count<(DayIndex+1)) then raise EBOBError.Create(strErr);

    sch:= TTwoCodes(Schedule[DayIndex]);
    TimeMin:= sch.ID1;
    TimeMax:= sch.ID2;
    if (TimeMin<1) and (TimeMax<1) then raise EBOBError.Create(strErr);

    if (compDate>0) then Exit;

    DecodeTime(Now, iHour, iMinute, iSec, iMsec); // сегодня проверяем текущее время
    TestDayTime:= iHour*60+iMinute+DelayTime;    // запаздывание склада
    if flWithSVKDelay then                       // запаздывание СВК
      TestDayTime:= TestDayTime+Cache.GetConstItem(pcSVKShipDelayMinutes).IntValue;
    TestDayTime:= TestDayTime*60;
    if (TimeMin<TestDayTime) then TimeMin:= TestDayTime;

  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      prMessageLOGS('GetShipTimeLimits: '+E.Message);
      Result:= MessText(mtkErrProcess);
    end;
  end;
end;
//******************************************************************************
//                               TClientInfo
//******************************************************************************
constructor TClientInfo.Create(pID: Integer; pName: String);
begin
  inherited Create(pID, 0, 0, pName, 2);
  LastTestTime:= DateNull;
//  LastPriceLoadTime:= DateNull;
  CS_client:= TCriticalSection.Create; // для изменения параметров клиента
  TestSearchCountDay:= Date;
  FCountSearch := -1;                  // начальное значение счетчика
  FCountQty    := 0;                   // начальное значение счетчика
  LastCountQtyTime:= Now;
  LastCountConnectTime:= Now;
  FCountConnect:= 0;                   // начальное значение счетчика
  TmpBlockTime:= 0;                    // время окончания временной блокировки
  FLastContract:= 0;
  CliContracts:= TIntegerList.Create;   // контракты клиента                      // PartiallyFilled
//  CliContStores:= TObjectList.Create;   // порядок складов по настройкам клиента по контрактам
  CliContMargins:= TObjectList.Create;  // наценки клиента по контрактам
  CliMails:= fnCreateStringList(True, DupIgnore);
  CliPhones:= fnCreateStringList(True, DupIgnore);
  CliContDefs:= TObjectList.Create;      // настройки клиента по контрактам (TTwoCodes) в соотв.с CliContracts
end;
//==================================================
destructor TClientInfo.Destroy;
var i: Integer;
begin
  if not Assigned(self) then Exit;
//  for i:= 0 to CliContStores.Count-1 do TIntegerList(CliContStores[i]).Free;
//  prFree(CliContStores);
  for i:= 0 to CliContMargins.Count-1 do TLinkList(CliContMargins[i]).Free;
  prFree(CliContMargins);
  for i:= 0 to CliContDefs.Count-1 do TTwoCodes(CliContDefs[i]).Free;
  prFree(CliContDefs);
  prFree(CliContracts);
  prFree(CS_client);
  prFree(CliMails);
  prFree(CliPhones);
  inherited;
end;
//============================================================== записать строку
procedure TClientInfo.SetStrC(const ik: T8InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
    ik8_1: if (FLogin   <>Value) then FLogin   := Value; // логин
    ik8_2: if (FPassword<>Value) then FPassword:= Value; // пароль
//    ik8_3: if (FMail    <>Value) then FMail    := Value; // Email
//    ik8_4: if (FPhone   <>Value) then FPhone   := Value; // телефоны
    ik8_5: if (FPost    <>Value) then FPost    := Value; // должность
    ik8_8: if (FSid     <>Value) then FSid     := Value; // sid
  end;
end;
//============================================================== получить строку
function TClientInfo.GetStrC(const ik: T8InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FLogin;    // логин
    ik8_2: Result:= FPassword; // пароль
    ik8_3: Result:= fnGetDelimiterText(CliMails, ',', '');     // Email
//    ik8_3: Result:= FMail;     // Email
//    ik8_4: Result:= FPhone;    // телефоны
    ik8_4: Result:= fnGetDelimiterText(CliPhones, ',', '');    // телефоны
    ik8_5: Result:= FPost;     // должность
    ik8_6: Result:= IntToStr(SearchCurrencyID);                                    // SearchCurrencyID символьный
    ik8_7: if Cache.FirmExist(FirmID) then Result:= Cache.arFirmInfo[FirmID].Name; // наименование фирмы
    ik8_8: Result:= FSid;      // sid
  end;
end;
//================================================================= получить код
function TClientInfo.GetIntC(const ik: T16InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik16_1 : Result:= FSubCode;             // код фирмы
    ik16_2 : Result:= FSrcID;
    ik16_3 : Result:= FOrderNum;
    ik16_4 : Result:= FDEFACCOUNTINGTYPE;
    ik16_5 : Result:= FDEFDELIVERYTYPE;
    ik16_6 : Result:= FCountSearch;
    ik16_7 : Result:= FCountQty;
    ik16_8 : Result:= FCountConnect;
    ik16_9 : Result:= FLastContract;
    ik16_10: Result:= FBlockKind;
  end;
end;
//================================================================= записать код
procedure TClientInfo.SetIntC(const ik: T16InfoKinds; Value: Integer);
begin
  if not Assigned(self) then Exit else case ik of
    ik16_1 : if (FSubCode          <>Value) then FSubCode          := Value; // код фирмы
    ik16_2 : if (FSrcID            <>Value) then FSrcID            := Value;
    ik16_3 : if (FOrderNum         <>Value) then FOrderNum         := Value;
    ik16_4 : if (FDEFACCOUNTINGTYPE<>Value) then FDEFACCOUNTINGTYPE:= Value;
    ik16_5 : if (FDEFDELIVERYTYPE  <>Value) then FDEFDELIVERYTYPE  := Value;
    ik16_6 : if (FCountSearch      <>Value) then FCountSearch      := Value;
    ik16_7 : if (FCountQty         <>Value) then FCountQty         := Value;
    ik16_8 : if (FCountConnect     <>Value) then FCountConnect     := Value;
    ik16_9 : if (FLastContract     <>Value) then FLastContract     := Value;
    ik16_10: if (FBlockKind        <>Value) then FBlockKind        := Value;
  end;
end;
//======================================= проверка доступности контракта клиенту
function TClientInfo.CheckContract(contID: Integer): boolean;
begin
  Result:= False;
  if not Assigned(self) or (ID<1) or (CliContracts.Count<1) then Exit;
  Result:= Cache.Contracts.ItemExists(contID) and Cache.FirmExist(FirmID)
    and Cache.arFirmInfo[FirmID].CheckContract(contID)
    and (CliContracts.IndexOf(contID)>-1);
end;
{//========================================== индекс склада в списке по контракту
function TClientInfo.GetCliStoreIndex(contID, StoreID: Integer): Integer;
var i: integer;
begin
  Result:= -1;
  if not Assigned(self) or (ID<1) then Exit;
  i:= CliContracts.IndexOf(contID);    // индекс контракта
  if (i<0) then Exit;
  if (CliContStores.Count<(i+1)) or not Assigned(CliContStores[i]) then Exit;
  try
    Result:= TIntegerList(CliContStores[i]).IndexOf(StoreID);    // индекс склада
  except
    Result:= -1;
  end;
end; }
//========================================= добавляем контракт в список (в базу)
function TClientInfo.AddCliContract(contID: Integer; OnlyCache: Boolean=False): Integer;
var OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
begin
  Result:= -1;
  if not Assigned(self) or (ID<1) then Exit;
  if not Cache.Contracts.ItemExists(contID) or not Cache.FirmExist(FirmID)
    or not Cache.arFirmInfo[FirmID].CheckContract(contID) then Exit;

  Result:= CliContracts.IndexOf(contID);        // индекс контракта
  if (Result>-1) then Exit;

  if not OnlyCache then begin
    ORDIBS:= nil;
    OrdIBD:= cntsOrd.GetFreeCnt;
    try
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_AddCliContract', -1, tpWrite, true);
      OrdIBS.SQL.Text:= 'update or insert into WEBCLIENTCONTRACTS (WCCCLIENT, WCCCONTRACT, WCCARCHIVE)'+
        ' values ('+IntToStr(ID)+', '+IntToStr(contID)+', "F") matching (WCCCLIENT, WCCCONTRACT)';
      OrdIBS.ExecQuery;
      OrdIBS.Transaction.Commit;
    finally
      prFreeIBSQL(OrdIBS);
      cntsOrd.SetFreeCnt(OrdIBD);
    end;
  end;

  CS_client.Enter;
  try
    Result:= CliContracts.Add(contID);
//    CliContStores.Insert(Result, TIntegerList.Create);
    CliContMargins.Insert(Result, TLinkList.Create);
    CliContDefs.Insert(Result, TTwoCodes.Create(0, 0));
    UpdateStorageOrderC;
  finally
    CS_client.Leave;
  end;
end;
//========================================= удаляем контракт из списка (из базы)
procedure TClientInfo.DelCliContract(contID: Integer; OnlyCache: Boolean=False);
var i: integer;
    OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
begin
  if not Assigned(self) or (ID<1) then Exit;
  i:= CliContracts.IndexOf(contID);      // индекс контракта
  if (i<0) then Exit;

  if not OnlyCache then begin
    ORDIBS:= nil;
    OrdIBD:= cntsOrd.GetFreeCnt;
    try
      OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_DelCliContract', -1, tpWrite, true);
      OrdIBS.SQL.Text:= 'update or insert into WEBCLIENTCONTRACTS (WCCCLIENT, WCCCONTRACT, WCCARCHIVE)'+
        ' values ('+IntToStr(ID)+', '+IntToStr(contID)+', "T") matching (WCCCLIENT, WCCCONTRACT)';
      OrdIBS.ExecQuery;
      OrdIBS.Transaction.Commit;
    finally
      prFreeIBSQL(OrdIBS);
      cntsOrd.SetFreeCnt(OrdIBD);
    end;
  end;

  CS_client.Enter;
  try
//    CliContStores.Delete(i);             // удаляем склады
    CliContMargins.Delete(i);            // удаляем наценки
    CliContDefs.Delete(i);               // удаляем настройки
    CliContracts.Delete(i);              // удаляем контракт
  finally
    CS_client.Leave;
  end;
end;
//=========================== получить код текущего/доступного контракта клиента
function TClientInfo.GetCliCurrContID: Integer;
var errmess: string;
begin
  Result:= 0;
  if not Assigned(self) or (ID<1) then Exit;
  if (CliContracts.Count<1) then // если нет доступных контрактов
    raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));
  Result:= LastContract; //  берем последний активный
  if (Result<1) or (CliContracts.IndexOf(Result)<0) then  // если не подходит
    Result:= Cache.arFirmInfo[FirmID].GetDefContractID; // берем Default
  if (CliContracts.IndexOf(Result)<0) then  // если не подходит
    Result:= CliContracts[0]; // берем первый в списке
  if not Cache.Contracts.ItemExists(Result) then
    raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));
  if (Result<>LastContract) then begin // меняем LastContract
    errmess:= SetLastContract(Result);
    if (errmess<>'') then raise EBOBError.Create(errmess);
  end;
end;
//========================================== получить доступный контракт клиента
function TClientInfo.GetCliContract(var contID: Integer; ChangeNotFound: Boolean=False): TContract;
var i: integer;
begin
  Result:= nil;
  if not Assigned(self) or (ID<1) then Exit;
  if (CliContracts.Count<1) then // если нет доступных контрактов
    raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));
  i:= ContID;
  if (i<1) then i:= GetCliCurrContID // если контракт не задан - ищем код текущего/доступного контракта клиента
  else if (CliContracts.IndexOf(i)<0) then begin // если контракт задан - проверяем
    if ChangeNotFound then i:= GetCliCurrContID
    else raise EBOBError.Create('Контракт не доступен');
  end;
  if not Cache.Contracts.ItemExists(i) then
    raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));
  contID:= i;
  Result:= Cache.Contracts[contID];
end;
//========================================== изменить последний контракт клиента
function TClientInfo.SetLastContract(contID: Integer): String;
const nmProc = 'SetLastContract'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    firma: TFirmInfo;
begin
  Result:= '';
  if not Assigned(self) or (ID<1) then Exit;
  IBS:= nil;
  try
    if (CliContracts.Count<1) or (contID<1) or (CliContracts.IndexOf(contID)<0) then
      raise EBOBError.Create(MessText(mtkNotFoundAvaiCont));

    if not Cache.FirmExist(FirmID) then raise EBOBError.Create(MessText(mtkNotFirmExists));
    firma:= Cache.arFirmInfo[FirmID]; // Проверяем, доступен ли вообще этот контракт
    if not firma.CheckContract(contID) then raise EBOBError.Create('Контракт к/а не найден');

    if (contID=LastContract) then Exit;

    IBD:= cntsORD.GetFreeCnt;
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, -1, tpWrite, true);
      IBS.SQL.Text:= 'update WEBORDERCLIENTS set WOCLLASTCONTRACT='+
        IntToStr(contID)+' where WOCLCODE='+IntToStr(ID);
      IBS.ExecQuery;
      IBS.Transaction.Commit;
      IBS.Close;
      LastContract:= contID;
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD);
    end;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
end;
//============================================= ссылка на настройки по контракту
function TClientInfo.GetCliContDefs(contID: Integer=0): TTwoCodes; // not Free !!!
var i: integer;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  if not CheckContract(contID) then contID:= LastContract;
  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;
  Result:= TTwoCodes(CliContDefs[i]);
end;
//=============================================== проверка настроек по контракту
procedure TClientInfo.CheckCliContDefs(contID, deliv, dest: Integer);
var i: integer;
begin
  if not Assigned(self) then Exit;
  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;
  with TTwoCodes(CliContDefs[i]) do begin
    if (ID1<>deliv) then ID1:= deliv;
    if (ID2<>dest)  then ID2:= dest;
  end;
end;

//=============================================== ссылки на наценки по контракту
function TClientInfo.GetContMarginLinks(contID: Integer): TLinkList; // not Free !!!
var i: integer;
begin
  Result:= TLinkList(EmptyList);
  if not Assigned(self) then Exit;
  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;
  Result:= TLinkList(CliContMargins[i]);
end;
//===================================== наценка по группе/подгруппе по контракту
function TClientInfo.GetContCacheGrpMargin(contID, grID: Integer): Double;
var lst: TLinkList;
    link: TQtyLink;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  lst:= GetContMarginLinks(contID);
  if (lst.Count<1) then Exit;
  link:= lst.GetLinkListItemByID(grID, lkLnkByID);
  if Assigned(link) then Result:= link.Qty;
end;
//================= список групп/подгрупп с наценками по контракту (TCodeAndQty)
function TClientInfo.GetContMarginListAll(contID: Integer;     // must Free !!!
         WithPgr: Boolean=False; OnlyNotZero: Boolean=False): TList;
var i, j, sysID, grID: integer;
    mlst: TLinkList;
    grlst, pgrlst: TList;
    marg: Double;
    gr: TWareInfo;
    mlink: TQtyLink;
begin
  Result:= TList.Create;
  if not Assigned(self) then Exit;
  if not CheckContract(contID) then Exit;
//  sysID:= GetCliContract(contID).SysID;  // систему - по контракту
  sysID:= 0;  //
  mlst:= GetContMarginLinks(contID);         // ссылки на наценки клиента
  grlst:= Cache.MarginGroups.GetGroupList(sysID); // список групп
  for i:= 0 to grlst.Count-1 do begin
    gr:= grlst[i];         // группа
    grID:= gr.ID;
    mlink:= mlst.GetLinkListItemByID(grID, lkLnkByID); // ищем наценку
    if Assigned(mlink) then marg:= mlink.Qty else marg:= 0;
    if not OnlyNotZero or fnNotZero(marg) then
      Result.Add(TCodeAndQty.Create(Integer(gr), marg)); // ссылка на группу -> Integer, наценка

    if not WithPgr then Continue; // только группы

    pgrlst:= Cache.MarginGroups.GetSubGroupList(grID, sysID); // список подгрупп группы
    for j:= 0 to pgrlst.Count-1 do begin
      gr:= pgrlst[j];         // подгруппа
      grID:= gr.ID;
      mlink:= mlst.GetLinkListItemByID(grID, lkLnkByID); // ищем наценку
      if Assigned(mlink) then marg:= mlink.Qty else marg:= 0;
      if not OnlyNotZero or fnNotZero(marg) then
        Result.Add(TCodeAndQty.Create(Integer(gr), marg)); // ссылка на подгруппу -> Integer, наценка
    end;
  end;
end;
//================================== проверяем наценку по группе/подгуппе в базе
function TClientInfo.CheckCliContMargin(contID, grID: Integer; marg: Double): String;
const nmProc = 'CheckCliContMargin';
var OrdIBS: TIBSQL;
    OrdIBD: TIBDatabase;
    i: Integer;
begin
  Result:= '';
  if not Assigned(self) or (ID<1) then Exit;
  ORDIBD:= nil;
  ORDIBS:= nil;
  try try
    OrdIBD:= cntsOrd.GetFreeCnt;
    OrdIBS:= fnCreateNewIBSQL(OrdIBD, 'OrdIBS_'+nmProc, -1, tpWrite, true);
    OrdIBS.SQL.Text:= 'select ResCode from CheckCliContMargin('+
      IntToStr(ID)+', '+IntToStr(contID)+', '+IntToStr(grID)+', :marg)';
    OrdIBS.ParamByName('marg').AsFloat:= marg;
    for i:= 0 to RepeatCount do with OrdIBS.Transaction do try
      Application.ProcessMessages;
      OrdIBS.Close;
      if not InTransaction then StartTransaction;
      OrdIBS.ExecQuery;
      if (OrdIBS.Bof and OrdIBS.Eof) then raise Exception.Create('ошибка записи в базу');
      if (OrdIBS.FieldByName('ResCode').AsInteger>0) then OrdIBS.Transaction.Commit;
      break;
    except
      on E: Exception do begin
        RollbackRetaining;
        if (i<RepeatCount) then sleep(RepeatSaveInterval) else Result:= E.Message;
      end;
    end;
  finally
    prFreeIBSQL(OrdIBS);
    cntsOrd.SetFreeCnt(OrdIBD);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;

{//============================================================== добавляем склад
procedure TClientInfo.AddCliStoreCode(contID, StoreID: Integer);
var i: integer;
    codes: TIntegerList;
begin
  if not Assigned(self) then Exit;

  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;

  codes:= TIntegerList(CliContStores[i]);
  i:= codes.IndexOf(StoreID);
  if (i>-1) then Exit;

  CS_client.Enter;
  try
    codes.Add(StoreID); // добавляем склад
  finally
    CS_client.Leave;
  end;
end;
//================================================================ удаляем склад
procedure TClientInfo.DelCliStoreCode(contID, StoreID: Integer);
var i: integer;
    codes: TIntegerList;
begin
  if not Assigned(self) then Exit;

  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;

  codes:= TIntegerList(CliContStores[i]);
  i:= codes.IndexOf(StoreID);
  if (i<0) then Exit;

  CS_client.Enter;
  try
    codes.Delete(i); // удаляем склад
  finally
    CS_client.Leave;
  end;
end;
//========================================================== склады по контракту
function TClientInfo.GetContStoreCodes(contID: Integer): TIntegerList; // not Free !!!
var i: integer;
begin
  Result:= EmptyIntegerList;
  if not Assigned(self) then Exit;

  i:= CliContracts.IndexOf(contID);        // индекс контракта
  if (i<0) then Exit;

  Result:= TIntegerList(CliContStores[i]);
end; }
//============= проверяет соответствие складов клиента видимым складам контракта
procedure TClientInfo.UpdateStorageOrderC;
const nmProc = 'UpdateStorageOrderС';
var ii,{ VisibleCount,} StoreID, jj, contID, i, MainUser, deliv, dest: integer;
    flEx, flArh, flDel: boolean;
    FirmCode, UserCode: string;
    Firma: TFirmInfo;
    Contract: TContract;
    listChange: TStringList;
    Conts, Stores{, Temp}: TIntegerList;
    IBSord: TIBSQL;
    IBDord: TIBDatabase;
    marg: Double;
    mlst: TLinkList;
    link: TQtyLink;
  //----------------------------------------------------------------------------
  procedure LoadStorageOrderFromGB;
//  var i: Integer;
//    IBSgb: TIBSQL;
//    IBDgb: TIBDatabase;
  begin
{    IBSgb:= nil;
    IBDgb:= cntsGRB.GetFreeCnt;
    try
      IBSgb:= fnCreateNewIBSQL(IBDgb, 'IBSgb_'+nmProc, -1, tpRead, True);
      IBSgb.SQL.Text:= 'select STORDPRTCODE, STORORDER from STORAGESORDER_VLAD'+
                       ' where STORPERSONCODE='+UserCode+' order by STORORDER';
}
      if (LastContract>0) then begin
        contID:= LastContract;
        Contract:= Firma.GetContract(contID);
      end else begin
        Contract:= Firma.GetDefContract;   // def-контракт фирмы
        contID:= Contract.ID;
      end;
      ii:= CliContracts.IndexOf(contID); // индекс def-контракта в списке клиента
      listChange.Add('update or insert into WEBCLIENTCONTRACTS (WCCCLIENT, WCCCONTRACT)'+
        ' values ('+UserCode+', '+IntToStr(contID)+') matching (WCCCLIENT, WCCCONTRACT);');
      if (ii<0) then ii:= AddCliContract(contID, True); // если контракта нет в списке клиента - добавляем
{
      Stores.Clear; // здесь собираем только видимые склады
      IBSgb.ExecQuery;
      if (IBSgb.EOF and IBSgb.BOF) then Exit;
      while not IBSgb.Eof do begin
        StoreID:= IBSgb.FieldByName('STORDPRTCODE').AsInteger;
        if (Contract.GetСontStoreIndex(StoreID)>-1) then begin
          jj:= IBSgb.FieldByName('STORORDER').AsInteger;
          if (jj<1000) then begin
            jj:= 100;
            Stores.Add(StoreID); // собираем коды складов клиента по контракту
          end;
          listChange.Add('execute procedure ChangeCliContrStoreOrder('+
            UserCode+', '+IntToStr(contID)+', '+IntToStr(StoreID)+', '+IntToStr(jj)+');');
        end;
        IBSgb.Next;
      end;
      IBSgb.Close;

      Temp:= TIntegerList(CliContStores[ii]);
      CS_client.Enter;
      try
        for i:= Temp.Count-1 downto Stores.Count do Temp.Delete(i);                  // лишнее кол-во удаляем
        for i:= 0 to Temp.Count-1 do if Temp[i]<>Stores[i] then Temp[i]:= Stores[i]; // имеющееся кол-во сверяем
        ii:= Temp.Count;
        for i:= ii to Stores.Count-1 do Temp.Add(Stores[i]);                         // новое кол-во добавляем
      finally
        CS_client.Leave;
      end;  }
      Conts.Remove(contID); // проверили def-контракт - удаляем из рабочего списка
{    finally
      prFreeIBSQL(IBSgb);
      cntsGRB.SetFreeCnt(IBDgb);
    end;  }
  end;
  //----------------------------------------------------------------------------
begin
  if not Assigned(self) or (ID<1) then Exit;
  IBSord:= nil;
  IBDord:= nil;
  listChange:= TStringList.Create; // строки SQL для изменений
  Conts:= TIntegerList.Create;     // рабочий список контрактов фирмы для сверки
  Stores:= TIntegerList.Create;    // рабочий список складов контракта для сверки
  try try
    IBDord:= cntsORD.GetFreeCnt;
    IBSord:= fnCreateNewIBSQL(IBDord, 'IBSord_'+nmProc, -1, tpWrite, True);

    UserCode:= IntToStr(ID);
    FirmCode:= IntToStr(FirmID);
    Firma:= Cache.arFirmInfo[FirmID];
    MainUser:= Firma.SUPERVISOR;

    for i:= 0 to Firma.FirmContracts.Count-1 do // контракты фирмы - в рабочий список
      Conts.Add(Firma.FirmContracts[i]);

{    IBSord.SQL.Text:= 'Select wc.*, rOrder, rDprt from'+   //
                      ' (select WCCCONTRACT, WCCARCHIVE, WCCDeliveryDef, wccDestDef'+
                      '  from WEBCLIENTCONTRACTS WHERE WCCCLIENT='+UserCode+') wc'+
                      ' left join GetCliContrStoreOrder('+UserCode+', WCCCONTRACT) on 1=1'; }
    IBSord.SQL.Text:= 'select WCCCONTRACT, WCCARCHIVE, WCCDeliveryDef, wccDestDef'+
                      ' from WEBCLIENTCONTRACTS WHERE WCCCLIENT='+UserCode;
    IBSord.ExecQuery;
    if (IBSord.EOF and IBSord.BOF) then
      LoadStorageOrderFromGB // если у клиента нет записей - ищем в Гроссби

    else while not IBSord.EOF do begin
      contID:= IBSord.FieldByName('WCCCONTRACT').AsInteger;  // контракт
      flArh:= GetBoolGB(IBSord, 'WCCARCHIVE');
      flEx:= (CliContracts.IndexOf(contID)>-1);
//----------------------------------------- проверяем контракт из списка клиента
      if (Conts.IndexOf(contID)<0) then begin // если у фирмы нет контракта (закрыт)
        if not flArh then begin
          flArh:= True;            // пометить контракт клиента, как недоступный
          listChange.Add('update WEBCLIENTCONTRACTS set WCCARCHIVE="T"'+
            ' WHERE WCCCLIENT='+UserCode+' and WCCCONTRACT='+IntToStr(contID)+';');
        end;
        flDel:= flEx;
      end else begin
        if flArh and (ID=MainUser) then begin
          flArh:= False;            // пометить контракт клиента, как доступный
          listChange.Add('update WEBCLIENTCONTRACTS set WCCARCHIVE="F"'+
            ' WHERE WCCCLIENT='+UserCode+' and WCCCONTRACT='+IntToStr(contID)+';');
        end;
        flDel:= flEx and flArh;
        Conts.Remove(contID); // проверили контракт - удаляем из рабочего списка
      end;

      if flDel then DelCliContract(contID); // если контракт был в списке клиента - удаляем
      if flArh then begin                   // прокручиваем записи по недоступному контракту
        while not IBSord.EOF and (contID=IBSord.FieldByName('WCCCONTRACT').AsInteger) do IBSord.Next;
        Continue;
      end;

      if not flEx then AddCliContract(contID, True); // если контракта нет в списке клиента - добавляем
      Contract:= Firma.GetContract(contID);

      deliv:= IBSord.FieldByName('WCCDeliveryDef').AsInteger;
      dest:= IBSord.FieldByName('wccDestDef').AsInteger;
      CheckCliContDefs(contID, deliv, dest); // проверка настроек по контракту

//----------------------------------- проверяем рабочий список складов контракта
      Stores.Clear;
{       VisibleCount:= 0;
     while not IBSord.EOF and (contID=IBSord.FieldByName('WCCCONTRACT').AsInteger) do begin
        StoreID:= IBSord.FieldByName('rDprt').AsInteger;
        if (StoreID>0) then begin
          jj:= IBSord.FieldByName('rOrder').AsInteger;
          if (jj<1000) then inc(VisibleCount); // считаем, сколько складов видимых
          Stores.Add(StoreID);                 // собираем коды складов клиента по контракту в Stores
        end;
//        IBSord.Next;
      end;

      //------- проверяем, есть ли у клиента склады, запрещенные для контракта
      for i:= Stores.Count-1 downto 0 do          // если есть такие - удаляем
        if (Contract.GetСontStoreIndex(Stores[i])<0) then begin
          listChange.Add('execute procedure ChangeCliContrStoreOrder('+
                         UserCode+', '+IntToStr(contID)+', '+IntToStr(Stores[i])+', -1000);');
          DelCliStoreCode(contID, Stores[i]); // сразу удаляем из списка складов клиента
          Stores.Delete(i);                   // удаляем из рабочего списка
          if (i<VisibleCount) then Dec(VisibleCount);
        end;
      // проверяем, появились ли у контракта склады, отсутствовавшие или невидимые у клиента
      for i:= 0 to High(Contract.ContStorages) do begin
        StoreID:= Contract.ContStorages[i].DprtID;
        ii:= Stores.IndexOf(StoreID);
        // если у контракта появился склад, отсутствовавший у клиента - добавляем
        // если у контракта появился склад, доступный для резервирования, невидимый клиенту - делаем видимым
        if (ii<0) or ((VisibleCount<=ii) and Contract.ContStorages[i].IsReserve) then begin
          listChange.Add('execute procedure ChangeCliContrStoreOrder('+
                         UserCode+', '+IntToStr(contID)+', '+IntToStr(StoreID)+', 100);');
          if (ii<0) then Stores.Insert(VisibleCount, StoreID)
          else if (VisibleCount<ii) then Stores.Move(ii, VisibleCount);
          inc(VisibleCount);
        end;
      end;
//-------- приводим в соответствие склады клиента по контракту с рабочим списком
      ii:= CliContracts.IndexOf(contID); // индекс контракта
      Temp:= TIntegerList(CliContStores[ii]);
      CS_client.Enter;
      try
        for i:= Temp.Count-1 downto VisibleCount do Temp.Delete(i);                  // лишнее кол-во удаляем
        for i:= 0 to Temp.Count-1 do if Temp[i]<>Stores[i] then Temp[i]:= Stores[i]; // имеющееся кол-во сверяем
        ii:= Temp.Count;                                                             // новое кол-во добавляем
        for i:= ii to VisibleCount-1 do Temp.Add(Stores[i]);
      finally
        CS_client.Leave;
      end; }
      IBSord.Next;
    end;
    IBSord.Close;

    for i:= 0 to Conts.Count-1 do begin // если главный пользователь и остались непроверенные контракты фирмы
      contID:= Conts[i];
      ii:= CliContracts.IndexOf(contID);
      if (ii<0) then begin
        if (ID<>MainUser) then Continue; // если не главный пользователь - пропускаем
        ii:= AddCliContract(contID, True); // если главный пользователь - добавляем контракт в список
      end;
      listChange.Add('update or insert into WEBCLIENTCONTRACTS (WCCCLIENT, WCCCONTRACT, WCCArchive)'+
        ' values ('+UserCode+', '+IntToStr(contID)+', "F") matching (WCCCLIENT, WCCCONTRACT);');

{      Temp:= TIntegerList(CliContStores[ii]);
      if (Temp.Count>0) then Continue;  // на всяк.случай

      //---------------------- если складов нет - добавляем все склады контракта
      Contract:= Firma.GetContract(contID);
      for ii:= 0 to High(Contract.ContStorages) do begin
        StoreID:= Contract.ContStorages[ii].DprtID;
        listChange.Add('execute procedure ChangeCliContrStoreOrder('+
                       UserCode+', '+IntToStr(contID)+', '+IntToStr(StoreID)+', 100);');
        Temp.Add(StoreID);
      end; }
    end;

    if (CliContracts.Count>0) and ((LastContract<1) or (CliContracts.IndexOf(LastContract)<0)) then begin  // ???
      contID:= CliContracts[0];
      listChange.Add('update WEBORDERCLIENTS set WOCLLASTCONTRACT='+
        IntToStr(contID)+' where WOCLCODE='+UserCode+';');
      LastContract:= contID;
    end;

    if (listChange.Count>0) then begin //--------------------- если есть изменения
      listChange.Insert(0, 'execute block as begin ');
      listChange.Add(' end');
      IBSord.SQL.Clear;
      with IBSord.Transaction do if not InTransaction then StartTransaction;
      IBSord.SQL.AddStrings(listChange);
      IBSord.ExecQuery;                  // меняем в базе
      IBSord.Close;
      with IBSord.Transaction do if InTransaction then Commit;
    end;

//---------------------------------------------------------------------- наценки
    IBSord.Close;
    fnSetTransParams(IBSord.Transaction, tpRead, True);
    IBSord.SQL.Text:= 'Select WCCCONTRACT, WCCMGrPgrCode, WCCMmargin from'+
                      ' (select WCCCODE, WCCCONTRACT '+
                      '   from WEBCLIENTCONTRACTS WHERE WCCCLIENT='+UserCode+
                      '     and WCCARCHIVE="F" order by WCCCONTRACT)'+
                      ' left join WebCliContMargins on WCCMCliCont=WCCCODE';
    IBSord.ExecQuery;
    while not IBSord.EOF do begin
      contID:= IBSord.FieldByName('WCCCONTRACT').AsInteger;  // контракт
      jj:= CliContracts.IndexOf(contID);
      if (jj<0) then begin      // прокручиваем записи по недоступному контракту
        while not IBSord.EOF and (contID=IBSord.FieldByName('WCCCONTRACT').AsInteger) do IBSord.Next;
        Continue;
      end;

      mlst:= TLinkList(CliContMargins[jj]);
      mlst.SetLinkStates(False, CS_client);
      while not IBSord.EOF and (contID=IBSord.FieldByName('WCCCONTRACT').AsInteger) do begin
        StoreID:= IBSord.FieldByName('WCCMGrPgrCode').AsInteger; // код группы/подгруппы
        marg   := IBSord.FieldByName('WCCMmargin').AsFloat;      // наценка
        if fnNotZero(marg) and Cache.GrPgrExists(StoreID) then begin
          link:= mlst.GetLinkListItemByID(StoreID, lkLnkByID);
          if not Assigned(link) then begin
            link:= TQtyLink.Create(0, marg, Cache.arWareInfo[StoreID]);
            mlst.AddLinkListItem(link, lkLnkByID, CS_client);
          end else begin
            link.Qty:= marg;
            link.State:= True;
          end;
        end;
        IBSord.Next;
      end;
      mlst.DelNotTestedLinks(CS_client);
    end;

  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'_'+UserCode+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+'_'+UserCode+': '+E.Message, fLogCache);
  end;
  finally
    prFree(listChange);
    prFree(Conts);
    prFree(Stores);
    prFreeIBSQL(IBSord);
    cntsORD.SetFreeCnt(IBDord);
  end;
{  if flDebug then for ii:= 0 to CliContracts.Count-1 do begin
    prMessageLOGS(nmProc+'_'+UserCode+': CliContract='+IntToStr(CliContracts[ii]), fLogDebug, false);
    Temp:= TIntegerList(CliContStores[ii]);
    for i:= 0 to Temp.Count-1 do
      prMessageLOGS(nmProc+'_'+UserCode+':    CliStoreCode='+IntToStr(Temp[i]), fLogDebug, false);
  end; }
end;
//========================================================== проверка блокировки
function TClientInfo.CheckBlocked(inCS: Boolean=False; mess: Boolean=False; Source: Integer=0): String;
const nmProc = 'CheckBlocked';
// iBlock, tLastAct - актуальные значения из базы, mess=True - вернуть в Result сообщение пользователю
var fl: Boolean;
    ss, sTimeTo, Delim: String;
//    tLastAct: TDateTime;
begin
  Result:= '';
  fl:= Blocked; // запоминаем состояние блокировки
  if InCS then CS_client.Enter;
  try

//-------------------------------------------------------- временно заблокирован
    if (BlockKind=cbBlockedTmpByConnLimit) then begin

      if (TmpBlockTime<1) then // вычисляем время окончания
        TmpBlockTime:= IncMinute(LastAct, Cache.GetConstItem(pcTmpBlockInterval).IntValue);

      if Now>TmpBlockTime then  //--------------- пора разблокировать временную
        if SaveClientBlockType(cbUnBlockedTmpByCSS, ID, LastAct) then // разблокировка клиента в базе
          BlockKind:= 0;                  // в кеше

//---------- другая блокировка - сбрасываем время окончания временной блокировки
    end else if (BlockKind in [cbBlockedByAdmin, cbBlockedByConnectLimit]) and (TmpBlockTime>0) then begin
      TmpBlockTime:= 0;

//--------- начался новый день - сбрасываем время окончания временной блокировки
    end else if (BlockKind=0) and (TmpBlockTime>0) and not SameDate(Now, TmpBlockTime) then begin
      TmpBlockTime:= 0;
    end;

    Blocked:= (BlockKind>0); // в кеше

    if Blocked and mess then begin // формируем сообщение пользователю о блокировке
      if not (Source in [cosByVlad, cosByWeb]) then Source:= cosByWeb;
      if Source=cosByVlad then Delim:= cStrVladDelim else Delim:= ''; // разделитель для Vlad

      ss:= MessText(mtkNotLoginProcess, Login); // 'Обработка запросов по логину '+Login+' заблокирована.'
      ss:= copy(ss, 1, length(ss)-1)+Delim; // отрезаем точку и добавляем разделитель для Vlad
      case BlockKind of
        cbBlockedBySearchLimit : ss:= ss+' из-за превышения лимита запросов.'; // из-за превышения лимита поисковых запросов за день
        cbBlockedByAdmin       : ss:= ss+' администратором системы заказов.'; // (вручную)
        cbBlockedTmpByConnLimit: begin
            sTimeTo:= FormatDateTime(cDateTimeFormatY4N, TmpBlockTime);
            ss:= ss+' до '+sTimeTo+Delim+' из-за превышения лимита запросов.';         // временно
          end;
        cbBlockedByConnectLimit: ss:= ss+' из-за повторного превышения лимита запросов.'; // окончательно
      end; // case
      Result:= ss;

    end else if not Blocked and fl then begin // если разблокировали - сбрасываем счетчики
      CountSearch:= 0;
      CountQty:= 0;
      CountConnect:= 0;
    end;
  finally
    if InCS then CS_client.Leave;
  end;
end;
//======================================== вкладываем отчет по запросам в письмо
procedure CheckRequestsAttach(clientID: Integer; var Att: TStringList; bTime, eTime: TDateTime);
const nmProc = 'CheckRequestsAttach';
var ss, nf: String;
begin
  ss:= fnRepClientRequests(clientID, bTime, eTime, nf);
  if (ss<>'') then prMessageLOGS(nmProc+': '+ss)
  else if (nf<>'') then Att.Add(nf);
end;
//================================================== проверяет счетчик коннектов
procedure TClientInfo.CheckConnectCount; // вызов - в prSetThLogParams
const nmProc = 'CheckConnectCount';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    iCount, CountLimit, LimitInterval, HistInterval, BlockType, minCount, secCount: Integer;
    s, adrTo, regMail, cliMail, sTimeTo, mess, CliMess, sCount, ss: String;
//    Empl: TEmplInfoItem;
    Body, Attach: TStringList;
    flTmpBlock, TestSending: Boolean;
    BlockTime, BeginTime, EndTime: TDateTime;
begin
  if not Assigned(self) or Arhived or Blocked then Exit; // заблокирован   
  Body:= nil;
  Attach:= nil;
  ORD_IBS:= nil;
  sTimeTo:= '';
  adrTo:= '';
  cliMess:= '';
  flTmpBlock:= TmpBlockTime<1;
  TestSending:= GetIniParamInt(nmIniFileBOB, 'Options', 'ConnectLimit_tmp', 0)=1;
  BeginTime:= LastCountConnectTime;
  EndTime  := Now();
  secCount:= SecondsBetween(BeginTime, EndTime);
  minCount:= secCount div 60; // кол-во минут
  secCount:= secCount mod 60;
  BlockTime:= EndTime;
  try //--------------------------------------------------------------- проверка
    CountLimit:= Cache.GetConstItem(pcClientConnectLimit).IntValue;
    LimitInterval:= Cache.GetConstItem(pcClientConnLimInterval).IntValue;
    CS_client.Enter;
    try
      if (minCount>=LimitInterval) then begin
        LastCountConnectTime:= Now;     // сбрасываем счетчик
        iCount:= 1;                                                         
      end else iCount:= CountConnect+1; // добавляем счетчик

      if iCount<>CountConnect then CountConnect:= iCount; // меняем значение счетчика клиента
      if CountConnect<=CountLimit then Exit; // не превышает - выходим

      sCount:= '  '+IntToStr(CountConnect)+' запросов за '+IntToStr(minCount)+' мин '+IntToStr(secCount)+' сек';

// begin ---------------- тестовая рассылка 2 - при [Options] ConnectLimit_tmp=1
      if TestSending then try
        Body:= TStringList.Create;
        Attach:= TStringList.Create;
        with Cache do try
          Body.Add(FormatDateTime(cDateTimeFormatY4S, Now()));
          Body.Add('Пользователь с логином <'+Login+'> (код '+IntToStr(ID)+')');
          Body.Add('  контрагент '+FirmName);
          if FirmExist(FirmID) then begin
            s:= arFirmInfo[FirmID].GetFirmManagersString([fmpName, fmpShort, fmpPref]);
            if (s<>'') then Body.Add('  '+s);
          end;
          Body.Add('превысил лимит обращений к системе:');
          Body.Add(sCount);

          adrTo:= Cache.GetConstEmails(pcTestingSending2, FirmID);
          if adrTo='' then adrTo:= fnGetSysAdresVlad(caeOnlyDayLess);

          CheckRequestsAttach(ID, Attach, BeginTime, EndTime); // вкладываем отчет по запросам

          s:= n_SysMailSend(adrTo, 'превышение лимита обращений к системе', Body, Attach, '', '', True);
          if s<>'' then prMessageLOGS(nmProc+': error send mail to admins: '+s);

          for iCount:= 0 to Body.Count-1 do begin // пишем в лог
            s:= Body[iCount];
            if (trim(s)='') then Continue;
            if iCount=0 then prMessageLOGS(nmProc+': '+s) else prMessageLOGS(s);
          end;
          LastCountConnectTime:= EndTime; // сбрасываем счетчик
          CountConnect:= 0;
        except
          on E: Exception do prMessageLOGS(nmProc+'('+IntToStr(ID)+'): '+E.Message);
        end;
        exit;
      finally
        prFree(Body);
        ClearAttachments(Attach, True);
      end;
// end ----------------------------------------------------- тестовая рассылка 2     

//----------------------------------------------------------- блокировка клиента
      BlockType:= fnIfInt(flTmpBlock, cbBlockedTmpByConnLimit, cbBlockedByConnectLimit);
      if SaveClientBlockType(BlockType, ID, BlockTime) then begin // блокировка клиента в базе
        Blocked:= True;              // блокировка в кеше
        LastCountConnectTime:= EndTime;
        CountConnect:= 0;            // сбрасываем счетчик
        if flTmpBlock then begin     // временная блокировка
          TmpBlockTime:= IncMinute(BlockTime, Cache.GetConstItem(pcTmpBlockInterval).IntValue);
                       // добавляем 2 мин из-за возм.разницы времени на серверах
          sTimeTo:= FormatDateTime(cDateTimeFormatY4N, IncMinute(TmpBlockTime, 2));
        end else TmpBlockTime:= 0;   // окончательная блокировка
      end;
    finally
      CS_client.Leave;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  if not Blocked then exit; // если не получилось - выходим
                                                                                      
//--------------------------------------------- рассылаем извещения о блокировке
  Body:= TStringList.Create;
  Attach:= TStringList.Create;
  with Cache do try
    cliMail:= Mail; //--------------------------------------------- пользователю
    if cliMail='' then begin  // ищем Mail фирмы ???
      cliMess:= 'Уведомление о блокировке клиенту не отправлено - не найден Email';
    end else begin
      Body.Add('Учётная запись пользователя (логин <'+Login+'>) заблокирована');
      if flTmpBlock then begin // временная блокировка
        Body.Add(' до '+sTimeTo+' из-за превышения лимита обращений к системе.');
//        Body.Add('По вопросу срочной разблокировки'+#10' обращайтесь к торговому представителю Компании.');
      end else begin
        Body.Add(' из-за повторного превышения лимита обращений к системе.');
        Body.Add('По вопросу разблокировки обращайтесь');
        Body.Add(' к торговому представителю Компании.');
      end;
      s:= n_SysMailSend(cliMail, 'Уведомление о блокировке учетной записи', Body, nil, '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then begin // если не записалось в файл
        prMessageLOGS(nmProc+'(send mail to client): '+s);
        cliMess:= 'Ошибка отправки уведомления о блокировке клиенту';
      end else
        cliMess:= 'Уведомление о блокировке отправлено клиенту на Email '+cliMail;
    end;

    regMail:= ''; //----------------------------------------- по списку рассылки
    Body.Clear;
    Body.Add(FormatDateTime(cDateTimeFormatY4S, Now()));
    Body.Add('Пользователь с логином <'+Login+'> (код '+IntToStr(ID)+')');
    Body.Add('  контрагент '+FirmName);
    if FirmExist(FirmID) then begin
      s:= arFirmInfo[FirmID].GetFirmManagersString([fmpName, fmpShort, fmpPref]);
      if (s<>'') then Body.Add('  '+s);
    end;

    if flTmpBlock then begin // временная блокировка
      regMail:= Cache.GetConstEmails(pcEmpl_list_TmpBlock, mess, FirmID);
      Body.Add('превысил лимит обращений к системе.');
      iCount:= Body.Count; // запоминаем позицию для вставки кол-ва запросов
      Body.Add(#10'Учетная запись в системе заказов заблокирована до '+sTimeTo);
    end else begin   // окончательная блокировка
      regMail:= Cache.GetConstEmails(pcEmpl_list_FinalBlock, mess, FirmID);
      Body.Add('повторно превысил лимит обращений к системе.');
      iCount:= Body.Count; // запоминаем позицию для вставки кол-ва запросов
      Body.Add(#10'Учетная запись в системе заказов заблокирована.');
    end;
    if cliMess<>'' then Body.Add(#10+cliMess);

    cliMess:= '';                         // история блокировок из протокола
    HistInterval:= Cache.GetConstItem(pcBlockHistoryIntMonth).IntValue;
    if HistInterval<1 then HistInterval:= 1;
    try
      ORD_IBD:= cntsOrd.GetFreeCnt;
      try
        ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
        ORD_IBS.SQL.Text:= 'select protComment, PROTTIME'+ // protCommand, protType, protUSERID,
          ' from protocol where protWOCL='+IntToStr(ID)+
          ' and protCommand in ('+IntToStr(csBlockWebUser)+', '+IntToStr(csUnblockWebUser)+')'+
          ' and PROTTIME between :time1 and :time2 order by PROTTIME';
        ORD_IBS.ParamByName('time1').AsDateTime:= IncMonth(Date, -HistInterval); // за HistInterval м-цев
        ORD_IBS.ParamByName('time2').AsDateTime:= IncMinute(BlockTime, -5);      // до этой блокировки
        ORD_IBS.ExecQuery;
        while not ORD_IBS.Eof do begin
          s:= FormatDateTime(cDateTimeFormatY4S, ORD_IBS.fieldByName('PROTTIME').AsDateTime);
          cliMess:= cliMess+#10+s+' - '+ORD_IBS.fieldByName('protComment').AsString;
          ORD_IBS.Next;
        end;
      finally
        prFreeIBSQL(ORD_IBS);
        cntsOrd.SetFreeCnt(ORD_IBD);
      end;
    except
      on E: Exception do prMessageLOGS(nmProc+'('+IntToStr(ID)+'): '+E.Message);
    end;
    if cliMess<>'' then begin
      case HistInterval of
        1: ss:= 'м-ц';
        2..4: ss:= 'м-ца';
        5..12: ss:= 'м-цев';
        else ss:= '';
      end;
      if ss<>'' then ss:= ' за '+IntToStr(HistInterval)+' '+ss;
      Body.Add(#10+'История блокировок клиента'+ss+':'+cliMess);
    end;

    CheckRequestsAttach(ID, Attach, BeginTime, EndTime); // вкладываем отчет по запросам

    if regMail='' then // в s запоминаем строку в письмо контролю
      s:= 'Сообщение о блокировке клиента не отправлено - не найдены адреса рассылки'
    else begin
      s:= n_SysMailSend(regMail, 'Блокировка учетной записи пользователя', Body, Attach, '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then begin // если не записалось в файл
        prMessageLOGS(nmProc+'(send mail to empls): '+s);
        s:= 'Ошибка отправки сообщения о блокировке клиента на Email: '+regMail;
      end else s:= 'Сообщение о блокировке клиента отправлено на Email: '+regMail;
    end;
                             //---------------------------- контролю (Щербакову)
    if s<>''       then Body.Add(#10+s);
    if mess<>''    then Body.Add(#10+mess); // сообщение о ненайденных адресах

    adrTo:= Cache.GetConstEmails(pcBlockMonitoringEmpl, mess, FirmID);
    if mess<>'' then Body.Add(mess);

    if adrTo='' then adrTo:= GetSysTypeMail(constIsAuto); // адрес Щербакова (на всяк.случай)

    if adrTo<>'' then begin
      s:= n_SysMailSend(adrTo, 'Блокировка учетной записи пользователя', Body, Attach, '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then
        prMessageLOGS(nmProc+'(send mail to Monitoring): '+s);
    end;
                             //----------------------------------------- админам
    Body.Insert(iCount, 'for admin ----- '+sCount); // вставка кол-ва запросов

    adrTo:= GetConstEmails(pcEmplORDERAUTO);
    if adrTo='' then adrTo:= fnGetSysAdresVlad(caeOnlyDayLess);
    if adrTo<>'' then begin
      s:= n_SysMailSend(adrTo, 'Блокировка учетной записи пользователя', Body, Attach, '', '', True);
      if (s<>'') and (Pos(MessText(mtkErrMailToFile), s)>0) then
        prMessageLOGS(nmProc+'(send mail to admins): '+s);
    end;
                             // ------------------------------------ пишем в лог
    prMessageLOGS(nmProc+': блокировка клиента');
    for iCount:= 0 to Body.Count-1 do if trim(Body[iCount])<>'' then
      prMessageLOGS(StringReplace(Body[iCount], #10, '', [rfReplaceAll]));
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  prFree(Body);
  ClearAttachments(Attach, True);
end;
//======================= проверяет счетчик запросов наличия (сообщение админам)
procedure TClientInfo.CheckQtyCount;
const nmProc = 'CheckQtyCount';
var iCount, LimitCount, LimitInterval, minCount, secCount: Integer;
    s, adrTo: String;
    Body, Attach: TStringList;
    BeginTime, EndTime: TDateTime;
begin
  if not Assigned(self) or Arhived or Blocked then Exit; // заблокирован
  CS_client.Enter;
  try try
    LimitCount:= Cache.GetConstItem(pcMaxClientQtyCount).IntValue;
    LimitInterval:= Cache.GetConstItem(pcMaxClientQtyInterval).IntValue;
    BeginTime:= LastCountQtyTime;
    EndTime:= Now;
    secCount:= SecondsBetween(BeginTime, EndTime);
    minCount:= secCount div 60; // кол-во полных минут
    secCount:= secCount mod 60;
    if (minCount>=LimitInterval) then begin
      LastCountQtyTime:= EndTime;     // сбрасываем счетчик
      iCount:= 1;
    end else iCount:= CountQty+1; // добавляем счетчик
    if iCount<>CountQty then CountQty:= iCount; // меняем значение счетчика
    if CountQty<=LimitCount then Exit; // не превышает - выходим

//---------------------------------------------------------  тестовая рассылка 1
    Body:= TStringList.Create;
    Attach:= TStringList.Create;
    with Cache do try
      Body.Add(FormatDateTime(cDateTimeFormatY4S, Now()));
      Body.Add('Пользователь с логином <'+Login+'> (код '+IntToStr(ID)+')');
      Body.Add('  контрагент '+FirmName);
      if FirmExist(FirmID) then
        s:= arFirmInfo[FirmID].GetFirmManagersString([fmpName, fmpShort, fmpPref])
      else s:= '';
      if (s<>'') then Body.Add('  '+s);
      Body.Add('превысил лимит запросов наличия:');
      Body.Add('  '+IntToStr(CountQty)+' запросов за '+IntToStr(minCount)+' мин '+IntToStr(secCount)+' сек');

      CheckRequestsAttach(ID, Attach, BeginTime, EndTime); // вкладываем отчет по запросам

      adrTo:= Cache.GetConstEmails(pcTestingSending1, FirmID);
      if adrTo='' then adrTo:= fnGetSysAdresVlad(caeOnlyDayLess);

      s:= n_SysMailSend(adrTo, 'превышение лимита запросов наличия', Body, Attach, '', '', True);
      if s<>'' then prMessageLOGS(nmProc+': error send mail to admins: '+s);

      for iCount:= 0 to Body.Count-1 do begin // пишем в лог
        s:= Body[iCount];
        if (trim(s)='') then Continue;
        if iCount=0 then prMessageLOGS(nmProc+': '+s) else prMessageLOGS(s);
      end;

      LastCountQtyTime:= EndTime; // сбрасываем счетчик
      CountQty:= 0;
    finally
      prFree(Body);
      ClearAttachments(Attach, True);
    end;
//---------------------------------------------------------  тестовая рассылка 1
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  finally
    CS_client.Leave;
  end;
end;

//******************************************************************************
//                               TEmplInfoItem
//******************************************************************************
constructor TEmplInfoItem.Create(pID, pManID, pDprtID: Integer; pName: String);
begin
  inherited Create(pID, pManID, pDprtID, pName, soGrossBee, True);
  SetLength(UserRoles, 0);
  LastTestTime:= DateNull;
  LastActionTime:= DateNull;
  Session:= '';
  FVisRule:= 0;
end;
//==================================================
destructor TEmplInfoItem.Destroy;
begin
  if not Assigned(self) then Exit;
  TestUserRolesLength(0, false);
  inherited;
end;
//================================================================= получить код
function TEmplInfoItem.GetIntE(const ik: T8InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FID;       // = EMPLCODE(GB)
    ik8_2: Result:= FSubCode;  // = EMPLMANCODE(GB)
    ik8_3: Result:= FOrderNum; // код подразделения из EMPLDPRTCODE(ORD, EMPLOYEES)
    ik8_4: Result:= FVisRule;  // код схемы видимости из VMPERMISSIONGROUP
    ik8_5: Result:= FFaccReg;   // регион
  end;
end;
//================================================================= записать код
procedure TEmplInfoItem.SetIntE(const ik: T8InfoKinds; Value: Integer);
begin
  if not Assigned(self) then Exit else case ik of
    ik8_1: if (FID      <>Value) then FID      := Value; // = EMPLCODE(GB)
    ik8_2: if (FSubCode <>Value) then FSubCode := Value; // = EMPLMANCODE(GB)
    ik8_3: if (FOrderNum<>Value) then FOrderNum:= Value; // код подразделения из EMPLDPRTCODE(ORD, EMPLOYEES)
    ik8_4: if (FVisRule <>Value) then FVisRule := Value; // код схемы видимости из VMPERMISSIONGROUP
    ik8_5: if (FFaccReg <>Value) then FFaccReg := Value; // регион
  end;
end;
//============================================================== получить строку
function TEmplInfoItem.GetStrE(const ik: T16InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then Exit else case ik of
    ik16_1: Result:= FSurname;     // фамилия из MANS
    ik16_2: Result:= FName;        // имя из MANS
    ik16_3: Result:= FPatron;      // отчество из MANS
    ik16_4: Result:= FServerLog;   // логин из EMPLLOGIN(ORD, EMPLOYEES)
    ik16_5: Result:= FPASSFORSERV; // пароль из EMPLPASS(ORD, EMPLOYEES)
    ik16_6: Result:= FGBLogin;     // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTCODE
    ik16_7: Result:= FGBRepLogin;  // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTREPORTCODE
    ik16_8: Result:= FMail;        // Email
    ik16_9: Result:= FSession;
    ik16_10: begin                 // краткое Ф И.О. сотрудника
        Result:= FSurname;
        if FName<>''   then Result:= Result+' '+AnsiUpperCase(copy(FName, 1, 1))+'.';
        if FPatron<>'' then Result:= Result+AnsiUpperCase(copy(FPatron, 1, 1))+'.';
      end;
    ik16_11: begin                  // полное Ф И О сотрудника
        Result:= FSurname;
        if FName<>''   then Result:= Result+' '+FName;
        if FPatron<>'' then Result:= Result+' '+FPatron;
      end;
  end;
end;
//============================================================== записать строку
procedure TEmplInfoItem.SetStrE(const ik: T16InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
    ik16_1: if (FSurname    <>Value) then FSurname    := Value; // фамилия из MANS
    ik16_2: if (FName       <>Value) then FName       := Value; // имя из MANS
    ik16_3: if (FPatron     <>Value) then FPatron     := Value; // отчество из MANS
    ik16_4: if (FServerLog  <>Value) then FServerLog  := Value; // логин из EMPLLOGIN(ORD, EMPLOYEES)
    ik16_5: if (FPASSFORSERV<>Value) then FPASSFORSERV:= Value; // пароль из EMPLPASS(ORD, EMPLOYEES)
    ik16_6: if (FGBLogin    <>Value) then FGBLogin    := Value; // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTCODE
    ik16_7: if (FGBRepLogin <>Value) then FGBRepLogin := Value; // логин из USLSUSERID (GB, USERLIST) USLSCODE=TEmplInfoItem.USERLISTREPORTCODE
    ik16_8: if (FMail       <>Value) then FMail       := Value; // Email
    ik16_9: if (FSession    <>Value) then FSession    := Value;
  end;
end;
//================================================ проверяем длину массива ролей
procedure TEmplInfoItem.TestUserRolesLength(len: integer; ChangeOnlyLess: boolean=True; inCS: boolean=True);
var fl: boolean;
begin
  if not Assigned(self) then Exit;
  if ChangeOnlyLess then fl:= (Length(UserRoles)<len) else fl:= (Length(UserRoles)<>len);
  if fl then try // если надо менять длину
    if inCS then Cache.CS_Empls.Enter;
    if Length(UserRoles)<len then
      prCheckLengthIntArray(UserRoles, len-1) // добавляем длину массива, если надо, и инициируем элементы
    else SetLength(UserRoles, len);
  finally
    if inCS then Cache.CS_Empls.Leave;
  end;
end;
//======================================================= проверяем список ролей
procedure TEmplInfoItem.TestUserRoles(roles: Tai);
var i: integer;
begin
  if not Assigned(self) then Exit else try
    Cache.CS_Empls.Enter;                    // проверяем /изменяем длину массива
    TestUserRolesLength(length(roles), false, false);
    for i:= 0 to High(roles) do  // идем по новому списку
      if UserRoles[i]<>roles[i] then UserRoles[i]:= roles[i];
  finally
    Cache.CS_Empls.Leave;
  end;
end;
//=============================================================== добавляем роль
procedure TEmplInfoItem.AddUserRole(role: Integer);
var i: integer;
begin
  if not Assigned(self) then Exit;
  i:= fnInIntArray(role, UserRoles); // проверяем присутствие роли в массиве
  if i>-1 then Exit;                 // если есть - выходим
  i:= Length(UserRoles);
  try
    Cache.CS_Empls.Enter;
    TestUserRolesLength(i+1, true, false); // добавляем длину массива
    UserRoles[i]:= role;                   // добавляем роль
  finally
    Cache.CS_Empls.Leave;
  end;
end;
//================================================================= удаляем роль
procedure TEmplInfoItem.DelUserRole(role: Integer);
var i, j: integer;
begin
  if not Assigned(self) then Exit;
  i:= fnInIntArray(role, UserRoles); // проверяем присутствие роли в массиве
  if i<0 then Exit;                  // если нет - выходим
  try
    Cache.CS_Empls.Enter;                                         // удаляем роль
    for j:= i to Length(UserRoles)-2 do UserRoles[j]:= UserRoles[j+1];
    TestUserRolesLength(Length(UserRoles)-1, false, false); // обрезаем длину массива
  finally
    Cache.CS_Empls.Leave;
  end;
end;
//=============================================================== проверяем роль
function TEmplInfoItem.UserRoleExists(role: Integer): boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  Result:= fnInIntArray(role, UserRoles)>-1; // проверяем присутствие роли в массиве
end;
//======================================== сортировка линков с видимыми складами
function VisStoresSortCompare(Item1, Item2: Pointer): Integer;
var Store1, Store2: TDprtInfo;
    Par1, Par2: Integer;
begin
  with Cache do try
    Store1:= GetLinkPtr(Item1);
    Store2:= GetLinkPtr(Item2);
    Par1:= Store1.ParentID;
    Par2:= Store2.ParentID;
    if (Par1<>Par2) and DprtExist(Par1) and DprtExist(Par2) then begin
      Store1:= arDprtInfo[Par1];
      Store2:= arDprtInfo[Par2];
      Result:= AnsiCompareText(Store1.MainName, Store2.MainName);
    end else begin
      if Store1.IsStoreHouse then Par1:= 0 else Par1:= 2;
      if Store2.IsStoreHouse then Par2:= 0 else Par2:= 2;
      if (Par1=Par2) then
        Result:= AnsiCompareText(Store1.MainName, Store2.MainName)
      else if (Par1>Par2) then Result:= 1 else  Result:= -1;
    end;
  except
    Result:= 0;
  end;
end;
//========================================== проверяем, нужны ли права видимости
procedure TEmplInfoItem.TestVisRuleNeeds(ruleID: Integer);
const nmProc = 'TestVisRule';
var iw, k, ipos: Integer;
    ars: Tas;
begin
  if not Assigned(self) then Exit;
                    // если не заданы роли для заполнения видимых складов и фирм
  if (ruleID>0) then
    if not Cache.ConstExists(pcVisStoresRoles) or
      (Cache.GetConstItem(pcVisStoresRoles).StrValue='') then ruleID:= 0
    else begin
      iw:= -1;
      ars:= fnSplitString(Cache.GetConstItem(pcVisStoresRoles).StrValue, ',');
      try // проверяем, есть ли роль для заполнения видимых складов и фирм у сотрудника
        for k:= 0 to High(ars) do begin
          ipos:= StrToIntDef(ars[k], 0);
          if (ipos>0) then begin
            iw:= fnInIntArray(ipos, UserRoles);
            if (iw>-1) then break;
          end;
        end;
      finally
        SetLength(ars, 0);
      end;
      if iw<0 then ruleID:= 0;
    end;

  VisRule:= ruleID; // проставляем схему видимости
end;

//******************************************************************************
//                               TFirmInfo
//******************************************************************************
constructor TFirmInfo.Create(pID: Integer; pName: String);
begin
  inherited Create(pID, 0, 0, pName, 2);
  CS_firm:= TCriticalSection.Create; // для изменения параметров
  SetLength(FirmClients, 0);
  FirmClasses:= TIntegerList.Create;   // коды категорий фирмы
  FirmContracts:= TIntegerList.Create; // контракты фирмы
  FirmManagers:= TIntegerList.Create;  // менеджеры фирмы
//  FirmSysTypes:= TIntegerList.Create;  //
  LastDebtTime:= DateNull;
  LastTestTime:= DateNull;
  PartiallyFilled:= True;
  FHostCode:= pID;
  FBonusQty:= 0;
//  FLabelLinks:= TLinks.Create(CS_firm); // связки с наклейками
  FirmDiscModels:= TObjectList.Create; // действующие шаблоны скидок фирмы
  LegalEntities:= TObjectList.Create;  // юрид.фирмы к/а, Object - TBaseDirItem
end;
//==================================================
destructor TFirmInfo.Destroy;
begin
  if not Assigned(self) then Exit;
  SetLength(FirmClients, 0);
  prFree(FirmClasses);
  prFree(FirmContracts);
  prFree(FirmManagers);
//  prFree(FirmSysTypes);
  prFree(FirmDiscModels);
//  prFree(FLabelLinks);
  prFree(CS_firm);
  prFree(LegalEntities);
  inherited;
end;
//============================================================== записать строку
procedure TFirmInfo.SetStrF(const ik: T8InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
    ik8_1: if (FUPPERSHORTNAME<>Value) then FUPPERSHORTNAME:= Value;
    ik8_2: if (FUPPERMAINNAME <>Value) then FUPPERMAINNAME := Value;
    ik8_3: if (FNUMPREFIX     <>Value) then FNUMPREFIX     := Value; // префикс фирмы клиента
    ik8_4: if (FActionText    <>Value) then FActionText:= Value;     // состояние участия в акции
  end;
end;
//============================================================== получить строку
function TFirmInfo.GetStrF(const ik: T8InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: Result:= FUPPERSHORTNAME;
    ik8_2: Result:= FUPPERMAINNAME;
    ik8_3: Result:= FNUMPREFIX;               // префикс фирмы клиента
    ik8_4: Result:= FActionText;             // состояние участия в акции
    ik8_5: Result:= Cache.GetFirmTypeName(FFirmType);
  end;
end;
//================================================================= получить код
function TFirmInfo.GetIntF(const ik: T8InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  case ik of
    ik8_2: Result:= FSUPERVISOR;  // код главного пользователя
    ik8_3: Result:= FFirmType;
    ik8_4: Result:= FHostCode;    // код для связи с наклейками
    ik8_5: Result:= FContUnitOrd; // код контракта unit-заказа
  end;
end;
//================================================================= записать код
procedure TFirmInfo.SetIntF(const ik: T8InfoKinds; Value: Integer);
begin
  if not Assigned(self) then Exit;
  case ik of
    ik8_2: if (FSUPERVISOR  <>Value) then FSUPERVISOR  := Value; // код главного пользователя
    ik8_3: if (FFirmType    <>Value) then FFirmType    := Value;
    ik8_4: if (FHostCode    <>Value) then FHostCode    := Value; // код для связи с наклейками
    ik8_5: if (FContUnitOrd <>Value) then FContUnitOrd := Value; // код контракта unit-заказа
  end;
end;
//==============================================================================
function TFirmInfo.GetBoolF(const ik: T8InfoKinds): boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  case ik of
    ik8_5: Result:= True; // (FirmSysTypes.IndexOf(constIsAuto)>-1);
    ik8_6: Result:= True; // (FirmSysTypes.IndexOf(constIsMoto)>-1);
    else Result:= (ik in FFirmBoolOpts);
  end;
end;
//================================================================= получить код
function TFirmInfo.GetRegional: Integer;          // получить код менеджера по def-контракту  // временно
var empl: TEmplInfoItem;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  if GetDefContract.FindContManager(empl) then Result:= Empl.ID; // код менеджера
end;
{//============================================================= проверка системы
function TFirmInfo.CheckSysType(pSysID: Integer): boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  Result:= (pSysID=0);
  if Result then Exit;
  Result:= (FirmSysTypes.IndexOf(pSysID)>-1);
end; }
//=============== список кодов/ЦФУ/ФИО/Email-ов менеджеров фирмы (через запятую)
function TFirmInfo.GetFirmManagersString(params: TFirmManagerParams=[fmpName, fmpShort]): String;
//    TFirmManagerParam = (fmpCode, fmpName, fmpEmail, fmpShort, fmpPref, fmpFacc);
// 1. fmpCode - список кодов менеджеров, +fmpFacc - список кодов ЦФУ (остальные игнорируются)
// 2. fmpEmail - список Email-ов менеджеров (остальные игнорируются)
// 3. fmpName - список полных ФИО менеджеров, +fmpShort - фамилия+инициалы,
// 4. fmpName + fmpFacc - список полных наименований ЦФУ
// 3-4. +fmpPref - с префиксом 'менеджеры к/а ' или 'ЦФУ к/а '

var i, j, pID: Integer;
    Empl: TEmplInfoItem;
    s: String;
    ilst: TIntegerList;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  j:= 0; // счетчик
//-------------------------------------------------------------------------- ЦФУ
  if (fmpFacc in params) then try
    ilst:= TIntegerList.Create;
    for i:= 0 to FirmContracts.Count-1 do begin // собираем коды ЦФУ, убираем дубляж
      pID:= FirmContracts[i];
      if not Cache.Contracts.ItemExists(pID) then Continue;
      ilst.Add(Cache.Contracts[pID].FacCenter);
    end;
    for i:= 0 to ilst.Count-1 do begin
      pID:= ilst[i];
      if not Cache.FiscalCenters.ItemExists(pID) then Continue;
      s:= '';
      if (fmpCode in params) then s:= IntToStr(pID) // коды
      else if (fmpName in params) then              // наименования
        s:= TFiscalCenter(Cache.FiscalCenters[pID]).Name;
      if (s<>'') then begin
        Result:= Result+fnIfStr(Result='', '', ', ')+s;
        inc(j);
      end;
    end;
  finally
    prFree(ilst);
//-------------------------------------------------------------------- менеджеры
  end else for i:= 0 to FirmManagers.Count-1 do begin
    pID:= FirmManagers[i];
    if not Cache.EmplExist(pID) then Cache.TestEmpls(pID);
    if not Cache.EmplExist(pID) then Continue;
    s:= '';
    if (fmpCode in params) then s:= IntToStr(pID) // коды
    else begin
      Empl:= Cache.arEmplInfo[pID];
      if (fmpEmail in params) then s:= Empl.Mail
      else if (fmpName in params) then
        if (fmpShort in params) then s:= Empl.EmplShortName
        else s:= Empl.EmplLongName;
    end;
    if (s<>'') then begin
      Result:= Result+fnIfStr(Result='', '', ', ')+s;
      inc(j);
    end;
  end;
  if (j<1) then Exit;

  if (fmpPref in params) then begin
    s:= '';
    if (fmpFacc in params) then s:= 'ЦФУ к/а '
    else if (fmpName in params) then begin
      if j>1 then s:= 'менеджеры к/а '
      else if j>0 then s:= 'менеджер к/а ';
    end;
    if (s<>'') then Result:= s+' '+Result;
  end;
end;
//===================================================== проверка менеджера фирмы
function TFirmInfo.CheckFirmManager(emplID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  Result:= (FirmManagers.IndexOf(emplID)>-1);
  if not Result then Exit;
  if not Cache.EmplExist(emplID) then Cache.TestEmpls(emplID);
  Result:= Cache.EmplExist(emplID) and not Cache.arEmplInfo[emplID].Arhived;
end;
//======================================================= проверка региона фирмы
function TFirmInfo.CheckFirmRegion(regNum: Integer): Boolean;
var i, j: Integer;
begin
  Result:= False;
  if not Assigned(self) or (regNum<1) then Exit;
  for i:= 0 to FirmContracts.Count-1 do begin
    j:= FirmContracts[i];
    if not Cache.Contracts.ItemExists(j) then Continue;
    j:= Cache.Contracts[j].FacCenter;
    if not Cache.FiscalCenters.ItemExists(j) then Continue;
    Result:= (TFiscalCenter(Cache.FiscalCenters[j]).Region=regNum);
    if Result then Exit;
  end;
end;
/////////////////////////////////////////////////////////////////////////////////////////////////////
//=================================================== получить код def-контракта
function TFirmInfo.GetDefContractID: Integer;
var i, k, kp: Integer;
begin
  Result:= 0;
  kp:= 0;
  if not Assigned(self) or not Assigned(FirmContracts) then Exit;
  with FirmContracts do begin
    if (Count<1) then Exit;
    if (Count=1) then begin
      Result:= Items[0];
      Exit;
    end;
    for i:= Count-1 downto 0 do begin // ищем с конца
      k:= Items[i];
      if not Cache.Contracts.ItemExists(k) then Continue;
      Result:= k;
      with Cache.Contracts[k] do begin
        if Disable then Continue; // недоступный пропускаем
        if ContDefault then Exit; // нашли по признаку - выходим
        if (kp<1) and (PayType=0) then kp:= k; // запоминаем код последнего наличного контракта
      end;
    end; // если по признаку не нашли, в Result - код 1-го существующего контракта
    if (kp>0) and (kp<>Result) then Result:= kp; // если нашли наличный - берем его
  end;
end;
//======================================================== получить def-контракт
function TFirmInfo.GetDefContract: TContract;
var i, k: Integer;
begin
  Result:= nil;
  if not Assigned(self) or not Assigned(FirmContracts) then Exit;
  with FirmContracts do begin
    if (Count<1) then Exit;
    for i:= Count-1 downto 0 do begin // ищем с конца
      k:= Items[i];
      with Cache do begin
        if not Contracts.ItemExists(k) then Continue;
        Result:= Contracts[k];
        if Result.Disable then Continue;
        if Result.ContDefault then break; // нашли по признаку
      end;
    end; // если по признаку не нашли, в Result - 1-й существующий контракт
  end;
end;
//====================================== проверка принадлежности контракта фирме
function TFirmInfo.CheckContract(contID: Integer): boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  Result:= (contID>0) and Cache.Contracts.ItemExists(contID) and (FirmContracts.IndexOf(contID)>-1);
end;
//============================================= получить список контрактов фирмы
function TFirmInfo.GetContracts: TStringList;  // must Free !!!
var i, k: Integer;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  with FirmContracts do for i:= 0 to Count-1 do with Cache do begin
    k:= Items[i];
    if Contracts.ItemExists(k) then Result.AddObject(Contracts[k].Name, Pointer(k));
  end;
end;
//============================================== получить контракт фирмы по коду
function TFirmInfo.GetContract(var contID: Integer): TContract;
// если контракт не найден, возвращает def-контракт и меняет contID
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  if CheckContract(contID) then Result:= Cache.Contracts[contID]
  else begin
    Result:= GetDefContract;
    if Assigned(Result) then contID:= Result.ID;
  end;
end;
//===================================== проверка/изменение контракта unit-заказа
procedure TFirmInfo.SetContUnitOrd(contID: Integer);
begin
  if not Assigned(self) then Exit;
  if (ContUnitOrd=contID) then Exit;
  if (contID>0) and not CheckContract(contID) then Exit;
  CS_firm.Enter;
  try
    ContUnitOrd:= contID;
  finally
    CS_firm.Leave;
  end;
end;
/////////////////////////////////////////////////////////////////////////////////////////////////////

//=========================================== проверяем список сотрудников фирмы
procedure TFirmInfo.TestFirmClients(codes: Tai; j: integer=0; inCS: boolean=True);
// codes- массив кодов сотрудников, j- кол-во, если 0 - длина массива codes
// inCS=True - проверять в CriticalSection
var i: integer;
begin
  if not Assigned(self) then Exit;
  if j=0 then j:= length(codes);
  try
    if inCS then CS_firm.Enter;
    if (j<>Length(FirmClients)) then SetLength(FirmClients, j);
    for i:= 0 to j-1 do if FirmClients[i]<>codes[i] then FirmClients[i]:= codes[i];
  finally
    if inCS then CS_firm.Leave;
  end; // if FirmExist(FirmID)
end;
//======================================================== проверка WIN-запросов
function TFirmInfo.CheckFirmVINmail: boolean;
var i: Integer;
    ar: Tai;
    s1, s2, s3: String;
begin
  Result:= False;
  s1:= Cache.GetConstItem(pcVINmailEmpl_list).StrValue;
  if (s1='') then Exit; // адресов нет - выходим

  s1:= Cache.GetConstItem(pcVINmailFirmTypes_list).StrValue;
  s2:= Cache.GetConstItem(pcVINmailFilial_list).StrValue;
  s3:= Cache.GetConstItem(pcVINmailFirmClass_list).StrValue;
  if (s1='') and (s2='') and (s3='') then Exit; // параметров нет - выходим
  SetLength(ar, 0);
  try
    if (s1<>'') then begin // если заданы типы
      ar:= fnArrOfCodesFromString(s1);
      if (fnInIntArray(FirmType, ar)<0) then Exit; // тип не подходит - выходим
    end;

    if (s2<>'') then begin // если заданы филиалы
      ar:= fnArrOfCodesFromString(s2);
      if (fnInIntArray(GetDefContract.Filial, ar)<0) then Exit; // филиал не подходит - выходим
    end;

    if (s3<>'') then begin // если заданы категории
      ar:= fnArrOfCodesFromString(s3);
      for i:= 0 to FirmClasses.Count-1 do begin
        Result:= (fnInIntArray(FirmClasses[i], ar)>-1);
        if Result then Break; // категория подходит - выходим
      end;
    end else Result:= True;

  finally
    SetLength(ar, 0);
  end;
end;
//======================================== проверка разрешения скачивания прайса
function TFirmInfo.CheckFirmPriceLoadEnable: boolean;
var i: Integer;
    ar: Tai;
    s1: String;
begin
  Result:= False;
  s1:= Cache.GetConstItem(pcPriceLoadFirmClasses).StrValue;
  if (s1='') then Exit; // категорий нет - выходим

  SetLength(ar, 0);
  try
    ar:= fnArrOfCodesFromString(s1);
    for i:= 0 to FirmClasses.Count-1 do begin
      Result:= (fnInIntArray(FirmClasses[i], ar)>-1);
      if Result then Break; // категория подходит - выходим
    end;
  finally
    SetLength(ar, 0);
  end;
end;
//================================ текущие шаблон скидок и оборот по направлению
function TFirmInfo.GetCurrentDiscModel(direct: Integer; var firmSales: Integer): TDiscModel;
var i, j: Integer;
begin
  Result:= Cache.DiscountModels.EmptyModel;
  firmSales:= 0;
  for i:= FirmDiscModels.Count-1 downto 0 do begin
    with TTwoCodes(FirmDiscModels[i]) do
    if (ID1=direct) then begin
      j:= ID2;              // код текущего шаблона
      Result:= Cache.DiscountModels[j];
      firmSales:= Round(Qty); // округл. текущий оборот
      Exit;
    end;
  end;
end;

//******************************************************************************
//                                TWareOpts
//******************************************************************************
constructor TWareOpts.Create(CS: TCriticalSection);
//var i: Integer;
begin
  Fdivis:= 1.0;
  FModelLinks:= TLinkList.Create;  // связки с моделями
//  FAutoVisModelsManufs:= TIntegerList.Create; // коды произв.авто/мото из FModelLinks
//  FMotoVisModelsManufs:= TIntegerList.Create; // коды произв.авто/мото из FModelLinks
  FFileLinks := TLinks.Create(CS); // связки с файлами
  FAttrLinks := TLinks.Create(CS); // связки с атрибутами
  FRestLinks := TLinks.Create(CS); // связки со складами и остатками
  FSatelLinks:= TLinks.Create(CS); // связки с сопутствующими товарами
  SetLength(FPrices, 0);

//  SetLength(FArSysAttrs, SysTypes.Count); // связки с атрибутами и их значениями по системам
//  for i:= 0 to High(FArSysAttrs) do FArSysAttrs[i]:= TLinkList.Create;
//  FAttrGrCodes:= TIntegerList.Create; // коды групп атрибутов
//  SetLength(FGrAttrLinks, 0);         // связки с атрибутами и их значениями по группам
end;
//==================================================
destructor TWareOpts.Destroy;
//var i: Integer;
begin
  if not Assigned(self) then Exit;
  prFree(FModelLinks);
  prFree(FFileLinks);
  prFree(FAttrLinks);
  prFree(FRestLinks);
  prFree(FSatelLinks);  // связки с сопутствующими товарами
  SetLength(FPrices, 0);
//  prFree(FAutoVisModelsManufs);
//  prFree(FMotoVisModelsManufs);

//  for i:= 0 to High(FArSysAttrs) do prFree(FArSysAttrs[i]);
//  SetLength(FArSysAttrs, 0);
//  for i:= 0 to High(FGrAttrLinks) do TLinkList(FGrAttrLinks[i]).Free;
//  SetLength(FGrAttrLinks, 0);
//  prFree(FAttrGrCodes);
  inherited Destroy;
end;

//******************************************************************************
//                                TInfoWareOpts
//******************************************************************************
constructor TInfoWareOpts.Create(CS: TCriticalSection);
begin
  FWareSupName:= '';
  FCommentUP:= '';
  FNameBS:= '';
  FMainName:= '';
  FTypeID:= 0;
  FProdDirect:= 0;
  FManagerID:= 0;
  FmeasID:= 0;
  FAnalogLinks:= TLinks.Create(CS); // связки с аналогами
  FONumLinks  := TLinkList.Create;  // связки с оригинальными номерами
end;
//==================================================
destructor TInfoWareOpts.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FAnalogLinks); // связки с аналогами
  prFree(FONumLinks);   // связки с оригинальными номерами
  inherited Destroy;
end;

//******************************************************************************
//                               TWareInfo
//******************************************************************************
constructor TWareInfo.Create(pID, ParentID: Integer; pName: String);
begin
  inherited Create(pID, 0, 0, pName, 2);
  FParCode:= ParentID;
  FComment:= '';
  FWareBoolOpts:= [];
  FWareOpts:= nil;
  FInfoWareOpts:= nil;
  CS_wlinks:= TCriticalSection.Create; // для изменения линков, аналогов
  FDiscModLinks:= nil;    // связки с шаблонами скидок
//  FDiscModLinks:= TLinkList.Create;    // связки с шаблонами скидок
end;
//==================================================
destructor TWareInfo.Destroy;
begin
  if not Assigned(self) then Exit;
  prFree(FWareOpts);
  prFree(FInfoWareOpts);
  prFree(CS_wlinks);
  FWareBoolOpts:= [];
  prFree(FDiscModLinks);
  inherited Destroy;
end;
//======================================= очистка связей (удаление при проверке)
procedure TWareInfo.ClearOpts;
var i, j, wareID: integer;
begin
  if not Assigned(self) then Exit;
  wareID:= ID;
  if Assigned(FWareOpts) then with FWareOpts do if Assigned(FModelLinks) then
    for i:= 0 to FModelLinks.Count-1 do try // связки с моделями
      if assigned(FModelLinks[i]) then with TModelAuto(FModelLinks[i]) do
        if assigned(NodeLinks) then with NodeLinks do for j:= LinkCount-1 downto 0 do
          if DoubleLinkExists(ListLinks[j], wareID) then try
            GetDoubleLinks(ListLinks[j]).DelLinkListItemByID(wareID, lkLnkNone, CS_wlinks);
          except end;
    except end;

  if Assigned(FInfoWareOpts) then with FInfoWareOpts do try
    // аналоги  ???
    if Assigned(ONumLinks) then // связки с ОН
      for i:= 0 to ONumLinks.Count-1 do begin
        j:= GetLinkID(ONumLinks[i]);
        with Cache.FDCA do if OrigNumExist(j) then try
          arOriginalNumInfo[j].Links.DeleteLinkItem(wareID);
        except end;
      end;
  except end;
end;
//============================================================== получить связки
function TWareInfo.GetWareLinks(const ik: T8InfoKinds): TLinks;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  if assigned(FInfoWareOpts) then with FInfoWareOpts do case ik of
   ik8_4: if IsWare then Result:= FAnalogLinks;
  end;
  if assigned(FWareOpts) then with FWareOpts do case ik of
   ik8_1: Result:= FFileLinks;
   ik8_2: Result:= FAttrLinks;
   ik8_3: Result:= FRestLinks;
   ik8_5: Result:= FSatelLinks;
  end;
end;
//============================================================== получить связки
function TWareInfo.GetWareLinkList(const ik: T8InfoKinds): TLinkList;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  case ik of
   ik8_1: if assigned(FInfoWareOpts) then Result:= FInfoWareOpts.FONumLinks;
   ik8_2: if assigned(FWareOpts) then Result:= FWareOpts.FModelLinks;
   ik8_3: begin // связки с шаблонами скидок
            if not assigned(FDiscModLinks) then FDiscModLinks:= TLinkList.Create;
            Result:= FDiscModLinks;
          end;
  end;
end;
//== признак товара для продажи с проверкой сответствия бизнес-направлению фирмы
function TWareInfo.IsMarketWare(FirmID: Integer=IsWe; contID: Integer=0): Boolean;
//var i, k: integer;
//    firma: TFirmInfo;
//    Contract: TContract;
begin
  Result:= False;
  if not Assigned(self) or not Assigned(Cache) or IsINFOgr or IsArchive then Exit;

  Result:= fnNotZero(RetailPrice(FirmID, cDefCurrency, contID));
  if not Result or (FirmID=isWe) then Exit;

  with Cache do begin // отсев по сответствию бизнес-направлению
    Result:= FirmExist(FirmID);
    if not Result then Exit;
{
    firma:= arFirmInfo[FirmID];
    if (contID>0) then begin
      Contract:= firma.GetContract(contID);
      Result:= (Contract.SysID=0);
      if Result then Exit;
    end else Contract:= nil;

    with SysTypes do for i:= 0 to Count-1 do begin
      k:= GetDirItemID(ItemsList[i]);
      Result:= CheckWareTypeSys(k) and firma.CheckSysType(k);
      if Result and Assigned(Contract) then Result:= (Contract.SysID=k);
      if Result then Exit;
    end; }
  end;
end;
//======== признак товара для продажи с проверкой сответствия бизнес-направлению
function TWareInfo.IsSysMarketWare(sysID: Integer=0): Boolean;
begin
  Result:= False;
  if not Assigned(self) or IsINFOgr or IsArchive then Exit;

  Result:= IsMarketWare;
  if not Result or (sysID<constIsAuto) or not Assigned(Cache) then Exit;

  Result:= CheckWareTypeSys(sysID); // отсев по сответствию бизнес-направлению
end;
//==============================================================================
function CheckAnalogLinkKind(Kind: Integer; link: TAnalogLink): Boolean;
begin
  Result:= False;
  with link do case Kind of
    ca_GR,       ca_GR_OE      : Result:= IsOldAnalog or (IsCross and (SrcID=soGrossBee));      // старые аналоги + кроссы GrossBee
//        ca_GR,       ca_GR_OE      : Result:= IsOldAnalog;  // старые аналоги
    ca_Ex_TD,    ca_Ex_TD_OE   : Result:= IsCross;                                              // все кроссы
    ca_TD,       ca_TD_OE      : Result:= IsCross and (SrcID in [soTecDocBatch, soTDparts, soTDsupersed, soTDold]); // кроссы TD
    ca_Ex,       ca_Ex_OE      : Result:= IsCross and (SrcID in [soHand, soGrossBee, soExcel]);             // кроссы Excel
    ca_GR_TD,    ca_GR_TD_OE   : Result:= IsOldAnalog or (IsCross and (SrcID in [soTecDocBatch, soTDparts, soTDsupersed, soTDold])); // старые + кроссы TD
    ca_GR_Ex,    ca_GR_Ex_OE   : Result:= IsOldAnalog or (IsCross and (SrcID in [soHand, soGrossBee, soExcel])); // старые + кроссы Excel
    ca_GR_Ex_TD, ca_GR_Ex_TD_OE: Result:= IsOldAnalog or IsCross;                               // все
  end; // case
end;
//========================== получить список кодов аналогов товара с источниками
function TWareInfo.GetSrcAnalogs(ShowKind: Integer=-1): TObjectList;  // must Free
// Objects - TTwoCodes(wareID, link.SrcID)
var i: Integer;
    link: TAnalogLink;
begin
  Result:= nil;
  if not Assigned(self) then Exit;

  Result:= TObjectList.Create;
  if not Assigned(FInfoWareOpts) or not Assigned(FInfoWareOpts.FAnalogLinks) then Exit;

  if ShowKind<0 then ShowKind:= Cache.GetConstItem(pcAnalogsShowKind).IntValue;
  if (ShowKind=ca_OE) then Exit;                // только OE

  CS_wlinks.Enter;
  with FInfoWareOpts.FAnalogLinks do try
    i:= LinkCount;
    Result.Capacity:= i;
    for i:= 0 to LinkCount-1 do try
      link:= ListLinks[i];
      if CheckAnalogLinkKind(ShowKind, link) then
        Result.Add(TTwoCodes.Create(link.LinkID, link.SrcID));
    except end; // for
  finally
    CS_wlinks.Leave;
  end;
end;
//======================================== получить массив кодов аналогов товара
function TWareInfo.Analogs: Tai;  // must Free
var i, j, ShowKind: Integer;
    link: TAnalogLink;
begin
  SetLength(Result, 0);
  if not Assigned(self) or not Assigned(FInfoWareOpts)
    or not Assigned(FInfoWareOpts.FAnalogLinks) then Exit;

  ShowKind:= Cache.GetConstItem(pcAnalogsShowKind).IntValue;
  if (ShowKind=ca_OE) then Exit;                // только OE

  CS_wlinks.Enter;
  with FInfoWareOpts.FAnalogLinks do try
    SetLength(Result, LinkCount);
    j:= 0;    // счетчик Result
    for i:= 0 to LinkCount-1 do try
      link:= ListLinks[i];
      if CheckAnalogLinkKind(ShowKind, link) then begin
        Result[j]:= link.LinkID;
        inc(j);
      end;
    except end; // for
    if (Length(Result)>j) then SetLength(Result, j);
  finally
    CS_wlinks.Leave;
  end;
end;
//======================== добавить в кеш линк с аналогом (def - аналог Гроссби)
function TWareInfo.CheckAnalogLink(AnalogID: Integer;  pSrcID: Integer=soGrossBee; pCross: Boolean=True): Boolean;
var iCount: Integer;
    link: TAnalogLink;
    Ware: TWareInfo;
begin
  Result:= False;
  if not Assigned(self) or (AnalogID<1) or not assigned(FInfoWareOpts)
    or not Cache.WareExist(AnalogID) then exit;
  with FInfoWareOpts do begin
    Result:= FAnalogLinks.LinkExists(AnalogID);
    if not Result then begin
      Ware:= Cache.GetWare(AnalogID, True);
      if (Ware=NoWare) or Ware.IsArchive or Ware.IsINFOgr then Exit; // не пишем в аналоги ИНФО-группу
      iCount:= FAnalogLinks.LinkCount;
      link:= TAnalogLink.Create(pSrcID, Ware, not pCross, pCross);
      FAnalogLinks.AddLinkItem(link);
      Result:= FAnalogLinks.LinkCount>iCount;
    end else try
      CS_wlinks.Enter;
      link:= FAnalogLinks[AnalogID];
      if pCross and not link.IsCross then begin
        link.IsCross:= True;
        if {link.IsOldAnalog and} (link.SrcID<>pSrcID) then link.SrcID:= pSrcID; // источник кросса
      end;
      if not pCross and not link.IsOldAnalog then link.IsOldAnalog:= True;
      link.State:= True;
    finally
      CS_wlinks.Leave;
    end;
  end;
end;
//=============== удалить из кеша линк с аналогом/кроссом (def - аналог Гроссби)
procedure TWareInfo.DelAnalogLink(AnalogID: Integer;  pCross: Boolean=False);
var link: TAnalogLink;
begin
  if not Assigned(self) or (AnalogID<1) or not assigned(FInfoWareOpts) then exit;
  with FInfoWareOpts do begin
    if not FAnalogLinks.LinkExists(AnalogID) then exit;
    link:= FAnalogLinks[AnalogID];
    if pCross and link.IsCross then link.IsCross:= False;
    if not pCross and link.IsOldAnalog then link.IsOldAnalog:= False;
    if not link.IsOldAnalog and not link.IsCross then
      FAnalogLinks.DeleteLinkItem(AnalogID);
  end;
end;
//============================ заменить в кеше источник линка с аналогом/кроссом
procedure TWareInfo.SetAnalogLinkSrc(AnalogID, src: Integer);
var link: TAnalogLink;
begin
  if not Assigned(self) or (AnalogID<1) or not assigned(FInfoWareOpts) then exit;
  with FInfoWareOpts do begin
    if not FAnalogLinks.LinkExists(AnalogID) then exit;
    link:= FAnalogLinks[AnalogID];
    if (link.SrcID<>src) then link.SrcID:= src;
  end;
end;
//===================== удалить из кеша непроверенные линки с аналогами/кроссами
procedure TWareInfo.DelNotTestedAnalogs(pCross: Boolean=False; pDel: Boolean=False);
var i: Integer;
    link: TAnalogLink;
begin
  if not Assigned(self) or not assigned(FInfoWareOpts) then exit;
  with FInfoWareOpts do for i:= FAnalogLinks.LinkCount-1 downto 0 do begin
    link:= FAnalogLinks.ListLinks[i];
    if link.State then Continue;
    if pCross and link.IsCross then link.IsCross:= False;
    if not pCross and link.IsOldAnalog then link.IsOldAnalog:= False;
    if not pDel then Continue;
    if not link.IsOldAnalog and not link.IsCross then
      FAnalogLinks.DeleteLinkItem(link);
  end;
end;
//========================================== сортировка аналогов по наименованию
procedure TWareInfo.SortAnalogsByName;
begin
  if not Assigned(self) or not assigned(FInfoWareOpts) then exit;
  with FInfoWareOpts do FAnalogLinks.SortByLinkName;
end;
//==============================================================================
procedure TWareInfo.SetName(const Value: String);
var s: String;
begin
  if not Assigned(self) then exit;
  s:= AnsiUpperCase(fnDelEndOfStr(Value));
  if (FName=s) then Exit;
  FName:= s;
  SetStrW(ik16_3, FName);
end;
//================================================== массив кодов типов аналогов
function TWareInfo.GetAnalogTypes(WithoutEmpty: Boolean=False): Tai; // must Free
var i, pType: Integer;
    analog: TWareInfo;
begin
  SetLength(Result, 0);
  if not Assigned(self) or IsArchive or not Assigned(AnalogLinks)
    or (AnalogLinks.LinkCount<1) then Exit;
  pType:= 0;
  for i:= 0 to AnalogLinks.LinkCount-1 do begin    // идем по аналогам
    analog:= GetLinkPtr(AnalogLinks.ListLinks[i]);
    if not Assigned(analog) or (analog=NoWare) then Continue;
    with analog do begin
      if IsArchive or (PgrID<1) or IsINFOgr then Continue; // инфо пропускаем
      pType:= analog.TypeID;
    end;
    if WithoutEmpty and (pType<1) then Continue; // если нужны только ненулевые типы
//    if (fnInIntArray(pType, Result)>-1) then Continue; // тип уже был
    prAddItemToIntArray(pType, Result);
  end;
end;
//============================================================== записать строку
procedure TWareInfo.SetStrW(const ik: T16InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
    ik16_4: if (FComment<>Value) then FComment:= Value;
  end;
  if assigned(FInfoWareOpts) then with FInfoWareOpts do case ik of
    ik16_2: begin
        Value:= AnsiUpperCase(Value);
        if (FWareSupName<>Value) then
          if (FName<>Value) then FWareSupName:= Value else FWareSupName:= '';
      end;
    ik16_3: begin
        Value:= fnDelSpcAndSumb(FName);
        if Value<>FName then FNameBS:= Value else FNameBS:= '';
      end;
    ik16_4: begin
       Value:= AnsiUpperCase(FComment);
       if (Value<>FComment) then FCommentUP:= Value else FCommentUP:= '';
      end;
    ik16_10: if (FArticleTD<>Value) then FArticleTD:= Value; // Article TecDoc
    ik16_15: if Value<>FName then FMainName:= Value else FMainName:= ''; // WAREMAINNAME
  end;
//  if assigned(FWareOpts) then with FWareOpts do case ik of
//    ik16_1: if (FSLASHCODE<>Value) then FSLASHCODE:= Value;
//  end;
end;
//============================================================== получить строку
function TWareInfo.GetStrW(const ik: T16InfoKinds): String;
var i, j: Integer;
    kind: TCommentKind;
    s: String;
    arTypes: Tai;
    lst: TStringList;
begin
  Result:= '';
  if not Assigned(self) then Exit else case ik of
    ik16_4 : Result:= FComment;
    ik16_9 : with Cache do Result:= arWareInfo[GetPgrID(ID)].Name; // наименование подгруппы
    ik16_11: with Cache do Result:= arWareInfo[GetGrpID(ID)].Name; // наименование группы
  end;

  if assigned(FInfoWareOpts) then with FInfoWareOpts do case ik of
//        ik16_1:  Result:= FSLASHCODE;
    ik16_2:  Result:= fnIfStr(FWareSupName='', FName, FWareSupName);
    ik16_3:  Result:= fnIfStr(FNameBS='', FName, FNameBS);
    ik16_5:  Result:= fnIfStr(FCommentUP='', FComment, FCommentUP);
    ik16_8:  Result:= Cache.GetMeasName(measID);     // наименование ед.изм.
    ik16_10: Result:= FArticleTD;                    // Article TecDoc
    ik16_12: Result:= Cache.GetWareTypeName(TypeID); // наименование типа товара
    ik16_13: begin //------------------ комментарий для Web с учетом типа товара
        kind:= ckEmpty;
        Result:= trim(FComment); // сначала берем, что есть
        //---------- инфо-группа: если FComment пустой или 'OE' - добавляем типы
        if IsINFOgr then begin
          i:= length(Result);
          if (i=2) then begin // проверяем на 'OE'
            s:= AnsiUpperCase(Result);
            if (s='OE') or (s='ОЕ') or (s='OЕ') or (s='ОE') then i:= 0;
          end;
          if (i<1) then
            if (FTypeID>0) then kind:= ckByType // тип задан
            else if Assigned(AnalogLinks) and   // типы по аналогам
              (AnalogLinks.LinkCount>0) then kind:= ckByTypes;
        end //---------- товар: если FComment пустой и тип задан - добавляем тип
        else if (Result='') and (FTypeID>0) then kind:= ckByType;

        if (kind=ckByType) then                               // тип задан
          Result:= Result+fnIfStr(Result='', '', ', ')+Cache.GetWareTypeName(FTypeID)
        else if (kind=ckByTypes) then try // типы по аналогам
          s:= ''; // собираем строку из названий типов
          arTypes:= GetAnalogTypes(True); // массив кодов типов (без нулевого)
          for i:= 0 to High(arTypes) do
            s:= s+fnIfStr(s='', '', ' / ')+Cache.GetWareTypeName(arTypes[i]);
          if s<>'' then Result:= Result+fnIfStr(Result='', '', ', ')+s;
        finally
          SetLength(arTypes, 0);
        end;
      end; // ik16_13
    ik16_15:  Result:= fnIfStr(FMainName='', FName, FMainName); // WAREMAINNAME
    ik16_16: begin //------------------------- название направления по продуктам
        lst:= Cache.DiscountModels.ProdDirectList;
        for i:= 0 to lst.Count-1 do begin
          j:= Integer(lst.Objects[i]);
          if (j<>ProdDirect) then Continue;
          Result:= lst[i];
          Exit;
        end;
      end; // ik16_16
  end; // with FInfoWareOpts do case ik of

  if Cache.WareBrands.ItemExists(WareBrandID) and (ik in [ik16_6, ik16_7, ik16_14]) then
    with TBrandItem(Cache.WareBrands[WareBrandID]) do case ik of
      ik16_6 : Result:= NameWWW;   // наименование для файла логотипа бренда
      ik16_7 : Result:= Name;      // наименование бренда
      ik16_14: Result:= adressWWW; // адрес ссылки на сайт бренда
    end;
end;
//======================================================== получить вещ.значение
function TWareInfo.GetDoubW(const ik: T8InfoKinds): Single;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  if assigned(FWareOpts) then with FWareOpts do case ik of
   ik8_1: Result:= Fdivis;                                 // кратность
  end else case ik of
    ik8_1: Result:= 1.0;      // кратность для ИНФО
  end;
end;
//======================================================== записать вещ.значение
procedure TWareInfo.SetDoubW(const ik: T8InfoKinds; Value: Single);
begin
  if not Assigned(self) or not assigned(FWareOpts) then Exit;
  with FWareOpts do case ik of
    ik8_1: begin                        // кратность
           if not fnNotZero(Value) then Value:= 1.0;
           if fnNotZero(Fdivis-Value) then Fdivis:= RoundTo(Value, -3);
         end;
  end;
end;
//============================================================= получить признак
function TWareInfo.GetBoolW(const Index: TKindBoolOptW): boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  case Index of
    ikwFixT: if Assigned(FInfoWareOpts) then Result:= (FInfoWareOpts.FTypeID>0);
//    ikwAuto: Result := (PrDirectName=cpdNameAuto);
//    ikwMoto : Result:= (PrDirectName=cpdNameMoto);
//    ikwMotul: Result:= (PrDirectName=cpdNameMotul);
  else Result:= (Index in FWareBoolOpts);
  end;
end;
//============================================================= записать признак
procedure TWareInfo.SetBoolW(const Index: TKindBoolOptW; Value: boolean);
begin
  if not Assigned(self) then Exit;
  if Value then begin
    FWareBoolOpts:= FWareBoolOpts+[Index];
    if not (Index in [ikwWare, ikwPgr, ikwGrp, ikwType]) then Exit;
    if IsGrp then begin
      FWareBoolOpts:= FWareBoolOpts-[ikwWare, ikwPgr, ikwType];
    end else if IsPgr then begin
      FWareBoolOpts:= FWareBoolOpts-[ikwWare, ikwGrp, ikwType];
    end else if IsWare then begin
      FWareBoolOpts:= FWareBoolOpts-[ikwPgr, ikwGrp, ikwType];
    end else if IsType then begin
      FWareBoolOpts:= FWareBoolOpts-[ikwPgr, ikwGrp, ikwWare];
    end;
  end else FWareBoolOpts:= FWareBoolOpts-[Index];
end;
//================================================================= получить код
function TWareInfo.GetIntW(const ik: T16InfoKinds): Integer;
var i, pType: Integer;
    analog: TWareInfo;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik16_1: if Cache.PgrExists(PgrID) then Result:= Cache.arWareInfo[PgrID].PgrID; // код группы
    ik16_5: Result:= FParCode;     // код подгруппы
    ik16_6: Result:= FOrderNum;    // код бренда товара
    else if assigned(FInfoWareOpts) then with FInfoWareOpts do case ik of
      ik16_3: Result:= FManagerID;   // код менеджера (EMPLCODE)
      ik16_7: Result:= FmeasID;      // код ед.изм.
      ik16_4: Result:= FSubCode;     // SupID TecDoc (DS_MF_ID !!!)
      ik16_8: if FTypeID>0 then Result:= FTypeID  // код типа товара
             else if IsINFOgr and Assigned(AnalogLinks) then // у ИНФО определяем по аналогам
               with AnalogLinks do if (LinkCount>0) then begin
                 analog:= GetLinkPtr(ListLinks[0]);
                 pType:= analog.TypeID; // берем тип первого
                 for i:= 1 to LinkCount-1 do begin
                   analog:= GetLinkPtr(ListLinks[i]);
                   if analog.IsINFOgr then Continue;
                   if (pType<>analog.TypeID) then Exit; // если нашли другой тип - выходим
                 end;
                 Result:= pType;
               end; // with AnalogLinks ... if (LinkCount>0)
      ik16_9: Result:= FProdDirect;      // Направление по продуктам
      else if assigned(FWareOpts) then with FWareOpts do case ik of
        ik16_2: if Assigned(AttrLinks) then with AttrLinks do try // код группы атрибутов
                 if LinkCount>0 then Result:= GetDirItemSubCode(GetLinkPtr(ListLinks[0]));
               except end;
      end;
    end;
  end;
end;
//================================================================= записать код
procedure TWareInfo.SetIntW(const ik: T16InfoKinds; Value: Integer);
begin
  if not Assigned(self) then Exit else case ik of
    ik16_5:     if (FParCode    <>Value) then FParCode    := Value; // код подгруппы
    ik16_6:     if (FOrderNum   <>Value) then FOrderNum   := Value; // код бренда товара
    else if assigned(FInfoWareOpts) then with FInfoWareOpts do case ik of
      ik16_3:   if (FManagerID  <>Value) then FManagerID  := Value; // код менеджера (EMPLCODE)
      ik16_7:   if (FmeasID     <>Value) then FmeasID     := Value; // код ед.изм.
      ik16_4:   if (FSubCode    <>Value) then FSubCode    := Value; // SupID TecDoc (DS_MF_ID !!!)
      ik16_8:   if (FTypeID     <>Value) then FTypeID     := fnIfInt(Cache.TypeExists(Value), Value, 0); // код типа товара
      ik16_9:   if (FProdDirect <>Value) then FProdDirect := Value; // Направление по продуктам
//      else if assigned(FWareOpts) then with FWareOpts do case ik of
//      end;
    end;
  end;
end;
//============================================== розничная цена товара по прайсу
function TWareInfo.RetailTypePrice(pTypeInd: Integer; currcode: Integer=cDefCurrency): double;
var curr: Single;
begin
  Result:= 0;
  if not Assigned(self) or (currcode<1) then Exit;
  with Cache do begin                      // проверка валидности индекса прайса
    if (pTypeInd<Low(PriceTypes)) or (pTypeInd>High(PriceTypes)) then pTypeInd:= Low(PriceTypes);
    if not CurrExists(currcode) then currcode:= cDefCurrency; // проверка валюты
    Result:= FWareOpts.FPrices[pTypeInd];                        // розн.цена товара в евро
//    if currcode<>cDefCurrency then Result:= Result*DefCurrRate; // розн.цена товара в грн.
    if (currcode<>cDefCurrency) then begin
      curr:= Currencies.GetCurrRate(currcode);
      if fnNotZero(curr) then // розн.цена товара в валюте(не евро)
        Result:= Result*Currencies.GetCurrRate(cDefCurrency)/curr;
    end;
  end;
//  Result:= RoundToHalfDown(Result);
end;
//========================= записать / проверить розничную цену товара по прайсу
procedure TWareInfo.CheckPrice(price: Single; pTypeInd: Integer);
begin
  if not Assigned(self) or not IsWare or not Assigned(FWareOpts) then Exit;
  with Cache do if (pTypeInd<Low(PriceTypes)) or (pTypeInd>High(PriceTypes)) then
    pTypeInd:= Low(PriceTypes);            // проверка валидности индекса прайса
  with FWareOpts do begin
    if High(FPrices)<pTypeInd then try
      CS_wlinks.Enter;
      SetLength(FPrices, Length(Cache.PriceTypes));
    finally
      CS_wlinks.Leave;
    end;
    if fnNotZero(FPrices[pTypeInd]-price) then FPrices[pTypeInd]:= price;
  end;
end;
//======================================== получить скидки и индекс прайса фирмы
procedure TWareInfo.GetFirmDiscAndPriceIndex(FirmID: Integer; var ind: Integer;
                    var disc, disNext: double; contID: Integer=0);
var link: TQtyLink;
    Contract: TContract;
    firm: TFirmInfo;
    gr: TWareInfo;
    id1, id2, dm, i: Integer;
  //-------------------------------- скидка по шаблону
  function _GetDiscByModel: double;
  begin
    link:= nil;
    Result:= 0;
    if Assigned(FDiscModLinks) and (FDiscModLinks.Count>0) then // ищем скидку товара
      link:= FDiscModLinks.GetLinkListItemByID(dm, lkLnkByID);
    if not Assigned(link) then begin                          // ищем скидку подгруппы
      gr:= Cache.arWareInfo[id1];
      if Assigned(gr.FDiscModLinks) and (gr.FDiscModLinks.Count>0) then
        link:= gr.FDiscModLinks.GetLinkListItemByID(dm, lkLnkByID);
    end;
    if not Assigned(link) and (id2>0) then begin              // ищем скидку группы
      gr:= Cache.arWareInfo[id2];
      if Assigned(gr.FDiscModLinks) and (gr.FDiscModLinks.Count>0) then
        link:= gr.FDiscModLinks.GetLinkListItemByID(dm, lkLnkByID);
    end;
    if not Assigned(link) then Exit;
    Result:= link.Qty;
  end;
  //--------------------------------
begin
  if Assigned(Cache) then ind:= Low(Cache.PriceTypes) else ind:= 0;
  disc:= 0;
  disNext:= 0;
  link:= nil;
  if not Assigned(self) or (FirmID=IsWe) or not Cache.FirmExist(FirmID) then Exit;
  firm:= Cache.arFirmInfo[FirmID];
  Contract:= firm.GetContract(contID);
  if IsWare then begin         // скидка клиента на товар
    id1:= PgrID;
    id2:= GrpID;
  end else if IsPgr then begin // скидка клиента на подгруппу
    id1:= ID;
    id2:= PgrID;
  end else if IsGrp then begin // скидка клиента на группу
    id1:= ID;
    id2:= 0;
  end else Exit;

  i:= fnInIntArray(Contract.ContPriceType, Cache.PriceTypes);
  if (i>-1) then ind:= i;                           // индекс прайса
  if (ProdDirect<1) then Exit; // не задано направление товара

  dm:= firm.GetCurrentDiscModel(ProdDirect, i).ID;  // код текущего шаблона скидок
  if (dm<1) then Exit; // не найден текущий шаблон
  disc:= _GetDiscByModel;                           // скидка по текущему шаблону

  dm:= Cache.DiscountModels.GetNextDirectModel(dm); // код следующего шаблона
  if (dm<1) then disNext:= disc // не найден следующий шаблон - берем по текущему
  else disNext:= _GetDiscByModel;                   // скидка по следующему шаблону
end;
//============================================== розничная цена товара для фирмы
function TWareInfo.RetailPrice(FirmID: Integer=IsWe; currcode: Integer=cDefCurrency; contID: Integer=0): double;
var i: Integer;
    dis, disNext: double;
begin
  Result:= 0;
  if not Assigned(self) or (currcode<1) or not IsWare or not Assigned(FWareOpts) then Exit;
  GetFirmDiscAndPriceIndex(FirmID, i, dis, disNext, contID); // индекс прайса
  Result:= RetailTypePrice(i, currcode);    // розн.цена товара
  Result:= RoundToHalfDown(Result);
end;
//============================================== продажная цена товара для фирмы
function TWareInfo.SellingPrice(FirmID: Integer=IsWe; currcode: Integer=cDefCurrency; contID: Integer=0): double;
var i: Integer;
    dis, disNext: double;
begin
  Result:= 0;
  if not Assigned(self) or (currcode<1) or not IsWare or not Assigned(FWareOpts) then Exit;
  GetFirmDiscAndPriceIndex(FirmID, i, dis, disNext, contID); // индекс прайса, скидка фирмы
  Result:= RetailTypePrice(i, currcode);    // розн.цена товара

  if not fnNotZero(Result) then Exit; // 0-я цена

  Result:= RoundToHalfDown(Result);
  if IsSale or IsCutPrice or not fnNotZero(dis) then Exit; // распродажа/уценка/нет скидки

  Result:= Result*(1.0-dis/100.0); // продажная цена товара
  Result:= RoundToHalfDown(Result);
//  if currcode=1 then Result:= RoundTo(Result/6, -2)*6; // пересчет грн под НДС
end;
//=========================== цена товара с наценкой (% к продажной) для клиента
function TWareInfo.MarginPrice(FirmID: Integer=IsWe; UserID: Integer=0;
         currcode: Integer=cDefCurrency; contID: Integer=0): double;
var marg: double;
    Client: TClientInfo;
begin
  Result:= 0;
  if not Assigned(self) or (currcode<1) or not IsWare or not Assigned(FWareOpts) then Exit;
  Result:= SellingPrice(FirmID, currcode, contID);
  Result:= RoundToHalfDown(Result);

  if not fnNotZero(Result) then Exit; // 0-я цена
  if (FirmID=IsWe) or not Cache.ClientExist(UserID) then Exit;

  Client:= Cache.arClientInfo[UserID];
  if not Client.CheckContract(contID) then Exit; // недоступный контракт

  marg:= Client.GetContCacheGrpMargin(contID, self.PgrID); // ищем наценку на подгруппу
  if not fnNotZero(marg) then  // если нет - ищем наценку на группу
    marg:= Client.GetContCacheGrpMargin(contID, self.GrpID);
  if not fnNotZero(marg) then Exit;  // наценки нет

  Result:= Result*(1.0+marg/100.0); // цена с наценкой (% к продажной)
  Result:= RoundToHalfDown(Result);
end;
//========================================== все цены товара по фирме, контракту
function TWareInfo.CalcFirmPrices(FirmID: Integer=IsWe; currID: Integer=cDefCurrency; // must Free !!!
                                 contID: Integer=0): TDoubleDynArray;
// 0- Розница, 1- со скидкой, 2- со след.скидкой
var i, len: Integer;
    dis, disNext: double;
begin
  len:= Length(arPriceColNames);
  SetLength(Result, len);
  for i:= 0 to High(Result) do Result[i]:= 0;
  if not Assigned(self) or (currID<1) or not IsWare or not Assigned(FWareOpts) then Exit;
  GetFirmDiscAndPriceIndex(FirmID, i, dis, disNext, contID); // индекс прайса, скидка фирмы
  Result[0]:= RoundToHalfDown(RetailTypePrice(i, currID));   // розн.цена товара

  if IsSale or IsCutPrice then begin // распродажа/уценка
    Result[1]:= Result[0];
    Result[2]:= Result[0];
    Exit;
  end;

  if not fnNotZero(dis) then Result[1]:= Result[0]
  else Result[1]:= RoundToHalfDown(Result[0]*(1.0-dis/100.0)); // продажная цена товара
//  if currcode=1 then Result[1]:= RoundTo(Result[1]/6, -2)*6; // пересчет грн под НДС

  if not fnNotZero(disNext) then Result[2]:= Result[0]
  else if not fnNotZero(dis-disNext) then Result[2]:= Result[1]
  else Result[2]:= RoundToHalfDown(Result[0]*(1.0-disNext/100.0)); // цена со скидкой след.уровня
end;
//=============================== список значений атрибутов товара для просмотра
function TWareInfo.GetWareAttrValuesView: TStringList; // must Free Result
// возвращает список: имя атрибута = значение атрибута
const nmProc='GetWareAttrValuesView';
var i: integer;
    s1, s2: string;
    attlink: TTwoLink;
begin
  Result:= TStringList.Create;
  Result.Sorted:= False;
  attlink:= nil;
  if not Assigned(self) or not IsWare or not Assigned(AttrLinks) then Exit;
  with AttrLinks do try // список атрибутов
    if LinkCount<1 then Exit;
    Result.Capacity:= Result.Capacity+LinkCount;
    for i:= 0 to LinkCount-1 do begin
      s1:= GetLinkName(ListLinks[i]);
      if (s1='') then Continue else attlink:= ListLinks[i];
      if Assigned(attlink.LinkPtrTwo) then begin
        s2:= GetDirItemName(attlink.LinkPtrTwo); // значение атрибута
        Result.Add(s1+'='+s2);
      end;
    end; // for
  except end; // with AttrLinks
end;
//=================== список значений атрибутов товара по кодам в нужном порядке
function TWareInfo.GetWareAttrValuesByCodes(AttCodes: Tai): TStringList; // must Free
const nmProc='GetWareAttrValuesByCodes';
var i, attcode: integer;
    s2: string;
    fl: Boolean;
    attlink: TTwoLink;
begin
  Result:= fnCreateStringList(False, Length(AttCodes));
  fl:= Assigned(self) and IsWare and Assigned(AttrLinks) and (AttrLinks.LinkCount>0);
  for i:= Low(AttCodes) to High(AttCodes) do begin
    s2:= '';
    attcode:= AttCodes[i];
    if fl and AttrLinks.LinkExists(attcode) then try // если есть линк на такой атрибут
      attlink:= AttrLinks[attcode];
      if Assigned(attlink.LinkPtrTwo) then
        s2:= GetDirItemName(attlink.LinkPtrTwo); // значение атрибута
    except end;
    Result.Add(s2);
  end;
end;
//================================ Проверка принадлежности к системе Авто / Мото
function TWareInfo.CheckWareTypeSys(TypeSysID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) then exit;

  Result:= IsPrize or (TypeSysID=0);
  if Result then Exit;

  case TypeSysID of
    constIsAuto: Result:= IsAUTOWare;
    constIsMoto: Result:= IsMOTOWare;
  end;
end;
{//==================================== Установить / снять принадлежность системе
procedure TWareInfo.SetWareTypeSys(pTypeSys: Integer; IsSys: Boolean=False);
// pTypeSys - код системы, 0 - сбросить признаки AUTO и MOTO
// IsSys - признак принадлежности системе pTypeSys (AUTO или MOTO)
begin
  if not Assigned(self) then Exit else case pTypeSys of
    0: begin
        IsAUTOWare:= False;
        IsMOTOWare:= False;
      end;
    constIsAuto: IsAUTOWare:= IsSys;
    constIsMoto: IsMOTOWare:= IsSys;
  end;
end; }
//=== список ориг.номеров товара, сортированный по производителям и наименованию
procedure TWareInfo.SortOrigNumsWithSrc(var arCodes, arSrc: Tai);
var i, onID, src: Integer;
    TwoCodes: TTwoCodes;
begin
  SetLength(arCodes, 0);
  SetLength(arSrc, 0);
  if not Assigned(self) or not Assigned(Cache) then Exit;
  with TStringList.Create do try
    Capacity:= Capacity+ONumLinks.Count;
    for i:= 0 to ONumLinks.Count-1 do begin
      onID:= GetLinkID(ONumLinks[i]);
      src:= GetLinkSrc(ONumLinks[i]);
      if Cache.FDCA.OrigNumExist(onID) then
        AddObject(Cache.FDCA.GetOriginalNum(onID).SortString, TTwoCodes.Create(onID, src));
    end; // for i:= 0 to ONumLinks.Count-1
    if Count>1 then Sort;
    SetLength(arCodes, Count);
    SetLength(arSrc, Count);
    for i:= 0 to Count-1 do begin
      TwoCodes:= TTwoCodes(Objects[i]);
      arCodes[i]:= TwoCodes.ID1;
      arSrc[i]:= TwoCodes.ID2;
      prFree(TwoCodes);
    end;
  finally Free; end;
end;
//======================== Поиск оригинального номера в списке ор.номеров товара
function TWareInfo.FindOriginalNum(ONumID, mfauID: Integer; OrigNum: String): Boolean;
var  i, j, mfID: Integer;
   s: String;
   fMF, fON, fID: Boolean;
begin
  Result:= False;
  if not Assigned(self) or not Assigned(Cache) then Exit;
  mfID:= 0;
  s:= '';
  OrigNum:= AnsiUpperCase(fnDelSpcAndSumb(fnDelEndOfStr(OrigNum)));
  fON:= OrigNum<>'';
  fMF:= mfauID>0;
  fID:= ONumID>0;
  if not (fON or fMF or fID) then Exit;
  for i:= 0 to ONumLinks.Count-1 do begin
    j:= GetLinkID(ONumLinks[i]);
    if not Cache.FDCA.OrigNumExist(j) then Continue;
    with Cache.FDCA.arOriginalNumInfo[j] do begin
      if fMF then mfID:= MfAutoID;
      if fON then s:= OriginalNum;
    end;
    Result:= (fID and (j=ONumID)) or (fON and (s=OrigNum) and (not fMF or (mfID=mfauID)));
    if Result then Exit;
  end; // for
end;
//======== сортировка TList моделей - произв. + м.р. + порядк.№ + наименование
function WareModelsSortCompare(Item1, Item2: Pointer): Integer;
var i1, i2: Integer;
    Model1, Model2: TModelAuto;
begin
  with Cache.FDCA do try
    Model1:= Item1;
    Model2:= Item2;
    if Model1.ModelMfauID<>Model2.ModelMfauID then
      Result:= AnsiCompareText(Model1.ModelMfauName, Model2.ModelMfauName)
    else if Model1.ModelLineID<>Model2.ModelLineID then
      Result:= AnsiCompareText(Model1.ModelLineName, Model2.ModelLineName)
    else begin
      i1:= Model1.ModelOrderNum;
      i2:= Model2.ModelOrderNum;
      if i1=i2 then Result:= AnsiCompareText(Model1.SortName, Model2.SortName)
      else if i1<i2 then Result:= -1 else Result:= 1;
    end;
  except
    Result:= 0;
  end;
end;
//==== видим.модели системы по товару - произв. + м.р. + порядк.№ + наименование
function TWareInfo.GetSysModels(pSys: Integer; pMfau: Integer=0): TList; // Object - TModelAuto, must Free
const nmProc = 'GetSysModels';
// pMfau=0 - все модели товара по системе, pMfau>0 - только заданного производителя
var i: Integer;
    model: TModelAuto;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
begin
  Result:= TList.Create;
  if not Assigned(self) or not IsWare or
    not Assigned(FWareOpts) or not CheckTypeSys(pSys) then Exit;
//---------------------------------------------------------------------- из кеша
  if Cache.WareLinksUnLocked then with ModelLinks do begin
    if not ModelsSorting and (Count>1) then begin
      Sort(WareModelsSortCompare); // сортируем линки при первом вызове
      ModelsSorting:= True;        // флаг - уже отсортирован
    end;
    for i:= 0 to Count-1 do try
      model:= Items[i];
      if not model.IsVisible or (model.TypeSys<>pSys) then Continue;
      if (pMfau>0) and (model.ModelMfauID<>pMfau) then Continue;
      Result.Add(model);
    except end;
    Exit;
  end;

  ORD_IBD:= nil;
  ORD_IBS:= nil;
  try try  //--------------------------------------------------------------- из базы
    ORD_IBD:= cntsOrd.GetFreeCnt;
    ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
    ORD_IBS.SQL.Text:= 'select DMOSCODE from LINKDETMODWARE lw1'+
      '  inner join LINKDETAILMODEL l1 on l1.LDEMCODE=lw1.LDMWLDEMCODE and l1.LDEMWRONG="F"'+
      '  inner join DIRMODELS m1 on m1.DMOSCODE=l1.LDEMDMOSCODE and m1.dmosisvisible="T"'+
      '  inner join DIRMODELLINES ml1 on ml1.DRMLCODE=m1.DMOSDRMLCODE and ml1.drmldtsycode='+IntToStr(pSys)+
      '  where lw1.LDMWWARECODE='+IntToStr(ID)+' and lw1.LDMWWRONG="F"';
    if (pMfau>0) then ORD_IBS.SQL.Text:= ORD_IBS.SQL.Text+' and ml1.drmlmfaucode='+IntToStr(pMfau);
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      i:= ORD_IBS.FieldByName('DMOSCODE').AsInteger;  // Код модели
      if Cache.FDCA.Models.ModelExists(i) then Result.Add(Cache.FDCA.Models[i]);
      cntsORD.TestSuspendException;
      ORD_IBS.Next;
    end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ORD_IBS);
    cntsOrd.SetFreeCnt(ORD_IBD);
    if (Result.Count>1) then Result.Sort(WareModelsSortCompare); // сортируем
  end;
end;
//============================== признак наличия видим.моделей системы по товару
function TWareInfo.SysModelsExists(pSys: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not IsWare or not Assigned(FWareOpts) or not CheckTypeSys(pSys) then Exit;
  case pSys of
    constIsAuto: Result:= HasModelAuto;
    constIsMoto: Result:= HasModelMoto;
  end;
end;
//==================== проверка признака наличия видим.моделей системы по товару
function TWareInfo.CheckHasModels(pSys: Integer): Boolean;
var i: Integer;
    model: TModelAuto;
    fl: Boolean;
begin
  Result:= False;
  if not Assigned(self) or not IsWare or not Assigned(FWareOpts) or not CheckTypeSys(pSys) then Exit;
  fl:= False;
  with ModelLinks do for i:= 0 to Count-1 do try
    model:= Items[i];
    fl:= model.IsVisible and (model.TypeSys=pSys);
    if fl then break;
  except end;
  case pSys of
    constIsAuto: HasModelAuto:= fl;
    constIsMoto: HasModelMoto:= fl;
  end;
end;
//=========================================== заполнить параметры товара из базы
procedure TWareInfo.SetWareParams(pPgrID: Integer; ibs: TIBSQL; fromGW: Boolean=False);
var flWareOpts: boolean;
    k: Integer;
    n: String;
begin
  IsWare:= True;
  IsPrize:= GetBoolGB(ibs, 'WAREBONUS');
  if not fromGW then begin // вызов из TestWares
    PgrID:= pPgrID;
    IsSale:= GetBoolGB(ibs, 'sale');
    IsINFOgr:= Cache.arWareInfo[pPgrID].IsINFOgr;
    flWareOpts:= not IsINFOgr; // WareOpts заполняем только у неИНФО товаров
  end else begin // вызов из GetWare
    IsArchive:= GetBoolGB(ibs, 'warearchive');
//    flWareOpts:= not IsArchive and (pPgrID>0) and Cache.PgrExists(pPgrID);
    flWareOpts:= not IsArchive and (IsPrize or ((pPgrID>0) and Cache.PgrExists(pPgrID)));
    if flWareOpts then begin // WareOpts заполняем только у неархивных товаров
      PgrID:= pPgrID;
      IsSale:= GetBoolGB(ibs, 'sale');
//      IsINFOgr:= Cache.arWareInfo[GrpID].IsINFOgr;  // добавить ???
    end;
  end;

  if not assigned(FInfoWareOpts) then
    FInfoWareOpts:= TInfoWareOpts.Create(CS_wlinks);

  Name       := ibs.FieldByName('WAREOFFICIALNAME').AsString;
  MainName   := ibs.FieldByName('WAREMAINNAME').AsString;
  Comment    := ibs.FieldByName('WARECOMMENT').AsString;
  WareSupName:= ibs.FieldByName('WARESUPPLIERNAME').AsString;
  measID     := ibs.FieldByName('WAREMEAS').AsInteger;
  WareBrandID:= ibs.FieldByName('WAREBRANDCODE').AsInteger;
  ManagerID  := ibs.FieldByName('REmplCode').AsInteger; // код менеджера
  TypeID     := ibs.FieldByName('wType').AsInteger;
  IsTop      := (ibs.FieldByName('wTOP').AsInteger=1);
  IsCutPrice := (ibs.FieldByName('wCutPrice').AsInteger=1);

//  IsNonReturn:= IsSale or IsCutPrice;
  IsNonReturn:= IsCutPrice;
  ProdDirect:= ibs.FieldByName('WrPrProductDirection').AsInteger;
  IsAUTOWare:= IsPrize or (PrDirectName=cpdNameAuto) or (PrDirectName=cpdNameMotul);
  IsMOTOWare:= IsPrize or (PrDirectName=cpdNameMoto) or (PrDirectName=cpdNameMotul);
//  IsAUTOWare:= (ibs.FieldByName('wAUTO').AsInteger>0);
//  IsMOTOWare:= (ibs.FieldByName('wMOTO').AsInteger>0);

  if not flWareOpts then exit;

  if not assigned(FWareOpts) then FWareOpts:= TWareOpts.Create(CS_wlinks);
//  SLASHCODE:= ibs.FieldByName('WARESLASHCODE').AsString;
  divis:= ibs.FieldByName('WAREDIVISIBLE').AsFloat;
  for k:= 0 to High(Cache.PriceTypes) do begin // цены по прайсам
    if k=0 then n:= '' else n:= IntToStr(k);
    if ibs.FieldIndex['priceEUR'+n]>-1 then    // подстраховка
      CheckPrice(ibs.FieldByName('priceEUR'+n).AsFloat, k);
  end;
end;
//=============================== список значений критериев товара для просмотра
function TWareInfo.GetWareCriValuesView(SysID: Integer=0): TStringList; // must Free Result
const nmProc = 'GetWareCriValuesView';
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    iCri, iNode: integer;
    s, ss, CriName: String;
    flSysOnly: Boolean;
begin
  Result:= TStringList.Create;
  if not Assigned(self) or not IsWare then Exit;
  ORD_IBS:= nil;
  ORD_IBD:= nil;
  try try
   ORD_IBD:= cntsOrd.GetFreeCnt;
   ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
    //----------------------------------------------------- значения критериев
    ORD_IBS.SQL.Text:= 'select WCRICODE, WCRIDESCR, WCVSVALUE'+
      ' from (select LWCVWCVSCODE from LINKWARECRIVALUES'+
      ' where LWCVWARECODE='+IntToStr(ID)+' and LWCVWRONG="F")'+
      ' left join WARECRIVALUES on WCVSCODE=LWCVWCVSCODE'+
      ' left join WARECRITERIES on WCRICODE=WCVSWCRICODE'+
      ' order by WCRIORDNUM nulls last, WCRICODE, WCVSVALUE';
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      iCri:= ORD_IBS.FieldByName('WCRICODE').AsInteger;
      CriName:= ORD_IBS.FieldByName('WCRIDESCR').AsString;
      s:= '';
      while not ORD_IBS.Eof and (iCri=ORD_IBS.FieldByName('WCRICODE').AsInteger) do begin
        ss:= ORD_IBS.FieldByName('WCVSVALUE').AsString;
        if ss<>'' then s:= s+fnIfStr(s='', '', ', ')+ss;
        cntsORD.TestSuspendException;
        ORD_IBS.Next;
      end;
      Result.Add(CriName+fnIfStr(s='', '', ': '+s)); // строка по 1-му критерию
    end;
    ORD_IBS.Close;
    //------------------------------------------- тексты к связке товар - нода
    flSysOnly:= CheckTypeSys(SysID); // признак вывода текстов только по заданной системе
    ORD_IBS.SQL.Text:= 'select LWNTnodeID, LWNTinfotype, DITMNAME, TRNANAME,'+
      ' iif(ITATEXT is null, ITTEXT, ITATEXT) text'+
      fnIfStr(flSysOnly, '', ', TRNADTSYCODE')+
      ' from (select LWNTnodeID, LWNTinfotype, LWNTWIT'+
      '  from LinkWareNodeText where LWNTwareID='+IntToStr(ID)+' and LWNTWRONG="F")'+
      ' left join DIRINFOTYPEMODEL on DITMCODE = LWNTinfotype'+
      ' left join TREENODESAUTO on TRNACODE=LWNTnodeID'+
      ' left join WareInfoTexts on WITCODE=LWNTWIT'+
      ' left join INFOTEXTS on ITCODE=WITTEXTCODE'+
      ' left join INFOTEXTSaltern on ITACODE=ITALTERN'+
      fnIfStr(flSysOnly, ' where TRNADTSYCODE='+IntToStr(SysID), '')+
      ' order by'+fnIfStr(flSysOnly, '', ' TRNADTSYCODE,')+' LWNTnodeID, LWNTinfotype, text';
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      iNode:= ORD_IBS.FieldByName('LWNTnodeID').AsInteger;
      s:= 'Узел - '+ORD_IBS.FieldByName('TRNANAME').AsString+':';
      s:= brcWebColorBlueBegin+s+brcWebColorEnd; // синий шрифт
      Result.Add(s);
      while not ORD_IBS.Eof and (iNode=ORD_IBS.FieldByName('LWNTnodeID').AsInteger) do begin
        iCri:= ORD_IBS.FieldByName('LWNTinfotype').AsInteger;
        CriName:= ORD_IBS.FieldByName('DITMNAME').AsString;
        s:= '';
        while not ORD_IBS.Eof and (iNode=ORD_IBS.FieldByName('LWNTnodeID').AsInteger)
          and (iCri=ORD_IBS.FieldByName('LWNTinfotype').AsInteger) do begin
          ss:= ORD_IBS.FieldByName('text').AsString;
          if ss<>'' then s:= s+fnIfStr(s='', '', ', ')+ss;
          cntsORD.TestSuspendException;
          ORD_IBS.Next;
        end; // while ... and (iNode= ... and (iCri=
      end; // while ... and (iNode=
      Result.Add(cWebSpace+cWebSpace+CriName+fnIfStr(s='', '', ': '+s)); // отступ + строка по 1-му типу текста
    end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
  finally
    prFreeIBSQL(ORD_IBS);
    cntsOrd.SetFreeCnt(ORD_IBD);
  end;
end;
//=================================== Установить / снять связь с артиклем TecDoc
function TWareInfo.CheckArticleLink(pArticle: String; pSupID: Integer;
         var ResCode: Integer; userID: Integer=0; flDelInfo: Boolean=True): String;
const nmProc = 'CheckArticleLink';
// вид операции - ResCode - на входе (resAdded, resDeleted, resWrong, resNotWrong)
// (flDelInfo=True) + (ResCode in [resDeleted, resWrong]) - удалить всю инф-цию, посаженную из TecDoc
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось,
// resAdded - связка добавлена, resDeleted - связка удалена,
// resWrong - отмечена ошибочная связка в базе и удалена из кеша
// resNotWrong - снята отметка ошибочной связки в базе и связка добавлена в кеш
type RWareIndo = record
    kind, rCode, rCode1, rCode2: Integer;
  end;
var IBDord, IBDtdt: TIBDatabase;
    IBSord, IBStdt: TIBSQL;
    ari: array of RWareIndo;
    j, i, k, OpCode, wCount: Integer;
    Model: TModelAuto;
    Eng: TEngine;
    link: TLink;
    link2: TSecondLink;
    flEx: Boolean;
    sArtLink: String;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  if not Assigned(self) or not IsWare or not Assigned(FInfoWareOpts) then Exit;
  pArticle:= Trim(pArticle);
  wCount:= 0;
  IBSord:= nil;
  IBStdt:= nil;
  j:= 0;
  SetLength(ari, 0);
  try
//-------------------------------------------------------------------- проверяем
    if not (OpCode in [resAdded, resDeleted, resWrong, resNotWrong]) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if (pArticle='') or (pSupID<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' артикула');
    if not IsInfoGr and
      (fnInIntArray(pSupID, TBrandItem(Cache.WareBrands[WareBrandID]).TDMFcodes)<0) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' бренда');

    sArtLink:= MessText(mtkWareArticleLink);
    case OpCode of
    resAdded, resNotWrong: begin
        if (pArticle=ArticleTD) and (pSupID=ArtSupTD) then begin
          ResCode:= resDoNothing;
          raise EBOBError.Create('такая '+sArtLink+' уже есть');
        end;
        if (ArticleTD<>'') and (ArtSupTD>0) then
          raise EBOBError.Create('товар связан с другим артикулом');
        if (userID<1) then raise EBOBError.Create(MessText(mtkNotParams));
      end;
    resDeleted, resWrong:
      if (pArticle<>ArticleTD) or (pSupID<>ArtSupTD) then begin
        ResCode:= resDoNothing;
        raise EBOBError.Create('не найдена такая '+sArtLink);
      end;
    end; // case
//--------------------------------------------------- отрабатываем запись в базу
    IBDtdt:= cntsTDT.GetFreeCnt;
    try
      IBDord:= cntsOrd.GetFreeCnt;

      IBStdt:= fnCreateNewIBSQL(IBDtdt, 'IBS_'+nmProc, -1, tpWrite, True);
      try
        IBSord:= fnCreateNewIBSQL(IBDord, 'IBS_'+nmProc, -1, tpWrite, True);

        if (OpCode in [resWrong, resDeleted]) then begin
          if  flDelInfo then          // удалить инфо товара по источнику-TecDoc
            IBSord.SQL.Text:= 'select * from DelWareInfoByTDsrc('+IntToStr(ID)+')'
          else // изменить источник инфо-товара с источника-TecDoc на TecDoc-старый
            IBSord.SQL.Text:= 'select * from ChangeWareInfoSrcFromTDtoTDold('+IntToStr(ID)+')';
      // возвращает коды для отработки кеша, kind - вид возвращаемых кодов:
      // 1 - rCode - код аналога заданного товара;
      // 2 - rCode - код товара, у которого заданный товар - аналог;
      // 3 - rCode - код оригинального номера товара;
      // 4 - rCode - код файла товара;
      // 5 - rCode - код узла, rCode1 - код модели, (flDelInfo) rCode2 - признак наличия фильтров;
      // (flDelInfo) 6 - rCode - признак наличия узлов, rCode1 - код двигателя, rCode2 - признак наличия товаров
          IBSord.ExecQuery;
          while not IBSord.Eof do begin  // запоминаем возвращаемые коды
            if High(ari)<j then SetLength(ari, j+10);
            with ari[j] do begin
              kind  := IBSord.FieldByName('kind').AsInteger;
              rCode := IBSord.FieldByName('rCode').AsInteger;
              rCode1:= IBSord.FieldByName('rCode1').AsInteger;
              rCode2:= IBSord.FieldByName('rCode2').AsInteger;
            end;
            inc(j);
            IBSord.Next;
          end;
          IBSord.Close;
        end; // if (OpCode in [resWrong, resDeleted])

        if (OpCode in [resAdded, resNotWrong]) then begin //-- проверить наличие артикула в TDT
          IBStdt.SQL.Text:= 'select art_id from articles left join data_suppliers'+
            ' on ds_id=art_sup_id where art_nr=:art and ds_mf_id='+IntToStr(pSupID);
          IBStdt.ParamByName('art').AsString:= pArticle;
          IBStdt.ExecQuery;
          if (IBStdt.Bof and IBStdt.Eof) or (IBStdt.Fields[0].AsInteger<1) then
            raise EBOBError.Create('Не найден артикул Tecdoc '+pArticle);
          IBStdt.Close;
        end; // if (OpCode in [resAdded, resNotWrong])

        IBSord.SQL.Text:= 'execute procedure CheckWareArticleTDLink('+IntToStr(OpCode)+', '+
          IntToStr(ID)+', '+IntToStr(pSupID)+', :art, '+IntToStr(userID)+')';
        IBSord.ParamByName('art').AsString:= pArticle;
        IBSord.ExecQuery;
        IBSord.Transaction.Commit;
        IBSord.Close;
        try             // отрабатываем признак наличия товаров у артикула в TDT
          with IBSord.Transaction do if not InTransaction then StartTransaction;
          IBSord.SQL.Text:= 'select count(WATDWARECODE) from WAREARTICLETD'+
            ' where WATDWRONG="F" and WATDARTSUP='+IntToStr(pSupID)+' and WATDARTICLE=:art';
          IBSord.ParamByName('art').AsString:= pArticle;
          IBSord.ExecQuery;
          if not (IBSord.Bof and IBSord.Eof) then wCount:= IBSord.Fields[0].AsInteger;
          IBSord.Close;

          IBStdt.SQL.Text:= 'SELECT rResult from CheckArtWarecode(:Art, '+IntToStr(pSupID)+', '+IntToStr(wCount)+')';
          IBStdt.ParamByName('art').AsString:= pArticle;
          IBStdt.ExecQuery;
          if (IBStdt.Bof and IBStdt.Eof) or IBStdt.fieldByName('rResult').IsNull then wCount:= -1
          else wCount:= IBStdt.fieldByName('rResult').AsInteger;
          if not (wCount in [0, 1]) then raise Exception.Create(' result='+IntToStr(wCount));
          with IBStdt.Transaction do if InTransaction then Commit;
        except
          on E:Exception do prMessageLOGS(nmProc+': error TDT->CheckArtWarecode, '+E.Message, 'import', False);
        end;
      finally
        prFreeIBSQL(IBSord);
        cntsOrd.SetFreeCnt(IBDord);
      end;
    finally
      prFreeIBSQL(IBStdt);
      cntsTDT.SetFreeCnt(IBDtdt);
    end;
//------------------------------------------------------------- отрабатываем кеш
    try
      CS_wlinks.Enter;
      if OpCode in [resAdded, resNotWrong] then begin // добавляем / восстанавливаем
        ArticleTD:= pArticle;
        ArtSupTD:= pSupID;  // SupID TecDoc (DS_MF_ID !!!)
      end else begin // удаляем / отмечаем, как ошибочную
        ArticleTD:= '';
        ArtSupTD:= 0;
      end;
    finally
      CS_wlinks.Leave;
    end;

    if (j>0) then begin
      i:= 0;
      while (i<j) do begin
        if flDelInfo then begin
//-------------------------- удалить инфо товара по источнику-TecDoc (если надо)
          with ari[i] do case kind of
          1: DelAnalogLink(rCode, True);    //------------------- аналоги товара
          2: if Cache.WareExist(rCode) then //----------------- кроссы с товаром
              Cache.GetWare(rCode).DelAnalogLink(ID, True);
          3: begin //------------------------------------------------- ОН товара
              ONumLinks.DelLinkListItemByID(rCode, lkLnkByID, CS_wlinks); // удал.связку у товара
              with Cache.FDCA do if OrigNumExist(rCode) then // удал.связку у ОН
                GetOriginalNum(rCode).Links.DeleteLinkItem(ID);
            end;
          4: FileLinks.DeleteLinkItem(rCode); //------------------- файлы товара
          5: begin //------------------------------------------- 3 связки товара
              Model:= Cache.FDCA.Models[rCode1];
              if Assigned(Model) and Model.NodeLinks.LinkExists(rCode) then begin
                link2:= Model.NodeLinks[rCode];
                link2.DoubleLinks.DelLinkListItemByID(ID, lkLnkNone, Model.CS_mlinks);
                                       // уточняем наличие фильтров у 2-й связки
                if link2.NodeHasFilters and (rCode2<1) then link2.NodeHasFilters:= False;
                if link2.NodeHasWares and (link2.DoubleLinks.LinkCount<1) then link2.NodeHasWares:= False;
              end;
            end;
          6: begin //------------------------------- связки товара с двигателями
              Eng:= Cache.FDCA.Engines[rCode1];
              if Assigned(Eng) then begin // уточняем наличие узлов и товаров у двигателя
                if Eng.EngHasNodes and (rCode<1) then Eng.EngHasNodes:= False;
                if Eng.EngHasWares and (rCode2<1) then Eng.EngHasNodes:= False;
              end;
            end;
          // критерии товара, инфо-тексты товар-нода удаляются без возврата кодов
          end; // case

        end else begin
//--------------------------------------------------- изменить источник на TDold
          with ari[i] do case kind of
          1: SetAnalogLinkSrc(rCode, soTDold); //---------------- аналоги товара
          2: if Cache.WareExist(rCode) then    //-------------- кроссы с товаром
               Cache.GetWare(rCode).SetAnalogLinkSrc(ID, soTDold);
          3: begin //------------------------------------------------- ОН товара
               if ONumLinks.LinkListItemExists(rCode, lkLnkByID) then begin
                 link:= ONumLinks.GetLinkListItemByID(rCode, lkLnkByID);
                 link.SrcID:= soTDold; // связка у товара
               end;
               with Cache.FDCA do if OrigNumExist(rCode) then // связка у ОН
                 with GetOriginalNum(rCode) do if Links.LinkExists(ID) then begin
                   link:= Links[ID];
                   link.SrcID:= soTDold;
                 end;
            end;
          4: if FileLinks.LinkExists(rCode) then begin //---------- файлы товара
               link:= FileLinks[rCode];
               link.SrcID:= soTDold;
            end;
          5: begin //------------------------------------------- 3 связки товара
              Model:= Cache.FDCA.Models[rCode1];
              if Assigned(Model) and Model.NodeLinks.LinkExists(rCode) then begin
                link2:= Model.NodeLinks[rCode];
                with link2.DoubleLinks do if LinkListItemExists(ID, lkLnkNone) then begin
                  link:= GetLinkListItemByID(ID, lkLnkNone);
                  link.SrcID:= soTDold;
                end;
              end;
            end;
          end; // case
        end;
//------------------------------------------------------------------------------
        inc(i);
      end; // while

      i:= 0;
      if flDelInfo then while (i<j) do begin
        with ari[i] do case kind of
        5: begin //------------------------------------ связки товара с моделями
            Model:= Cache.FDCA.Models[rCode1];
            if Assigned(Model) then begin
              flEx:= False; // проверяем, остались ли линки на товар у модели
              with Model.NodeLinks do for k:= 0 to LinkCount-1 do begin
                with TSecondLink(ListLinks[k]) do
                  flEx:= Assigned(DoubleLinks) and DoubleLinks.LinkListItemExists(ID, lkLnkNone);
                if flEx then break;
              end;
              if not flEx then // если не осталось - удаляем линк товара с моделью
                ModelLinks.DelLinkListItemByID(Model.ID, lkDirNone, CS_wlinks);
            end;
          end; // 5
        end; // case
        inc(i);
      end; // while
    end; // if (j>0)

    case OpCode of
      resAdded:    Result:= sArtLink+' добавлена';
      resDeleted:  Result:= sArtLink+' удалена';
      resWrong:    Result:= sArtLink+' отмечена, как неверная';
      resNotWrong: Result:= sArtLink+' восстановлена';
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
  SetLength(ari, 0);
end;
//====================================== набор параметров файлов рисунков товара
function TWareInfo.GetWareFiles: TarWareFileOpts; // array of records
var i: Integer;
    link: TFlagLink;
    wfItem: TWareFile;
begin
  SetLength(Result, 0);
  if not Assigned(self) or not IsWare or not Assigned(FWareOpts) then Exit;
  with FileLinks do begin
    SetLength(Result, LinkCount);
    for i:= 0 to ListLinks.Count-1 do begin
      link:= ListLinks[i];                  // линк на файл
      wfItem:= link.LinkPtr;                // объект файла
      Result[i].SupID   := wfItem.supID;    // код SupID (для поиска папки)
      Result[i].FileName:= wfItem.FileName; // имя файла с расширением
      Result[i].HeadName:= wfItem.HeadName; // заголовок файла
      Result[i].LinkURL := link.Flag;       // признак URL-ссылки на файл
    end;
  end;
end;
//========================================== получить массив кодов сопут.товаров
function TWareInfo.GetSatellites(pTypeSys: Integer=0): Tai;  // must Free
var i, j: Integer;
    ware: TWareInfo;
begin
  SetLength(Result, 0);
  if not Assigned(self) or not Assigned(SatelLinks) then Exit;

  with SatelLinks do for i:= 0 to ListLinks.Count-1 do begin
    j:= GetLinkID(ListLinks[i]);
    if not Cache.WareExist(j) then Continue;
    ware:= GetLinkPtr(ListLinks[i]); // проверяем сопут.товар
    if not Assigned(ware) then Continue;
    try
      if ware.IsINFOgr then Continue;     // исключаем инфо-группу
      if (pTypeSys>0) and not ware.CheckWareTypeSys(pTypeSys) then Continue; // проверяем систему
    except
      Continue;
    end;
    prAddItemToIntArray(ware.ID, Result);
  end;
end;
//================================================ признак наличия сопут.товаров
function TWareInfo.SatelliteExists(pTypeSys: Integer=0): Boolean;
var i: Integer;
    ware: TWareInfo;
begin
  Result:= False;
  if not Assigned(self) or not Assigned(SatelLinks) then Exit;

  with SatelLinks do for i:= 0 to ListLinks.Count-1 do begin
    ware:= TLink(ListLinks[i]).LinkPtr; // проверяем сопут.товар
    if ware.IsINFOgr then Continue;     // исключаем инфо-группу
    if (pTypeSys>0) and not ware.CheckWareTypeSys(pTypeSys) then Continue; // проверяем систему
    Result:= True; // нашли 1-й
    break;
  end;
end;

//******************************************************************************
//                               TWareFile
//******************************************************************************
//================================================== получить значение заголовка
function TWareFile.GetWFHeadName: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  Result:= Cache.FDCA.TypesInfoModel.InfoItems[headID].Name;
end;

//******************************************************************************
//                               TShipMethodItem
//******************************************************************************
constructor TShipMethodItem.Create(pID: Integer; pName: String; pTimeKey: Boolean=False; pLabelKey: Boolean=False);
begin
  inherited Create(pID, pName);
  TimeKey:= pTimeKey;
  LabelKey:= pLabelKey;
end;

//******************************************************************************
//                                TShipTimeItem
//******************************************************************************
constructor TShipTimeItem.Create(pID: Integer; pName: String; pHour: Byte=0; pMinute: Byte=0);
begin
  inherited Create(pID, pName);
  FHour:= pHour;
  FMinute:= pMinute;
end;

//******************************************************************************
//                               TDataCache
//******************************************************************************
constructor TDataCache.Create;
begin
  inherited;
  flMailSendSys:= False; // по умолчанию
  flCheckClosingDocs:= False;
  SingleThreadExists:= False;
  WareCacheTested:= True;
  LongProcessFlag:= cdlpNotLongPr;
  CliLoginLength:= 20;
  CliPasswLength:= 20;
  OrdWarrNumLength:= 20;
  OrdWarrPersLength:= 100;
  OrdSelfCommLength:= 30;
  OrdCommentLength:= 255;
  AccEmpCommLength:= 255;      // длина поля счета Комментарий сотрудника
  AccCliCommLength:= 255;      // длина поля счета Комментарий клиента
  AccWebCommLength:= 255;      // длина поля счета Комментарий Web
  CScache := TCriticalSection.Create; // для изменений
  CS_Empls:= TCriticalSection.Create; // для изменения параметров сотрудников
  CS_wares:= TCriticalSection.Create; // для изменения параметров товаров

  SysTypes:= TDirItems.Create;
  FillSysTypes; // контролируемые системы учета
  if not Assigned(SysTypes) or (SysTypes.Count<1) then
    raise Exception.Create('не могу определить системы учета');

  SetLength(arFirmTypesNames, 1);
  arFirmTypesNames[0]:= 'Неизв.';

  SetLength(arFirmClassNames, 1);
  arFirmClassNames[0]:= 'Неизв.';

  SetLength(arDprtInfo, 1);
  arDprtInfo[0]:= TDprtInfo.Create(0, 0, 0, 'Неизв.подразделение');

  arClientInfo:= TClients.Create;

  Contracts:= TContracts.Create;       // справочник контрактов

  SetLength(arFirmInfo, 1);
  arFirmInfo[0]:= TFirmInfo.Create(0, 'Неизв.фирма');

  SetLength(arEmplInfo, 1);
  arEmplInfo[0]:= TEmplInfoItem.Create(0, 0, 1, '');
  arEmplInfo[0].Surname:= 'Не определен';

  setLength(arFictiveEmpl, 0);
  setLength(arRegionROPFacc, 0);  // коды ЦФУ РОП-а по номеру региона

  FDCA:= TDataCacheAdditionASON.Create; // Galeta

  SetLength(arWareInfo, 1);
  arWareInfo[0]:= TWareInfo.Create(0, 0, 'Неизв.группа');  // подгруппа для старых товаров
  with arWareInfo[0] do begin
    IsPgr:= True;
//    IsAUTOWare:= True; // признаки AUTO / MOTO подгруппы
//    IsMOTOWare:= True;
  end; // with arWareInfo[0]

  NoWare:= TWareInfo.Create(-1, 0, 'Неизв.товар'); // фиктивный товар
  NoWare.IsWare:= True;

  SetLength(PriceTypes, 0);
//  PriceTypesList:= TIntegerList.Create; // коды используемых прайсов
  DefCurrRate:= 0;
  CreditPercent:= 90;
  LastTimeCache:= DateNull;
//  LastTimeMemUsed:= DateNull;
  LastTestRestTime:= DateNull;
//  LastTimeCacheAlter:= DateNull;

  BonusCrncCode:= 22;     // код валюты бонусов
//  BonusVolumePercent:= 0; // процент отчислений на бонусы

  BrandTDList   := nil;                    // список брендов TecDoc
  AttrGroups    := TAttrGroupItems.Create; // справочник групп
  Attributes    := TAttributeItems.Create; // справочник атрибутов
  FWareFiles    := TDirItems.Create;       // справочник файлов рисунков/документов
  WareBrands    := TDirItems.Create;       // справочник брендов
  FImportTypes  := TDirItems.Create;       // справочник видов импорта
  FParConstants := TDirItems.Create;       // справочник констант
  FEmplRoles    := TDirItems.Create;       // справочник ролей
  FMeasNames    := TDirItems.Create;       // справочник ед.изм.
  InfoNews      := TDirItems.Create;       // инфо-блок
  Notifications := TNotifications.Create;  // Справочник уведомлений
  EmplVisRules  := TDirItems.Create;       // справочник схем видимости
  ShipMethods   := TDirItems.Create;       // справочник методов отгрузки
  ShipTimes     := TDirItems.Create;       // справочник времен отгрузки
  FiscalCenters := TDirItems.Create;       // справочник FISCALACCOUNTINGCENTER
  Currencies    := TCurrencies.Create;     // справочник валют

//  FirmLabels    := TDirItems.Create;       // справочник наклеек

  MarginGroups  := TMarginGroups.Create;   // группы/подгруппы наценок

  DeliveriesList:= fnCreateStringList(true, dupIgnore); // список доставок
  BrandLaximoList:= fnCreateStringList(true, dupIgnore); // список брендов Laximo
  NoTDPictBrandCodes:= TIntegerList.Create;     // коды брендов без показа рисунков TD
  DiscountModels:= TDiscModels.Create;          // справочник шаблонов скидок

  WareCacheUnLocked:= False;
  WareLinksUnLocked:= False;
  WebAutoLinks:= False;
  WareCacheTested:= False;
end;
//==================================================
destructor TDataCache.Destroy;
const nmProc = 'Cache_Destroy'; // имя процедуры/функции
var i: Integer;
    LocalStart: TDateTime;
begin
  if not Assigned(self) then Exit;
  LocalStart:= now();
  prFree(arClientInfo);
  if flTest then begin
    prMessageLOGS(nmProc+'_Clients: - '+GetLogTimeStr(LocalStart), fLogDebug, false);
    LocalStart:= now();
  end;
  TestCacheArrayLength(taCurr, 0, false);
  TestCacheArrayLength(taDprt, 0, false);
  TestCacheArrayLength(taFirm, 0, false);
  prFree(Contracts);
  if flTest then begin
    prMessageLOGS(nmProc+'_Firms: - '+GetLogTimeStr(LocalStart), fLogDebug, false);
    LocalStart:= now();
  end;
  TestCacheArrayLength(taWare, 0, false);
  if flTest then begin
    prMessageLOGS(nmProc+'_Wares: - '+GetLogTimeStr(LocalStart), fLogDebug, false);
    LocalStart:= now();
  end;
  TestCacheArrayLength(taEmpl, 0, false);
  if flTest then begin
    prMessageLOGS(nmProc+'_Empls: - '+GetLogTimeStr(LocalStart), fLogDebug, false);
    LocalStart:= now();
  end;
  TestCacheArrayLength(taFtyp, 0, false);
  TestCacheArrayLength(taFcls, 0, false);
  setLength(arFictiveEmpl, 0);
  SetLength(PriceTypes, 0);
//  prFree(PriceTypesList);
  setLength(arRegionROPFacc, 0);  // коды ЦФУ РОП-а по номеру региона
  prFree(NoWare);
  FDCA.Free;
  FDCA:= nil;
  prFree(AttrGroups);
  prFree(Attributes);
  if flTest then prMessageLOGS(nmProc+'_Attributes: - '+
                            GetLogTimeStr(LocalStart), fLogDebug, false);
  prFree(WareBrands);
  prFree(FImportTypes);
  prFree(FParConstants);      // справочник констант
  prFree(FEmplRoles);
  prFree(FMeasNames);
  prFree(FWareFiles);
  prFree(BrandTDList);
  prFree(InfoNews);
  prFree(Notifications);
  prFree(EmplVisRules);
  prFree(SysTypes);
  prFree(ShipMethods);
  prFree(ShipTimes);
  prFree(FiscalCenters);   // справочник FISCALACCOUNTINGCENTER
  prFree(Currencies);      // справочник валют
//  prFree(FirmLabels);
  prFree(MarginGroups);
  prFree(DeliveriesList);
  for i:= 0 to BrandLaximoList.Count-1 do TObject(BrandLaximoList.Objects[i]).Free;
  prFree(BrandLaximoList); // список брендов Laximo
  prFree(NoTDPictBrandCodes);
  prFree(DiscountModels);
  prFree(CScache);
  prFree(CS_Empls);
  prFree(CS_wares);
  inherited;
end;
//============================================================= получить признак
function TDataCache.GetBoolDC(ik: T16InfoKinds): boolean;
begin
  if not Assigned(self) then Result:= False else Result:= (ik in FCacheBoolOpts);
end;
//============================================================= записать признак
procedure TDataCache.SetBoolDC(ik: T16InfoKinds; Value: boolean);
begin
  if not Assigned(self) then Exit;
  if Value then FCacheBoolOpts:= FCacheBoolOpts+[ik]
  else FCacheBoolOpts:= FCacheBoolOpts-[ik];
end;
//================================================= проверяем длину массива кэша
procedure TDataCache.TestCacheArrayLength(kind: TArrayKind; len: integer; ChangeOnlyLess: boolean=True);
var fl: boolean;
    i, j: integer;
begin
  if not Assigned(self) then Exit else case kind of
    taWare: i:= Length(arWareInfo);
    taEmpl: i:= Length(arEmplInfo);
    taFirm: i:= Length(arFirmInfo);
    taDprt: i:= Length(arDprtInfo);
    taFtyp: i:= Length(arFirmTypesNames);
    taFcls: i:= Length(arFirmClassNames);
    else Exit;
  end;
  if ChangeOnlyLess then fl:= (i<len) else fl:= (i<>len);
  if fl then try // если надо менять длину
    CScache.Enter;
    if (i>len) then case kind of // если обрезаем - надо очистить элементы
      taWare: for j:= len to High(arWareInfo) do try prFree(arWareInfo[j]); except end;
      taEmpl: for j:= len to High(arEmplInfo) do try prFree(arEmplInfo[j]); except end;
      taFirm: for j:= len to High(arFirmInfo) do try prFree(arFirmInfo[j]); except end;
      taDprt: for j:= len to High(arDprtInfo) do try prFree(arDprtInfo[j]); except end;
    end;
    case kind of
      taWare: SetLength(arWareInfo, len);
      taEmpl: SetLength(arEmplInfo, len);
      taFirm: SetLength(arFirmInfo, len);
      taDprt: SetLength(arDprtInfo, len);
      taFtyp: SetLength(arFirmTypesNames, len);
      taFcls: SetLength(arFirmClassNames, len);
    end;
    if (i<len) then case kind of // если добавляем - надо инициировать элементы
      taWare: for j:= i to High(arWareInfo) do arWareInfo[j]:= nil;
      taEmpl: for j:= i to High(arEmplInfo) do arEmplInfo[j]:= nil;
      taFirm: for j:= i to High(arFirmInfo) do arFirmInfo[j]:= nil;
      taDprt: for j:= i to High(arDprtInfo) do arDprtInfo[j]:= nil;
      taFtyp: for j:= i to High(arFirmTypesNames) do arFirmTypesNames[j]:= '';
      taFcls: for j:= i to High(arFirmClassNames) do arFirmClassNames[j]:= '';
    end;
  finally
    CScache.Leave;
  end;
end;
//================================ проверяем существование элемента массива кэша
function TDataCache.TestCacheArrayItemExist(kind: TArrayKind; pID: integer; var flnew: boolean): boolean;
var fl: boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  fl:= false;
  TestCacheArrayLength(kind, pID+1);
  case kind of
    taWare: fl:= not Assigned(arWareInfo[pID]);
    taEmpl: fl:= not Assigned(arEmplInfo[pID]);
    taFirm: fl:= not Assigned(arFirmInfo[pID]);
    taClie: fl:= not Assigned(arClientInfo[pID]);
    taDprt: fl:= not Assigned(arDprtInfo[pID]);
  end;
  flnew:= flnew and fl;
  if flnew then try
    CScache.Enter;
    case kind of
      taWare: arWareInfo[pID]:= TWareInfo.Create(pID, 0, '');
      taEmpl: arEmplInfo[pID]:= TEmplInfoItem.Create(pID, 0, 1, '');
      taFirm: arFirmInfo[pID]:= TFirmInfo.Create(pID, '');
      taClie: arClientInfo.AddClient(pID);
//      taDprt: arDprtInfo[pID]:= TDprtInfo.Create(pID, 0, 0, '');
      taDprt: arDprtInfo[pID]:= TDprtInfo.Create(pID, 0, 0, '', 0, True);
    end;
  finally
    CScache.Leave;
  end;
  case kind of
    taWare: Result:= Assigned(arWareInfo[pID]);
    taEmpl: Result:= Assigned(arEmplInfo[pID]);
    taFirm: Result:= Assigned(arFirmInfo[pID]);
    taClie: Result:= Assigned(arClientInfo[pID]);
    taDprt: Result:= Assigned(arDprtInfo[pID]);
  end;
  if flnew then flnew:= Result; // возвращаем признак создания нового элемента
end;
//==================================================
function TDataCache.GrpExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arWareInfo)>pID) and
    Assigned(arWareInfo[pID]) and (arWareInfo[pID].IsGrp);
end;
//==================================================
function TDataCache.PgrExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arWareInfo)>pID) and
    Assigned(arWareInfo[pID]) and (arWareInfo[pID].IsPgr);
end;
//=================== проверка существования группы/подгруппы для скидок/наценок
function TDataCache.GrPgrExists(grID: integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  if PgrExists(grID) then
    Result:= (grID<>pgrDeliv)
  else Result:= GrpExists(grID);
end;
//==================================================
function TDataCache.WareExist(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arWareInfo)>pID) and
    Assigned(arWareInfo[pID]) and (arWareInfo[pID].IsWare);
end;
//==================================================
function TDataCache.TypeExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arWareInfo)>pID) and
    Assigned(arWareInfo[pID]) and (arWareInfo[pID].IsType);
end;
//==================================================
function TDataCache.ClientExist(pID: Integer): Boolean;
begin
//  Result:= Assigned(self) and (pID>0) // and (length(arClientInfo)>pID)
//    and Assigned(arClientInfo[pID]);
  Result:= arClientInfo.ClientExists(pID);
end;
//==================================================
function TDataCache.EmplExist(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arEmplInfo)>pID)
    and Assigned(arEmplInfo[pID]);
end;
//==================================================
function TDataCache.DprtExist(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arDprtInfo)>pID)
    and Assigned(arDprtInfo[pID]);
end;
//==================================================
function TDataCache.FirmExist(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arFirmInfo)>pID)
    and Assigned(arFirmInfo[pID]);
end;
//==================================================
function TDataCache.MeasExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and FMeasNames.ItemExists(pID);
end;
//==================================================
function TDataCache.RoleExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and FEmplRoles.ItemExists(pID);
end;
//==================================================
function TDataCache.ImpTypeExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and FImportTypes.ItemExists(pID);
end;
//==================================================
function TDataCache.ConstExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and FParConstants.ItemExists(pID);
end;
//==================================================
function TDataCache.CurrExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and Currencies.ItemExists(pID);
end;
//==================================================
function TDataCache.FaccExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and FiscalCenters.ItemExists(pID);
end;
//==================================================
function TDataCache.FirmTypeExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arFirmTypesNames)>pID)
    and (arFirmTypesNames[pID]<>'');
end;
//==================================================
function TDataCache.FirmClassExists(pID: Integer): Boolean;
begin
  Result:= Assigned(self) and (pID>0) and (length(arFirmClassNames)>pID)
    and (arFirmClassNames[pID]<>'');
end;
//=================================================================== код группы
function TDataCache.GetGrpID(ID: Integer): Integer;
begin
  Result:= 0;
  if not Assigned(self) or (ID<1) or not Assigned(arWareInfo[ID]) then Exit;
  with arWareInfo[ID] do if IsGrp then Result:= ID
    else if IsPgr then Result:= PgrID else if IsWare then Result:= GrpID;
end;
//================================================================ код подгруппы
function TDataCache.GetPgrID(ID: Integer): Integer;
begin
  Result:= 0;
  if not Assigned(self) or (ID<1) or not Assigned(arWareInfo[ID]) then Exit;
  with arWareInfo[ID] do if IsGrp then Exit
    else if IsPgr then Result:= ID else if IsWare then Result:= PgrID;
end;
//===================== коэффициент для расчета бонусов от суммы в валюте currID
function TDataCache.GetPriceBonusCoeff(currID: Integer): Single;
// для валюты "unit" возвращает 0
var rate: Single;
begin
  Result:= 0;
  if not Assigned(self) or not Currencies.ItemExists(currID) then Exit;
  if (currID=BonusCrncCode) then Exit;
  if (currID=cDefCurrency) then Result:= BonusVolumeCoeff
  else begin
    rate:= Currencies.GetCurrRate(currID);
  //  if not fnNotZero(rate) then rate:= 1;
    Result:= BonusVolumeCoeff*rate/DefCurrRate;
  end;
end;
//========================================================= наименование ед.изм.
function TDataCache.GetMeasName(pID: Integer): string;
begin
  if not Assigned(self) or not MeasExists(pID) then Result:= ''
  else Result:= FMeasNames.GetItemName(pID);
end;
//========================================================== наименование валюты
function TDataCache.GetCurrName(pID: Integer; ForClient: Boolean): string;
begin
  if not Assigned(self) or not CurrExists(pID) then Result:= ''
  else if ForClient then Result:= Currencies[pID].CliName
  else Result:= Currencies[pID].Name;
end;
//============================================================= наименование ЦФУ
function TDataCache.GetFaccName(pID: Integer): string;
begin
  if not Assigned(self) or not FaccExists(pID) then Result:= ''
  else Result:= FiscalCenters.GetItemName(pID);
end;
//====================================================== наименование типа фирмы
function TDataCache.GetFirmTypeName(typeID: Integer): string;
begin
  if not Assigned(self) or not FirmTypeExists(typeID) then Result:= ''
  else Result:= arFirmTypesNames[typeID];
end;
//================================================= наименование категории фирмы
function TDataCache.GetFirmClassName(ClassID: Integer): string;
begin
  if not Assigned(self) or not FirmClassExists(ClassID) then Result:= ''
  else Result:= arFirmClassNames[ClassID];
end;
//=================================================== наименование подразделения
function TDataCache.GetDprtMainName(pID: Integer): string;
begin
  if not Assigned(self) or not DprtExist(pID) then Result:= ''
  else Result:= arDprtInfo[pID].MainName;
end;
//================================================ кр.наименование подразделения
function TDataCache.GetDprtShortName(pID: Integer): string;
begin
  if not Assigned(self) or not DprtExist(pID) then Result:= ''
  else Result:= arDprtInfo[pID].ShortName;
end;
//============================================== заголовок колонки подразделения
function TDataCache.GetDprtColName(pID: Integer): string;
begin
  if not Assigned(self) or not DprtExist(pID) then Result:= ''
  else Result:= arDprtInfo[pID].ColumnName;
end;
//========================================================= наименование импорта
function TDataCache.GetImpTypeName(pID: Integer): string;
begin
  if Assigned(self) then Result:= FImportTypes.GetItemName(pID) else Result:= '';
end;
//============================================================ наименование роли
function TDataCache.GetRoleName(pID: Integer): string;
begin
  if Assigned(self) then Result:= FEmplRoles.GetItemName(pID) else Result:= '';
end;
//===================================================== наименование типа товара
function TDataCache.GetWareTypeName(typeID: Integer): string;
begin
  if Assigned(self) and TypeExists(typeID) then Result:= arWareInfo[typeID].Name
  else Result:= 'Не определен';
end;
//=================================================== коды всех ролей, must Free
function TDataCache.GetAllRoleCodes: Tai;
begin
  SetLength(Result, 0);
  if not Assigned(self) then Exit;
  Result:= FEmplRoles.GetDirCodes;
end;
//====================== коды запрещенных для загрузки прайса брендов, must Free
function TDataCache.GetDownLoadExcludeBrands: Tai;
var i: integer;
    br: TBrandItem;
begin
  SetLength(Result, 0);
  if not Assigned(self) then Exit;
  for i:= 0 to WareBrands.ItemsList.Count-1 do begin
    br:= WareBrands.ItemsList[i];
    if br.DownLoadExclude then prAddItemToIntArray(br.ID, Result);
  end;
end;
//==================================================
function TDataCache.GetEmplIDByLogin(login: string): Integer;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  login:= UpperCase(login);
  for Result:= 1 to High(arEmplInfo) do
    if EmplExist(Result) and (UpperCase(arEmplInfo[Result].ServerLogin)=login) then exit;
  Result:= -1;
end;
//==================================================
function TDataCache.GetEmplIDByGBLogin(Login: string): Integer;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  login:= UpperCase(login);
  for Result:= 1 to High(arEmplInfo) do
    if EmplExist(Result) then with arEmplInfo[Result] do
      if (UpperCase(GBLogin)=login) or (UpperCase(GBReportLogin)=login) then exit;
  Result:= -1;
end;
//==================================================
function TDataCache.GetEmplIDBySession(pSession: string): Integer;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  for Result:= 1 to High(arEmplInfo) do
    if EmplExist(Result) and (arEmplInfo[Result].Session=pSession) then exit;
  Result:= -1;
end;
//============================================================ список кодов фирм
function TDataCache.GetRegFirmCodes(RegID: Integer=0; Search: string=''; NotArchived: boolean=True): Tai;
// RegID>0 - код регионала, 0- все, <0 - отриц.номер региона ЦФУ
// Search - ключ поиска по наименованию, NotArchived - только неархивные
var i: integer;
    flReg, flSearch, flFaccReg: boolean;
    list: TStringList;
begin
  SetLength(Result, 0);
  if not Assigned(self) or (length(arFirmInfo)<2) then Exit;

  flFaccReg:= (RegID<0);
  if flFaccReg then begin
    RegID:= -RegID;
    flReg:= False;
  end else flReg:= (RegID>0);

  flSearch:= (Search<>'');
  if flSearch then Search:= AnsiUpperCase(Search);
  list:= TStringList.Create;
  try
    for i:= 1 to High(arFirmInfo) do if FirmExist(i) then with arFirmInfo[i] do begin
      if NotArchived and Arhived then Continue;
      if flFaccReg and not CheckFirmRegion(RegID) then Continue;
      if flReg and not CheckFirmManager(RegID) then Continue;
      if not flSearch or ((pos(Search, UPPERMAINNAME)>0)
        or (pos(Search, UPPERSHORTNAME)>0)) then
        list.AddObject(arFirmInfo[i].Name, Pointer(i));
    end;
    list.Sort; // сортируем по наименованию
    SetLength(Result, list.Count);
    for i:= 0 to list.Count-1 do Result[i]:= integer(list.Objects[i]);
  finally
    prFree(list);
  end;
end;
//==================== список кодов менеджеров, сортировка по коду филиала и ФИО
function TDataCache.GetEmplCodesByShortName(DprtID: Integer=0; role: Integer=0): Tai;
//DprtID - код филиала (0-все)
var list: TStringList;
    i, j: integer;
    s: string;
    flDprt, flRole: boolean;
begin
  SetLength(Result, 0);
  if not Assigned(self) or (length(arEmplInfo)<2) then Exit;
  list:= TStringList.Create;
  flDprt:= DprtID>0;
  flRole:= role>0;
  for i:= 1 to High(arEmplInfo) do
    if EmplExist(i) then begin
      if flRole and (fnInIntArray(role, arEmplInfo[i].UserRoles)<0) then Continue;
      if flDprt then begin
        if (arEmplInfo[i].EmplDprtID<>DprtID) then Continue;
        s:= arEmplInfo[i].EmplShortName;
      end else
        s:= String(fnMakeAddCharStr(arEmplInfo[i].EmplDprtID, 10, '*'))+arEmplInfo[i].EmplShortName;
      list.AddObject(s, Pointer(i));
    end;
  list.Sort; // сортируем по по коду филиала и ФИО
  SetLength(Result, list.Count);
  for i:= 0 to list.Count-1 do begin
    j:= Integer(list.Objects[i]);
    Result[i]:= j;
  end;
  prFree(list);
end;
//======================================= список подразделений в заданной группе
function TDataCache.GetGroupDprts(pDprtGroup: Integer=0; StoreAndRoad: Boolean=False): Tai; // must Free
// StoreAndRoad=True - только склады и пути, pDprtGroup=0 - все
var i: Integer;
    Dprt: TDprtInfo;
begin
  SetLength(Result, 0);
  if not Assigned(self) then Exit;
  if (pDprtGroup>0) and not DprtExist(pDprtGroup) then Exit;
  for i:= 1 to High(arDprtInfo) do if DprtExist(i) then begin
    Dprt:= arDprtInfo[i];
    if StoreAndRoad and not (Dprt.IsStoreHouse or Dprt.IsStoreRoad) then Continue;
    if (pDprtGroup>0) and not Dprt.IsInGroup(pDprtGroup) then Continue;
    prAddItemToIntArray(i, Result);
  end;
end;
//============================================================== список филиалов
function TDataCache.GetFilialList(flShortName: Boolean=False): TStringList; // must Free
var i, j: Integer;
    Dprt: TDprtInfo;
    s: String;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  for i:= 1 to High(arDprtInfo) do if DprtExist(i) then try
    Dprt:= arDprtInfo[i];
    if not Dprt.IsFilial then Continue;
    if flShortName then s:= Dprt.ShortName else s:= Dprt.Name;
    j:= Dprt.ID;
    Result.AddObject(s, Pointer(j));
  except end;
  if Result.Count>1 then Result.Sort;
end;
//============================================================= список типов к/а
function TDataCache.GetFirmTypesList: TStringList; // must Free
var i: Integer;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  for i:= 1 to High(arFirmTypesNames) do if arFirmTypesNames[i]<>'' then try
    Result.AddObject(arFirmTypesNames[i], Pointer(i));
  except end;
  if Result.Count>1 then Result.Sort;
end;
//========================================================= список категорий к/а
function TDataCache.GetFirmClassesList: TStringList; // must Free
var i: Integer;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  for i:= 1 to High(arFirmClassNames) do if arFirmClassNames[i]<>'' then try
    Result.AddObject(arFirmClassNames[i], Pointer(i));
  except end;
  if Result.Count>1 then Result.Sort;
end;
//=================================================== заполнение / проверка кэша
procedure TDataCache.TestDataCache(CompareTime: boolean=True; alter: boolean=False);
// CompareTime=True - проверять время последнего обновления, False - не проверять
// alter=True - по alter-таблицам, False - полная
const nmProc = 'TestDataCache'; // имя процедуры/функции
var LocalStart: TDateTime;
    flFill: Boolean;
    interval, cdlp: Integer;
begin
  if not Assigned(self) or WareCacheTested then Exit;
  flFill:= (LastTimeCache=DateNull) or (Length(arDprtInfo)<2);
  LocalStart:= now();
  WareCacheTested:= True;
  try
    try
      if flFill then begin //------- первоначальное заполнение
        FillSysTypes; // контролируемые системы учета
        cdlp:= cdlpFillCache;
        if CompareTime then CompareTime:= False;
      end else begin
        cdlp:= cdlpTestCache;
      end;

      TestParConstants(flFill); // настройки

      if not flFill then begin //----- проверка - с вечера до утра увеличиваем интервал
        Interval:= fnIfInt(fnGetActionTimeEnable(caeOnlyDay), TestCacheInterval, TestCacheNightInt);
        if CompareTime and (Now<IncMinute(LastTimeCache, Interval)) then begin
          TestWareRests(CompareTime); // проверка связок с остатками товаров (свой интервал)
          Exit;
        end;
      end;

      prMessageLOGS(' ', fLogCache, false);
      prMessageLOGS('................ '+
        fnIfStr(flFill, 'filling', 'testing')+' cache ...', fLogCache, false);

      SetLongProcessFlag(cdlp, flFill); // флаг - заполнение/проверка кеша
      try
        TestSmallDirectories(flFill);
        FillInfoNews(flFill);             // заполнение/проверка инфо-блока
        FillNotifications(flFill);        // заполнение/проверка уведомлений (Web)
        if AllowWebArm then begin
          TestEmpls(0, true, CompareTime, true);
          if flFill then BrandTDList:= FillBrandTDList;   // Заполнение списка брендов TecDoc
//          if flDebug and flFill then CheckClientsEmails;
        end;
        TestCssStopException;

        TestWares(flFill);          // заполнение/проверка товаров
        TestWareRests(CompareTime); // заполнение/проверка связок с остатками товаров
        TestCssStopException;
                 // заполнение/проверка линков групп/подгрупп с шаблонами скидок
        TestGrPgrDiscModelLinks;

        with FDCA do begin
          FillSourceLinks;
          if flFill then FillDirManuf(flFill);  //------- заполнение
          FillOriginalNums(flFill);
          FillWareONLinks(flFill);
          TestCssStopException;
          if flFill and (AllowWeb or AllowWebArm) then begin //------- заполнение
            FillTreeNodesAuto;
            FillTypesInfoModel;
            FillDirModelLines(flFill);
            FillDirEngines(flFill);
            FillDirModels(flFill);
            TestCssStopException;
          end; // if flFill
        end; // with FDCA

        if AllowWeb or AllowWebArm then begin
          FillWareFiles(flFill);                // Загрузка/проверка файлов товаров
          if flFill then FillAttributes;        // Заполнение атрибутов
        end;

        if AllowWebArm then begin
          CheckGAMainNodesLinks; // сверка TD->GA и TreeNodesAuto->MainNode
          CheckArticleWareMarks(fLogCache); // проверить наличие товаров у артикулов в TDT (по запросу)

        end else if not flFill and not CompareTime then begin // если по запросу с формы или из коммандера
          TestFirms(0, false, CompareTime, true);   // частичная проверка кэша фирм
          TestClients(0, false, CompareTime, true); // частичная проверка кэша клиентов
        end;

        if flFill then begin //------------ первоначальное заполнение

          WareCacheUnLocked:= True;  // разрешаем работу с кешем товаров
          Application.ProcessMessages;

          if AllowWeb or AllowWebArm then
            prMessageLOGS('................ загружен кеш до связок', fLogCache);
        end; // if flFill
      finally
        SetNotLongProcessFlag(cdlp); // сбрасываем флаг длинного процесса
      end;

      if flFill and (AllowWeb or AllowWebArm) then with FDCA do begin
        TestCssStopException;
        sleep(3*997); // ждем - может кому-то надо запуститься
        cdlp:= cdlpFillLinks;
        SetLongProcessFlag(cdlp, flFill); // флаг - заполнение связок
        try
  //          LongProcessFlag:= cdlpFillLinks; // флаг - заполнение связок
  //          while not SetLongProcessFlag(cdlpFillLinks) do begin // флаг - заполнение связок
  //            sleep(997);                                        // ждем, если идет другой длинный процесс
  //            TestCssStopException;
  //          end;
          FillModelNodeLinks;       // Загрузка связей моделей с деревом узлов (связка 2)
          FillWareModelNodeLinks;   // Загрузка связей товара со связкой 2 (связка 3)
          WareLinksUnLocked:= True; // разрешаем работу с подбором
          prMessageLOGS('................ загружены связки', fLogCache);
        finally
          SetNotLongProcessFlag(cdlp); // сбрасываем флаг длинного процесса
        end;
      end; // if flFill
//    end;
      LastTimeCache:= Now;

      prMessageLOGS(StringOfChar('-', 10)+nmProc+'_'+
        fnIfStr(flFill, 'start_fill', 'full_test')+': - '+
        GetLogTimeStr(LocalStart), fLogCache, false);
    except
      on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  finally
    WareCacheTested:= False;
  end;
end;
//====================================== индикатор своевременности проверки кеша
function TDataCache.GetTestCacheIndication: Integer;
var Interval: Integer;
begin
  Result:= 0;
//  if AppStatus in [stSuspending, stSuspended] then begin
//    Result:= 1;
//    Exit;
//  end;
                            // определяем интервал проверки кеша (день-ночь)
  Interval:= fnIfInt(fnGetActionTimeEnable(caeOnlyDay), TestCacheInterval, TestCacheNightInt);
  Interval:= Interval*60;    // переводим в сек
  if WareCacheTested then
    Interval:= Interval+(Interval div 2) // если идет проверка - добавляем еще половину
  else begin
    Interval:= Interval+       // добавляем интервал запуска проверки кеша
      GetIniParamInt(nmIniFileBOB, 'intervals', 'CheckDBConnectInterval', 30);
    Interval:= Interval+5*60;  // добавляем еще запас - 5 мин
  end;
  if (Now<IncSecond(LastTimeCache, Interval)) then Result:= 1;
end;
//====================== используется для сортировки TList справочника ShipTimes
function ShipTimesSortCompare(Item1, Item2: Pointer): Integer;
var st1, st2: TShipTimeItem;
begin
  Result:= 0;
  with Cache do try
    st1:= TShipTimeItem(Item1);
    st2:= TShipTimeItem(Item2);
    if st1.Hour>st2.Hour then Result:= 1
    else if st1.Hour<st2.Hour then Result:= -1
    else if st1.Minute>st2.Minute then Result:= 1
    else if st1.Minute<st2.Minute then Result:= -1;
  except
    Result:= 0;
  end;
end;
//===================== используется для сортировки TList справочника DiscModels
function DiscModelsSortCompare(Item1, Item2: Pointer): Integer;
var i1, i2: TDiscModel;
begin
  try
    i1:= TDiscModel(Item1);
    i2:= TDiscModel(Item2);
    if i1.DirectInd>i2.DirectInd then Result:= 1 // сначала по индексу направления
    else if i1.DirectInd<i2.DirectInd then Result:= -1
    else if i1.Rating>i2.Rating then Result:= 1 // потом по рейтингу
    else if i1.Rating<i2.Rating then Result:= -1
    else Result:= AnsiCompareText(i1.Name, i2.Name); // потом по названию
  except
    Result:= 0;
  end;
end;
//======================================= заполнение/проверка малых справочников
procedure TDataCache.TestSmallDirectories(flFill: Boolean=True; alter: boolean=False);
// alter=True - по alter-таблицам, False - полная
const nmProc = 'TestSmallDirectories'; // имя процедуры/функции
var i, j, ii, jj, mStart, mEnd: integer;
    s, ss, n, str: string;
    ibs: TIBSQL;
    ibd: TIBDatabase;
    fl, flnew, flOnlyErrAll: boolean;
    Item: Pointer;
    BonusCrncRate, BonusVolumePercent, curr: double;
    mDate: TDate;
    ar: Tai;
    TimeProc: TDateTime;
    h, m, Hmin, Hmax, Mmin, Mmax: Byte;
    fc: TFiscalCenter;
    sch: TTwoCodes;
    dprt: TDprtInfo;
    ilst: TIntegerList;
    lst: TList;
begin
  if not Assigned(self) then Exit;
  if alter then str:= 'alter' else str:= 'full';
  ibs:= nil;
  ibd:= nil;
  mDate:= 0;
  TimeProc:= Now;
  SetLength(ar, 0);
  BonusCrncRate:= 0;
  BonusVolumePercent:= 0; // процент отчислений на бонусы
  ilst:= TIntegerList.Create;
  lst:= TList.Create;
  try try
////////////////////////////////////////////////////////////////////////////////
    ibd:= cntsGRB.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibsGRB_'+nmProc, -1, tpRead, True);
///////////////////////////////////////////////////// длины комментариев в счете
    ibs.SQL.Text:= 'select f.RDB$FIELD_NAME fname, ff.RDB$FIELD_LENGTH fsize'+
    ' from rdb$relation_fields f, rdb$fields ff where ff.RDB$FIELD_NAME=f.RDB$FIELD_SOURCE'+
    ' and (f.RDB$RELATION_NAME=:table1)';
    ibs.ParamByName('table1').AsString:= 'PAYINVOICEREESTR';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.FieldByName('fsize').AsInteger;
      s:= ibs.FieldByName('fname').AsString;
      if      (s='PINVCOMMENT')       and (AccEmpCommLength<>i) then AccEmpCommLength:= i
      else if (s='PINVCLIENTCOMMENT') and (AccCliCommLength<>i) then AccCliCommLength:= i
      else if (s='PINVWEBCOMMENT')    and (AccWebCommLength<>i) then AccWebCommLength:= i;
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
//////////////////////////////////////////////////// получаем код валюты бонусов
    i:= 0;
    ibs.SQL.Text:= 'SELECT TUNEBONUSCRNCCODE FROM TUNEPARAMETRS';
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then begin
      BonusCrncCode:= ibs.Fields[0].AsInteger;
    end;

    ibs.Close;
    if (i>0) and (i<>BonusCrncCode) then BonusCrncCode:= i;
    TestCssStopException;
////////////////////////////////////////// получаем процент отчислений на бонусы
    curr:= 0;
    ibs.SQL.Text:= 'select p.bnprpercent from BONUSPERCENT p order by p.bnprdate desc';
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then curr:= ibs.Fields[0].AsFloat;
    ibs.Close;
    if fnNotZero(curr) and fnNotZero(curr-BonusVolumePercent) then BonusVolumePercent:= curr;
    TestCssStopException;
////////////////////////////////////////// процент кредита клиента для сообщения
    curr:= 0;
    ibs.SQL.Text:= 'SELECT DTZNCREDITPERCENT FROM DUTYZONES where DTZNCODE=2';
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then curr:= ibs.Fields[0].AsFloat;
    ibs.Close;
    if fnNotZero(curr) and fnNotZero(curr-CreditPercent) then CreditPercent:= curr;
    TestCssStopException;
////////////////////////////////////////////// минимальная дата док-тов Grossbee
    ibs.SQL.Text:= 'select max(LockDate) from (select TuneWageSuperLockDate LockDate'+
      ' from TuneParametrs union select UserDocmIntermediateDate LockDate'+
      ' from userpsevdonimreestr where USERCODE=1)';
    ibs.ExecQuery;
    if not (ibs.Bof and ibs.Eof) then mDate:= ibs.Fields[0].AsDate+1;
    ibs.Close;
    if (mDate>0) and (mDate<>DocmMinDate) then DocmMinDate:= mDate;
    TestCssStopException;
///////////////////////////////////////////////////////////////////////// валюты
    if not flFill then Currencies.SetDirStates(False);
    ibs.SQL.Text:= 'SELECT CRNCCODE, CRNCSHORTNAME, CRNCARCHIVE, RESULTVALUE FROM CURRENCY'+
                   ' left join convertmoney (1.0, CRNCCODE, '+IntToStr(cUAHCurrency)+', "TODAY")'+
                   ' on exists(select * from RateCrnc where RateCrncCode=CRNCCODE)';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('CRNCCODE').AsInteger;
      n:= fnDelEndOfStr(ibs.fieldByName('CRNCSHORTNAME').AsString);
      fl:= GetBoolGB(ibs, 'CRNCARCHIVE');
      curr:= ibs.fieldByName('RESULTVALUE').AsFloat;
      if (i in [cUAHCurrency, BonusCrncCode]) then ss:= n else ss:= 'у.е.'; // наименование для клиента
      if not Currencies.ItemExists(i) then begin
        Item:= TCurrency.Create(i, n, ss, curr, fl);
        Currencies.CheckItem(Item);
      end else with Currencies[i] do begin
        Name:= n;
        Arhived:= fl;
        if (CliName<>ss) then CliName:= ss;
        if fnNotZero(curr-CurrRate) then CurrRate:= curr;
        State:= True;
      end;
      if fnNotZero(curr) then begin
        if (i=cDefCurrency) and fnNotZero(curr-DefCurrRate) then DefCurrRate:= curr;
        if (i=BonusCrncCode) and fnNotZero(curr-BonusCrncRate) then BonusCrncRate:= curr;
      end;

      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    if not flFill then Currencies.DelDirNotTested;

    if not fnNotZero(BonusCrncRate) then BonusCrncRate:= DefCurrRate;
    if fnNotZero(BonusVolumePercent) then begin
      curr:= RoundTo(DefCurrRate/BonusCrncRate*BonusVolumePercent/100, -4);
      if fnNotZero(curr-BonusVolumeCoeff) then BonusVolumeCoeff:= curr;
    end;
{    if flDebug then with Currencies.ItemsList do
      for i:= 0 to Count-1 do if not TCurrency(Items[i]).Arhived then begin
        j:= TCurrency(Items[i]).ID;
        n:= TCurrency(Items[i]).Name;
        ss:= TCurrency(Items[i]).CliName;
        curr:= TCurrency(Items[i]).CurrRate;
        prMessageLOGS(fnMakeAddCharStr(j, 5)+' '+fnMakeAddCharStr(n, 6, True)+
          fnMakeAddCharStr(ss, 6, True)+fnMakeAddCharStr(FormatFloat('# ##0.00', curr), 10), fLogDebug, false); // пишем в log
      end;  }
    TestCssStopException;
////////////////////////////////////////////////////////////////////// типы фирм
    if Length(arFirmTypesNames)<2 then begin
      ibs.SQL.Text:= 'SELECT GEN_ID (CLTPCODEGEN, 0) FROM RDB$DATABASE';
      ibs.ExecQuery;
      i:= ibs.Fields[0].AsInteger;
      ibs.Close;
      TestCacheArrayLength(taFtyp, i);
    end;
    ibs.SQL.Text:= 'SELECT CLTPCODE, CLTPNAME FROM CLIENTTYPES where CLTPARCHIVE="F"';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('CLTPCODE').AsInteger;
      TestCacheArrayLength(taFtyp, i+1);
      ss:= fnDelEndOfStr(ibs.fieldByName('CLTPNAME').AsString);
      if arFirmTypesNames[i]<>ss then arFirmTypesNames[i]:= ss;
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    TestCssStopException;
///////////////////////////////////////////////////////////////// категории фирм
    if Length(arFirmTypesNames)<2 then begin
      ibs.SQL.Text:= 'SELECT GEN_ID (FRCLCODEGEN, 0) FROM RDB$DATABASE';
      ibs.ExecQuery;
      i:= ibs.Fields[0].AsInteger;
      ibs.Close;
      TestCacheArrayLength(taFtyp, i);
    end;
    ibs.SQL.Text:= 'SELECT FRCLCODE, FRCLNAME from FIRMCLASS where FRCLARCHIVE="F"';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('FRCLCODE').AsInteger;
      TestCacheArrayLength(taFcls, i+1);
      ss:= fnDelEndOfStr(ibs.fieldByName('FRCLNAME').AsString);
      if arFirmClassNames[i]<>ss then arFirmClassNames[i]:= ss;
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    TestCssStopException;
//////////////////////////////////////////////////////////////////////// ед.изм.
    if not flFill then FMeasNames.SetDirStates(False);
    ibs.SQL.Text:= 'SELECT MEASCODE, MEASNAME from MEASURE';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('MEASCODE').AsInteger;
      ss:= fnDelEndOfStr(ibs.fieldByName('MEASNAME').AsString);
      Item:= TDirItem.Create(i, ss);
      FMeasNames.CheckItem(Item);
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    if not flFill then FMeasNames.DelDirNotTested;
    FMeasNames.CheckLength;
    TestCssStopException;
//////////////////////////////////////////////////////////////// методы отгрузки
    ShipMethods.SetDirStates(False);  // ss:= GetIniParam(nmIniFileBOB, 'GrossBee', 'ClientShipMethods');
    ibs.SQL.Text:= 'SELECT SHMHCODE, SHMHNAME, SHMHTIMEKEY, SHMHLABELKEY'+
      ' from SHIPMENTMETHODS where SHMHARCHIVE="F"'; // +fnIfStr(ss='', '', ' and SHMHCODE in ('+ss+')');
    ibs.ExecQuery;
    while not ibs.Eof do begin
      Item:= TShipMethodItem.Create(ibs.fieldByName('SHMHCODE').AsInteger,
        fnDelEndOfStr(ibs.fieldByName('SHMHNAME').AsString),
        GetBoolGB(ibs, 'SHMHTIMEKEY'), GetBoolGB(ibs, 'SHMHLABELKEY'));
      ShipMethods.CheckItem(Item);
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    ShipMethods.DelDirNotTested;
    ShipMethods.CheckLength;
    ShipMethods.SortDirListByName; // сортировка списка по наименованию
    TestCssStopException;
/////////////////////////////////////////////////////////////// времена отгрузки
    Hmin:= 0;
    Hmax:= 24;
    Mmin:= 0;
    Mmax:= 0;
    ss:= GetConstItem(pcSelfGetShipPeriod).StrValue;
    i:= pos('-', ss);
    if (i>0) then begin
      s:= copy(ss, 1, i-1);
      ii:= pos(':', s);
      if (ii>0) then begin
        n:= trim(copy(s, 1, ii-1));
        Hmin:= StrToIntDef(n, 0);
        n:= trim(copy(s, i+1, length(s)));
        Mmin:= StrToIntDef(n, 0);
      end;
      s:= copy(ss, i+1, length(ss));
      ii:= pos(':', s);
      if (ii>0) then begin
        n:= trim(copy(s, 1, ii-1));
        Hmax:= StrToIntDef(n, 24);
        n:= trim(copy(s, i+1, length(s)));
        Mmax:= StrToIntDef(n, 0);
      end;
    end;
    mStart:= Hmin*60+Mmin;
    mEnd:= Hmax*60+Mmax;

    ShipTimes.SetDirStates(False);  // ss:= GetIniParam(nmIniFileBOB, 'GrossBee', 'ClientShipTimes');
    ibs.SQL.Text:= 'SELECT SHTICODE, SHTINAME, SHTIHOUR, SHTIMINUTE'+
      ' from SHIPMENTTIMES where SHTIARCHIVE="F"'; // +fnIfStr(s='', '', ' and SHTICODE in ('+ss+')');
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('SHTICODE').AsInteger;
      ss:= fnDelEndOfStr(ibs.fieldByName('SHTINAME').AsString);
      h:= ibs.fieldByName('SHTIHOUR').AsInteger;
      m:= ibs.fieldByName('SHTIMINUTE').AsInteger;
      if not ShipTimes.ItemExists(i) then begin
        Item:= TShipTimeItem.Create(i, ss, h, m);
        ShipTimes.CheckItem(Item);                //
      end else with TShipTimeItem(ShipTimes[i]) do begin
        Name:= ss;
        if (Hour  <>h) then Hour  := h;
        if (Minute<>m) then Minute:= m;
        State:= True;
      end;
//      j:= h*60+m;
//      TShipTimeItem(ShipTimes[i]).SelfGetAllow:= not ((j<mStart) or (j>mEnd));
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    ShipTimes.DelDirNotTested;
    ShipTimes.CheckLength;
    ShipTimes.DirSort(ShipTimesSortCompare); // сортировка списка - час + мин
    TestCssStopException;
////////////////////////////////////////////////////////////////// подразделения
                // коды филиалов - отправлять только письма о счетах с ошибками
    ss:= GetConstItem(pcOnlyErrAccMailFilials).StrValue;
    flOnlyErrAll:= (ss='');
    if not flOnlyErrAll then ar:= fnArrOfCodesFromString(ss);
    if Length(arDprtInfo)<2 then begin
      ibs.SQL.Text:= 'SELECT GEN_ID (DPRTCODEGEN, 0) FROM RDB$DATABASE';
      ibs.ExecQuery;
      i:= ibs.Fields[0].AsInteger;
      ibs.Close;
      TestCacheArrayLength(taDprt, i);
    end;
    if alter then begin
    {  ibs.SQL.Text:='SELECT DPRTCODE, DPRTSHORTNAME, DPRTCOLUMNNAME, DPRTMAINNAME, DprtKind, DPRTMASTERCODE'+
        ' FROM DEPARTMENT inner join DEPARTMENTALTER on DPRTALTERTIME>:time and DPRTALTERCODE=DPRTCODE'+
        ' order by DPRTCODE';
      ibs.ParamByName('time').AsDateTime:= IncMinute(LastTimeCacheAlter, -1);   }
    end else begin
      ibs.SQL.Text:= 'SELECT DPRTCODE, DPRTSHORTNAME, DPRTCOLUMNNAME,'+
        ' DPRTMAINNAME, DprtKind, DPRTMASTERCODE, DPRTEMAILORDER, DPRTDELAYTIME'+
        ' FROM DEPARTMENT where DPRTARCHIVE="F" order by DPRTCODE';
    end;
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('DPRTCODE').AsInteger;
      flnew:= True;
      if TestCacheArrayItemExist(taDprt, i, flnew) then with arDprtInfo[i] do begin
        ss:= fnDelEndOfStr(ibs.fieldByName('DPRTMAINNAME').AsString);
        if MainName<>ss then MainName:= ss;
        if ParentID<>ibs.fieldByName('DPRTMASTERCODE').AsInteger then
          ParentID:= ibs.fieldByName('DPRTMASTERCODE').AsInteger;

        if DelayTime<>ibs.fieldByName('DPRTDELAYTIME').AsInteger then  // запаздывание
          DelayTime:= ibs.fieldByName('DPRTDELAYTIME').AsInteger;

        fl:= not ibs.fieldByName('DprtKind').IsNull
             and (ibs.fieldByName('DprtKind').AsInteger=0);
        if IsStoreHouse<>fl then IsStoreHouse:= fl;
        fl:= not ibs.fieldByName('DprtKind').IsNull
             and (ibs.fieldByName('DprtKind').AsInteger=1);
        if IsFilial<>fl then IsFilial:= fl;
         fl:= not ibs.fieldByName('DprtKind').IsNull
             and (ibs.fieldByName('DprtKind').AsInteger=2);
        if IsStoreRoad<>fl then IsStoreRoad:= fl;

        if IsStoreHouse or IsFilial or IsStoreRoad then begin
          ss:= fnDelEndOfStr(ibs.fieldByName('DPRTSHORTNAME').AsString);
          if ShortName<>ss then ShortName:= ss;
        end;
        if IsStoreHouse then begin
          ss:= fnDelEndOfStr(ibs.fieldByName('DPRTCOLUMNNAME').AsString);
          if ColumnName<>ss  then ColumnName:= ss;
        end;
        if IsFilial then begin
          ss:= fnDelEndOfStr(ibs.fieldByName('DPRTEMAILORDER').AsString);
          if not fnCheckEmail(ss) then begin
//            if flDebug then prMessageLOGS(nmProc+'_dprt'+IntToStr(i)+': not correct Email '+ss, fLogDebug);
            ss:= '';
          end;
          if MailOrder<>ss  then MailOrder:= ss;
          IsFilOnlyErr:= flOnlyErrAll or (fnInIntArray(i, ar)>-1);
        end;
      end;
      cntsGRB.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;

    for i:= 1 to High(arDPRTInfo) do          // проставляем филиал по всем
      if Assigned(arDPRTInfo[i]) then arDPRTInfo[i].SetFilialID(i);

    j:= Length(arDprtInfo);
    for i:= High(arDprtInfo) downto 1 do if Assigned(arDprtInfo[i]) then begin
      j:= arDprtInfo[i].ID+1;
      break;
    end;
    if Length(arDprtInfo)>j then try
      CScache.Enter;
      SetLength(arDprtInfo, j); // обрезаем по мах.коду
    finally
      CScache.Leave;
    end;
    TestCssStopException;
///////////////////////////////////////////////////// методы отгрузки по складам
    ibs.SQL.Text:= 'SELECT DPSHMHDPRTCODE, DPSHMHMETHODCODE'+
      ' FROM DPRTSHIPMENTMETHODS order by DPSHMHDPRTCODE';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('DPSHMHDPRTCODE').AsInteger;
      if not DprtExist(i) then begin
        while not ibs.Eof and (i=ibs.fieldByName('DPSHMHDPRTCODE').AsInteger) do ibs.Next;
        Continue;
      end;
      with arDprtInfo[i].ShipLinks do begin
        SetLinkStates(False);
        while not ibs.Eof and (i=ibs.fieldByName('DPSHMHDPRTCODE').AsInteger) do begin
          j:= ibs.fieldByName('DPSHMHMETHODCODE').AsInteger;
          if ShipMethods.ItemExists(j) then CheckLink(j, 0, ShipMethods[j]);
          cntsGRB.TestSuspendException;
          ibs.Next;
        end;
        DelNotTestedLinks;
        SortByLinkName; // сортировка списка по наименованию
      end;
    end;
    ibs.Close;
    TestCssStopException;
///////////////////////////////////////////////// расписания отгрузки по складам
    mDate:= Date();
    ibs.SQL.Text:= 'SELECT SHBDDATE, DpScDprtCode,'+
      ' iif(DpExScCode is null, DpScStartTime, DpExScStartTime) StartTime,'+
      ' iif(DpExScCode is null, DpScStopTime, DpExScStopTime) StopTime'+
      ' FROM OPERSCHDBODY left join DprtSchedule on dpscdaytype=SHBDSHIFT'+
      ' left join DprtExceptSchedule on DpExScDprtCode=DpScDprtCode and DpExScDate=SHBDDATE'+
      ' where SHBDDATE between :d1 and :d2 and DpScDprtCode is not null'+
      ' order by DpScDprtCode, SHBDDATE';
    ibs.ParamByName('d1').AsDate:= mDate;
    ibs.ParamByName('d2').AsDate:= mDate+Cache.GetConstItem(pcShipChoiceDays).IntValue;  // пока 7 дней
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('DpScDprtCode').AsInteger;
      if not DprtExist(i) then begin
        while not ibs.Eof and (i=ibs.fieldByName('DpScDprtCode').AsInteger) do ibs.Next;
        Continue;
      end;
      dprt:= arDprtInfo[i];
      lst.Clear;
      for j:= 0 to dprt.Schedule.Count-1 do lst.Add(Pointer(0)); // флаги проверки
      while not ibs.Eof and (i=ibs.fieldByName('DpScDprtCode').AsInteger) do begin
        ii:= trunc(ibs.fieldByName('SHBDDATE').AsDate-mDate);
        j:= ibs.fieldByName('StartTime').AsInteger;
        jj:= ibs.fieldByName('StopTime').AsInteger;
        if (dprt.Schedule.Count>ii) then begin
          sch:= TTwoCodes(dprt.Schedule[ii]);
          if (sch.ID1<>j) then sch.ID1:= j;
          if (sch.ID2<>jj) then sch.ID2:= jj;
          lst[ii]:= Pointer(1);
        end else begin
          dprt.Schedule.Insert(ii, TTwoCodes.Create(j, jj));
          lst.Insert(ii, Pointer(1));
        end;
        cntsGRB.TestSuspendException;
        ibs.Next;
      end;
      for i:= 0 to dprt.Schedule.Count-1 do begin // ищем непроверенные
        if not Assigned(dprt.Schedule[i]) then
          dprt.Schedule[i]:= TTwoCodes.Create(0, 0)
        else if not Assigned(lst[i]) or (lst[i]=Pointer(0)) then begin
          sch:= TTwoCodes(dprt.Schedule[i]);
          sch.ID1:= 0;
          sch.ID2:= 0;
        end
      end;
    end;
    ibs.Close;
    TestCssStopException;
/////////////////////////////////////////////////// ЦФУ (FISCALACCOUNTINGCENTER)
    if not flFill then FiscalCenters.SetDirStates(False);   // только категория <Планирование ПРОДАЖ>
    SetLength(ar, 0);
    ibs.ParamCheck:= False;
    ibs.SQL.Clear;
    ibs.SQL.Add('execute block returns (rCode integer, rPar integer, rName varchar(100), rEmpl integer)');
    ibs.SQL.Add('as declare variable xCode integer=0; declare variable xCount integer=0;');
    ibs.SQL.Add('declare variable xDate Date; begin');
    ibs.SQL.Add('  for select FcGrFiscalCode, FcGrMasterCode, FCGRFISCALNAME, FCGRSTARTDATE');
    ibs.SQL.Add('    from fiscalcentergroup where FcGrClassCode='+GetConstItem(pcFaccPlanSaleClassCode).StrValue);
    ibs.SQL.Add('      and FCGRSTARTDATE<="today" and FCGRFISCALARCHIVE="F"');
    ibs.SQL.Add('    order by FcGrMasterCode, FcGrFiscalCode, FCGRSTARTDATE desc');
    ibs.SQL.Add('  into :rCode, :rPar, :rName, :xDate do if (xCode<>rCode) then begin xCode=rCode; xCount=0;');
    ibs.SQL.Add('    if (exists(select * from fiscalcentergroup f where f.FcGrMasterCode=:rCode'); // верхний уровень
    ibs.SQL.Add('      and f.FcGrClassCode=6 and f.FCGRSTARTDATE<="today" and f.FCGRFISCALARCHIVE="F"))');
    ibs.SQL.Add('    then begin rEmpl=-1; suspend; end');
    ibs.SQL.Add('    else begin for select e.emplcode from CONTROLUNITLINK cul'); // нижний уровень
    ibs.SQL.Add('      left join AnalitDict BKE on BKE.andtCode = cul.CnUnLnControlUnitCode');
    ibs.SQL.Add('      left join AnalitDict EmplAnalit on EmplAnalit.AnDtCode = BKE.AnDtMasterDict');
    ibs.SQL.Add('      left join employees e on e.emplmancode = EmplAnalit.AnDtMasterDict');
    ibs.SQL.Add('      where cul.CNUNLNFACCCODE = :rCode and "TODAY" between cul.CnUnLnStartDate');
    ibs.SQL.Add('        and cul.CnUnLnStopDate and e.emplcode is not null and e.emplarchive = "F"');
    ibs.SQL.Add('      group by e.emplcode into :rEmpl do begin xCount=xCount+1;');
    ibs.SQL.Add('      if (rEmpl is null or rEmpl <1) then rEmpl=0; suspend; end');
    ibs.SQL.Add('      if (xCount<1) then begin rEmpl=0; suspend; end end end end');
    ibs.ExecQuery;
    while not ibs.EOF do begin
      i:= ibs.FieldByName('rCode').AsInteger;  // ID
      j:= ibs.FieldByName('rPar').AsInteger;   // Parent
      n:= fnDelEndOfStr(ibs.FieldByName('rName').AsString);
      fl:= (ibs.FieldByName('rEmpl').AsInteger<0);
      if not FiscalCenters.ItemExists(i) then begin
        fc:= TFiscalCenter.Create(i, j, n);
        fc.LastLevel:= not fl;
        Item:= fc;
        FiscalCenters.CheckItem(Item);
      end else begin
        fc:= FiscalCenters[i];
        fc.Name:= n;
        FiscalCenters.CS_DirItems.Enter;
        try
          if (fc.Parent<>j) then fc.Parent:= j;
          fc.LastLevel:= not fl;
          fc.State:= True;
        finally
          FiscalCenters.CS_DirItems.Leave;
        end;
      end;
      s:= '';
      if fl then ibs.Next
      else while not ibs.EOF and (i=ibs.FieldByName('rCode').AsInteger) do begin
        if (ibs.FieldByName('rEmpl').AsInteger>0) then
          s:= s+fnIfStr(s='', '', ',')+ibs.FieldByName('rEmpl').AsString;
        ibs.Next;
      end;
      j:= fc.Region;
      if fc.CheckIsROPFacc and (j>0) then begin // ЦФУ РОП-а округа
        if High(ar)<j then SetLength(ar, j+1);
        if ar[j]<>i then ar[j]:= i;
      end;
      FiscalCenters.CS_DirItems.Enter;
      try
        if (s<>'') then begin
          prCheckIntegerListByCodesString(fc.BKEempls, s);
          for ii:= 0 to fc.BKEempls.Count-1 do begin
            jj:= fc.BKEempls[ii];
            if not Cache.EmplExist(jj) then Continue;
            Cache.arEmplInfo[jj].FaccRegion:= j;
          end;
        end else if (fc.BKEempls.Count>0) then fc.BKEempls.Clear;
      finally
        FiscalCenters.CS_DirItems.Leave;
      end;
      cntsGRB.TestSuspendException;
    end;
    ibs.Close;
    if not flFill then FiscalCenters.DelDirNotTested;
    FiscalCenters.CheckLength;
    FiscalCenters.CS_DirItems.Enter;
    try
      for j:= 0 to FiscalCenters.ItemsList.Count-1 do begin
        fc:= FiscalCenters.ItemsList[j];
        jj:= fc.GetSaleType;
        fc.IsAutoSale:= (jj=constIsAuto);
        fc.IsMotoSale:= (jj=constIsMoto);
      end;
    finally
      FiscalCenters.CS_DirItems.Leave;
    end;
    try // сверяем массив ЦФУ РОП-а округа по номеру округа
      CScache.Enter;
      if Length(arRegionROPFacc)<>Length(ar) then
        SetLength(arRegionROPFacc, Length(ar));
      for i:= Low(ar) to High(ar) do
        if arRegionROPFacc[i]<>ar[i] then arRegionROPFacc[i]:= ar[i];
    finally
      CScache.Leave;
    end;
{      if flDebug then begin
      prMessageLOGS('-------------------', fLogDebug, false); // пишем в log
      for i:= 0 to ItemsList.Count-1 do with TFiscalCenter(ItemsList[i]) do
        prMessageLOGS(fnMakeAddCharStr(GetSaleType, 3)+' '+fnMakeAddCharStr(Parent, 5)+' '+
          fnMakeAddCharStr(ID, 5)+' '+Name, fLogDebug, false); // пишем в log
    end;   }
    TestCssStopException;
////////////////////////////// коды брендов через запятую без показа рисунков TD
    s:= GetConstItem(pcBrandsWithoutTDPicts).StrValue;
    prCheckIntegerListByCodesString(NoTDPictBrandCodes, s); // сверить TIntegerList со строкой кодов

    ibs.ParamCheck:= True;
///////////////////////////////////////////////////////////////////////// прайсы
{    ibs.SQL.Text:= 'SELECT PRTPCODE from PRICETYPE where PRTPARCHIVE="F"'+
      ' and PRTPUPPERNAME containing "РОЗНИЦА" order by PRTPCODE';
    ibs.ExecQuery;
    ilst.Clear;
    while not ibs.Eof do begin
      ilst.Add(ibs.fieldByName('PRTPCODE').AsInteger);
      ibs.Next;
      cntsGRB.TestSuspendException;
    end;
    ibs.Close;
    try // сверяем список прайсов
      CScache.Enter;

    finally
      CScache.Leave;
    end;

    if s<>'' then try
      ars:= fnSplitString(s, ',');
      j:= Length(ars);
      CScache.Enter;
      try
        if Length(PriceTypes)<j then SetLength(PriceTypes, j);
        for i:= 0 to High(ars) do begin
          ii:= StrToIntDef(ars[i], 0);
          if (ii>0) and (PriceTypes[i]<>ii) then PriceTypes[i]:= ii;
        end;
        if Length(PriceTypes)>j then SetLength(PriceTypes, j);
      finally
        CScache.Leave;
      end;
    finally
      SetLength(ars, 0);
    end;
}

///////////////////////////////////////////////////////////////// шаблоны скидок
    ibs.SQL.Clear;         // направления по продуктам
    ibs.SQL.Text:= 'SELECT rProdDirect, rPrDirName from Vlad_CSS_GetProdDirects';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('rProdDirect').AsInteger;
      s:= ibs.fieldByName('rPrDirName').AsString;
      DiscountModels.CheckProdDirect(i, s); // проверяем/добавляем направление
      if not flFill then ilst.Add(i);
      ibs.Next;
      cntsGRB.TestSuspendException;
    end;
    ibs.Close;
    if not flFill then with DiscountModels do for i:= ProdDirectList.Count-1 downto 0 do begin
      jj:= Integer(ProdDirectList.Objects[i]);
      if (ilst.IndexOf(jj)<0) then DelProdDirect(jj);     // удаляем лишние
    end;

    ibs.SQL.Text:= 'SELECT rProdDirect, rDiscModel, rModelName, rRating, rValue'+
                   ' from Vlad_CSS_GetProdDirDiscModels';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.fieldByName('rProdDirect').AsInteger;
      while not ibs.EOF and (i=ibs.FieldByName('rProdDirect').AsInteger) do begin
        j:= ibs.fieldByName('rDiscModel').AsInteger; // проверяем/добавляем шаблон
        DiscountModels.CheckDiscModel(j, i, ibs.fieldByName('rRating').AsInteger,
          ibs.fieldByName('rValue').AsInteger, ibs.fieldByName('rModelName').AsString);
        ibs.Next;
      end;
      cntsGRB.TestSuspendException;
    end;
    ibs.Close;
    if not flFill then DiscountModels.DelNotTestedDiscModels; // удалить лишние шаблоны
    DiscountModels.SortDiscModels;
{    if flDebug then begin
      prMessageLOGS('-------------------', fLogDebug, false); // пишем в log
      for i:= 0 to DiscountModels.DiscModels.Count-1 do
      with TDiscModel(DiscountModels.DiscModels[i]) do
        prMessageLOGS(fnMakeAddCharStr(ID, 3)+' '+fnMakeAddCharStr(DirectInd, 5)+' '+
          fnMakeAddCharStr(Rating, 5)+' '+fnMakeAddCharStr(Sales, 5)+' '+Name, fLogDebug, false); // пишем в log
    end;  }

  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'_'+s+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+'_'+str+': '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibs);
    cntsGRB.SetFreeCnt(ibd, True);
    SetLength(ar, 0);
    prFree(lst);
    prFree(ilst);
    prMessageLOGS(nmProc+': '+GetLogTimeStr(TimeProc), fLogCache, false);
  end;
  TestCssStopException;
end;
//================================================= наименование метода отгрузки
function TDataCache.GetShipMethodName(smID: Integer): string;
begin
  Result:= '';
  if not Assigned(self) or not ShipMethods.ItemExists(smID) then Exit;
  Result:= GetDirItemName(ShipMethods[smID]);
end;
//==================================== признак запрета времени у метода отгрузки
function TDataCache.GetShipMethodNotTime(smID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not ShipMethods.ItemExists(smID) then Exit;
  Result:= not TShipMethodItem(ShipMethods[smID]).TimeKey;
end;
//=================================== признак запрета наклейки у метода отгрузки
function TDataCache.GetShipMethodNotLabel(smID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not ShipMethods.ItemExists(smID) then Exit;
  Result:= not TShipMethodItem(ShipMethods[smID]).LabelKey;
end;
//================================================ наименование времени отгрузки
function TDataCache.GetShipTimeName(stID: Integer): string;
begin
  Result:= '';
  if not Assigned(self) or not ShipTimes.ItemExists(stID) then Exit;
  Result:= GetDirItemName(ShipTimes[stID]);
end;
//====== сортированный список методов отгрузки по складу или всех (Objects - ID)
function TDataCache.GetShipMethodsList(dprt: Integer=0): TStringList; // must Free
var i, id: Integer;
    s: String;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  if dprt<1 then begin // все
    with ShipMethods do for i:= 0 to ItemsList.Count-1 do begin
      s:= GetDirItemName(ItemsList[i]);
      id:= GetDirItemID(ItemsList[i]);
      Result.AddObject(s, Pointer(id));
    end;
    Exit;
  end;
  if not DprtExist(dprt) then Exit;            // по складу
  with arDprtInfo[dprt].ShipLinks do for i:= 0 to ListLinks.Count-1 do begin
    s:= GetLinkName(ListLinks[i]);
    id:= GetLinkID(ListLinks[i]);
    Result.AddObject(s, Pointer(id));
  end;
end;
//========================== сортированный список времен отгрузки (Objects - ID)
function TDataCache.GetShipTimesList: TStringList; // must Free
var i, id: Integer;
    s: String;
begin
  Result:= TStringList.Create;
  with ShipTimes do for i:= 0 to ItemsList.Count-1 do begin
    s:= GetDirItemName(ItemsList[i]);
    id:= GetDirItemID(ItemsList[i]);
    Result.AddObject(s, Pointer(id));
  end;
end;
//======================================================= проверка кэша констант
procedure TDataCache.TestParConstants(flFill: Boolean=True; alter: boolean=False);
// alter=True - по alter-таблицам, False - полная
const nmProc = 'TestParConstants'; // имя процедуры/функции
var i, j, ii: integer;
    s: string;
    ibs: TIBSQL;
    ibd: TIBDatabase;
    flnew: boolean;
    Item: Pointer;
    ars: Tas;
//    curr: Double;
begin
  if not Assigned(self) then Exit;
  if alter then s:= 'alter' else s:= 'full';
  ibd:= nil;
  ibs:= nil;
//////////////////////////////////////////////////////////////
  try try
    if flFill then begin
      Item:= TConstItem.Create(0, 'Неизв.параметр', 2);
      FParConstants.CheckItem(Item); // добавляем в справочник 0-й элемент
    end{ else FParConstants.SetDirStates(False)};
    try
      ibd:= cntsORD.GetFreeCnt;
      ibs:= fnCreateNewIBSQL(ibd, 'ibsORD_'+nmProc, -1, tpRead, True);
      ibs.SQL.Text:= 'select * from SERVERPARAMCONSTANTS'; // список констант
      ibs.ExecQuery;
      while not ibs.Eof do begin
        i:= ibs.fieldByName('SPCCODE').asInteger;
        s:= IntToStr(i);
        flnew:= not FParConstants.ItemExists(i);
        if flnew then begin
          Item:= TConstItem.Create(i, ibs.fieldByName('SPCNAME').asString,
            ibs.fieldByName('SPCTYPECODE').asInteger,
            ibs.fieldByName('SPCUSERID').asInteger,
            ibs.fieldByName('SPCPRECISION').asInteger, True); // Links - роли
          FParConstants.CheckItem(Item);                  // добавляем в справочник
        end;
        with GetConstItem(i) do try
          FParConstants.CS_DirItems.Enter;
          if not flnew then begin
            Name     := ibs.fieldByName('SPCNAME').asString;
            ItemType := ibs.fieldByName('SPCTYPECODE').asInteger;
            Precision:= ibs.fieldByName('SPCPRECISION').asInteger;
            LastUser := ibs.fieldByName('SPCUSERID').asInteger;
          end;
          StrValue   := ibs.fieldByName('SPCVALUE').asString;
          maxStrValue:= ibs.fieldByName('SPCmaxVALUE').asString;
          minStrValue:= ibs.fieldByName('SPCminVALUE').asString;
          NotEmpty   := GetBoolGB(ibs, 'SPCnotEmptyValue');
          LastTime   := ibs.fieldByName('SPCTIME').AsDateTime; // время посл.изменения
          Grouping   := ibs.fieldByName('SPCGROUP').asString;
        finally
          FParConstants.CS_DirItems.Leave;
        end;
        cntsORD.TestSuspendException;
        ibs.Next;
      end;
      ibs.Close;
    finally
      prFreeIBSQL(ibs);
      cntsORD.SetFreeCnt(ibd);
    end;
//    if not flFill then FParConstants.DelDirNotTested; // удаление маловероятно
    FParConstants.CheckLength;

    //-------------- строка для вставки в заголовок письма (SysMailSend)
    VSMail.CheckXstring(GetConstItem(pcX_section).StrValue, GetConstItem(pcX_value).StrValue);

    //--------------  список кодов фиктивных менеджеров (ИНФО, ЯяяАРХИВ и т.п.)
    s:= GetConstItem(pcFictiveEmplCodes).StrValue;
    ars:= fnSplitString(S, ',');
    CScache.Enter;
    try
      if Length(ars)<>Length(arFictiveEmpl) then SetLength(arFictiveEmpl, Length(ars));
      for i:= 0 to High(ars) do begin
        j:= StrToIntDef(ars[i], 0);
        if arFictiveEmpl[i]<>j then arFictiveEmpl[i]:= j;
      end;
    finally
      CScache.Leave;
    end;

    //-----------------------------------------------------  код группы ДОСТАВКИ
    pgrDeliv:= GetConstItem(pcDeliveriesMasterCode).IntValue;

    //-----------  отображение складов в 2 колонки (резерв только по def-складу)
    flClientStoragesView_2col:= (Cache.GetConstItem(pcNewClientStoragesView).IntValue in [1, 2]);
    //---------------------------------------  отображение складов доп.видимости
    flClientStoragesView_add:= (Cache.GetConstItem(pcNewClientStoragesView).IntValue=2);
    //---------------------------------------  менеджеры контракта только по BKE
    flContManagerBKEonly:= (GetConstItem(pcContManagerBKEonly).IntValue>0);

///////////////////////////////////////////////////////////////////////// прайсы
    s:= GetConstItem(pcUsedPriceTypes).StrValue;
    if s<>'' then try
      ars:= fnSplitString(s, ',');
      j:= Length(ars);
      CScache.Enter;
      try
        if Length(PriceTypes)<j then SetLength(PriceTypes, j);
        for i:= 0 to High(ars) do begin
          ii:= StrToIntDef(ars[i], 0);
          if (ii>0) and (PriceTypes[i]<>ii) then PriceTypes[i]:= ii;
        end;
        if Length(PriceTypes)>j then SetLength(PriceTypes, j);
      finally
        CScache.Leave;
      end;
    finally
      SetLength(ars, 0);
    end;
    if Length(PriceTypes)<1 then begin // подстраховка
      SetLength(PriceTypes, 1);
      PriceTypes[0]:= 1;
    end;

  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'_'+s+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+'_'+s+': '+E.Message, fLogCache);
  end;
  finally
    SetLength(ars, 0);
  end;
  TestCssStopException;
end;
//============================================== заполнение/проверка сотрудников
procedure TDataCache.TestEmpls(pEmplID: Integer; FillNew: boolean=True;
          CompareTime: boolean=True; TestEmplFirms: boolean=False);
const nmProc = 'TestEmpls'; // имя процедуры/функции
type
  TUserGBInfo = record //----- для параметров USERLIST
    UserLogin: string;    // логин Grossbee
    UserMail : string;    // Email сотрудника
    VisRuleID: Integer;   // код схемы видимости
  end;
var UserCode, s, ss, sp, sm: string;
    i, j, iw, iCount, iUser: integer;
    roles, rules: Tai;
    fl, flfill, flnew: boolean;
    userslist: array of TUserGBInfo;
    LocalStart, dd: TDateTime;
    ibs: TIBSQL;
    ibd: TIBDatabase;
    Item, Item1: Pointer;
begin
  iCount:= 0;
  if not Assigned(self) then Exit;
  if (pEmplID>0) and EmplExist(pEmplID) and (CompareTime and
    (Now<IncMinute(arEmplInfo[pEmplID].LastTestTime, ClientActualInterval))) then Exit;
  ibd:= nil;
  ibs:= nil;
  flfill:= length(arEmplInfo)<2;
  SetLength(rules, 0);
  SetLength(roles, 0);
  SetLength(userslist, 0);
  try
    try
      if pEmplID<0 then UserCode:= 'alter'
      else if pEmplID>0 then UserCode:= IntToStr(pEmplID)
      else UserCode:= fnIfStr(flfill, 'fill_', 'test_')+'full';
      LocalStart:= now();
      try try                                      // проверяем данные из Grossbee
        ibd:= cntsGRB.GetFreeCnt;
        ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc+'_'+UserCode, -1, tpRead, True);
        if pEmplID<0 then begin                            // по alter-таблицам

        end else if pEmplID=0 then begin                    // полная проверка
          ibs.SQL.Text:='Select EMPLCODE, EMPLMANCODE, EMPLARCHIVE,'+
            ' MANLASTNAME, MANNAME, MANPATRONYMICNAME, MANARCHIVE, MANWORKEMAIL'+
            ' FROM EMPLOYEES inner join MANS on EMPLMANCODE=MANCODE';
        end else begin                                 // 1 сотрудник
          ibs.SQL.Text:='Select EMPLCODE, EMPLMANCODE, EMPLARCHIVE,'+
            ' MANLASTNAME, MANNAME, MANPATRONYMICNAME, MANARCHIVE, MANWORKEMAIL'+
            ' FROM EMPLOYEES inner join MANS on EMPLMANCODE=MANCODE'+
            ' where EMPLCODE='+UserCode;
        end;

        ibs.ExecQuery;       // заполняем данные сотрудников из EMPLOYEES, MANS Grossbee
        while not ibs.Eof do begin
          i:= ibs.fieldByName('EMPLCODE').AsInteger;
          flnew:= FillNew;
          if TestCacheArrayItemExist(taEmpl, i, flnew) then with arEmplInfo[i] do try try
            s:= fnDelEndOfStr(ibs.fieldByName('MANNAME').AsString);
            ss:= fnDelEndOfStr(ibs.fieldByName('MANLASTNAME').AsString);
            sp:= fnDelEndOfStr(ibs.fieldByName('MANPATRONYMICNAME').AsString);
            sm:= fnDelEndOfStr(ibs.fieldByName('MANWORKEMAIL').AsString);
            CS_Empls.Enter;
            if flnew then begin    // новый объект заполняем
  //            EmplID:= ibs.fieldByName('EMPLCODE').AsInteger;
              ManID:= ibs.fieldByName('EMPLMANCODE').AsInteger;
              Name      := s;
              Surname   := ss;
              Patronymic:= sp;
              Mail      := sm;
              Arhived:=  GetBoolGB(ibs, 'EMPLARCHIVE') or GetBoolGB(ibs, 'MANARCHIVE');
            end else begin         // существующий объект проверяем
              j:= ibs.fieldByName('EMPLCODE').AsInteger;
              if EmplID<>j then EmplID:= j;
              j:= ibs.fieldByName('EMPLMANCODE').AsInteger;
              if ManID<>j then ManID:= j;
              if Name<>s        then Name:= s;
              if Surname<>ss    then Surname:= ss;
              if Patronymic<>sp then Patronymic:= sp;
//              if not fnCheckEmail(sm) then
//                if flDebug then prMessageLOGS(nmProc+'_empl'+IntToStr(j)+': not correct Email '+sm, fLogDebug);
              if Mail<>sm       then Mail:= sm;
              fl:= GetBoolGB(ibs, 'EMPLARCHIVE') or GetBoolGB(ibs, 'MANARCHIVE');
              if Arhived<>fl then Arhived:= fl;
            end;
            LastTestTime:= Now;
            if pEmplID=0 then inc(iCount);
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'g: '+E.Message, fLogCache);
          end;
          finally
            CS_Empls.leave;
          end;
          cntsGRB.TestSuspendException;
          ibs.Next;
        end;
        ibs.Close;
                                      // заполняем массив из USERLIST Grossbee
        ibs.SQL.Text:= 'select USLSCODE, USLSUSERID, USLSEMAIL, USRLVISIBLEGROUPCODE'+
                       ' from USERLIST left join USERROLES on USRLCODE=USLSROLECODE'+
                                 // неархивные и роль <> "Архивные пользователи"
                       ' where uslsarchive="F" and usrlcode<>21 order by USLSCODE desc';
        ibs.ExecQuery; // вынимаем максимальную длину текста прав видимости
        while not ibs.Eof do begin
          i:= ibs.fieldByName('USLSCODE').AsInteger;
          if High(userslist)<i then begin // должно отработать 1 раз
            iw:= Length(userslist);
            SetLength(userslist, i+1);
            for j:= iw to High(userslist) do with userslist[j] do begin
              UserLogin:= '';
              UserMail := '';
              VisRuleID:= 0;   // код схемы видимости
            end;
          end;
          with userslist[i] do begin
            UserLogin:= fnDelEndOfStr(ibs.fieldByName('USLSUSERID').AsString);
            UserMail := fnDelEndOfStr(ibs.fieldByName('USLSEMAIL').AsString);
            VisRuleID:= ibs.fieldByName('USRLVISIBLEGROUPCODE').AsInteger;
          end;
          cntsGRB.TestSuspendException;
          ibs.Next;
        end;
        ibs.Close;
        if ibs.Transaction.InTransaction then ibs.Transaction.Rollback;
      except
        on E: EBOBError do raise EBOBError.Create(nmProc+'_'+UserCode+': '+E.Message);
        on E: Exception do prMessageLOGS(nmProc+'_'+UserCode+': '+E.Message, fLogCache);
      end;
      finally
        prFreeIBSQL(ibs);
        cntsGRB.SetFreeCnt(ibd);
      end;
      TestCssStopException;

      i:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
      if (pEmplID in [0, i]) and not EmplExist(i) then begin //  empl - ORDERAUTO
        flnew:= FillNew;
        if TestCacheArrayItemExist(taEmpl, i, flnew) then with arEmplInfo[i] do try
          CS_Empls.Enter;
          ManID     := 0;
          Surname   := 'ORDERAUTO';  //        Name      := 'ORDERAUTO';
          Patronymic:= '';
          Mail      := '';
          Arhived   :=  False;
          LastTestTime:= Now;
        finally
          CS_Empls.leave;
        end;
      end;
      TestCssStopException;

      try try                                      // проверяем данные из css_ord
        ibd:= cntsOrd.GetFreeCnt;
        ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc+'_'+UserCode, -1, tpRead, True);
        s:= 'Select EMPLCODE, EMPLDPRTCODE, EMPLLOGIN, EMPLPASS,'+
            ' EMPLRESETPASWORD, EMPLGBUSER, EMPLGBREPORTUSER, EMRLROLECODE,'+
            ' EMPLSESSIONID, EMPLLASTACTION, EMPLBLOCK, EMPLDISABLEOUT'+
            ' FROM EMPLOYEES left join EMPLOYEESROLES on EMRLEMPLCODE=EMPLCODE';
        if pEmplID<0 then begin                             // по alter-таблицам

        end else if pEmplID=0 then begin                    // полная проверка
          s:= s+' order by EMPLCODE, EMRLROLECODE';
        end else begin                                      // 1 сотрудник
          s:= s+' where EMPLCODE='+UserCode+' order by EMRLROLECODE';
        end;
        ibs.SQL.Text:= s;
        ibs.ExecQuery;                   // заполняем данные сотрудников из dbOrd
        while not ibs.Eof do begin
          cntsORD.TestSuspendException;
          i:= ibs.fieldByName('EMPLCODE').AsInteger;
          if not EmplExist(i) or arEmplInfo[i].Arhived then begin
            while not ibs.Eof and (i=ibs.fieldByName('EMPLCODE').AsInteger) do ibs.Next;
            Continue;
          end;
          iUser:= 0;
          with arEmplInfo[i] do try try   // существующий объект проверяем
            CS_Empls.Enter;
            s:= ibs.fieldByName('EMPLLOGIN').AsString;
            if (ServerLogin<>s) then ServerLogin:= s;
            s:= ibs.fieldByName('EMPLPASS').AsString;
            if (USERPASSFORSERVER<>s) then USERPASSFORSERVER:= s;
            s:= ibs.fieldByName('EMPLSESSIONID').AsString;
            if (Session<>s) then Session:= s;
            dd:= ibs.fieldByName('EMPLLASTACTION').AsDateTime;
            if (dd>DateNull) and (LastActionTime<>dd) then LastActionTime:= dd;
            j:= ibs.fieldByName('EMPLDPRTCODE').AsInteger;
            if (EmplDprtID<>j) then EmplDprtID:= j;  // пока
            fl:= GetBoolGB(ibs, 'EMPLRESETPASWORD');
            if RESETPASSWORD<>fl then RESETPASSWORD:= fl;
            fl:= (ibs.fieldByName('EMPLBLOCK').AsInteger>0);
            if Blocked<>fl then Blocked:= fl;
            fl:= GetBoolGB(ibs, 'EMPLDISABLEOUT');
            if DisableOut<>fl then DisableOut:= fl;

            iUser:= ibs.fieldByName('EMPLGBUSER').AsInteger;
            if (iUser>0) and (length(userslist)>iUser) then begin
              s:= userslist[iUser].UserLogin;
              if (s<>'') and (GBLogin<>s) then GBLogin:= s;
              s:= userslist[iUser].UserMail;
              if (s<>'') and (Mail='') then Mail:= s; // ??? пока для ORDERAUTO
            end else iUser:= 0;
            j:= ibs.fieldByName('EMPLGBREPORTUSER').AsInteger;
            if (j>0) and (length(userslist)>j) then begin
              s:= userslist[j].UserLogin;
              if (s<>'') and (GBReportLogin<>s) then GBReportLogin:= s;
            end;
            LastTestTime:= Now;
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'o: '+E.Message, fLogCache);
          end;
          finally
            CS_Empls.leave;
          end;

          SetLength(roles, 0);
          while not ibs.Eof and (i=ibs.fieldByName('EMPLCODE').AsInteger) do begin
            prAddItemToIntArray(ibs.fieldByName('EMRLROLECODE').AsInteger, roles);
            ibs.Next;
          end;

          with arEmplInfo[i] do begin
            TestUserRoles(roles); // проверяем роли
            if TestEmplFirms and (iUser>0) then begin
              TestVisRuleNeeds(userslist[iUser].VisRuleID); // проверяем, нужны ли права видимости
              if VisRule>0 then prAddItemToIntArray(VisRule, rules); // собираем коды схем
            end;
          end;
        end;
        ibs.Close;

        if (pEmplID=0) then begin
          try
            if not flfill then FEmplRoles.SetDirStates(False); // список ролей
            ibs.SQL.Text:= 'Select ROLECODE, ROLENAME FROM ROLES';
            ibs.ExecQuery;
            while not ibs.Eof do begin
              i:= ibs.fieldByName('ROLECODE').AsInteger;
              s:= ibs.fieldByName('ROLENAME').AsString;
              Item:= TEmplRole.Create(i, s);
              FEmplRoles.CheckItem(Item);          // добавляем в справочник
              cntsORD.TestSuspendException;
              ibs.Next;
            end;
            ibs.Close;
            if not flfill then FEmplRoles.DelDirNotTested;
            FEmplRoles.CheckLength;
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'r: '+E.Message, fLogCache);
          end;

          try
            if not flfill then FImportTypes.SetDirStates(False); // список видов импорта
            ibs.SQL.Text:= 'select IMTPCODE, IMTPNAME, IMTPREPORT, IMTPIMPORT from ImportTypes';
            ibs.ExecQuery;
            while not ibs.Eof do begin
              i:= ibs.fieldByName('IMTPCODE').AsInteger;
              s:= ibs.fieldByName('IMTPNAME').AsString;
              if not FImportTypes.ItemExists(i) then begin
                Item:= TImportType.Create(i, s,
                  GetBoolGB(ibs, 'IMTPREPORT'), GetBoolGB(ibs, 'IMTPIMPORT'));
                FImportTypes.CheckItem(Item);       // добавляем в справочник
              end else with TImportType(FImportTypes[i]) do begin
                Name:= s;
                ApplyReport:= GetBoolGB(ibs, 'IMTPREPORT');
                ApplyImport:= GetBoolGB(ibs, 'IMTPIMPORT');
                State:= True;
              end;
              cntsORD.TestSuspendException;
              ibs.Next;
            end;
            ibs.Close;
            if not flfill then FImportTypes.DelDirNotTested;
            FImportTypes.CheckLength;
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'i: '+E.Message, fLogCache);
          end;

          try
            ibs.SQL.Text:= 'select LITRIMTPCODE, LITRROLECODE,'+ // связки видов импорта с ролями
              ' LITRAllowRep, LITRAllowImp from LINKIMPTYPEROLE';
            ibs.ExecQuery;
            while not ibs.Eof do begin
              i:= ibs.fieldByName('LITRIMTPCODE').asInteger; // вид импорта
              j:= ibs.fieldByName('LITRROLECODE').asInteger; // роль
              if FImportTypes.ItemExists(i) and FEmplRoles.ItemExists(j) then begin
                iw:= GetLinkSrcFromRepImpAllow(GetBoolGB(ibs, 'LITRAllowRep'),
                  GetBoolGB(ibs, 'LITRAllowImp')); // SrcID= 1- отчет, 2- импорт, 3- отчет + импорт
                Item:= FImportTypes[i];
                Item1:= FEmplRoles[j];
                TImportType(Item).RoleLinks.CheckLink(j, iw, Item1);
                TEmplRole(Item1).ImpLinks.CheckLink(i, iw, Item);
              end;
              cntsORD.TestSuspendException;
              ibs.Next;
            end;
            ibs.Close;
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'li: '+E.Message, fLogCache);
          end;

          try // список констант заполняется раньше, в TestSmallDirectories
            ibs.SQL.Text:= 'select SPCRSPCCODE, SPCRROLECODE, SPCRWRITE'+
              ' from LINKSERVPARCONSTROLE'; // связки констант с ролями
            ibs.ExecQuery;
            while not ibs.Eof do begin
              i:= ibs.fieldByName('SPCRSPCCODE').asInteger; // вид импорта
              j:= ibs.fieldByName('SPCRROLECODE').asInteger; // роль
              iw:= FnIfInt(GetBoolGB(ibs, 'SPCRWRITE'), 1, 0);
              if FParConstants.ItemExists(i) and FEmplRoles.ItemExists(j) then begin
                TConstItem(FParConstants[i]).Links.CheckLink(j, iw, FEmplRoles[j]);     // SrcID=1 - признак разрешения записи
                TEmplRole(FEmplRoles[j]).ConstLinks.CheckLink(i, iw, FParConstants[i]); // SrcID=1 - признак разрешения записи
              end;
              cntsORD.TestSuspendException;
              ibs.Next;
            end;
          except
            on E: Exception do prMessageLOGS(nmProc+'_'+IntToStr(i)+'lc: '+E.Message, fLogCache);
          end;
          ibs.Close;
        end; //  if (ID=0)
        if ibs.Transaction.InTransaction then ibs.Transaction.Rollback;

        j:= Length(arEmplInfo);
        for i:= High(arEmplInfo) downto 1 do if Assigned(arEmplInfo[i]) then begin
          j:= arEmplInfo[i].EmplID+1;
          break;
        end;
        if Length(arEmplInfo)>j then try
          CS_Empls.Enter;
          SetLength(arEmplInfo, j); // обрезаем по мах.коду
        finally
          CS_Empls.Leave;
        end;
      except
        on E: EBOBError do raise EBOBError.Create(nmProc+'_'+UserCode+': '+E.Message);
        on E: Exception do prMessageLOGS(nmProc+'_'+UserCode+': '+E.Message, fLogCache);
      end;
      finally
        prFreeIBSQL(ibs);
        cntsOrd.SetFreeCnt(ibd);
      end;
    finally
      SetLength(userslist, 0);
      SetLength(roles, 0);
    end;

    if (pEmplID=0) then begin
      prMessageLOGS(nmProc+'_'+UserCode+' '+IntToStr(iCount)+' сотр: - '+
        GetLogTimeStr(LocalStart), fLogCache, false);
      if TestEmplFirms then begin
        TestFirms(0, FillNew, CompareTime, True);
        TestClients(0, FillNew, CompareTime, True);
      end;
    end else if (pEmplID>0) and TestEmplFirms then
      TestFirms(0, FillNew, CompareTime, True, pEmplID); // проверка фирм регионала
    TestCssStopException;
    if (TestEmplFirms and (length(rules)>0)) then begin // проверяем права видимости
      iCount:= 0;
      LocalStart:= now();
      s:= fnArrOfIntToString(rules); // строка кодов нужных схем
      try try
        ibd:= cntsGRB.GetFreeCnt;
        ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc+'_VisRules', -1, tpRead, True);
        ibs.SQL.Text:= 'select max(char_length(prgrrules))'+
                       ' from VMPERMISSIONGROUP where prgractive="T"';
        ibs.ExecQuery; // вынимаем максимальную длину текста прав видимости
        if (ibs.Bof and ibs.Eof) then iw:= 4800
        else iw:= ibs.fields[0].AsInteger+10;
        ibs.Close;
        ibs.SQL.Clear;
        ibs.ParamCheck:= False;
        ibs.SQL.Add('execute block returns (PRGRCODE integer,');
        ibs.SQL.Add(' PRGRNAME varchar(30), rules varchar('+IntToStr(iw)+'))');
        ibs.SQL.Add('as declare variable xRule varchar(500); declare variable xPos integer;');
        ibs.SQL.Add('  declare variable xStr varchar('+IntToStr(iw)+'); begin');
        ibs.SQL.Add('  for select PRGRCODE, PRGRNAME, cast(prgrrules as varchar(4800))');
        ibs.SQL.Add('    from VMPERMISSIONGROUP where PRGRCODE in ('+s+') and prgractive="T"');
        ibs.SQL.Add('  into :PRGRCODE, :PRGRNAME, :xstr do begin rules="";');
        ibs.SQL.Add('    while (xstr<>"") do begin xPos=position(";", xstr);');
        ibs.SQL.Add('      if (xPos>0) then begin');
        ibs.SQL.Add('        xRule=substring(xstr from 1 for xpos);');
        ibs.SQL.Add('        xstr=substring(xstr from xpos+1);');
        ibs.SQL.Add('      end else begin xRule=xstr; xstr=""; end');
        ibs.SQL.Add('      xPos=position("deny", xRule);');
        ibs.SQL.Add('      if (xPos>0) then rules=rules||substring(xRule from xpos);');
        ibs.SQL.Add('      else begin xPos=position("allow", xRule);');
        ibs.SQL.Add('        if (xPos>0) then rules=rules||substring(xRule from xpos);');
        ibs.SQL.Add('    end end suspend; end end');
        ibs.ExecQuery;
        while not ibs.Eof do begin
          j:= ibs.fieldByName('PRGRCODE').AsInteger;
          s:= fnDelEndOfStr(ibs.fieldByName('PRGRNAME').AsString); // название схемы видимости
          ss:= fnDelEndOfStr(ibs.fieldByName('rules').AsString);   // текст прав видимости
          with Cache do try // заполняем / проверяем схему видимости
            flNew:= not EmplVisRules.ItemExists(j);
            if flNew then begin
              Item:= TEmplVisRule.Create(j, s);
              EmplVisRules.CheckItem(Item);
            end else Item:= EmplVisRules[j];
            TEmplVisRule(Item).CheckVisRules(s, ss, flNew);
          except
            on E: Exception do prMessageLOGS(nmProc+'(vr '+IntToStr(j)+'): '+E.Message, fLogCache);
          end;
          cntsGRB.TestSuspendException;
          inc(iCount);
          ibs.Next;
        end;
        ibs.Close;
      except
        on E: EBOBError do raise EBOBError.Create(nmProc+'_VisRules: '+E.Message);
        on E: Exception do prMessageLOGS(nmProc+'_VisRules: '+E.Message, fLogCache);
      end;
      finally
        prFreeIBSQL(ibs);
        cntsGRB.SetFreeCnt(ibd);
      end;
      if (pEmplID=0) then
        prMessageLOGS(nmProc+'_CheckVisRules('+IntToStr(iCount)+'): - '+
          GetLogTimeStr(LocalStart), fLogCache, false);
    end; // if (TestEmplFirms and (length(rules)>0))
  finally
    SetLength(rules, 0);
  end;
  TestCssStopException;

//--------------------------------------------------------- для отладки
{  if flDebug then begin
    prMessageLOGS('----------------------------------', fLogDebug, False);
    prMessageLOGS('права видимости empl=190:', fLogCache+'_test1', False);
    prMessageLOGS('----------------------------------', fLogDebug, False);
    with GetEmplVisFirmLinkList(190) do for i:= 0 to Count-1 do begin
      j:= GetLinkID(items[i]);
      if Cache.FirmExist(j) then
        prMessageLOGS('     '+GetLinkName(items[i]), fLogDebug, False);
     end;
  end;  }
//---------------------------------------------------------
end;
//============================================ проверка видимости к/а сотруднику
function TDataCache.CheckEmplVisFirm(pEmplID, pFirmID: Integer): Boolean;
var i: integer;
    vr: TEmplVisRule;
begin
  Result:= False;
  if not Assigned(self) or not EmplExist(pEmplID) or not FirmExist(pFirmID) then Exit;
  i:= arEmplInfo[pEmplID].VisRule;
  if not EmplVisRules.ItemExists(i) then Exit;
  vr:= EmplVisRules[i];
  if not Assigned(vr.FirmLinks) then Exit;
  Result:= vr.FirmLinks.LinkExists(pFirmID);
end;
//============================ список связок с к/а по схеме видимости сотрудника
function TDataCache.GetEmplVisFirmLinkList(EmplID: Integer): TList; // not Free !!!
// возвращает перечень связок или пустой TList - не nil
// вынимать ссылку на фирму из TList - GetLinkPtr(Items[index])
var i: Integer;
    vr: TEmplVisRule;
begin
  Result:= EmptyList;
  if not Assigned(self) or not EmplExist(EmplID) then Exit;
  i:= arEmplInfo[EmplID].VisRule;
  if not EmplVisRules.ItemExists(i) then Exit;
  vr:= EmplVisRules[i];
  if not Assigned(vr.FirmLinks) then Exit;
  Result:= vr.FirmLinks.ListLinks;
end;
//========================================= проверка видимости склада сотруднику
function TDataCache.CheckEmplVisStore(pEmplID, pDprtID: Integer): Boolean;
var i: integer;
    vr: TEmplVisRule;
begin
  Result:= False;
  if not Assigned(self) or not EmplExist(pEmplID) or not DprtExist(pDprtID) then Exit;
  i:= arEmplInfo[pEmplID].VisRule;
  if not EmplVisRules.ItemExists(i) then Exit;
  vr:= EmplVisRules[i];
  if not Assigned(vr.StoreLinks) then Exit;
  Result:= vr.StoreLinks.LinkExists(pDprtID);
end;
//====================== список связок со складами по схеме видимости сотрудника
function TDataCache.GetEmplVisStoreLinkList(EmplID: Integer): TList; // not Free !!!
// возвращает перечень связок или пустой TList - не nil
// вынимать ссылку на склад из TList - GetLinkPtr(Items[index])
var i: Integer;
    vr: TEmplVisRule;
begin
  Result:= EmptyList;
  if not Assigned(self) or not EmplExist(EmplID) then Exit;
  i:= arEmplInfo[EmplID].VisRule;
  if not EmplVisRules.ItemExists(i) then Exit;
  vr:= EmplVisRules[i];
  if not Assigned(vr.StoreLinks) then Exit;
  Result:= vr.StoreLinks.ListLinks;
end;
//=================== получить признак доступности отчета/импорта из srcID линка
function GetRepImpAllowFromLinkSrc(srcID: Integer; flReport: Boolean=False): Boolean;
// flReport=True - проверять разрешение отчета, False - разрешение импорта
// в линке - SrcId= 1- отчет, 2- импорт, 3- отчет + импорт
begin
  Result:= False;
  if (srcID<1) then Exit
  else if (srcID=3) then Result:= True
  else if flReport then Result:= (srcID=1)
  else Result:= (srcID=2);
end;
//================= получить srcID линка из признаков доступности отчета/импорта
function GetLinkSrcFromRepImpAllow(RepAllow, ImpAllow: Boolean): Integer;
// в линке - SrcId= 1- отчет, 2- импорт, 3- отчет + импорт
begin
  Result:= 0;
  if not (RepAllow or ImpAllow) then Exit;
  if RepAllow then Result:= 1;
  if ImpAllow then Result:= Result+2;
end;
//============================================ доступные роли для отчета/импорта
function TDataCache.GetRepOrImpRoles(ImpID: Integer; flReport: Boolean=True): Tai; // must Free
// flReport=True - проверять разрешение на отчет, False - импорт
var j: integer;
    link: TLink;
begin
  SetLength(Result, 0);
  if not Assigned(self) or not FImportTypes.ItemExists(impID) then Exit;
  with TImportType(FImportTypes[ImpID]) do
    if Assigned(RoleLinks) then with RoleLinks do for j:= 0 to LinkCount-1 do begin
      link:= ListLinks[j];
      if not GetRepImpAllowFromLinkSrc(link.SrcID, flReport) then Continue;
      prAddItemToIntArray(link.LinkID, Result);
    end;
end;
//================================= список доступных отчетов/импортов сотрудника
function TDataCache.GetEmplAllowRepOrImpList(pEmplID: Integer; flReport: Boolean=True): TStringList; // must Free
// flReport=True - список отчетов, False - импортов
const nmProc = 'GetEmplAllowRepOrImpList'; // имя процедуры/функции
var i, j, k: integer;
    s: String;
    empl: TEmplInfoItem;
    rol: TEmplRole;
    lnks: TLinks;
    link: TLink;
    ilst: TIntegerList;
begin
  Result:= fnCreateStringList(True, dupIgnore);
  ilst:= TIntegerList.Create;
  try
    if not Assigned(self) or not EmplExist(pEmplID) then Exit;
    empl:= arEmplInfo[pEmplID];
    for i:= 0 to High(empl.UserRoles) do begin
      k:= empl.UserRoles[i];
      if not RoleExists(k) then Continue;
      rol:= FEmplRoles[k];
      if not Assigned(rol.ImpLinks) then Continue;
      lnks:= rol.ImpLinks;
      for j:= 0 to lnks.ListLinks.Count-1 do begin
        link:= lnks.ListLinks[j];
        k:= link.SrcID;
        if GetRepImpAllowFromLinkSrc(k, flReport) then ilst.Add(link.LinkID);
      end;
    end;
    for i:= 0 to ilst.Count-1 do begin
      j:= ilst[i];
      if not Cache.ImpTypeExists(j) then Continue;
      s:= GetDirItemName(Cache.FImportTypes[j]);
      Result.AddObject(s, Pointer(j));
    end;
  except
    on e: Exception do prMessageLOGS(nmProc+': '+E.Message); // пишем в log
  end;
  prFree(ilst);
end;
{//=================================== доступные виды отчетов/импортов сотрудника - убрать
function TDataCache.GetEmplImports(pEmplID: Integer): TStringList; // must Free
const nmProc = 'GetEmplImports'; // имя процедуры/функции
var i, j, k: integer;
    empl: TEmplInfoItem;
    rol: TEmplRole;
    lnks: TLinks;
    link: TLink;
begin
  Result:= fnCreateStringList(True, dupIgnore);
  try
    if not Assigned(self) or not EmplExist(pEmplID) then Exit;
    empl:= arEmplInfo[pEmplID];
    for i:= 0 to High(empl.UserRoles) do begin
      k:= empl.UserRoles[i];
      if not RoleExists(k) then Continue;
      rol:= FEmplRoles[k];
      if not Assigned(rol.ImpLinks) then Continue;
      lnks:= rol.ImpLinks;
      for j:= 0 to lnks.ListLinks.Count-1 do begin
        link:= lnks.ListLinks[j];
        k:= link.SrcID;
        if GetRepImpAllowFromLinkSrc(k, True) or GetRepImpAllowFromLinkSrc(k) then
          Result.AddObject(GetLinkName(link), Pointer(link.LinkID));
      end;
    end;
  except
    on e: Exception do prMessageLOGS(nmProc+': '+E.Message); // пишем в log
  end;
end;  }
//==================== признак наличия разрешенных отчетов/импортов у сотрудника
function TDataCache.GetEmplAllowRepImp(pEmplID: Integer): boolean;
const nmProc = 'GetEmplAllowRepImp'; // имя процедуры/функции
var i, j, k: integer;
    rol: TEmplRole;
    lnks: TLinks;
    link: TLink;
    empl: TEmplInfoItem;
begin
  Result:= False;
  if not Assigned(self) or not EmplExist(pEmplID) then Exit;
  empl:= arEmplInfo[pEmplID];
  try
    for i:= 0 to High(empl.UserRoles) do begin
      k:= empl.UserRoles[i];
      if not RoleExists(k) then Continue;
      rol:= FEmplRoles[k];
      if not Assigned(rol.ImpLinks) then Continue;
      lnks:= rol.ImpLinks;
      for j:= 0 to lnks.ListLinks.Count-1 do begin
        link:= lnks.ListLinks[j];
        Result:= (link.SrcID>0);
        if Result then Exit;
      end;
    end;
  except
    on e: Exception do prMessageLOGS(nmProc+': '+E.Message); // пишем в log
  end;
end;
 //================== проверка кодов фиктивных менеджеров (ИНФО, ЯяяАРХИВ и т.п.)
function TDataCache.CheckEmplIsFictive(pEmplID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not EmplExist(pEmplID) then Exit;
  Result:= (fnInIntArray(pEmplID, arFictiveEmpl)>-1);
end;
//=============================== проверка доступности отчета/импорта сотруднику  - убрать
function TDataCache.CheckEmplImpType(pEmplID, impID: Integer; flReport: Boolean=False): Boolean;
// flReport=True - проверять разрешение отчета, False - разрешение импорта
var i, j: integer;
begin
  Result:= False;
  if not Assigned(self) or not EmplExist(pEmplID) or not FImportTypes.ItemExists(impID) then Exit;

  with arEmplInfo[pEmplID] do for i:= 0 to High(UserRoles) do begin
    j:= UserRoles[i];
    if RoleExists(j) then with TEmplRole(FEmplRoles[j]) do
      if Assigned(ImpLinks) then with ImpLinks do begin
        Result:= LinkExists(impID) and
          GetRepImpAllowFromLinkSrc(GetLinkSrc(Items[impID]), flReport);
        if Result then exit;
      end;
  end;
end;
//================== сортировка TStringList (Objects-ID ConstItem) Grouping+Name
function EmplConstSortCompareSL(List: TStringList; Index1, Index2: Integer): Integer;
var s1, s2: String;
begin
  with List do try
    with Cache.GetConstItem(Integer(Objects[Index1])) do s1:= Grouping+Name;
    with Cache.GetConstItem(Integer(Objects[Index2])) do s2:= Grouping+Name;
    Result:= AnsiCompareText(s1, s2);
  except
    Result:= 0;
  end;
end;
//=============================================== доступные константы сотрудника
function TDataCache.GetEmplConstants(pEmplID: Integer): TStringList; // must Free
var i, j, k: integer;
begin
  Result:= fnCreateStringList(True, dupIgnore);
  if not Assigned(self) or not EmplExist(pEmplID) then Exit;
  try
    with arEmplInfo[pEmplID] do for i:= 0 to High(UserRoles) do begin
      k:= UserRoles[i];
      if RoleExists(k) then with TEmplRole(FEmplRoles[k]) do
        if Assigned(ConstLinks) then with ConstLinks.ListLinks do for j:= 0 to Count-1 do
          Result.AddObject(GetLinkName(items[j]), Pointer(GetLinkID(items[j])));
    end;
  except
  end;
  if Result.Count<2 then exit;

  Result.Sorted:= False;
  Result.CustomSort(EmplConstSortCompareSL);
end;
//==================================== проверка доступности константы сотруднику
function TDataCache.CheckEmplConstant(pEmplID, constID: Integer; var errmess: string; CheckWrite: Boolean=False): Boolean;
// CheckWrite=True - проверять разрешение на запись (в линке - SrcId=1)
var i, j: integer;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  errmess:= '';
  if not EmplExist(pEmplID) then errmess:= MessText(mtkNotEmplExist)
  else if not FParConstants.ItemExists(constID) then errmess:= MessText(mtkNotValidParam);
  if errmess<>'' then Exit;

  with arEmplInfo[pEmplID] do for i:= 0 to High(UserRoles) do begin
    j:= UserRoles[i];
    if RoleExists(j) then with TEmplRole(FEmplRoles[j]) do
      if Assigned(ConstLinks) then with ConstLinks do begin
        Result:= LinkExists(constID) and (not CheckWrite or (GetLinkSrc(Items[constID])=1));
        if Result then exit;
      end;
  end;
  if not Result then errmess:= MessText(mtkNotRightExists);
end;
//========================================= кол-во доступных констант сотрудника
function TDataCache.GetEmplConstantsCount(pEmplID: Integer): Integer;
begin
  Result:= 0;
  if not Assigned(self) or not EmplExist(pEmplID) then Exit;
  with GetEmplConstants(pEmplID) do try
    Result:= Count;
  finally Free; end;
end;
//============================ список адресов константы-списка кодов сотрудников
function TDataCache.GetConstEmails(pc: Integer; pFirm: Integer=0; pWare: Integer=0): String;
var s: String;
begin
  Result:= GetConstEmails(pc, s, pFirm, pWare);
  s:= '';
end;
//============================ список адресов константы-списка кодов сотрудников
function TDataCache.GetConstEmails(pc: Integer; var mess: String; pFirm: Integer=0; pWare: Integer=0): String;
// в mess возвращает сообщения о ненайденных адресах
var ar: Tai;
    index: Integer;
begin
  Result:= '';
  mess:= '';
  if not Assigned(self) or not ConstExists(pc) then Exit;
  try
    ar:= GetConstEmpls(pc);
    if length(ar)<1 then exit;
                                 // удалить РОП-мото
    if (length(ar)>1) and FirmExist(pFirm) and arFirmInfo[pFirm].IsMOTOFirm
      and not arFirmInfo[pFirm].IsAUTOFirm then begin
      index:= fnInIntArray(ceFilialROP, ar);
      prDelItemFromArray(index, ar);
    end;

    if length(ar)<1 then exit;
    Result:= GetEmplEmails(ar, mess, pFirm, pWare);
  finally
    SetLength(ar, 0);
  end;
end;
//================================= список кодов сотрудников из константы-списка
function TDataCache.GetConstEmpls(pc: Integer): Tai; // must Free
var emplID, i, iCount: Integer;
    s: string;
    ars: Tas;
begin
  SetLength(Result, 0);
  if not Assigned(self) or not ConstExists(pc) then Exit;
  s:= GetConstItem(pc).StrValue;
  if (s='') then Exit;
  ars:= fnSplitString(s, ',');
  SetLength(Result, Length(ars));
  iCount:= 0;
  try
    for i:= 0 to High(ars) do if ars[i]<>'' then try
      emplID:= StrToIntDef(ars[i], 0);
      if fnInIntArray(emplID, Result)>-1 then Continue; // проверяем на дубляж
      if (emplID>0) then begin // если emplID>0 - проверяем сотрудника
        if not EmplExist(emplID) then TestEmpls(emplID);
        if not EmplExist(emplID) then Continue;
      end;
      Result[iCount]:= emplID;
      inc(iCount);
    except
      on E: Exception do prMessageLOGS('Cache.GetConstEmpls: '+E.Message);
    end;
    if Length(Result)>iCount then SetLength(Result, iCount);
  finally
    SetLength(ars, 0);
  end;
end;
//=================================================== список адресов сотрудников
function TDataCache.GetEmplEmails(empls: Tai; pFirm: Integer=0; pWare: Integer=0;
                    pSys: Integer=0; pRegion: Integer=0): String;
const nmProc = 'GetEmplEmails';
var s: string;
begin
  Result:= GetEmplEmails(empls, s, pFirm, pWare, pSys, pRegion);
  s:= '';
end;
//=================================================== список адресов сотрудников
function TDataCache.GetEmplEmails(empls: Tai; var mess: String; pFirm: Integer=0;
                    pWare: Integer=0; pSys: Integer=0; pRegion: Integer=0): String;
// в mess возвращает сообщения о ненайденных адресах
const nmProc = 'GetEmplEmails';
var emplID, i, j, jj: Integer;
    ar, arCodes, arFirmCodes, arFil: Tai;
    Firm: TFirmInfo;
    Empl: TEmplInfoItem;
    facc: TFiscalCenter;
  //----------------------------------- ищем фирму
  function _FindFirm: Boolean;
  begin
    Result:= Assigned(Firm);
    if Result then exit;     // уже нашли раньше
    Result:= (pFirm>0) and FirmExist(pFirm);
    if Result then Firm:= arFirmInfo[pFirm]
    else mess:= mess+fnIfStr(mess='', '', #13#10)+
      MessText(mtkNotFirmExists, IntToStr(pFirm));
  end;
  //----------------------------------- ищем сотрудника
  function _FindEmpl: Boolean;
  begin
    Result:= False;
    if (emplID<1) then exit;
    if not EmplExist(emplID) then TestEmpls(emplID);
    Result:= EmplExist(emplID);
    if Result then Empl:= Cache.arEmplInfo[emplID]
    else mess:= mess+fnIfStr(mess='', '', #13#10)+
      MessText(mtkNotEmplExist, IntToStr(emplID));
  end;
  //----------------------------------- добавляем адрес в Result
  procedure _AddEmplMail;
  begin
    if (fnInIntArray(Empl.ID, arCodes)>-1) then exit; // проверяем на дубляж
    prAddItemToIntArray(Empl.ID, arCodes); // добавить код в массив, если его там нет
    if Empl.Mail='' then
      mess:= mess+fnIfStr(mess='', '', #13#10)+MessText(mtkNotFoundEmplMail, Empl.EmplShortName)
    else Result:= Result+fnIfStr(Result='', '', ',')+Empl.Mail;
  end;
  //-----------------------------------
begin
  Result:= '';
  mess:= '';
  if not Assigned(self) or (Length(empls)<1) then Exit;
  SetLength(ar, 0);
  SetLength(arCodes, 0); // сюда собираем коды для проверки дубляжа
  SetLength(arFirmCodes, 0);     // список систем/менеджеров фирмы
  SetLength(arFil, 0);
  Firm:= nil;
  try
    for i:= 0 to High(empls) do if (empls[i]<>0) then
      prAddItemToIntArray(empls[i], ar); // добавить код в массив, если его там нет

    for i:= 0 to High(ar) do try
      if (ar[i]=0) then Continue;
//--------------------------------------------------- обычные сотрудники (код>0)
      if (ar[i]>0) then begin
        emplID:= ar[i];
        if _FindEmpl then _AddEmplMail;
        Continue;
      end;
//------------------------------------------ "типизированные" сотрудники (код<0)
      case ar[i] of
      ceWareProduct: //--------------------------------- Продукт-менеджер товара
        if (pWare>0) and WareExist(pWare) then begin
          emplID:= GetWare(pWare).ManagerID;
          if _FindEmpl then _AddEmplMail;
        end;

      ceSysSaleDirector:       //------- Директор по продажам бизнес-направления
        if CheckTypeSys(pSys) then begin
          if (pSys=constIsMoto) then
            j:= pcEmplSaleDirectorMoto
          else j:= pcEmplSaleDirectorAuto;
          EmplID:= GetConstItem(j).IntValue;
          if _FindEmpl then _AddEmplMail;
        end else begin
          if not _FindFirm then Continue;
//          if (Firm.FirmSysTypes.IndexOf(constIsAuto)>-1) then begin
            EmplID:= GetConstItem(pcEmplSaleDirectorAuto).IntValue;
            if _FindEmpl then _AddEmplMail; // 'dmitriy.voloshin@vladislav.ua';
//          end;
//          if (Firm.FirmSysTypes.IndexOf(constIsMoto)>-1) then begin
            EmplID:= GetConstItem(pcEmplSaleDirectorMoto).IntValue;
            if _FindEmpl then _AddEmplMail; // 'valeriy.nestjurin@motogorodok.com';
//          end;
        end;

      ceSysResponsible:       //--------------- Ответственный бизнес-направления
        if CheckTypeSys(pSys) then begin
          EmplID:= GetSysTypeEmpl(pSys);
          if _FindEmpl then _AddEmplMail;
        end else begin
          if not _FindFirm then Continue;
//          for j:= 0 to Firm.FirmSysTypes.Count-1 do begin // список систем фирмы
//            EmplID:= GetSysTypeEmpl(Firm.FirmSysTypes[j]);
//            if _FindEmpl then _AddEmplMail;
//          end;
          EmplID:= GetSysTypeEmpl(constIsAuto);
          if _FindEmpl then _AddEmplMail;
          EmplID:= GetSysTypeEmpl(constIsMoto);
          if _FindEmpl then _AddEmplMail;
        end;

      ceFirmManager:       //------------------------------ Менеджер контрагента
        if _FindFirm then for j:= 0 to Firm.FirmManagers.Count-1 do begin
          EmplID:= Firm.FirmManagers[j];
          if _FindEmpl then _AddEmplMail;
        end;

      ceFilialROP: begin //-------------------------------- РОП филиала (округа)
{
          SetLength(arFil, 0); // коды филиалов
          if (pRegion>0) then prAddItemToIntArray(pRegion, arFil)
          else begin // если не задан филиал - ищем по менеджерам
            if not _FindFirm then Continue;
            for j:= 0 to Firm.FirmManagers.Count-1 do begin // коды менеджеров фирмы
              EmplID:= Firm.FirmManagers[j];
              if not _FindEmpl then Continue;
              if Empl.UserRoleExists(rolSuperRegional) then _AddEmplMail // менеджер - РОП
              else prAddItemToIntArray(Empl.EmplDprtID, arFil); // филиал менеджера
            end;
          end;
                      // коды РОП-ов, в arFil>0 - филиалы с ненайденными РОП-ами
          arFirmCodes:= GetFilialROPcodes(arFil);
          for j:= 0 to High(arFirmCodes) do begin
            emplID:= arFirmCodes[j];
            if _FindEmpl then _AddEmplMail;
          end;
          for j:= 0 to High(arFil) do begin
            pRegion:= arFil[j];
            if not DprtExist(pRegion) then Continue;
            mess:= mess+fnIfStr(mess='', '', #13#10)+
              'Не найден РОП филиала '+arDprtInfo[pRegion].Name;
          end;
}
          SetLength(arFil, 0); // коды ЦФУ РОП-ов
          if (pRegion>0) then begin
            if (pRegion>High(Cache.arRegionROPFacc)) then j:= 0
            else j:= Cache.arRegionROPFacc[pRegion];
            if (j>0) then prAddItemToIntArray(j, arFil);
          end else begin // если не задан округ - ищем по контрактам
            if not _FindFirm then Continue;
            SetLength(arFirmCodes, 0); // коды ЦФУ
            for j:= 0 to Firm.FirmContracts.Count-1 do begin // коды контрактов фирмы
              jj:= Firm.FirmContracts[j];
              if not Cache.Contracts.ItemExists(jj) then Continue;
              pRegion:= Cache.Contracts[jj].FacCenter;
              if (pRegion<1) then Continue;
              prAddItemToIntArray(pRegion, arFirmCodes); //  собираем коды ЦФУ
            end;
            for j:= 0 to High(arFirmCodes) do begin
              jj:= arFirmCodes[j]; // код ЦФУ
              if not Cache.FiscalCenters.ItemExists(jj) then Continue;
              facc:= Cache.FiscalCenters[jj];
              pRegion:= facc.ROPfacc;         // собираем коды ЦФУ РОП-ов
              if (pRegion>0) then prAddItemToIntArray(pRegion, arFil)
              else if facc.IsAutoSale then
                mess:= mess+fnIfStr(mess='', '', #13#10)+'Не найден ЦФУ РОП для ЦФУ '+facc.Name;
            end;
          end;

          for j:= 0 to High(arFil) do begin
            jj:= arFil[j];
            if not Cache.FiscalCenters.ItemExists(jj) then Continue;
            facc:= Cache.FiscalCenters[jj];
            if (facc.BKEempls.Count<1) then
              mess:= mess+fnIfStr(mess='', '', #13#10)+'Не найден сотрудник для ЦФУ '+facc.Name
            else for jj:= 0 to facc.BKEempls.Count-1 do begin
              EmplID:= facc.BKEempls[jj];
              if _FindEmpl then _AddEmplMail;
            end;
          end;
        end;

//      ceUIKdepartment: begin //--------------------------------------- Отдел УИК
//        end;
      end; // case
    except
      on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
    end;
  finally
    SetLength(ar, 0);
    SetLength(arCodes, 0);
    SetLength(arFirmCodes, 0);
    SetLength(arFil, 0);
  end;
end;
{//========================================================= коды РОП-ов филиалов
function TDataCache.GetFilialROPcodes(var filials: Tai): Tai;
// возвращает найденные коды РОП-ов, в filials филиалы с найденными РОП-ами обнуляем
const nmProc = 'GetFilialROPcodes';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    i, j: integer;
begin
  SetLength(Result, 0);
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  ORD_IBD:= nil;
  try try
   ORD_IBD:= cntsOrd.GetFreeCnt;
   ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
    ORD_IBS.SQL.Text:= 'select EMPLCODE, EMPLDPRTCODE from EMPLOYEES'+ //
      ' left join EMPLOYEESROLES on EMRLEMPLCODE=EMPLCODE'+
      ' where EMPLDPRTCODE in ('+fnArrOfIntToString(filials)+')'+
      ' and EMRLROLECODE='+IntToStr(rolSuperRegional)+' group by EMPLCODE, EMPLDPRTCODE';
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      i:= ORD_IBS.Fields[0].AsInteger;
      if not EmplExist(i) then TestEmpls(i);
      if EmplExist(i) and not arEmplInfo[i].Arhived then begin
        prAddItemToIntArray(i, Result);
        j:= fnInIntArray(ORD_IBS.Fields[1].AsInteger, filials);
        if (j>-1) then filials[j]:= 0; // обнуляем филиалы с найденными РОП-ами
     end;
      ORD_IBS.Next;
    end;
  finally
    prFreeIBSQL(ORD_IBS);
    cntsOrd.SetFreeCnt(ORD_IBD);
  end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end; }
//======================================================
function TDataCache.GetConstItem(csID: Integer): TConstItem;
begin
  if not Assigned(self) or not ConstExists(csID) then Result:= FParConstants[0]
  else Result:= FParConstants[csID];
end;
//===================================================== новое значение константы
function TDataCache.SaveNewConstValue(csID, pUserID: Integer; pValue: String): String;
const nmProc = 'SaveNewConstValue';
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    pLastTime: TDateTime;
    ConstItem: TConstItem;
    iValue, i: Integer;
    list: TStringList;
begin
  Result:= '';
  pLastTime:= Now;
  iValue:= 0;
  ORD_IBS:= nil;
  try
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrEditRecord));
    if not ConstExists(csID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - constID='+IntToStr(csID));

    ConstItem:= FParConstants[csID];
    pValue:= trim(pValue);
    if ConstItem.StrValue=pValue then Exit; // значение не изменилось

    if ConstItem.NotEmpty and (pValue='') then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - значение не может быть пустым');

    try //------------------------------------------- проверяем значение по типу
      case ConstItem.ItemType of
      constInteger: iValue:= StrToInt(pValue);
      constDouble: begin
          pValue:= StrWithFloatDec(pValue); // проверяем DecimalSeparator
          StrToFloat(pValue);
        end;
      constDateTime: begin
          if ConstItem.Precision=0 then System.SysUtils.StrToDate(pValue)
          else System.SysUtils.StrToDateTime(pValue);
        end;
      end; // case
    except
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - значение='+pValue);
    end;

    if (pValue<>'') then case ConstItem.ID of //--- проверяем значение по смыслу
    pcUIKdepartmentMail, pcCheckDocMail: begin                  // адреса
        list:= fnSplit(',', pValue);
        try
          for i:= 0 to list.Count-1 do if not fnCheckEmail(list[i]) then
            raise EBOBError.Create(MessText(mtkNotValidParam)+' - значение='+list[i]);
        finally prFree(list); end;
      end;

    pcTestingSending1, pcTestingSending2, pcTestingSending3, // список кодов сотрудников
      pcEmpl_list_TmpBlock, pcEmpl_list_FinalBlock, pcEmpl_list_UnBlock,
      pcBlockMonitoringEmpl, pcErrMessMonitoringEmpl, pcEmplID_list_Rep30: begin
        list:= fnSplit(',', pValue);
        try
          for i:= 0 to list.Count-1 do begin
            iValue:= StrToIntDef(list[i], 0);
            if (iValue=0) or ((iValue>0) and not EmplExist(iValue)) or
              ((iValue<0) and ((iValue<Low(ceNames)) or (iValue>High(ceNames)))) then
              raise EBOBError.Create(MessText(mtkNotEmplExist, pValue));
          end;
        finally prFree(list); end;
      end;

    pcEmplSaleDirectorAuto, pcEmplSaleDirectorMoto, pcEmplORDERAUTO: // код сотрудника
      if not EmplExist(iValue) then
        raise EBOBError.Create(MessText(mtkNotEmplExist, pValue));
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt; //------------------------------- пишем в базу
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      ORD_IBS.SQL.Text:= 'update SERVERPARAMCONSTANTS set SPCVALUE=:SPCVALUE, SPCUSERID='+
        IntToStr(pUserID)+' where SPCCODE='+IntToStr(csID)+' returning SPCTIME';
      if ConstItem.ItemType=constDouble then
        ORD_IBS.ParamByName('SPCVALUE').AsString:= fnSetDecSep(pValue, ConstItem.Precision) // для записи в базу '.'
      else ORD_IBS.ParamByName('SPCVALUE').AsString:= pValue;
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Bof and ORD_IBS.Eof) then raise Exception.Create('empty LastTime');
      pLastTime:= ORD_IBS.fieldByName('SPCTIME').AsDateTime;
      ORD_IBS.Transaction.Commit;
      ORD_IBS.Close;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    
    ConstItem.StrValue:= pValue; //--------------------------------- пишем в кеш
    ConstItem.LastUser:= pUserID;
    ConstItem.LastTime:= pLastTime;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//============================================ проверить связь роли с константой
function TDataCache.CheckRoleConstLink(csID, roleID, UserID: Integer; flWrite: Boolean; var ResCode: Integer): String;
const nmProc = 'CheckRoleConstLink';
// вид операции - ResCode - на входе (resAdded, resEdited, resDeleted)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось,
//                    resAdded - добавлено, resEdited - изменено, resDeleted - удалено
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    ConstItem: TConstItem;
    EmplRole: TEmplRole;
    OpCode, iw: Integer;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  ORD_IBS:= nil;
  try
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrProcess));
    if not (OpCode in [resAdded, resEdited, resDeleted]) then       // проверяем код операции
      raise Exception.Create(MessText(mtkNotValidParam)+' операции');
    if not ConstExists(csID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' конст., код='+IntToStr(csID));
    if not RoleExists(roleID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' роли, код='+IntToStr(roleID));

    ConstItem:= FParConstants[csID];
    EmplRole:= FEmplRoles[roleID];
    iw:= fnIfInt(flWrite, 1, 0); // SrcID=1 - признак разрешения записи

    case OpCode of // проверяем связку
    resAdded: if EmplRole.ConstLinks.LinkExists(csID) then begin
        ResCode:= resDoNothing;
        if not ConstItem.Links.LinkExists(roleID) then  // на всяк.случай
          ConstItem.Links.CheckLink(roleID, iw, EmplRole);
        raise Exception.Create('Такая связка уже есть');
      end;
    resEdited: begin
        if not EmplRole.ConstLinks.LinkExists(csID) then
          raise Exception.Create(MessText(mtkNotFoundRecord));
        if (GetLinkSrc(EmplRole.ConstLinks[csID])=iw) then begin
          ResCode:= resDoNothing;
          if (GetLinkSrc(ConstItem.Links[roleID])<>iw) then // на всяк.случай
            TLink(ConstItem.Links[roleID]).SrcID:= iw;
          raise Exception.Create(MessText(mtkNotChanges));
        end;
      end;
    resDeleted: if not EmplRole.ConstLinks.LinkExists(csID) and
      not ConstItem.Links.LinkExists(roleID) then begin
        ResCode:= resDoNothing;
        raise Exception.Create(MessText(mtkNotFoundRecord));
      end;
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt;                             // пишем в базу
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      case OpCode of
      resAdded  : begin
          ORD_IBS.SQL.Text:= 'insert into LINKSERVPARCONSTROLE'+
            ' (SPCRSPCCODE, SPCRROLECODE, SPCRUSERID, SPCRWRITE) values ('+
            IntToStr(csID)+', '+IntToStr(roleID)+', '+IntToStr(UserID)+', "'+
            fnIfStr(flWrite, 'T', 'F')+'") returning SPCRCODE';
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Bof and ORD_IBS.Eof) or (ORD_IBS.Fields[0].AsInteger<1) then
            raise Exception.Create('empty SPCRCODE');
        end;
      resEdited : begin
          ORD_IBS.SQL.Text:= 'update LINKSERVPARCONSTROLE set SPCRWRITE="'+
            fnIfStr(flWrite, 'T', 'F')+'", SPCRUSERID='+IntToStr(UserID)+
            ' where SPCRSPCCODE='+IntToStr(csID)+' and SPCRROLECODE='+IntToStr(roleID);
          ORD_IBS.ExecQuery;
        end;
      resDeleted: begin
          ORD_IBS.SQL.Text:= 'delete from LINKSERVPARCONSTROLE'+
            ' where SPCRSPCCODE='+IntToStr(csID)+' and SPCRROLECODE='+IntToStr(roleID);
          ORD_IBS.ExecQuery;
        end;
      end; // case
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;

    Result:= 'связка роли с параметром';
    case OpCode of
    resAdded  : begin
        ConstItem.Links.CheckLink(roleID, iw, EmplRole);
        EmplRole.ConstLinks.CheckLink(csID, iw, ConstItem);
        Result:= Result+' добавлена';
      end;
    resEdited : begin
        TLink(ConstItem.Links[roleID]).SrcID:= iw;
        TLink(EmplRole.ConstLinks[csID]).SrcID:= iw;
        Result:= Result+' изменена';
      end;
    resDeleted: begin
        ConstItem.Links.DeleteLinkItem(roleID);
        EmplRole.ConstLinks.DeleteLinkItem(csID);
        Result:= Result+' удалена';
      end;
    end;  // case
    ResCode:= OpCode;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
{//============================================ проверить связь роли с импортом
function TDataCache.CheckRoleImportLink(impID, roleID, UserID: Integer; flWrite: Boolean; var ResCode: Integer): String;
const nmProc = 'CheckRoleImportLink';
// вид операции - ResCode - на входе (resAdded, resEdited, resDeleted)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось,
//                    resAdded - добавлено, resEdited - изменено, resDeleted - удалено
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    ImpItem: TImportType;
    EmplRole: TEmplRole;
    OpCode, iw: Integer;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  ORD_IBS:= nil;
  try
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrProcess));
    if not (OpCode in [resAdded, resEdited, resDeleted]) then       // проверяем код операции
      raise Exception.Create(MessText(mtkNotValidParam)+' операции');
    if not ImpTypeExists(impID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' импорта, код='+IntToStr(impID));
    if not RoleExists(roleID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' роли, код='+IntToStr(roleID));

    ImpItem:= FImportTypes[impID];
    EmplRole:= FEmplRoles[roleID];
    iw:= fnIfInt(flWrite, 1, 0); // SrcID=1 - признак разрешения записи

    case OpCode of // проверяем связку
    resAdded: if EmplRole.ImpLinks.LinkExists(impID) then begin
        ResCode:= resDoNothing;
        if not ImpItem.RoleLinks.LinkExists(roleID) then  // на всяк.случай
          ImpItem.RoleLinks.CheckLink(roleID, iw, EmplRole);
        raise Exception.Create('Такая связка уже есть');
      end;

    resEdited: begin
        if not EmplRole.ImpLinks.LinkExists(impID) then
          raise Exception.Create(MessText(mtkNotFoundRecord));
        if (GetLinkSrc(EmplRole.ImpLinks[impID])=iw) then begin
          ResCode:= resDoNothing;
          if (GetLinkSrc(ImpItem.RoleLinks[roleID])<>iw) then // на всяк.случай
            TLink(ImpItem.RoleLinks[roleID]).SrcID:= iw;
          raise Exception.Create(MessText(mtkNotChanges));
        end;
      end;

    resDeleted: if not EmplRole.ImpLinks.LinkExists(impID) and
      not ImpItem.RoleLinks.LinkExists(roleID) then begin
        ResCode:= resDoNothing;
        raise Exception.Create(MessText(mtkNotFoundRecord));
      end;
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt;                             // пишем в базу
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      case OpCode of
      resAdded  : begin
          ORD_IBS.SQL.Text:= 'insert into LINKIMPTYPEROLE'+
            ' (LITRIMTPCODE, LITRROLECODE, LITRUSERID, LITRWRITE) values ('+
            IntToStr(impID)+', '+IntToStr(roleID)+', '+IntToStr(UserID)+', "'+
            fnIfStr(flWrite, 'T', 'F')+'") returning LITRCODE';
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Bof and ORD_IBS.Eof) or (ORD_IBS.Fields[0].AsInteger<1) then
            raise Exception.Create('empty LITRCODE');
        end;
      resEdited : begin
          ORD_IBS.SQL.Text:= 'update LINKIMPTYPEROLE set LITRWRITE="'+
            fnIfStr(flWrite, 'T', 'F')+'", LITRUSERID='+IntToStr(UserID)+
            ' where LITRIMTPCODE='+IntToStr(impID)+' and LITRROLECODE='+IntToStr(roleID);
          ORD_IBS.ExecQuery;
        end;
      resDeleted: begin
          ORD_IBS.SQL.Text:= 'delete from LINKIMPTYPEROLE'+
            ' where LITRIMTPCODE='+IntToStr(impID)+' and LITRROLECODE='+IntToStr(roleID);
          ORD_IBS.ExecQuery;
        end;
      end; // case
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;

    Result:= 'связка роли с импортом';
    case OpCode of
    resAdded: begin
        ImpItem.RoleLinks.CheckLink(roleID, iw, EmplRole);
        EmplRole.ImpLinks.CheckLink(impID, iw, ImpItem);
        Result:= Result+' добавлена';
      end;
    resEdited: begin
        TLink(ImpItem.RoleLinks[roleID]).SrcID:= iw;
        TLink(EmplRole.ImpLinks[impID]).SrcID:= iw;
        Result:= Result+' изменена';
      end;
    resDeleted: begin
        ImpItem.RoleLinks.DeleteLinkItem(roleID);
        EmplRole.ImpLinks.DeleteLinkItem(impID);
        Result:= Result+' удалена';
      end;
    end;  // case
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;   }
//=================================== проверка доступности удаления по источнику
function TDataCache.CheckLinkAllowDelete(srcID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not Assigned(FDCA)
    or not FDCA.LinkSources.ItemExists(srcID) then Exit;
  Result:= TSubDirItem(FDCA.LinkSources[srcID]).OrderNum=0;
end;
//==================== проверка доступности пометки неверной связки по источнику
function TDataCache.CheckLinkAllowWrong(srcID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) or not Assigned(FDCA)
    or not FDCA.LinkSources.ItemExists(srcID) then Exit;
  Result:= TSubDirItem(FDCA.LinkSources[srcID]).OrderNum=1;
end;
//================= заполнение/проверка линков групп/подгрупп с шаблонами скидок
procedure TDataCache.TestGrPgrDiscModelLinks;
// flFill=True - заполнение
const nmProc = 'TestGrPgrDiscModelLinks'; // имя процедуры/функции
var gID, dmID: Integer;
    flNew: boolean;
    disg: Double;
    ibd: TIBDatabase;
    ibs: TIBSQL;
    link: TQtyLink;
    gr: TWareInfo;
    dm: TDiscModel;
//    LocalStart: TDateTime;
begin
//  LocalStart:= now();
  if not Assigned(self) then Exit;
  ibd:= nil;
  ibs:= nil;
  try try
    ibd:= cntsGRB.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
    ibs.SQL.Text:= 'select rProdDirect, rDiscModel, rWareCode, rDiscValue'+
      ' from Vlad_CSS_GetPrDirDiscModParams order by rWareCode';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      gID:= ibs.fieldByName('rWareCode').AsInteger;
      if not GrPgrExists(gID) then begin
        while not ibs.Eof and (gID=ibs.fieldByName('rWareCode').AsInteger) do ibs.Next;
        Continue;
      end;

      gr:= arWareInfo[gID];
      flNew:= (gr.DiscModLinks.Count<1);
      if not flNew then gr.DiscModLinks.SetLinkStates(False, gr.CS_wlinks);

      while not ibs.Eof and (gID=ibs.fieldByName('rWareCode').AsInteger) do begin
        dmID:= ibs.fieldByName('rDiscModel').AsInteger;
        disg:= RoundTo(ibs.fieldByName('rDiscValue').AsFloat, -2);
//        pd:= DiscountModels.GetDirectIndex(ibs.fieldByName('rProdDirect').AsInteger);
        dm:= Cache.DiscountModels[dmID]; // шаблон
        if flNew then link:= nil
        else link:= gr.DiscModLinks.GetLinkListItemByID(dmID, lkLnkByID);

        if Assigned(link) then try // если линк есть - проверяем
          gr.CS_wlinks.Enter;
          if fnNotZero(disg-Link.Qty) then Link.Qty:= disg;
//          if (Link.SrcID<>dm.DirectInd) then Link.SrcID:= dm.DirectInd;  // ???
          if (Link.LinkPtr<>dm) then Link.LinkPtr:= dm;
          Link.State:= True; // флаг проверки
        finally
          gr.CS_wlinks.Leave;

        end else begin // создаем новый линк
          link:= TQtyLink.Create(0, disg, dm);
          gr.DiscModLinks.AddLinkListItem(link, lkLnkByID, gr.CS_wlinks);
        end;

        cntsGRB.TestSuspendException;
        ibs.Next;
      end; // while not ibs.Eof and (gID=
      if not flNew then gr.DiscModLinks.DelNotTestedLinks(gr.CS_wlinks); // удаляет все связки с State = False
    end; // while not ibs.Eof

  finally
    prFreeIBSQL(ibs);
    cntsGRB.SetFreeCnt(ibd, True);
  end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
//  if flDebug then prMessageLOGS(nmProc+': '+GetLogTimeStr(LocalStart), fLogCache, false);
end;

//=========================================================== проверка кэша фирм
procedure TDataCache.TestFirms(pID: Integer; FillNew: boolean=False;
           CompareTime: boolean=True; Partially: boolean=False; RegID: Integer=0);
// CompareTime=True - проверять время последнего обновления, False - не проверять (ID>0)
// ID=-1 - по alter-таблицам, ID=0 - полная, ID>0 - по 1 фирме
// FillNew=True - заполнение новых, FillNew=False - проверка существующих
// Partially=True - частичная проверка(WebArm), Partially=False - полная проверка
// RegID>0 - проверка фирм регионала
const nmProc = 'TestFirms'; // имя процедуры/функции
var FirmCode, sSqlOrd, sSqlGb, s: string;
    FirmID, iCount, motoCount, i, ii: Integer;
    ibsGB, ibs, ibsOrd, ibs1: TIBSQL;
    LocalStart: TDateTime;
    ibdGB, ibdOrd: TIBDatabase;
    flnew, PrevPartFilled: boolean;
    Contract: TContract;
    dest: TDestPoint;
//    flex: boolean;
//----------------------------------- заполнение/проверка списка контрактов фирм
  procedure TestContDestPoints;
  var destID, i: Integer;
      fl: boolean;
  begin
    try
      fl:= (Contract.ContDestPoints.Count>0);
      if fl then for i:= 0 to Contract.ContDestPoints.Count-1 do
        TDestPoint(Contract.ContDestPoints[i]).State:= False;
      try
        ibs1.Close;
        if (ibs1.SQL.Text='') then
          ibs1.SQL.Text:= 'select RDestID, rDestName, rDestAdr'+
                          ' from Vlad_CSS_GetContDestPoints(:ContID, 1)';
        ibs1.ParamByName('ContID').AsInteger:= Contract.ID;
        ibs1.ExecQuery;
        while not ibs1.Eof do begin
          destID:= ibs1.FieldByName('RDestID').AsInteger;
          dest:= Contract.GetContDestPoint(destID);
          if Assigned(dest) then begin
            dest.Name:= ibs1.FieldByName('rDestName').AsString;
            s:= ibs1.FieldByName('rDestAdr').AsString;
            if (dest.Adress<>s) then dest.Adress:= s;
            dest.State:= True;
          end else begin
            dest:= TDestPoint.Create(destID, ibs1.FieldByName('rDestName').AsString,
                                     ibs1.FieldByName('rDestAdr').AsString);
            Contract.ContDestPoints.Add(dest);
          end;
          cntsGRB.TestSuspendException;
          ibs1.Next;
        end;
      finally
        ibs1.Close;
      end;

      if fl then for i:= Contract.ContDestPoints.Count-1 downto 0 do
        if not TDestPoint(Contract.ContDestPoints[i]).State then begin
          dest:= TDestPoint(Contract.ContDestPoints[i]);
          Contract.ContDestPoints.Delete(i); // удаляем непроверенные
          prFree(dest);
        end;
    except
      on E: Exception do prMessageLOGS('TestContDestPoints_'+IntToStr(Contract.ID)+': '+E.Message);
    end;
  end;
//----------------------------------- заполнение/проверка списка контрактов фирм
  procedure TestFirmContracts(ppID: Integer=0; pRegID: Integer=0); // ppID=0 - все существующие
  var fcode, ss, s1, s2, s3, s: string;
      i, fid, cc, sys: Integer;
      ff, flAll, fl, flEnt: boolean;
      arFC, arFM, arFS: Tai;
      Item: Pointer;
      firma: TFirmInfo;
  begin
    if not Assigned(self) or (ppID<0) or ((ppID>0) and not FirmExist(ppID)) then Exit;
    try
      flAll:= (ppID=0);
      flEnt:= TestRDB(cntsGRB, trkField, 'CONTRACT', 'ContSecondFirmLegalEntity');

      s1:= 'select CONTCODE, CONTSECONDPARTY, CONTSUMM, CONTUSEBYDEFAULT, CONTPAYTYPE,'+
           fnIfStr(flEnt, ' ContSecondFirmLegalEntity,', '')+
           ' iif(("TODAY"<=CONTENDINGDATE) and (CONTSTATE=2), 0, 1) as Disable,'+ // Состояние - "действует"
           ' CONTCRNCCODE, CONTNUMBER||"-"||RIGHT(cast(EXTRACT(YEAR FROM CONTBEGININGDATE)'+
           ' as varchar(4)), 2) CONTNUMBER, ContEmptyInvoice, ContPriceType,'+  //  ContBusinessTypeCode,
           ' CONTDUTYCRNCCODE, CONTSECONDEMAIL, FirmEmail, g.rEmplCode, g.rFaccCode'#10;
      if not Partially then  // полная проверка - фин.инфо
        s1:= s1+', g.rContCreditCrnc, g.rContCreditSumm, g.rDebtSum,'+
                ' g.rContDelay, g.rWhenBlocked, g.rWarnMessage,'+
                ' g.rOrderSum, g.rPlanOutSum, g.rSaleBlocked'#10;
      s1:= s1+' from CONTRACT left join firms on firmcode=CONTSECONDPARTY'#10+
              ' left join Vlad_CSS_GetFirmContOptions(CONTSECONDPARTY, CONTCODE, '+
              IntToStr(constDaysForBlockWarninig)+', '+fnIfStr(Partially, '0', '1')+') g on 1=1'#10;
      s2:= ' and FIRMARCHIVEDKEY="F" and firmchildcount=0 and firmservicefirm="F"';
      s3:= ' CONTBEGININGDATE<="TODAY"'; // тек.дата >= дате заключения контракта
//           ' and CONTBUSINESSTYPECODE in ('+IntToStr(constIsAuto)+', '+IntToStr(constIsMoto)+')' // напр.деят. - "MOTO" или "AUTO"
//           ' and CONTTYPE=9' // Тип - договор купли-продажи
      ibs.Close;
      if ppID>0 then begin // контракты 1 фирмы
        fcode:= IntToStr(ppID);
        ibs.SQL.Text:= s1+' where CONTSECONDPARTY='+fcode+' and '+s3;

      end else if (pRegID>0) then begin // контракты фирм регионала  ???
        ss:= IntToStr(pRegID);
        fcode:= 'RegID='+ss;
        ibs.SQL.Text:= s1+' where '+s3+s2+#10' and ('+
          fnIfStr(flContManagerBKEonly, '', 'g.rEmplCode='+ss+' or ')+
          ' exists(select * from Vlad_CSS_GetFaccBKEempls(g.rFaccCode) b where b.rEmplCode='+ss+'))'+
          ' order by CONTSECONDPARTY';

      end else begin // все
        fcode:= 'all';
        ibs.SQL.Text:= s1+' where '+s3+s2+#10' order by CONTSECONDPARTY';
      end;

      with ibs.Transaction do if not InTransaction then StartTransaction;
      ibs.ExecQuery;
      while not ibs.Eof do begin
        fid:= ibs.FieldByName('CONTSECONDPARTY').AsInteger; // код фирмы
        ff:= FirmExist(fid);
        if not ff then begin
          while not ibs.Eof and (fid=ibs.FieldByName('CONTSECONDPARTY').AsInteger) do ibs.Next;
          Continue;
        end;

        firma:= arFirmInfo[fid];
        setLength(arFC, 0); // коды контрактов фирмы
        setLength(arFS, 0); // коды систем учета фирмы
        setLength(arFM, 0); // коды менеджеров фирмы
        while not ibs.Eof and (fid=ibs.FieldByName('CONTSECONDPARTY').AsInteger) do begin
          cc:= ibs.FieldByName('CONTCODE').AsInteger;
          ss:= ibs.FieldByName('CONTNUMBER').AsString;
//          sys:= ibs.FieldByName('ContBusinessTypeCode').AsInteger;
          sys:= 0;

          fl:= Contracts.ItemExists(cc);
          if not fl then begin // новый контракт
            Item:= TContract.Create(cc, fid, sys, ss);
            Contracts.CheckItem(Item);
          end;
          Contract:= Contracts[cc];
//          with Contract do
          try // заполняем/проверяем параметры контракта
            Contract.CS_cont.Enter;
            if fl then begin  // в существующем проверяем параметры Create
              Contract.ContFirm:= fid;
//              SysID:= sys;
              Contract.Name:= ss;
            end;
            if not Partially then begin // полная проверка - фин.инфо
              Contract.CredDelay   := ibs.FieldByName('rContDelay').AsInteger;
              Contract.CredLimit   := ibs.FieldByName('rContCreditSumm').AsFloat;
              Contract.DebtSum     := ibs.FieldByName('rDebtSum').AsFloat;
              Contract.OrderSum    := ibs.FieldByName('rOrderSum').AsFloat;
              Contract.PlanOutSum  := ibs.FieldByName('rPlanOutSum').AsFloat;
              Contract.WarnMessage := ibs.FieldByName('rWarnMessage').AsString;
              Contract.WhenBlocked := ibs.FieldByName('rWhenBlocked').AsInteger;
              Contract.SaleBlocked := (ibs.FieldByName('rSaleBlocked').AsInteger=1);
              Contract.Disable     := (ibs.FieldByName('Disable').AsInteger=1); // признак недоступного контракта
              if Contract.Disable and not Contract.SaleBlocked then begin
                Contract.SaleBlocked:= True;
                Contract.WarnMessage:= Contract.WarnMessage+
                  fnIfStr(Contract.WarnMessage='', '', ' ')+'Контракт недоступен';
              end;
              i:= ibs.FieldByName('rContCreditCrnc').AsInteger;
              TestContDestPoints;
            end else i:= 0;
            Contract.CredCurrency:= fnIfInt(i<1, cDefCurrency, i);

            i:= ibs.FieldByName('CONTCRNCCODE').AsInteger;
            Contract.ContCurrency:= fnIfInt(i<1, Contract.CredCurrency, i);

            i:= ibs.FieldByName('CONTDUTYCRNCCODE').AsInteger;
            Contract.DutyCurrency:= fnIfInt(i<1, Contract.CredCurrency, i);

            s:= ibs.FieldByName('CONTSECONDEMAIL').AsString;
            if (s='') then s:= ibs.FieldByName('FirmEmail').AsString;
            Contract.ContEmail   := s;
            if flContManagerBKEonly then i:= 0 // только по BKE
            else i:= ibs.FieldByName('rEmplCode').AsInteger;
            if (Contract.FContManager<>i) then Contract.FContManager:= i;
            Contract.PayType     := ibs.FieldByName('CONTPAYTYPE').AsInteger;
            Contract.ContPriceType:= ibs.FieldByName('ContPriceType').AsInteger;
            Contract.FacCenter    := ibs.FieldByName('rFaccCode').AsInteger;
            Contract.ContSumm     := ibs.FieldByName('CONTSUMM').AsFloat;
            Contract.EmptyInvoice := (ibs.FieldByName('ContEmptyInvoice').AsString='T');
            Contract.ContDefault  := (ibs.FieldByName('CONTUSEBYDEFAULT').AsString='T');
            if flEnt then
              Contract.LegalEntity:= ibs.FieldByName('ContSecondFirmLegalEntity').AsInteger;
            Contract.Fictive:= False;
            prAddItemToIntArray(cc, arFC);      // собираем коды контрактов фирмы
//            if (SysID=0) then begin             // собираем коды систем учета фирмы
//              prAddItemToIntArray(constIsAuto, arFS);
//              prAddItemToIntArray(constIsMoto, arFS);
//            end else prAddItemToIntArray(SysID, arFS);
            if not flContManagerBKEonly and (Contract.FContManager>0) then
              prAddItemToIntArray(Contract.FContManager, arFM); // собираем коды менеджеров фирмы
            With Contract.GetContBKEempls do for i:= 0 to Count-1 do
              prAddItemToIntArray(Items[i], arFM); // добавляем коды менеджеров ЦФУ по BKE
          finally
            Contract.CS_cont.Leave;
          end; // with TContract(Cache.Contracts[cc])

          cntsGRB.TestSuspendException;
          ibs.Next;
        end; // while not ibs.Eof and (fid=...

        with firma do begin  // сверяем коды контрактов фирмы
          if flAll then CS_firm.Enter;
          try
            prCheckIntegerListByCodesArray(FirmContracts, arFC); // сверить TIntegerList с массивом кодов
            if (FirmContracts.Count>1) then FirmContracts.Sort;  // ???
            prCheckIntegerListByCodesArray(FirmManagers, arFM);  // сверить TIntegerList с массивом кодов
//            prCheckIntegerListByCodesArray(FirmSysTypes, arFS);  // сверить TIntegerList с массивом кодов
          finally
            if flAll then CS_firm.Leave;
          end;
          LastDebtTime:= Now;
        end; // with arFirmInfo[fid]
        setLength(arFC, 0);
        setLength(arFS, 0);
        setLength(arFM, 0);
      end; // while not ibsGB.Eof
    except
      on E: Exception do prMessageLOGS('TestFirmContracts_'+fcode+': '+E.Message, fLogCache);
    end;
    setLength(arFC, 0);
    setLength(arFM, 0);
    setLength(arFS, 0);
    ibs.Close;
  end;
//------------------------------------ заполнение/проверка списка категорий фирм
  procedure TestFirmClasses(ppID: Integer=0; pRegID: Integer=0); // ppID=0 - все существующие
  var fcode, ss, s, sSQLreg: string;
      i, j, fid: Integer;
      ff, flReg, flAll, ff1: boolean;
      ar, ar1: Tai;
      firma: TFirmInfo;
      tt: TTwoCodes;
      sums: TDoubleDynArray;
      le: TBaseDirItem;
    //----------------------------
    procedure SetLengthArrs(len: Integer);
    begin
      setLength(ar, len);
      setLength(ar1, len);
      setLength(sums, len);
    end;
    //----------------------------
  begin
    if not Assigned(self) or (ppID<0) or ((ppID>0) and not FirmExist(ppID)) then Exit;
    firma:= nil;
    tt:= nil;
    try
      flAll:= (ppID=0);
      if pID>0 then begin // 1 фирма
        fcode:= IntToStr(ppID);
        ibsGB.SQL.Text:= 'select FRGRFIRMCODE, FRGRCLASSCODE from FIRMGROUP'+
          ' where FRGRFIRMCODE='+fcode+' and FRGRFIRMARCHIVE="F"';

      end else if (pRegID>0) then begin // фирмы регионала
        ss:= IntToStr(pRegID);
        fcode:= 'RegID='+ss;
//        s:= IntToStr(constIsAuto)+','+IntToStr(constIsMoto);
        sSQLreg:= ' from (select c.CONTSECONDPARTY Firm from CONTRACT c'#10+
          ' inner join firms on FirmCode=c.CONTSECONDPARTY and '#10+
          '   firmchildcount=0 and firmarchivedkey="F" and firmservicefirm="F"'+
          ' left join Vlad_CSS_GetFirmContOptions(c.CONTSECONDPARTY, c.CONTCODE, 1, 0) m on 1=1'#10+
          ' where ("TODAY">=c.contbeginingdate) and ('+ //  and c.CONTBUSINESSTYPECODE in ('+s+')
          fnIfStr(flContManagerBKEonly, '', 'm.rEmplCode='+ss+' or ')+' exists(select * from'+
          ' Vlad_CSS_GetFaccBKEempls(m.rFaccCode) b where b.rEmplCode='+ss+')) group by Firm) f ';

        ibsGB.SQL.Text:= 'select FRGRFIRMCODE, FRGRCLASSCODE '#10+sSQLreg+
          ' inner join FIRMGROUP on FRGRFIRMCODE=f.Firm and FRGRFIRMARCHIVE="F"';

      end else begin // все
        fcode:= 'all';
        ibsGB.SQL.Text:= 'select FRGRFIRMCODE, FRGRCLASSCODE from FIRMGROUP'+
          ' where FRGRFIRMARCHIVE="F" order by FRGRFIRMCODE';
      end;
      try
        ibsGB.ExecQuery;
        while not ibsGB.Eof do begin
          fid:= ibsGB.FieldByName('FRGRFIRMCODE').AsInteger;
          ff:= FirmExist(fid);
          if ff then firma:= arFirmInfo[fid];
          flReg:= ff and ((pRegID<1) or firma.CheckFirmManager(pRegID));
          if not (ff and flReg) then begin
            while not ibsGB.Eof and (fid=ibsGB.FieldByName('FRGRFIRMCODE').AsInteger) do ibsGB.Next;
            Continue;
          end;

          j:= 0; // счетчик категорий фирмы
          setLength(ar, 10);
          while not ibsGB.Eof and (fid=ibsGB.FieldByName('FRGRFIRMCODE').AsInteger) do begin
            if High(ar)<j then setLength(ar, j+10);
            ar[j]:= ibsGB.FieldByName('FRGRCLASSCODE').AsInteger;
            inc(j);
            cntsGRB.TestSuspendException;
            ibsGB.Next;
          end; // while not ibsGB.Eof and (fid=ibsGB.FieldByName('FRGRFIRMCODE').AsInteger)
          if Length(ar)>j then setLength(ar, j);

          if flAll then firma.CS_firm.Enter;
          try
            for j:= 0 to High(ar) do
              if (firma.FirmClasses.IndexOf(ar[j])<0) then firma.FirmClasses.Add(ar[j]);
            for j:= firma.FirmClasses.Count-1 downto 0 do
              if fnInIntArray(firma.FirmClasses[j], ar)<0 then firma.FirmClasses.Delete(j);
          finally
            if flAll then firma.CS_firm.Leave;
          end;
          setLength(ar, 0);
        end; // while not ibsGB.Eof
      finally
        ibsGB.Close;
      end;
                           //-------------------- VIN запросы, скачивание прайса
      if ppID>0 then begin
        if FirmExist(ppID) then with arFirmInfo[ppID] do begin
          HasVINmail:= CheckFirmVINmail;
          EnablePriceLoad:= CheckFirmPriceLoadEnable;
        end;
      end else for j:= 0 to High(arFirmInfo) do begin
        if not FirmExist(j) then Continue;
        firma:= arFirmInfo[j];
        if ((pRegID>0) and not firma.CheckFirmManager(pRegID)) then Continue;
        with firma do begin
          ff:= CheckFirmVINmail;
          ff1:= CheckFirmPriceLoadEnable;
          if (HasVINmail<>ff) or (EnablePriceLoad<>ff1) then try
            if flAll then CS_firm.Enter;
            if (HasVINmail<>ff) then HasVINmail:= ff;
            if (EnablePriceLoad<>ff1) then EnablePriceLoad:= ff1;
          finally
            if flAll then CS_firm.Leave;
          end;
        end; // with firma
      end;

      //----------------------- текущие шаблоны скидок и обороты по направлениям
      if pID>0 then s:= IntToStr(ppID)+', 0' // 1 фирма
      else if (pRegID>0) then s:= '0, '+IntToStr(pRegID) // фирмы регионала
      else s:= '0, 0'; // все
      ibsGB.SQL.Text:= 'select rFirmCode, rProdDirect, rDiscModel, rSumm'+
        ' from Vlad_CSS_GetFirmsPrDirDiscMods('+s+')';
      try
        ibsGB.ExecQuery;
        while not ibsGB.Eof do begin
          fid:= ibsGB.FieldByName('rFirmCode').AsInteger;
          ff:= FirmExist(fid);
          if ff then firma:= arFirmInfo[fid];
          flReg:= ff and ((pRegID<1) or firma.CheckFirmManager(pRegID));
          if not (ff and flReg) then begin
            while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger) do ibsGB.Next;
            Continue;
          end;
          j:= 0; // счетчик направлений
          SetLengthArrs(10);
          while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger) do begin
            if High(ar)<j then SetLengthArrs(j+10);
            ar[j]:= ibsGB.FieldByName('rProdDirect').AsInteger; // код направления
            ar1[j]:= ibsGB.FieldByName('rDiscModel').AsInteger; // код шаблона
            sums[j]:= ibsGB.FieldByName('rSumm').AsFloat;       // текущий оборот к/а
            inc(j);
            cntsGRB.TestSuspendException;
            ibsGB.Next;
          end; // while not ibsGB.Eof and (fid=ibsGB.FieldByName('FRGRFIRMCODE').AsInteger)
          if Length(ar)>j then setLength(ar, j);

          if flAll then firma.CS_firm.Enter;
          try
            for j:= 0 to High(ar) do begin
              ff:= False;
              for i:= 0 to firma.FirmDiscModels.Count-1 do begin
                tt:= TTwoCodes(firma.FirmDiscModels[i]);
                ff:= (tt.ID1=ar[j]); // проверяем код направления
                if ff then break;
              end;
              if ff then begin
                if (tt.ID2<>ar1[j]) then tt.ID2:= ar1[j];               // проверяем код шаблона
                if not fnNotZero(tt.Qty-sums[j]) then tt.Qty:= sums[j]; // проверяем текущий оборот к/а
              end else firma.FirmDiscModels.Add(TTwoCodes.Create(ar[j], ar1[j], sums[j]));
            end;
            for j:= firma.FirmDiscModels.Count-1 downto 0 do begin
              tt:= TTwoCodes(firma.FirmDiscModels[j]);
              if (fnInIntArray(tt.ID1, ar)<0) then firma.FirmDiscModels.Delete(j);
            end;
          finally
            if flAll then firma.CS_firm.Leave;
          end;
  {          if flDebug then begin
              setLength(ar, FirmDiscModels.Count);
              for j:= 0 to FirmDiscModels.Count-1 do ar[j]:= TTwoCodes(FirmDiscModels[j]).ID1;
              prMessageLOGS('_FirmDiscModels_'+inttostr(fid)+': '+fnArrOfIntToString(ar), fLogDebug, false);
            end;  }
          SetLengthArrs(0);
        end; // while not ibsGB.Eof
      finally
        ibsGB.Close;
      end;

      //---------------------------------- юрид.фирмы к/а, Object - TBaseDirItem
      if not TestRDB(cntsGRB, trkTable, 'LegalEntities') then exit;
      //  LegalEntities:= TObjectList.Create;  //

      if pID>0 then  // 1 фирма
        ibsGB.SQL.Text:= 'select LgEnCode, LgEnFirmCode, LgEnFullName'+
          ' from LegalEntities where LgEnFirmCode='+fcode
      else if (pRegID>0) then  // фирмы регионала
        ibsGB.SQL.Text:= 'select LgEnCode, LgEnFirmCode, LgEnFullName '#10+sSQLreg+
          ' inner join LegalEntities on LgEnFirmCode=f.Firm'
      else  // все
        ibsGB.SQL.Text:= 'select LgEnCode, LgEnFirmCode, LgEnFullName'+
          ' from LegalEntities order by LgEnFirmCode';
      try
        ibsGB.ExecQuery;
        while not ibsGB.Eof do begin
          fid:= ibsGB.FieldByName('LgEnFirmCode').AsInteger;
          ff:= FirmExist(fid);
          if ff then firma:= arFirmInfo[fid];
          flReg:= ff and ((pRegID<1) or firma.CheckFirmManager(pRegID));
          if not (ff and flReg) then begin
            while not ibsGB.Eof and (fid=ibsGB.FieldByName('LgEnFirmCode').AsInteger) do ibsGB.Next;
            Continue;
          end;

          if flAll then firma.CS_firm.Enter;
          try
            for j:= 0 to firma.LegalEntities.Count-1 do begin
              le:= TBaseDirItem(firma.LegalEntities[j]);
              le.State:= False;
            end;

            while not ibsGB.Eof and (fid=ibsGB.FieldByName('LgEnFirmCode').AsInteger) do begin
              i:= ibsGB.FieldByName('LgEnCode').AsInteger;
              s:= ibsGB.FieldByName('LgEnFullName').AsString;
              ff:= False;
              for j:= 0 to firma.LegalEntities.Count-1 do begin
                le:= TBaseDirItem(firma.LegalEntities[j]);
                ff:= (le.ID=i);
                if ff then begin // нашли - проверяем
                  le.Name:= s;
                  le.State:= True;
                  break;
                end;
              end; // for j
              if not ff then begin // не нашли - добавляем
                le:= TBaseDirItem.Create(i, s);
                firma.LegalEntities.Add(le);
              end;
              cntsGRB.TestSuspendException;
              ibsGB.Next;
            end; // while not ibsGB.Eof and (fid=

            for j:= firma.LegalEntities.Count-1 downto 0 do begin
              le:= TBaseDirItem(firma.LegalEntities[j]);
              if not le.State then begin
                firma.LegalEntities.Delete(j);
                prFree(le);
              end;
            end;
          finally
            if flAll then firma.CS_firm.Leave;
          end;
        end; // while not ibsGB.Eof
      finally
        ibsGB.Close;
      end;

    except
      on E: Exception do prMessageLOGS('TestFirmClasses_'+fcode+': '+E.Message, fLogCache);
    end;
    SetLengthArrs(0);
  end;
//------------------------------- заполнение/проверка списков складов контрактов
  procedure TestContractStores(ppID: Integer=0; pRegID: Integer=0); // ppID=0 - все существующие
  var fcode, sParam: string;
      j, fid, cid, sid, jj: Integer;
      ff, flReg, flAll, flAdd: boolean;
      ar: Tai;
      firma: TFirmInfo;
      Contract: TContract;
  begin
    setLength(ar, 0);
    if not Assigned(self) or (ppID<0) or ((ppID>0) and not FirmExist(ppID)) then Exit;
    try
      flAll:= (ppID=0);
      if pID>0 then begin // 1 фирма
        fcode:= IntToStr(ppID);
        sParam:= fcode+', 0';
      end else if (pRegID>0) then begin // фирмы регионала
        sParam:= IntToStr(pRegID);
        fcode:= 'RegID='+sParam;
        sParam:= '0, '+sParam;
      end else begin // все фирмы
        fcode:= 'all';
        sParam:= '0, 0';
      end;
      with ibsGB.Transaction do if not InTransaction then StartTransaction;

      if not flClientStoragesView_add then
        ibsGB.SQL.Text:= 'select rFirmCode, rContCode, rDprtCode, rDefault, rVisible,'+
          ' rReserve, rSale, rOrdProc from Vlad_CSS_GetFirmContractStores('+sParam+')' else

      ibsGB.SQL.Text:= 'select rFirmCode, rContCode, rDprtCode, rDefault, rVisible,'+
        ' rReserve, rSale, rAddVis, rOrdProc from Vlad_CSS_GetFirmContrStores('+sParam+')';

      ibsGB.ExecQuery;
      while not ibsGB.Eof do begin
        fid:= ibsGB.FieldByName('rFirmCode').AsInteger;
        ff:= FirmExist(fid);
        if not ff then begin
          while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger) do ibsGB.Next;
          Continue;
        end;
        firma:= arFirmInfo[fid];

        while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger) do begin
          cid:= ibsGB.FieldByName('rContCode').AsInteger;
          ff:= firma.CheckContract(cid) and Contracts.ItemExists(cid);
          flReg:= False;
          if ff then begin
            Contract:= Contracts[cid];
            flReg:= ff and ((pRegID<1) or Contract.CheckContManager(pRegID));
          end else Contract:= nil;
          if not (ff and flReg) then begin
            while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger)
              and (cid=ibsGB.FieldByName('rContCode').AsInteger) do ibsGB.Next;
            Continue;
          end;

          j:= 0; // счетчик складов
          setLength(ar, 0);
          Contract.CS_cont.Enter;
          try
            while not ibsGB.Eof and (fid=ibsGB.FieldByName('rFirmCode').AsInteger)
              and (cid=ibsGB.FieldByName('rContCode').AsInteger) do begin

              if GetBoolGB(ibsGB, 'rOrdProc') then begin
                jj:= Length(ar);      // склады филиалов обработки счетов
                setLength(ar, jj+1);
                ar[jj]:= ibsGB.FieldByName('rDprtCode').AsInteger;
              end;
              if GetBoolGB(ibsGB, 'rVisible') or GetBoolGB(ibsGB, 'rReserve')
                or (flClientStoragesView_add and GetBoolGB(ibsGB, 'rAddVis')) then begin
                Contract.TestStoreArrayLength(taCurr, j+1, true, not (ff and flAll));
                sid:= ibsGB.FieldByName('rDprtCode').AsInteger;
                if not Assigned(Contract.ContStorages[j]) then
                  Contract.ContStorages[j]:= TStoreInfo.Create(sid, '');
                with Contract.ContStorages[j] do begin
                  if DprtID<>sid then DprtID:= sid;
                  IsDefault:= GetBoolGB(ibsGB, 'rDefault');
                  if IsDefault and (Contract.MainStorage<>sid) then
                    Contract.MainStorage:= sid;
                  IsVisible:= GetBoolGB(ibsGB, 'rVisible');
                  IsReserve:= GetBoolGB(ibsGB, 'rReserve');
                  IsSale   := GetBoolGB(ibsGB, 'rSale');
//                    IsAccProc:= GetBoolGB(ibsGB, 'rOrdProc'); // склад филиала обработки счетов
                  if not flClientStoragesView_add then IsAddVis:= False else
                  IsAddVis:= GetBoolGB(ibsGB, 'rAddVis'); // склад доп.видимости
                end;
                inc(j);
              end; // if GetBoolGB

              cntsGRB.TestSuspendException;
              ibsGB.Next;
            end;
                                                  // если какой-то склад закрыли
            Contract.TestStoreArrayLength(taCurr, j, false, not (ff and flAll and flReg));
            jj:= Length(ar);
            Contract.TestStoreArrayLength(taDprt, jj, false, not (ff and flAll and flReg));
            for jj:= Low(ar) to High(ar) do // склады филиалов обработки счетов
              if (Contract.ContProcDprts[jj]<>ar[jj]) then Contract.ContProcDprts[jj]:= ar[jj];
  //            prMessageLOGS('ContStores_'+inttostr(fid)+': '+fnArrOfIntToString(ContProcDprts), fLogCache);
            flAdd:= False;
            for jj:=0 to High(Contract.ContStorages) do begin
              flAdd:= Contract.ContStorages[jj].IsAddVis;
              if flAdd then break;
            end;
            Contract.HasAddVis:= flAdd;

          finally
            Contract.CS_cont.Leave;
            setLength(ar, 0);
          end;

        end; // while not ibsGB.Eof and (fid=...
      end; // while not ibsGB.Eof
    except
      on E: Exception do prMessageLOGS('TestContractStores_'+fcode+': '+E.Message, fLogCache);
    end;
    ibsGB.Close;
    setLength(ar, 0);
  end;
//-------------------------------------- проверка параметров фирмы из Grossbee
  procedure TestFirmDataFromGrossbee(jj: integer; new: boolean; InCS: boolean=True);
  var ss: string;
  begin
    if not FirmExist(jj) then Exit;
    with arFirmInfo[jj] do begin
      if InCS then CS_firm.Enter;
      try
        UPPERMAINNAME:= fnDelEndOfStr(ibsGB.fieldByName('FIRMUPPERMAINNAME').AsString);
        UPPERSHORTNAME:= fnDelEndOfStr(ibsGB.fieldByName('FIRMUPPERSHORTNAME').AsString);
        ss:= fnDelEndOfStr(ibsGB.fieldByName('FIRMMAINNAME').AsString);
        if new or (Name<>ss) then Name:= ss;
                                      // меняем только с частичной на полную !!!
        if not Partially and PartiallyFilled then PartiallyFilled:= Partially;
        Arhived := GetBoolGB(ibsGB, 'FIRMARCHIVEDKEY');
        FirmType:= ibsGB.FieldByName('FirmType').AsInteger;
        HostCode:= ibsGB.FieldByName('HOSTCODE').AsInteger;
        BonusQty:= ibsGB.FieldByName('bnrssumm').AsFloat;
      finally
        if InCS then CS_firm.Leave;
      end;
      TestFirmContracts(jj); // контракты фирмы (+ менеджеры, системы учета)
      LastTestTime:= Now;
    end;
  end;
//-------------------------------------- проверка параметров фирмы из ib_ord
  procedure TestFirmDataFromWebTables(jj: integer; InCS: boolean=True);
  begin
    if not FirmExist(jj) then Exit else with arFirmInfo[jj] do try
      if InCS then CS_firm.Enter;
      NUMPREFIX     := ibsOrd.fieldByName('WOFRNUMPREFIX').AsString;
      SUPERVISOR    := ibsOrd.fieldByName('WOFRSUPERVISOR').AsInteger;
      SKIPPROCESSING:= GetBoolGB(ibsOrd, 'WOFRSKIPPROCESSING');
      Blocked       := (ibsOrd.fieldByName('wofrblock').AsInteger>0);
      ActionText    := ibsOrd.fieldByName('WOFRActionStateText').AsString;
      ContUnitOrd   := ibsOrd.fieldByName('ContUnitOrd').AsInteger;
    finally
      if InCS then CS_firm.Leave;
    end;
  end;
//--------------------- признак необходимости проверки фирмы
  function FirmNeedTesting(jj: integer): boolean;
  begin // если полная проверка, а фирма заполнена частично - CompareTime не учитываем
    Result:= not FirmExist(jj);
    if not Result then with arFirmInfo[jj] do Result:= (LastTestTime=DateNull)
      or not CompareTime or (not Partially and PartiallyFilled)
      or ((Now>IncMinute(LastTestTime, FirmActualInterval))
        and cntsGRB.NotManyLockConnects and cntsORD.NotManyLockConnects);
  end;
//------------------------------------------
begin
  if not Assigned(self) then Exit;
  LocalStart:= now();
  iCount:= 0;
  motoCount:= 0;
  ibdGB:= nil;
  ibdOrd:= nil;
  ibs:= nil;
  ibsGB:= nil;
  ibsOrd:= nil;
  ibs1:= nil;
  if (pID>0) then
    if (not FirmExist(pID) and not FillNew) or not FirmNeedTesting(pID) then Exit;
  if pID<0 then FirmCode:= 'alter'
  else if pID>0 then FirmCode:= IntToStr(pID)
  else FirmCode:= fnIfStr(length(arFirmInfo)<2, 'fill_', 'test_')+
    fnIfStr(RegID>0, 'RegID='+IntToStr(RegID), 'full');
  try
    try
      ibdOrd:= cntsORD.GetFreeCnt;
      ibdGB:= cntsGRB.GetFreeCnt;
      ibsOrd:= fnCreateNewIBSQL(ibdOrd, 'ibsOrd_'+nmProc+'_'+FirmCode, -1, tpRead, True);
      ibs:= fnCreateNewIBSQL(ibdGB, 'ibs_'+nmProc+'_'+FirmCode); // для TestFirmContracts
      ibs1:= fnCreateNewIBSQL(ibdGB, 'ibs1_'+nmProc+'_'+FirmCode); // для TestContractDestPoints
      ibsGB:= fnCreateNewIBSQL(ibdGB, 'ibsGB_'+nmProc+'_'+FirmCode, -1, tpRead, True);
      if Length(arFirmInfo)<2 then begin  // при первом обращении
        cntsORD.TestSuspendException;
        ibsOrd.SQL.Text:= 'SELECT GEN_ID (WOFRCODEGEN, 0) FROM RDB$DATABASE';
        ibsOrd.ExecQuery;
        FirmID:= ibsOrd.fields[0].AsInteger;
        ibsOrd.Close;
        TestCacheArrayLength(taFirm, FirmID+100);
      end;

      sSqlOrd:= 'Select WOFRCODE, WOFRSKIPPROCESSING, WOFRNUMPREFIX,'+
        ' wofrblock, WOFRSUPERVISOR, WOFRActionStateText, (SELECT first 1 ORDRCONTRACT'+
        '  from ORDERSREESTR where ORDRFIRM=WOFRCODE and ORDRSTATUS='+IntToStr(orstForming)+
        '  and ORDRCURRENCY='+IntToStr(Cache.BonusCrncCode)+') ContUnitOrd FROM WEBORDERFIRMS';

      sSqlGb:= 'select f.FIRMCODE, f.FIRMMAINNAME, f.FIRMUPPERMAINNAME,'+
        ' f.FIRMARCHIVEDKEY, f.FIRMUPPERSHORTNAME,'+  //  f.FIRMMASTERCODE, f.firmchildcount,
        ' iif(f.firmhostcode is null, f.FirmCode, f.firmhostcode) HOSTCODE,'+
        ' RClTpCode FirmType, br.bnrssumm from FIRMS f'+
        ' left join GETFIRMCLIENTTYPE(f.firmcode, "TODAY") on 1=1'+
        ' left join BONUSREST br on br.bnrsfirmcode=f.firmcode and br.bnrssubfirmcode=1'+
        ' where f.firmchildcount=0 and FIRMSERVICEFIRM="F"';
      cntsGRB.TestSuspendException;

  //--------------------------------------- по alter-таблицам  // пока не работает
      if pID<0 then begin

      // alter table firms add FirmServiceFirm booleanGB; // признак  "Технический клиент"

  //------------------------------------------------------ проверка по всем фирмам
      end else if (pID=0) and (RegID<1) then begin
        ibsGB.SQL.Text:= sSqlGb+' order by FIRMMAINNAME';
        ibsGB.ExecQuery;                      // идем по фирмам Grossbee
        while not ibsGB.Eof do begin
          FirmID:= ibsGB.fieldByName('FIRMCODE').AsInteger;
          flnew:= FillNew and not FirmExist(FirmID);
          if TestCacheArrayItemExist(taFirm, FirmID, flnew) and FirmNeedTesting(FirmID) then
            with arFirmInfo[FirmID] do begin
//              PrevPartFilled:= PartiallyFilled; // запоминаем предыдущее состояние
              TestFirmDataFromGrossbee(FirmID, flnew); // проверка параметров фирмы из Grossbee
              inc(iCount);
              if IsMOTOFirm then inc(motoCount);
            end;
          cntsGRB.TestSuspendException;
          ibsGB.Next;
        end;
        ibsGB.Close;

        cntsORD.TestSuspendException;
        ibsOrd.SQL.Text:= sSqlOrd+' order by WOFRCODE';
        ibsOrd.ExecQuery;
        while not ibsOrd.Eof do begin
          FirmID:= ibsOrd.fieldByName('WOFRCODE').AsInteger;
          if FirmExist(FirmID) then
            TestFirmDataFromWebTables(FirmID); // существующий объект проверяем
          cntsORD.TestSuspendException;
          ibsOrd.Next;
        end;
        ibsOrd.Close;

        TestFirmClasses(pID); // категории фирм, VIN запросы
        TestContractStores(pID); // склады контрактов фирм

        prMessageLOGS(nmProc+'_'+FirmCode+' '+IntToStr(iCount)+' к/а, '+IntToStr(motoCount)+'moto: - '+
          GetLogTimeStr(LocalStart)+fnIfStr(Partially, ' Partially', ''), fLogCache, false);

  //------------------------------------------------- проверка по фирмам регионала
      end else if (pID=0) and (RegID>0) then begin
  //      flex:= EmplExist(RegID); // есть регионал
  //      prMessageLOGS(nmProc+'_'+FirmCode+' (RegID='+IntToStr(RegID)+'): - '+
  //        fnIfStr(Partially, ' Partially', ''), fLogCache, false);
        ibsGB.SQL.Text:= sSqlGb+' order by FIRMMAINNAME';
        ibsGB.ExecQuery;                      // идем по фирмам Grossbee
        while not ibsGB.Eof do begin
          FirmID:= ibsGB.fieldByName('FIRMCODE').AsInteger;
          flnew:= FillNew and not FirmExist(FirmID);
          if TestCacheArrayItemExist(taFirm, FirmID, flnew) and FirmNeedTesting(FirmID) then
            with arFirmInfo[FirmID] do begin
//              PrevPartFilled:= PartiallyFilled; // запоминаем предыдущее состояние
              TestFirmDataFromGrossbee(FirmID, flnew); // проверка параметров фирмы из Grossbee
              if length(FirmClients)>0 then
                TestClients(FirmClients[0], FillNew, CompareTime, Partially); // проверяем клиентов фирмы
              inc(iCount);
              if IsMOTOFirm then inc(motoCount);
            end;
          cntsGRB.TestSuspendException;
          ibsGB.Next;
        end;
        ibsGB.Close;

        cntsORD.TestSuspendException;
        ibsOrd.SQL.Text:= sSqlOrd+' order by WOFRCODE';
        ibsOrd.ExecQuery;
        while not ibsOrd.Eof do begin
          FirmID:= ibsOrd.fieldByName('WOFRCODE').AsInteger;
          if FirmExist(FirmID) and arFirmInfo[FirmID].CheckFirmManager(RegID) then
            TestFirmDataFromWebTables(FirmID); // существующий объект проверяем
          cntsORD.TestSuspendException;
          ibsOrd.Next;
        end;
        ibsOrd.Close;

        TestFirmClasses(pID, RegID);      // категории фирм регионала, VIN запросы
        TestContractStores(pID, RegID); // склады контрактов фирм регионала

        prMessageLOGS(nmProc+'_'+FirmCode+' '+IntToStr(iCount)+'к/а, MOTO-'+IntToStr(motoCount)+': - '+
          GetLogTimeStr(LocalStart)+fnIfStr(Partially, ' Partially', ''), fLogCache, false);

  //------------------------------------------------------------- проверка 1 фирмы
      end else begin
        flnew:= FillNew and not FirmExist(pID); // если 1 фирма
        if TestCacheArrayItemExist(taFirm, pID, flnew) then with arFirmInfo[pID] do
          if (flnew or not CompareTime or (not Partially and PartiallyFilled) or
            (Now>IncMinute(LastTestTime, FirmActualInterval))) then try
            CS_firm.Enter; // проверка - внутри CS_firm !!!

            ibsGB.SQL.Text:= sSqlGb+' and f.FIRMCODE='+FirmCode;
            ibsGB.ExecQuery;
            if not (ibsGB.Bof and ibsGB.Eof) then begin
              PrevPartFilled:= arFirmInfo[pID].PartiallyFilled; // запоминаем предыдущее состояние
              TestFirmDataFromGrossbee(pID, flnew, false); // проверка параметров фирмы из Grossbee
            end else PrevPartFilled:= False;
            ibsGB.Close;

            cntsORD.TestSuspendException;
            ibsOrd.SQL.Text:= sSqlOrd+' where WOFRCODE='+FirmCode;
            ibsOrd.ExecQuery;
            if not (ibsOrd.Bof and ibsOrd.Eof) then
              TestFirmDataFromWebTables(pID, false); // существующий объект проверяем
            ibsOrd.Close;

            if flnew or PrevPartFilled or cntsGRB.NotManyLockConnects then begin // если заполнение или не перегружен пул
              TestFirmClasses(pID); // категории фирмы, VIN запросы
              TestContractStores(pID); // склады контрактов фирмы
            end;
          finally
            CS_firm.Leave;
          end;
      end;
    finally
      prFreeIBSQL(ibs);
      prFreeIBSQL(ibsGB);
      prFreeIBSQL(ibs1);
      cntsGRB.SetFreeCnt(ibdGB);
      prFreeIBSQL(ibsOrd);
      cntsORD.SetFreeCnt(ibdOrd);
    end;
    ii:= Length(arFirmInfo);
    for i:= High(arFirmInfo) downto 1 do if Assigned(arFirmInfo[i]) then begin
      ii:= arFirmInfo[i].ID+1;
      break;
    end;
    if Length(arFirmInfo)>ii then try
      CScache.Enter;
      SetLength(arFirmInfo, ii); // обрезаем по мах.коду
    finally
      CScache.Leave;
    end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'_'+FirmCode+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+'_'+FirmCode+': '+E.Message, fLogCache);
  end;
  TestCssStopException;
{  if flDebug then begin
    for i:= 1 to High(arFirmInfo) do if FirmExist(i) then
      if not arFirmInfo[i].Arhived then
      prMessageLOGS('  '+fnMakeAddCharStr(IntToStr(i), 7, True)+
        fnMakeAddCharStr(arFirmInfo[i].FirmTypeName, 20, True)+
        arFirmInfo[i].Name, fLogDebug, false);
  end; }
end;
//======================================================= проверка кэша клиентов
procedure TDataCache.TestClients(pID: Integer; FillNew: boolean=False;
          CompareTime: boolean=True; Partially: boolean=False; pFirm: Integer=0);
// CompareTime=True - проверять время последнего обновления, False - не проверять (ID>0)
// ID=-1 - по alter-таблицам, ID>0 - 1 клиент, ID=0 - все клиенты (после проверки всех фирм !!!)
// FillNew=True - заполнение новых, FillNew=False - проверка только существующих
// Partially=True - частичная проверка(АРМ), Partially=False - полная проверка
const nmProc = 'TestClients'; // имя процедуры/функции
type
  TChange = record
    code, firmID: integer;
    name: string;
  end;
var i, pFirmID, j, j1, iCount: integer;
    UserCode, s, sSQLord, sSQLgb: string;
    ibsGB, ibsOrd: TIBSQL;
    ibdGB, ibdOrd: TIBDatabase;
    LocalStart: TDateTime;
    Change: array of TChange;
    codes: Tai;
    flnew, PrevPartFilled: boolean;
    Client: TClientInfo;
    Firma: TFirmInfo;
//    lst: TStringList;
//-------------------------------------- проверка параметров клиента из Grossbee
  procedure TestClientDataFromGrossbee(Client: TClientInfo; new: boolean; InCS: boolean=True);
  var fl: boolean;
      lst: TStringList;
      s: String;
//      i: integer;
  begin
    if not Assigned(Client) then Exit else with Client do try
      if InCS then CS_client.Enter;
      Post    := fnDelEndOfStr(ibsGB.fieldByName('PRSNPOST').AsString);
      Name    := fnDelEndOfStr(ibsGB.fieldByName('PRSNNAME').AsString);
      FirmID  := ibsGB.fieldByName('PRSNFIRMCODE').AsInteger;
      fl:= GetBoolGB(ibsGB, 'PRSNARCHIVEDKEY');
      if Arhived<>fl then Arhived:= fl;

      s:= fnDelEndOfStr(ibsGB.fieldByName('PHONEs').AsString);
      lst:= fnSplit(cSplitDelim, s);
      CheckStringList(CliPhones, Lst);
      DelEmptyStrings(CliPhones); // чистка пустых строк
      Lst.Clear;

      s:= fnDelEndOfStr(ibsGB.fieldByName('Mails').AsString);
      lst:= fnSplit(cSplitDelim, s);
      CheckStringList(CliMails, Lst);
      DelEmptyStrings(CliMails); // чистка пустых строк
      Lst.Clear;
{      if flDebug then
        for i:= 0 to CliMails.Count-1 do begin
          s:= CliMails[i];
          if not fnCheckEmail(s) then
            prMessageLOGS(nmProc+'_client'+IntToStr(ID)+': not correct Email '+s, fLogDebug);
        end;
      if flDebug and (CliMails.Count>1) or (CliPhones.Count>1) then begin
        s:= Phone;
        s:= Mail;
      end;    }
      PrevPartFilled:= PartiallyFilled;
      PartiallyFilled:= Partially;
      LastTestTime:= Now;
    finally
      if InCS then CS_client.Leave;
      prFree(lst);
    end;
  end;
//-------------------------------------- проверка параметров клиента из ib_ord
  procedure TestClientDataFromWebTables(Client: TClientInfo; new: boolean=false; InCS: boolean=True);
  begin
    if not Assigned(Client) then Exit else with Client do try
      if InCS then CS_client.Enter;
      Login:= ibsOrd.fieldByName('WOCLLOGIN').AsString;
      Password:= ibsOrd.fieldByName('WOCLPASSWORD').AsString;
      WareSemafor:= GetBoolGB(ibsOrd, 'WOCLWARERESTSEMAFOR');
      resetPW:= GetBoolGB(ibsOrd, 'WOCLRESETPASWORD');
      BlockKind:= ibsOrd.fieldByName('WOCLBLOCK').AsInteger;
      if ibsOrd.fieldByName('WOCLLASTACTIONTIME').AsDateTime>LastAct then
        LastAct:= ibsOrd.fieldByName('WOCLLASTACTIONTIME').AsDateTime;
      CheckBlocked(); // проверка блокировки
      LastContract:= ibsOrd.fieldByName('woclLastContract').AsInteger;
      if not Partially then begin // если полная
        SearchCurrencyID := ibsOrd.fieldByName('WOCLSEARCHCURRENCY').AsInteger;
        MaxRowShowAnalogs:= ibsOrd.fieldByName('WOCLMAXROWFORSHOWANALOGS').AsInteger;
        DEFACCOUNTINGTYPE:= ibsOrd.fieldByName('WOCLDEFAULTACCOUNTINGTYPE').AsInteger;
        DEFDELIVERYTYPE  := ibsOrd.fieldByName('WOCLDEFAULTDELIVERYTYPE').AsInteger;
        NOTREMINDCOMMENT := GetBoolGB(ibsOrd, 'WOCLNOTREMINDCOMMENT');
        DocsByCurrContr  := GetBoolGB(ibsOrd, 'WOCLDocsByContr');
      end;
      if not Partially and       // если полная проверка
        (new or PrevPartFilled or cntsGRB.NotManyLockConnects) then begin // если заполнение или не перегружен пул
        UpdateStorageOrderC;
      end;
      CheckWorkLogins(ID, Login); // проверка логина в списке поиска логинов
      LastTestTime:= Now;
    finally
      if InCS then CS_client.Leave;
    end;
  end;
//--------------------- признак необходимости проверки клиента
  function ClientNeedTesting(ii: integer): boolean;
  begin // если полная проверка, а клиент заполнен частично - CompareTime не учитываем
    Result:= not ClientExist(ii);
    if not Result then with arClientInfo[ii] do
      Result:= (LastTestTime=DateNull) or not CompareTime
               or (not Partially and PartiallyFilled)
               or ((Now>IncMinute(LastTestTime, ClientActualInterval))
                 and cntsGRB.NotManyLockConnects and cntsORD.NotManyLockConnects);
  end;
//------------------------------------------
begin
  if not Assigned(self) then Exit;
  iCount:= 0;  // счетчик
  LocalStart:= now();
  ibdGB:= nil;
  ibsGB:= nil;
  ibdOrd:= nil;
  ibsOrd:= nil;
  if pID<0 then UserCode:= 'alter'
  else if (pID=0) then begin
    if (pFirm=0) then
      UserCode:= fnIfStr(arClientInfo.MaxIndex<2, 'fill_', 'test_')+'full'
    else UserCode:= 'test_f'+IntToStr(pFirm);
  end else if (pID>0) then begin
    if not ClientNeedTesting(pID) then Exit;
    UserCode:= IntToStr(pID);
  end;

  try try
    ibdOrd:= cntsORD.GetFreeCnt;
    ibdGB:= cntsGRB.GetFreeCnt;
    ibsOrd:= fnCreateNewIBSQL(ibdOrd, 'ibsOrd_'+nmProc+'_'+UserCode, -1, tpRead, True);
    ibsGB:= fnCreateNewIBSQL(ibdGB, 'ibsGB_'+nmProc+'_'+UserCode, -1, tpRead, True);

    if (arClientInfo.MaxIndex<2) then begin // при первом обращении
                                            // вычисляем диапазон пропущенных кодов
      ibsGB.SQL.Text:= 'SELECT PRSNCODE from PERSONS inner join FIRMS'+
        ' on FIRMCODE=PRSNFIRMCODE and firmchildcount=0 order by PRSNCODE';
      ibsGB.ExecQuery;
      i:= 0;
      j:= 0;
      while not ibsGB.Eof do begin
        j:= ibsGB.fieldByName('PRSNCODE').AsInteger;
        if (j-i)>30000 then break;
        i:= j;
        ibsGB.Next;
      end;
      ibsGB.Close;
      arClientInfo.SetCalcBounds(i, j);

      ibsOrd.SQL.Text:= 'SELECT GEN_ID (WOCLCODEGEN, 0) FROM RDB$DATABASE';
      ibsOrd.ExecQuery;
      i:= ibsOrd.fields[0].AsInteger;
      ibsOrd.Close;
      arClientInfo.TestMaxCode(i);
    end;
    setlength(Change, 0);
    setlength(codes, 100);

    sSQLord:= 'Select WOCLCODE, WOCLLOGIN, WOCLPASSWORD, WOCLDEFAULTACCOUNTINGTYPE,'+
      ' WOCLDEFAULTDELIVERYTYPE, WOCLMAXROWFORSHOWANALOGS, WOCLNOTREMINDCOMMENT,'+
      ' WOCLSEARCHCURRENCY, WOCLWARERESTSEMAFOR, woclLastContract, WOCLLASTACTIONTIME,'+
      ' WOCLBLOCK, WOCLFIRMCODE, WOCLDocsByContr, WOCLRESETPASWORD FROM WEBORDERCLIENTS';

    sSQLgb:= 'select PRSNCODE, PRSNNAME, PRSNFIRMCODE, PRSNPOST, PRSNARCHIVEDKEY,'+
      ' (select LIST(PEEMAIL, "'+cSplitDelim+'") from PERSONEMAILS'+
      '   where PEPERSONCODE=PRSNCODE and PEARCHIVEDKEY="F") MAILs,'+
      ' (select LIST(PPHPHONE, "'+cSplitDelim+'") from PERSONPHONES'+
      '   where PPHPERSONCODE=PRSNCODE and PPHARCHIVEDKEY="F") PHONEs from PERSONS';

//------------------------------------------------------------ по alter-таблицам
    if pID<0 then begin

//------------------------------------------------------------------ все клиенты
    end else if (pID=0) and (pFirm=0) then begin
      ibsGB.SQL.Text:= sSQLgb+
        ' inner join FIRMS on FIRMCODE=PRSNFIRMCODE and firmchildcount=0'+
        ' order by PRSNFIRMCODE';
      ibsGB.ExecQuery;                     // проверяем параметры из Grossbee
      setlength(codes, 100);
      if not ((ibsGB.Bof and ibsGB.Eof)) then repeat
        pFirmID:= ibsGB.fieldByName('PRSNFIRMCODE').AsInteger;
        j:= 0; // счетчик клиентов фирмы
        if not FirmExist(pFirmID) then begin
          while not ibsGB.Eof and (pFirmID=ibsGB.fieldByName('PRSNFIRMCODE').AsInteger) do ibsGB.Next;
        end else begin
          Firma:= arFirmInfo[pFirmID];
          Firma.CS_firm.Enter; // блокируем фирму, чтобы не лезли другие ее сотрудники
          try
            while not ibsGB.Eof and (pFirmID=ibsGB.fieldByName('PRSNFIRMCODE').AsInteger) do begin
              i:= ibsGB.fieldByName('PRSNCODE').AsInteger;
              flnew:= FillNew and not ClientExist(i); // признак первоначального заполнения
              if TestCacheArrayItemExist(taClie, i, flnew)
                and (flnew or ClientNeedTesting(i)) then begin
                Client:= arClientInfo[i];
                TestClientDataFromGrossbee(Client, flnew); // проверка параметров клиента из Grossbee
                if not Client.Arhived then begin  // если неархивный сотрудник
                  if High(codes)>j then SetLength(codes, j+100);
                  codes[j]:= i;
                  inc(j);
                end;
                inc(iCount);
              end;
              cntsGRB.TestSuspendException;
              ibsGB.Next;
            end; // while not ibsGB.Eof and (FirmID=ibsGB.fieldByName('PRSNFIRMCODE').AsInteger)
            Firma.TestFirmClients(codes, j, false); // проверяем список кодов сотрудников фирмы
          finally
            Firma.CS_firm.Leave;
          end;
        end;
      until ibsGB.Eof;
      ibsGB.Close;

      ibsOrd.SQL.Text:= sSQLord;
      ibsOrd.ExecQuery;                            // проверяем параметры из ib_ord
      while not ibsOrd.Eof do begin
        i:= ibsOrd.fieldByName('WOCLCODE').AsInteger; // существующий объект проверяем
        if ClientExist(i)  then begin
          Client:= arClientInfo[i];
          if FirmExist(Client.FirmID) then begin
            TestClientDataFromWebTables(Client); // проверка параметров клиента из ib_ord
            if (Client.FirmID<>ibsOrd.fieldByName('WOCLFIRMCODE').AsInteger) then begin
              j1:= Length(Change); // запоминаем, кого надо изменить в ib_ord
              SetLength(Change, j1+1);
              Change[j1].code:= i;
              Change[j1].firmID:= Client.FirmID;
              Change[j1].name:= Client.Name;
            end;
          end;
        end;
        cntsORD.TestSuspendException;
        ibsOrd.Next;
      end;
      ibsOrd.Close;

      prMessageLOGS(nmProc+'_'+UserCode+' '+IntToStr(iCount)+' кл: - '+
        GetLogTimeStr(LocalStart)+fnIfStr(Partially, ' Partially', ''), fLogCache, false);

//------------------------------------------------------------- клиенты 1 фирмы
    end else begin
      if (pID=0) and (pFirm>0) then pFirmID:= pFirm
      else begin
        ibsGB.SQL.Text:= 'select PRSNFIRMCODE from PERSONS where PRSNCODE='+UserCode;
        ibsGB.ExecQuery;
        if (ibsGB.Bof and ibsGB.Eof) then
          raise Exception.Create(MessText(mtkNotClientExist, UserCode));
        pFirmID:= ibsGB.fieldByName('PRSNFIRMCODE').AsInteger;
        ibsGB.Close;
      end;
      s:= IntToStr(pFirmID);

      TestFirms(pFirmID, FillNew, CompareTime, Partially);

      j:= 0; // счетчик клиентов фирмы
      if FirmExist(pFirmID) then begin        // проверяем всех по фирме
        Firma:= arFirmInfo[pFirmID];
        ibsOrd.SQL.Text:= sSQLord+' where WOCLCODE=:WOCLCODE';
        ibsOrd.Prepare;
        ibsGB.SQL.Text:= sSQLgb+' WHERE PRSNFIRMCODE='+s;
        Firma.CS_firm.Enter; // блокируем фирму, чтобы не лезли другие ее сотрудники
        try
          ibsGB.ExecQuery;                   // проверяем параметры из Grossbee
          while not ibsGB.Eof do begin
            i:= ibsGB.fieldByName('PRSNCODE').AsInteger;
            flnew:= FillNew and not ClientExist(i); // признак первоначального заполнения
            if TestCacheArrayItemExist(taClie, i, flnew)
              and (flnew or ClientNeedTesting(i)) then begin
              Client:= arClientInfo[i];
              try
                Client.CS_client.Enter;
                TestClientDataFromGrossbee(Client, flnew, false); // проверка параметров клиента из Grossbee
                if not Client.Arhived then begin  // если неархивный сотрудник
                  if High(codes)>j then SetLength(codes, j+100);
                  codes[j]:= i;
                  inc(j);
                end;
                ibsOrd.ParamByName('WOCLCODE').AsInteger:= i;
                ibsOrd.ExecQuery;
                if not (ibsOrd.Bof and ibsOrd.Eof) then begin
                  TestClientDataFromWebTables(Client, flnew, false); // проверка параметров клиента из ib_ord
                  if (pFirmID<>ibsOrd.fieldByName('WOCLFIRMCODE').AsInteger) then begin
                    j1:= Length(Change); // запоминаем, кого надо изменить в ib_ord
                    SetLength(Change, j1+1);
                    Change[j1].code:= i;
                    Change[j1].firmID:= pFirmID;
                    Change[j1].name:= Client.Name;
                  end;
                end;
                ibsOrd.Close;
              finally
                Client.CS_client.Leave;
              end;
            end;
            cntsGRB.TestSuspendException;
            ibsGB.Next;
          end; // while not ibsGB.Eof
          ibsGB.Close;
          Firma.TestFirmClients(codes, j, false); // проверяем список кодов сотрудников фирмы
        finally
          Firma.CS_firm.Leave;
        end;
      end; // if FirmExist(FirmID)
    end;
    arClientInfo.CutEmptyCode;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+'_'+UserCode+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+'_'+UserCode+': '+E.Message, fLogCache);
  end;

  if length(Change)>0 then try  // если есть изменения в ib_ord
    fnSetTransParams(ibsOrd.Transaction, tpWrite, True);
    ibsOrd.SQL.Text:= 'Update WEBORDERCLIENTS set WOCLFIRMCODE=:WOCLFIRMCODE where WOCLCODE=:WOCLCODE';
    ibsOrd.Prepare;
    for j:= 0 to High(Change) do if Change[j].code>0 then try
      with ibsOrd.Transaction do if not InTransaction then StartTransaction;
      ibsOrd.ParamByName('WOCLCODE').AsInteger:= Change[j].code;
      ibsOrd.ParamByName('WOCLFIRMCODE').AsInteger:= Change[j].firmID;
      ibsOrd.ExecQuery;
      ibsOrd.Transaction.Commit;
      ibsOrd.Close;
    except
      on E: Exception do begin
        ibsOrd.Transaction.Rollback;
        prMessageLOGS('Update '+IntToStr(Change[j].code)+' '+Change[j].name+': '+E.Message, fLogCache);
      end;
    end;
{    if flDebug then if (pID=0) and (pFirm=0) then
    try
      lst:= TStringList.Create;
      for j1:= 1 to High(Cache.arFirmInfo) do if Cache.FirmExist(j1) then begin
        Firma:= Cache.arFirmInfo[j1];
        if Firma.Arhived then Continue;
        for j:= 0 to High(Firma.FirmClients) do
          if Cache.ClientExist(Firma.FirmClients[j]) then begin
            Client:= Cache.arClientInfo[Firma.FirmClients[j]];
            if not Client.Arhived then Continue;
            for i:= 0 to Client.CliMails.Count-1 do begin
              s:= Client.CliMails[i];
              if not fnCheckEmail(s) then
                lst.Add(IntToStr(Firma.ID)+';'+Firma.Name+';'+IntToStr(Client.ID)+';'+Client.Name+';'+s);
  //              prMessageLOGS(nmProc+'_client'+IntToStr(ID)+': not correct Email '+s, fLogDebug);
            end;
          end;
      end;

      if lst.Count>0 then lst.SaveToFile('d:\notcorrectemals.csv');
    finally
      prFree(lst);
    end;            }
  except
    on E: Exception do prMessageLOGS(nmProc+'_'+UserCode+': '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibsGB);     // отпускаем коннекты Grossbee
    cntsGRB.SetFreeCnt(ibdGB);
    prFreeIBSQL(ibsOrd);     // отпускаем коннект ib_ord
    cntsORD.SetFreeCnt(ibdOrd);
    setlength(Change, 0);
    setlength(codes, 0);
  end;
  TestCssStopException;
end;
//========================================= Загрузка / обновление файлов товаров
procedure TDataCache.FillWareFiles(fFill: Boolean=True);
const nmProc = 'FillWareFiles'; // имя процедуры/функции/потока
var ORD_IBS: TIBSQL;
    ORD_IBD: TIBDatabase;
    TimeProc: TDateTime;
    iCount, wareID, fileID, srcID: Integer;
    flLinkURL: Boolean;
    nlinks: TLinks;
    p: Pointer;
    s: String;
begin
  if not Assigned(self) then Exit;
  iCount:= 0;
  TimeProc:= Now;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  with FWareFiles do try try
  if not fFill then SetDirStates(False);

  ORD_IBD:= cntsOrd.GetFreeCnt;
    ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
    ORD_IBS.SQL.Text:= 'select WGFCODE, WGFSupTD, WGFFileName, WGFHeadID,'+
      ' WGFSRCLECODE from WareGraFiles';
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      p:= TWareFile.Create(ORD_IBS.FieldByName('WGFCODE').AsInteger,
        ORD_IBS.FieldByName('WGFSupTD').AsInteger,       // SubCode (supID TecDoc !!!)
        ORD_IBS.FieldByName('WGFHeadID').AsInteger,      // OrderNum
        ORD_IBS.FieldByName('WGFFileName').AsString,     // Name
        ORD_IBS.FieldByName('WGFSRCLECODE').AsInteger);
      CheckItem(p);
      Inc(iCount);
      cntsORD.TestSuspendException;
      ORD_IBS.Next;
    end; // while ...
    ORD_IBS.Close;
    CheckLength;  // DelDirNotTested - после проверки связок
    s:= IntToStr(iCount)+' файлов, ';

    iCount:= 0;
    ORD_IBS.SQL.Text:= 'select LWGFWGFCODE, LWGFWareID, LWGFLinkURL, LWGFSRCLECODE'+
      ' from LinkWareGraFiles inner join WareOptions on wowarecode=LWGFWareID and WOARHIVED="F"'+
       ' where LWGFWRONG="F" order by LWGFWareID';
    ORD_IBS.ExecQuery;
    while not ORD_IBS.Eof do begin
      wareID:= ORD_IBS.FieldByName('LWGFWareID').AsInteger; // Код товара
      if not WareExist(wareID) or GetWare(WareID).IsArchive then begin
        while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('LWGFWareID').AsInteger) do ORD_IBS.Next;
        Continue;
      end;
      nlinks:= GetWare(wareID).FileLinks;
      if not fFill then nlinks.SetLinkStates(False);

      while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('LWGFWareID').AsInteger) do begin
        fileID:= ORD_IBS.FieldByName('LWGFWGFCODE').AsInteger; // Код файла
        if FWareFiles.ItemExists(fileID) then begin
          srcID:= ORD_IBS.FieldByName('LWGFSRCLECODE').AsInteger;
          flLinkURL:= GetBoolGB(ORD_IBS, 'LWGFLinkURL');
          p:= FWareFiles[fileID];
          with nlinks do if not fFill and LinkExists(fileID) then try
            CS_Links.Enter;
            with TFlagLink(nlinks[fileID]) do begin
              if SrcID  <>srcID     then SrcID  := srcID;
              if LinkPtr<>p         then LinkPtr:= p;
              if Flag   <>flLinkURL then Flag   := flLinkURL;
              State:= True;
            end;
            if not TDirItem(p).State then TDirItem(p).State:= True; // на всяк случай
          finally
            CS_Links.Leave;
          end else AddLinkItem(TFlagLink.Create(srcID, p, flLinkURL));
          Inc(iCount);
        end;
        cntsORD.TestSuspendException;
        ORD_IBS.Next;
      end; // while ... and (wareID=

      if not fFill then nlinks.DelNotTestedLinks;
    end; // while ...
    ORD_IBS.Close;
    if not fFill then DelDirNotTested; // после проверки связок
  finally
    prFreeIBSQL(ORD_IBS);
    cntsOrd.SetFreeCnt(ORD_IBD);
  end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
//  prMessageLOGS(nmProc+': '+IntToStr(iCount)+' файлов - '+GetLogTimeStr(TimeProc), fLogCache, false);
  prMessageLOGS(nmProc+': '+s+IntToStr(iCount)+' св. - '+GetLogTimeStr(TimeProc), fLogCache, false);
  TestCssStopException;
end;
//=============================== заполнение/проверка связок с остатками товаров
procedure TDataCache.TestWareRests(CompareTime: boolean=True);
const nmProc = 'TestWareRests'; // имя процедуры/функции/потока
var Store, kod, wCount: integer;
    flFill: boolean;
    sd, ss, sDprts: string;
    ibs: TIBSQL;
    ibd: TIBDatabase;
    qty: double;
    Ware: TWareInfo;
    rLinks: TLinks;
    LocalStart: TDateTime;
begin
  if not Assigned(self) then Exit;
  if not (AllowWeb or AllowWebArm) then Exit; // только Web или WebArm
  flFill:= (LastTestRestTime=DateNull);
  if flFill then ss:= '_fill'
  else begin                              // если рано проверять
    if CompareTime and ((IncMinute(LastTestRestTime, GetConstItem(pcTestRestsIntMinute).IntValue))>Now) then Exit;
    ss:= '_test';
  end;
  ibd:= nil;
  ibs:= nil;
  wCount:= 0;
  LocalStart:= now();
  try try
  ibd:= cntsGRB.GetFreeCnt;
  sDprts:= '';
  if AllowWeb then sDprts:= 'and DprtKind=0'                   // только склады
  else if AllowWebArm then sDprts:= 'and DprtKind in (0, 2)';  // склады и пути
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
    ibs.ParamCheck:= False;
    if flFill then begin // заполнение - только ненулевые остатки
      ibs.SQL.Add('execute block returns (Rware integer, Rstore integer, Rmarket double precision)');
      ibs.SQL.Add('as declare variable XCoeff integer=1; begin');
      ibs.SQL.Add('for select RestWareCode, RestDprtCode, Rest, MeasCoefficient from');
      ibs.SQL.Add('  (select RestWareCode, RestDprtCode,');
      ibs.SQL.Add('    SUM(RestCurrent-RestOrder-RESTPLANOUTPUT-RestPlanTransfer) as Rest');
      ibs.SQL.Add('    from WAREREST inner join DEPARTMENT on DPRTCODE=RestDprtCode');
      ibs.SQL.Add('      where RestSubFirmCode=1 and not DprtKind is null '+sDprts);
      ibs.SQL.Add('    group by RestWareCode, RestDprtCode order by RestWareCode)');
      ibs.SQL.Add('  inner join wares w on w.warecode=RestWareCode');
      ibs.SQL.Add('  inner join VLADPGR pg on pg.KODPGR=w.waremastercode');
      ibs.SQL.Add('    and w.warearchive="F" and w.WARECHILDCOUNT=0');
      ibs.SQL.Add('  inner join VLADGR g on g.KODGR=pg.KODGR and g.KODTG='+IntToStr(codeTovar));
      ibs.SQL.Add('  inner join MEASURE on MeasCode=WareMeas');
      ibs.SQL.Add('  into :Rware, :Rstore, :Rmarket, :XCoeff do if (Rmarket<>0) then begin');
      ibs.SQL.Add('    if (XCoeff>1) then Rmarket=ROUNDSUMMWITHSHIFT(Rmarket/XCoeff); suspend; end end');
    end else begin // проверка - только те остатки, что менялись
      sd:= FormatDateTime(cDateTimeFormatY4S, IncMinute(LastTestRestTime, -1)); // лишняя минута для страховки
      ibs.SQL.Add('execute block returns (Rware integer, Rstore integer, Rmarket double precision)');
      ibs.SQL.Add('as begin if (not exists(select * from WARECACHE_VLAD');
      ibs.SQL.Add('  where WACARESTUPDATETIME>"'+sd+'")) then exit;');
//        ibs.SQL.Add('for select WACACODE, DPRTCODE, rm.Rmarket');
      ibs.SQL.Add('for select WACACODE, DPRTCODE,');
      ibs.SQL.Add('  (select SUM(RestCurrent-RestOrder-RESTPLANOUTPUT-RestPlanTransfer)');
      ibs.SQL.Add('    from WAREREST where RestSubFirmCode=1 and');
      ibs.SQL.Add('    RestWareCode=WACACODE and RestDprtCode=DPRTCODE) Rmarket');
      ibs.SQL.Add('  from (select WACACODE from WARECACHE_VLAD');
      ibs.SQL.Add('    where WACARESTUPDATETIME>"'+sd+'" order by WACACODE)');
      ibs.SQL.Add('  left join wares w on w.warecode=WACACODE');
      ibs.SQL.Add('  left join VLADPGR pg on pg.KODPGR=w.waremastercode');
      ibs.SQL.Add('  left join VLADGR g on g.KODGR=pg.KODGR');
      ibs.SQL.Add('  left join DEPARTMENT on not DprtKind is null '+sDprts);
      ibs.SQL.Add('    and exists(select * from WAREREST where RestSubFirmCode=1');
      ibs.SQL.Add('      and RestWareCode=WACACODE and RestDprtCode=DPRTCODE)');
//        ibs.SQL.Add('  left join GetWareRestsCSS_Vlad(w.warecode, DPRTCODE) rm on 1=1');
      ibs.SQL.Add('  where w.warearchive="F" and w.WARECHILDCOUNT=0 and g.KODTG='+IntToStr(codeTovar));
      ibs.SQL.Add('  into :Rware, :Rstore, :Rmarket do if (Rware>0) then suspend; end');
    end;
    ibs.ExecQuery;       // открываем список остатков из Grossbee
    while not ibs.Eof do begin
      kod:= ibs.FieldByName('Rware').AsInteger;
      Ware:= GetWare(kod, True);
      if (Ware=NoWare) or Ware.IsArchive or not Ware.IsMarketWare then begin
        while not ibs.Eof and (kod=ibs.FieldByName('Rware').AsInteger) do ibs.Next;
        Continue;
      end;

      rLinks:= Ware.RestLinks;
      if not flFill then rLinks.SetLinkStates(False);
      while not ibs.Eof and (kod=ibs.FieldByName('Rware').AsInteger) do begin
        Store:= ibs.FieldByName('Rstore').AsInteger;
        qty:= ibs.FieldByName('Rmarket').AsFloat;
        CheckWareRest(rLinks, Store, qty);
        ibs.Next;
      end;
      if not flFill then rLinks.DelNotTestedLinks;
      inc(wCount); // счетчик проверенных товаров
      cntsGRB.TestSuspendException;
   end;
    ss:= ss+'('+IntToStr(wCount)+'): ';
    LastTestRestTime:= Now;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibs);
    cntsGRB.SetFreeCnt(ibd, True);
  end;
  prMessageLOGS(nmProc+ss+' - '+GetLogTimeStr(LocalStart), fLogCache, false); // пишем в log
  TestCssStopException;
end;
//================================ проверить / уменьшить значение остатка товара
procedure TDataCache.CheckWareRest(wrLinks: TLinks; dprtID: Integer; pQty: Double; dec: Boolean=False);
const nmProc = 'CheckWareRest'; // имя процедуры/функции/потока
// возвращает False, если связка не найдена, при dec=False проставляет State:= True
var link: TQtyLink;
    NewQty: Double;
    Dprt: TDprtInfo;
begin
  if not Assigned(self) or not Assigned(wrLinks) then Exit;
  if not DprtExist(dprtID) then Exit;

  with wrLinks do try
    if not LinkExists(dprtID) then begin // если линка на остаток нет
      if not fnNotZero(pQty) then Exit;  // проверяем кол-во

      Dprt:= arDprtInfo[dprtID];         // проверяем склад
      if not (Dprt.IsStoreHouse or (AllowWebArm and Dprt.IsStoreRoad)) then Exit;

      NewQty:= fnIfDouble(dec, -pQty, pQty);
      AddLinkItem(TQtyLink.Create(0, NewQty, Dprt)); // добавляем линк
      Exit;
    end;

    link:= Items[dprtID]; // линк на остаток
    NewQty:= fnIfDouble(dec, link.Qty-pQty, pQty);

    if not fnNotZero(NewQty) then begin  // если новое кол-во = 0
      DeleteLinkItem(link);
      Exit;
    end;

    if fnNotZero(link.Qty-NewQty) then try // если новое кол-во <> старому - меняем
      CS_links.Enter;
      link.Qty:= NewQty;
    finally
      CS_links.Leave;
    end;
    if not dec then link.State:= True; // признак проверки
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;
//=========================================== получить остатки товара по складам
function TDataCache.GetWareRestsByStores(pWareID: Integer; WithNegative: Boolean=False): TObjectList; // must Free
const nmProc = 'GetWareRestsByStores';
var i: Integer;
    p: Pointer;
    ware: TWareInfo;
    pQty: Single;
begin
  Result:= TObjectList.Create;
  if not Assigned(self) or not WareExist(pWareID) then Exit;
  try
    ware:= GetWare(pWareID, True);
    if not Assigned(ware) or (Ware=NoWare) or Ware.IsArchive or not Assigned(ware.RestLinks) then Exit;
    with Ware.RestLinks do begin
      if LinkCount<1 then Exit;
      CS_links.Enter;
      try
        for i:= 0 to LinkCount-1 do begin
          p:= ListLinks[i];
          pQty:= GetLinkQty(p);
          if (pQty<0) and not WithNegative then Continue;
          Result.Add(TCodeAndQty.Create(GetLinkID(p), pQty));
        end;
      finally
        CS_links.Leave;
      end;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message);
  end;
end;
//========================================================
procedure TDataCache.FillWareTypes(GBIBS: TIBSQL);
const nmProc = 'FillWareTypes'; // имя процедуры/функции
var Code: integer;
    flnew: Boolean;
begin
  if not Assigned(self) or not Assigned(GBIBS) then exit;
  try
    Code:= GetConstItem(pcWareTypeRootCode).IntValue;
    with GBIBS.Transaction do if not InTransaction then StartTransaction;
    GBIBS.SQL.Clear;
    GBIBS.ParamCheck:= False;
    GBIBS.SQL.Add('execute block returns (Rcode integer, Rname varchar(100))');
    GBIBS.SQL.Add('as declare variable xMasterCode integer='+IntToStr(Code)+';');
    GBIBS.SQL.Add('  declare variable xCode integer=0; declare variable xChild integer=0;');
    GBIBS.SQL.Add('  declare variable xStr varchar(10)="";');
    GBIBS.SQL.Add('  declare variable xStrCodes varchar(2048)=""; begin');
    GBIBS.SQL.Add('  while (xMasterCode>0) do begin');
    GBIBS.SQL.Add('    if (exists(select * from WARES where WAREMASTERCODE=:xMasterCode)) then begin');
    GBIBS.SQL.Add('      for select WARECODE, WAREOFFICIALNAME, WARECHILDCOUNT from WARES');
    GBIBS.SQL.Add('        where WAREMASTERCODE=:xMasterCode into :Rcode, :Rname, :xChild do begin');
    GBIBS.SQL.Add('        if (xChild>0) then begin');  // родительский запоминаем
    GBIBS.SQL.Add('          if (xStrCodes="") then xStrCodes = cast(Rcode as varchar(10));');
    GBIBS.SQL.Add('          else xStrCodes=xStrCodes||","||cast(Rcode as varchar(10));');
    GBIBS.SQL.Add('        end else suspend; end end'); // конечный передаем
    GBIBS.SQL.Add('    if (xStrCodes="") then xStr = ""; else begin ');
    GBIBS.SQL.Add('      xChild=position("," IN xStrCodes);');
    GBIBS.SQL.Add('      if (xChild<1) then begin xStr=xStrCodes; xStrCodes=""; end');
    GBIBS.SQL.Add('      else begin xStr=SUBSTRING(xStrCodes FROM 1 FOR xChild-1);');
    GBIBS.SQL.Add('        xStrCodes=SUBSTRING(xStrCodes FROM xChild+1); end end');
    GBIBS.SQL.Add('    if (xStr="") then xMasterCode=0;');
    GBIBS.SQL.Add('    else xMasterCode=cast(xStr as varchar(10)); end end');
    GBIBS.ExecQuery;
    while not GBIBS.Eof do begin
      Code:= GBIBS.FieldByName('Rcode').AsInteger;
      flnew:= true;
      if not TypeExists(Code) or not arWareInfo[Code].State then
        if TestCacheArrayItemExist(taWare, Code, flnew) then
          with arWareInfo[Code] do try
            CS_wares.Enter;
            IsType:= True;
            Name:= GBIBS.FieldByName('Rname').AsString;
            State:= True;
          finally
            CS_wares.Leave;
          end; // with arWareInfo[kType]
      GBIBS.Next;
    end;
  except
    on E:Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  GBIBS.Close;
end;
//======================================================== проверяем кэш товаров
procedure TDataCache.TestWares(flFill: Boolean=True);
const nmProc = 'TestWares'; // имя процедуры/функции/потока
var i, j, ii, jj, k, jm, jam, iGr, kGr, kPgr, iaGB, iaComm, iaOrd, jtop: integer;
    fl, flnew, fGrMoto, fGrAuto, fPgrMoto, fPgrAuto, fGrInfo, flDeliv: boolean;
    s, n,{ AnFilename,} ss: string;
    tmpar, tmpar1: Tai;
    ibs: TIBSQL;
    ibd: TIBDatabase;
    LocalStart: TDateTime;
//    LocStart: TDateTime;
    fs: TFileStream;
    Item: Pointer;
    ware, wareA: TWareInfo;
begin
  if not Assigned(self) then Exit;
  if flFill then s:= '_fill: ' else s:= '_test: ';
  LocalStart:= now();
//  LocStart:= now();
  ibd:= nil;
  ibs:= nil;
  fs:= nil;
  ware:= NoWare;
  iaGB  := 0;
  iaComm:= 0;
  iaOrd := 0;
  jtop:= 0;
  try try
    if not flFill then begin
      SetWaresNotTested; // сбрасываем флажки проверки
      MarginGroups.SetLinkStatesAll(False);
    end;

    ibd:= cntsGRB.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc);

    with IBS.Transaction do if not InTransaction then StartTransaction;
//    LocStart:= now();
    with WareBrands do begin //-------------------- заполняем / проверяем бренды
      if not flFill then SetDirStates(False);
      ibs.SQL.Text:= 'Select WRBDCODE, WRBDUPPERNAME from WAREBRANDS';
      ibs.ExecQuery;
      while not ibs.EOF do begin
        i:= ibs.FieldByName('WRBDCODE').AsInteger;
        n:= fnDelEndOfStr(ibs.FieldByName('WRBDUPPERNAME').AsString);
        Item:= TBrandItem.Create(i, n);
        CheckItem(Item);
        cntsGRB.TestSuspendException;
        ibs.Next;
      end;
      ibs.Close;
      if not flFill then DelDirNotTested;
      CheckLength;
    end;

//    prMessageLOGS('-------------------', fLogDebug, false); // пишем в log
//    prMessageLOGS(nmProc+': WareBrands - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log

    ibs.SQL.Text:= 'SELECT GEN_ID (WARECODEGEN, 0) FROM RDB$DATABASE';
    ibs.ExecQuery;
    i:= ibs.Fields[0].AsInteger;
    ibs.Close;
    TestCacheArrayLength(taWare, i+100); // проверяем длину массива

    FillWareTypes(ibs); // заполняем объекты типов товаров

//    LocStart:= now();
                         //--------------------------- группы, подгруппы, товары
    j:= 0;    // счетчик товаров
    jm:= 0;   // счетчик MOTO
    jam:= 0;  // счетчик AUTO & MOTO
    iGr:= 0;  // счетчик групп и подгрупп

    ss:= 'Select w.*, sl.rsalekey sale, mg.REmplCode, wg1.WRGRMASTERCODE as wtype,'+
//      ' bta.WrBsTpBusinessTypeCode as wAUTO, btm.WrBsTpBusinessTypeCode as wMOTO,'+
      ' iif(wg2.WRGRCODE is null, 0, 1) as wTOP,'+
      ' iif(wg3.WRGRCODE is null, 0, 1) as wCutPrice';
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      ss:= ss+ ' , cm'+n+'.RESULTVALUE priceEUR'+n;
    end;
    ss:= ss+' from (select WARECODE, WAREMEAS, WAREBONUS, WrPrProductDirection,'+ // ' WARESLASHCODE,'+
      '  WARESUPPLIERNAME, WAREDIVISIBLE, WAREOFFICIALNAME, WARECOMMENT,'+
      '  WAREMAINNAME, WAREBRANDCODE, KODPGR, pgrName, KODGR, KODTG, grName, IsDeliv'+
      '  from (select KODPGR, pgrName, KODGR, KODTG, grName, mastercode, IsDeliv'+
      '    from (select p2.KODPGR, w4.wareofficialname pgrName, g.KODTG,'+
      '      g.KODGR, w3.wareofficialname grName, p1.KODPGR mastercode, 0 IsDeliv'+
      '    from VLADPGR p1 left join VLADPGR p2 on p2.KODPGR=p1.pgrvlad'+
      '    left join VLADGR g on g.KODGR=p2.KODGR'+
      '    left join wares w3 on w3.warecode=g.KODGR'+
      '    left join wares w4 on w4.warecode=p2.KODPGR'+
      '  union select w1.warecode KODPGR, w1.wareofficialname pgrName,'+
      '    w1.waremastercode KODGR, '+IntToStr(codeTovar)+' KODTG,'+
      '    w2.wareofficialname grName, w1.warecode mastercode, 1 IsDeliv'+
      '    from wares w1 left join wares w2 on w2.warecode=w1.waremastercode'+
      '  where w1.warecode='+GetConstItem(pcDeliveriesMasterCode).StrValue+')'+
      ' order by KODGR, KODPGR)'+
      '   left join wares on waremastercode=mastercode'+
      '   left join WareProducts on wrprregistrcode=wareproductscode'+
      '   where not WareCode is null and WARECHILDCOUNT=0 and warearchive="F") w'+
//      ' left join WareBusinessTypes bta on bta.WrBsTpWareCode=w.warecode'+
//      '   and bta.WrBsTpBusinessTypeCode='+IntToStr(constIsAuto)+
//      ' left join WareBusinessTypes btm on btm.WrBsTpWareCode=w.warecode'+
//      '   and btm.WrBsTpBusinessTypeCode='+IntToStr(constIsMoto)+
      ' left join WAREGROUP wg1 on wg1.WRGRCLASSCODE='+
      GetConstItem(pcWareTypeClassCode).StrValue+' and wg1.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg2 on wg2.WRGRCLASSCODE='+
      GetConstItem(pcWareTOPClassCode).StrValue+' and wg2.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg3 on wg3.WRGRCLASSCODE='+
      GetConstItem(pcWareCutPriceClassCode).StrValue+' and wg3.WRGRWARECODE=w.WARECODE'+
      ' left join GetWareSaleKey(w.warecode, "TODAY") sl on 1=1'+
      ' left join GETWAREMANAGER(w.warecode, "TODAY") mg on 1=1'; // код менеджера
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      ss:= ss+ ' left join GETWAREPRICE("TODAY", w.warecode, '+IntToStr(PriceTypes[k])+
           ', w.waremeas) p'+n+' on 1=1'+
           ' left join ConvertMoney(p'+n+'.RPRICEWARE, p'+n+'.RCRNCCODE, '+
           cStrDefCurrCode+', "TODAY") cm'+n+
           ' on exists(select * from RateCrnc where RateCrncCode=p'+n+'.RCRNCCODE)';
    end;
    ibs.SQL.Text:= ss;
    ibs.ExecQuery;
    while not ibs.EOF do begin
      kGr:= ibs.FieldByName('KODGR').AsInteger; //-------------- группы (бренды)
      if not GrpExists(kGr) or not arWareInfo[kGr].State then begin
        flnew:= true;
        if TestCacheArrayItemExist(taWare, kGr, flnew) then
          with arWareInfo[kGr] do try
            CS_wares.Enter;
            IsGrp   := True;
            Name    := ibs.FieldByName('grName').AsString;
            PgrID   := ibs.FieldByName('KODTG').AsInteger;
            IsINFOgr:= (PgrID=codeInfo);
            TypeID  := ibs.FieldByName('wType').AsInteger;  // ???
            inc(iGr);
//if flDebug then prMessageLOGS('   группа '+fnMakeAddCharStr(Name, 100, True)+fnIfStr(TypeID>0,' - тип '+TypeName, ''), fLogDebug, false); // debug
          finally
            CS_wares.Leave;
          end; // with arWareInfo[kGr]
      end;
      if not GrpExists(kGr) then begin
        while not ibs.EOF and (kGr=ibs.FieldByName('KODGR').AsInteger) do ibs.Next;
        Continue;
      end;

      fGrInfo:= arWareInfo[kGr].IsINFOgr;
      flDeliv:= (ibs.FieldByName('IsDeliv').AsInteger=1);
      if not fGrInfo and not flDeliv then // пропускаем инфо и доставки
        MarginGroups.CheckGroup(kGr); // проверяем группу наценки

      fGrMoto:= False;
      fGrAuto:= False;
      while not ibs.EOF and (kGr=ibs.FieldByName('KODGR').AsInteger) do begin
        kPgr:= ibs.FieldByName('KODPGR').AsInteger; //---------------- подгруппы
        if not PgrExists(kPgr) or not arWareInfo[kPgr].State then begin
          flnew:= true;
          if TestCacheArrayItemExist(taWare, kPgr, flnew) then
            with arWareInfo[kPgr] do try
              CS_wares.Enter;
              IsPgr:= True;
              Name:= ibs.FieldByName('pgrName').AsString;
              PgrID:= kGr;
              IsINFOgr:= fGrInfo;
              TypeID  := ibs.FieldByName('wType').AsInteger;  // ???
//if flDebug then prMessageLOGS('подгруппа '+fnMakeAddCharStr(Name, 100, True)+fnIfStr(TypeID>0,' - тип '+TypeName, ''), fLogDebug, false); // debug
              inc(iGr);
            finally
              CS_wares.Leave;
            end; // with arWareInfo[kPgr]
        end;
        if not PgrExists(kPgr) then begin
          while not ibs.EOF and (kGr=ibs.FieldByName('KODGR').AsInteger)
            and (kPgr=ibs.FieldByName('KODPGR').AsInteger) do ibs.Next;
          Continue;
        end;

        if not fGrInfo and not flDeliv then // пропускаем доставки
          MarginGroups.CheckSubGroup(kGr, kPgr); // проверяем подгруппу наценки

        fPgrAUTO:= False;
        fPgrMOTO:= False;
        while not ibs.EOF and (kGr=ibs.FieldByName('KODGR').AsInteger)
          and (kPgr=ibs.FieldByName('KODPGR').AsInteger) do begin
          i:= ibs.FieldByName('WARECODE').AsInteger;
          flnew:= true;                     //--------------------------- товары
          if TestCacheArrayItemExist(taWare, i, flnew) then
            with arWareInfo[i] do try
              CS_wares.Enter;
//              SetWareTypeSys(0); // сбрасываем признаки AUTO / MOTO
              SetWareParams(kPgr, ibs);
              if IsMOTOWare then begin
                inc(jm);                     // счетчик MOTO
                if IsAUTOWare then inc(jam); // счетчик AUTO - MOTO
              end;
              if IsTop then inc(jtop);
              if IsAUTOWare and not fPgrAUTO then fPgrAUTO:= True;
              if IsMOTOWare and not fPgrMOTO then fPgrMOTO:= True;
              if flnew and AllowWebArm and not EmplExist(ManagerID) then // для WebArm
                prMessageLOGS('WareCode='+IntToStr(i)+' '+Name+' - not found WareManager'+
                  fnIfStr(ManagerID>0, ' EmplCode= '+IntToStr(ManagerID), ''),
                  'NotWareManager', false); // пишем в log (только при первичном заполнении)
              State:= True;
//prMessageLOGS(fnIfStr(IsINFOgr,' инфо ', '      ')+fnMakeAddCharStr(Name, 64, True)+
//  ' - тип '+fnMakeAddCharStr(TypeName, 40, True)+' comment '+Comment, fLogDebug, false); // debug
              inc(j);
              if (PgrID=pgrDeliv) and not DeliveriesList.Find(Name, ii) then
                DeliveriesList.AddObject(Name, Pointer(ID));
//              if IsPrize then begin
//                IsAUTOWare:= True;
//                IsMOTOWare:= True;
//              end;
            finally
              CS_wares.Leave;
            end; // with arWareInfo[i]
          cntsGRB.TestSuspendException;
          ibs.Next;
        end; // while ... (kGr=... and (kPgr=...

        with arWareInfo[kPgr] do try // признаки AUTO / MOTO подгруппы
          CS_wares.Enter;
//          SetWareTypeSys(0); // сбрасываем
          if fPgrAUTO then begin
            IsAUTOWare:= True;
            if not fGrAUTO then fGrAUTO:= True;
          end;
          if fPgrMOTO then begin
            IsMOTOWare:= True;
            if not fGrMOTO then fGrMOTO:= True;
          end;
          State:= True;
        finally
          CS_wares.Leave;
        end; // with arWareInfo[kPgr]
      end; // while ... and (kGr=...

      with arWareInfo[kGr] do try // признаки AUTO / MOTO группы
        CS_wares.Enter;
//        SetWareTypeSys(0); // сбрасываем
        IsAUTOWare:= fGrAUTO;
        IsMOTOWare:= fGrMOTO;
        State:= True;
      finally
        CS_wares.Leave;
      end;
    end;
    ibs.Close;
    MarginGroups.SortByName(-1); // сортировать все

    s:= s+IntToStr(iGr)+'г, '+IntToStr(j)+'т('+IntToStr(jm)+'m, '+IntToStr(jam)+'am, '+IntToStr(jtop)+'t), ';
//    prMessageLOGS(nmProc+': wares test - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log
//    LocStart:= now();

//----------------------------------------- товары за бонусы в невидимых группах
    ss:= 'Select w.WARECODE, w.WAREMEAS, w.WAREBONUS,'+  // ' WARESLASHCODE,'+
      '  w.WARESUPPLIERNAME, w.WAREDIVISIBLE, w.WAREOFFICIALNAME, w.WARECOMMENT,'+
      '  w.WAREMAINNAME, w.WAREBRANDCODE, 0 KODPGR, "" pgrName, 0 KODGR,'+
      IntToStr(codeTovar)+' KODTG, "" grName, 0 IsDeliv, WrPrProductDirection,'+
      ' sl.rsalekey sale, mg.REmplCode, wg1.WRGRMASTERCODE as wtype,'+
//      ' bta.WrBsTpBusinessTypeCode as wAUTO, btm.WrBsTpBusinessTypeCode as wMOTO'+
      ' iif(wg2.WRGRCODE is null, 0, 1) as wTOP,'+
      ' iif(wg3.WRGRCODE is null, 0, 1) as wCutPrice';
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      ss:= ss+ ' , cm'+n+'.RESULTVALUE priceEUR'+n;
    end;
    ss:= ss+' from wares w'+
        ' left join WareProducts on wrprregistrcode=w.wareproductscode'+
//      ' left join WareBusinessTypes bta on bta.WrBsTpWareCode=w.warecode'+
//      '   and bta.WrBsTpBusinessTypeCode='+IntToStr(constIsAuto)+
//      ' left join WareBusinessTypes btm on btm.WrBsTpWareCode=w.warecode'+
//      '   and btm.WrBsTpBusinessTypeCode='+IntToStr(constIsMoto)+
      ' left join WAREGROUP wg1 on wg1.WRGRCLASSCODE='+
      GetConstItem(pcWareTypeClassCode).StrValue+' and wg1.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg2 on wg2.WRGRCLASSCODE='+
      GetConstItem(pcWareTOPClassCode).StrValue+' and wg2.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg3 on wg3.WRGRCLASSCODE='+
      GetConstItem(pcWareCutPriceClassCode).StrValue+' and wg3.WRGRWARECODE=w.WARECODE'+
      ' left join GetWareSaleKey(w.warecode, "TODAY") sl on 1=1'+
      ' left join GETWAREMANAGER(w.warecode, "TODAY") mg on 1=1'; // код менеджера
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      ss:= ss+ ' left join GETWAREPRICE("TODAY", w.warecode, '+IntToStr(PriceTypes[k])+
        ', w.waremeas) p'+n+' on 1=1'+
        ' left join ConvertMoney(p'+n+'.RPRICEWARE, p'+n+'.RCRNCCODE, '+
        cStrDefCurrCode+', "TODAY") cm'+n+
        ' on exists(select * from RateCrnc where RateCrncCode=p'+n+'.RCRNCCODE)';
    end;
    ss:= ss+' where w.WARECHILDCOUNT=0 and w.warearchive="F" and w.warebonus="T"'+
            ' and not exists(select * from VLADPGR where KODPGR=w.waremastercode)';
    ibs.SQL.Text:= ss;
    ibs.ExecQuery;
    ii:= 0;
    while not ibs.EOF do begin
      i:= ibs.FieldByName('WARECODE').AsInteger;
      flnew:= true;
      if TestCacheArrayItemExist(taWare, i, flnew) then
        with arWareInfo[i] do try
          CS_wares.Enter;
//          SetWareTypeSys(0); // сбрасываем признаки AUTO / MOTO
          SetWareParams(0, ibs); // в фиктивную группу
//          IsAUTOWare:= True;
//          IsMOTOWare:= True;
          inc(ii);
          State:= True;
        finally
          CS_wares.Leave;
        end; // with arWareInfo[i]

      cntsGRB.TestSuspendException;
      ibs.Next;
    end; // while ...
    ibs.Close;

    if not flFill then begin // удаляем непроверенные элементы
      DelNotTestedItems;
      MarginGroups.DelNotTestedLinksAll;
    end;
    cntsGRB.TestSuspendException;
    //------------------------------------------- односторонние аналоги Grossbee
    SetWaresNotTested; // сбрасываем флажки проверки товаров и аналогов   ???
    with ibs.Transaction do if not InTransaction then StartTransaction;
    ibs.SQL.Text:= 'Select PMWAWARECODE, PMWAWAREANALOGCODE, (AnDtSyncCode-'+
      Cache.GetConstItem(pcCrossAnalogsDeltaSync).StrValue+') SrcCode'+
      ' from PMWAREANALOGS left join AnalitDict on ANDTCODE=PMWASOURCECODE'+
      ' left join wares w1 on w1.warecode=PMWAWARECODE'+
      ' left join wares w2 on w2.warecode=PMWAWAREANALOGCODE'+
      ' where PMWAISWRONG="F" and w1.warearchive="F" and w2.warearchive="F"'+
      ' order by PMWAWARECODE';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.FieldByName('PMWAWARECODE').AsInteger;
      fl:= WareExist(i);
      if fl then begin
        ware:= arWareInfo[i];
        fl:= (not ware.IsArchive) and Assigned(ware.AnalogLinks);
      end;
      while not ibs.Eof and (i=ibs.FieldByName('PMWAWARECODE').AsInteger) do begin
        if not fl then begin
          ibs.Next;
          Continue;
        end;
        j:= ibs.FieldByName('PMWAWAREANALOGCODE').AsInteger;
        if not WareExist(j) then begin
          ibs.Next;
          Continue;
        end;
        wareA:= arWareInfo[j];
        if wareA.IsArchive or not wareA.IsMarketWare then begin
          ibs.Next;
          Continue;
        end;                         // добавить код в аналоги, если его там нет
        ware.CheckAnalogLink(j, ibs.FieldByName('SrcCode').AsInteger);
        ibs.Next;
      end;
      cntsORD.TestSuspendException;
    end;
    if ibs.Transaction.InTransaction then ibs.Transaction.Rollback;
    ibs.Close;

    for i:= High(arWareInfo) downto 1 do if Assigned(arWareInfo[i]) then
      with arWareInfo[i] do if Assigned(AnalogLinks) and (AnalogLinks.LinkCount>0) then begin
        if not flFill then DelNotTestedAnalogs(True, True); // удаляем непроверенные аналоги-кроссы
        SortAnalogsByName; // сортировка аналогов по наименованию
        if flFill then for j:= 0 to AnalogLinks.LinkCount-1 do
          with TAnalogLink(AnalogLinks.ListLinks[j]) do // распределение аналогов
            if IsOldAnalog and IsCross then inc(iaComm)
            else if IsOldAnalog then inc(iaGB) else if IsCross then inc(iaOrd);
        end; // AnalogLinks

    ii:= Length(arWareInfo);
    for i:= High(arWareInfo) downto 1 do if Assigned(arWareInfo[i]) then begin
      ii:= arWareInfo[i].ID+1;
      break;
    end;
    if Length(arWareInfo)>ii then try
      CS_wares.Enter;
      SetLength(arWareInfo, ii); // обрезаем по мах.коду
    finally
      CS_wares.Leave;
    end;
  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  finally
    prFreeIBSQL(ibs);
    cntsGRB.SetFreeCnt(ibd, True);
    SetLength(tmpar, 0);
    SetLength(tmpar1, 0);
    if Assigned(fs) then begin
      fs.Position:= 0;
      prFree(fs);
    end;
  end;

  try try
    ibd:= cntsORD.GetFreeCnt; // из dbOrder
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, True);
    //--------------------------------------------------------- бренды для сайта
    with WareBrands do begin
      SetDirStates(False);
      ibs.SQL.Text:= 'Select BRADCODE, BRADNAMEWWW, BRADprefix, BRADaddress,'+
                     ' BRADNotPriceLoad from BRANDADDITIONDATA';
      ibs.ExecQuery;
      while not ibs.Eof do begin
        i:= ibs.FieldByName('BRADCODE').AsInteger;
        if ItemExists(i) then begin
          n:= ibs.FieldByName('BRADNAMEWWW').AsString;
          with TBrandItem(DirItems[i]) do begin
            if flFill or (NameWWW<>n) then NameWWW:= n;
            ss:= ibs.FieldByName('BRADprefix').AsString;
            if flFill or (WarePrefix<>ss) then WarePrefix:= ss;
            ss:= ibs.FieldByName('BRADaddress').AsString;
            if flFill or (adressWWW<>ss) then adressWWW:= ss;
            DownLoadExclude:= GetBoolGB(ibs, 'BRADNotPriceLoad');
            State:= True;
          end;
        end;
        cntsORD.TestSuspendException;
        ibs.Next;
      end;
      ibs.Close;
      for i:= 0 to ItemsList.Count-1 do with TBrandItem(ItemsList[i]) do
        if not State then begin
          NameWWW:= '';
          WarePrefix:= '';
          adressWWW:= '';
          DownLoadExclude:= False;
        end;
      //------------------------------------------- коды брендов TecDoc - WebArm
      if AllowWebArm then begin
        SetDirStates(False);
        with ibs.Transaction do if not InTransaction then StartTransaction;
        ibs.SQL.Text:= 'Select BRRPGBCODE, BRRPTDCODE from BRANDREPLACE order by BRRPGBCODE';
        ibs.ExecQuery;
        while not ibs.EOF do begin
          i:= ibs.FieldByName('BRRPGBCODE').AsInteger;
          SetLength(tmpar, 0);
          while not ibs.EOF and (i=ibs.FieldByName('BRRPGBCODE').AsInteger) do begin
            ii:= ibs.FieldByName('BRRPTDCODE').AsInteger;
            jj:= BrandTDList.IndexOfObject(Pointer(ii));
            if jj>-1 then prAddItemToIntArray(ii, tmpar);
            cntsORD.TestSuspendException;
            ibs.Next;
          end;
          if ItemExists(i) then with TBrandItem(DirItems[i]) do try
            CS_DirItems.Enter;
            if Length(FTDMFcodes)<>Length(tmpar) then
              SetLength(FTDMFcodes, Length(tmpar));
            for i:= 0 to High(tmpar) do
              if FTDMFcodes[i]<>tmpar[i] then FTDMFcodes[i]:= tmpar[i];
            State:= True;
          finally
            CS_DirItems.Leave;
          end;
        end;
        ibs.Close;
        for i:= 0 to ItemsList.Count-1 do with TBrandItem(ItemsList[i]) do
          if not State and (Length(FTDMFcodes)>0) then try
            CS_DirItems.Enter;
            SetLength(FTDMFcodes, 0);
          finally
            CS_DirItems.Leave;
          end;
      end; // if AllowWebArm
    end;

    //--------------------------------------------------------- артикулы  TecDoc
    if not flFill then SetWaresNotTested; // сбрасываем флажки проверки товаров
    ibs.SQL.Text:= 'Select WATDWARECODE, WATDArtSup, WATDArticle from WareArticleTD'+
      ' where WATDWRONG="F"';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.FieldByName('WATDWARECODE').AsInteger;
      if WareExist(i) then with arWareInfo[i] do if not IsArchive then try
        CS_wlinks.Enter;
        if flFill or (ArticleTD<>ibs.FieldByName('WATDARTICLE').AsString) then
          ArticleTD:= ibs.FieldByName('WATDARTICLE').AsString; // Article TecDoc
        if flFill or (ArtSupTD<>ibs.FieldByName('WATDArtSup').AsInteger) then
          ArtSupTD:= ibs.FieldByName('WATDArtSup').AsInteger;  // SupID TecDoc (DS_MF_ID !!!)
        State:= True;
      finally
        CS_wlinks.Leave;
      end;
      cntsORD.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    if not flFill then for i:= High(arWareInfo) downto 1 do if Assigned(arWareInfo[i]) then
      with arWareInfo[i] do if not State and ((ArticleTD<>'') or (ArtSupTD>0)) then try
        CS_wlinks.Enter;
        ArticleTD:= '';
        ArtSupTD:= 0;
      finally
        CS_wlinks.Leave;
      end;

    SetWaresNotTested; // сбрасываем флажки проверки товаров
    //----------------------------------------------------- сопутствующие товары
    ibs.SQL.Text:= 'Select LWSWARECODE, LWSSatel, LWSSRCCODE from LinkWareSatellites'+
      ' where LWSWRONG="F" order by LWSWARECODE';
    ibs.ExecQuery;
    while not ibs.Eof do begin
      i:= ibs.FieldByName('LWSWARECODE').AsInteger;
      fl:= WareExist(i);
      if fl then with arWareInfo[i] do
        fl:= (not IsArchive) and (not IsInfoGr) and Assigned(SatelLinks);
      while not ibs.Eof and (i=ibs.FieldByName('LWSWARECODE').AsInteger) do begin
        if fl then begin
          j:= ibs.FieldByName('LWSSatel').AsInteger;
          flnew:= WareExist(j);
          if flnew then with arWareInfo[j] do // проверяем инфо и систему
            flnew:= (not IsArchive) and (not IsInfoGr) and CheckWaresEqualSys(i, j);
          if flnew then arWareInfo[i].SatelLinks.CheckLink(j, // добавить линк, если его нет
            ibs.FieldByName('LWSSRCCODE').AsInteger, arWareInfo[j]);
        end;
        ibs.Next;
      end;
      cntsORD.TestSuspendException;
    end;
    ibs.Close;

    for i:= High(arWareInfo) downto 1 do if Assigned(arWareInfo[i]) then
      with arWareInfo[i] do
        if Assigned(SatelLinks) and (SatelLinks.LinkCount>0) then begin
          if not flFill then SatelLinks.DelNotTestedLinks; // удаляем непроверенные сопут.товары
          SatelLinks.SortByLinkName;
        end; // SatelLinks

//    if flFill then prMessageLOGS('аналоги - GB/ORD='+IntToStr(iaComm)+
//      ' GB='+IntToStr(iaGB)+' ORD='+IntToStr(iaOrd), fLogCache, false); // пишем в log

//-------------------------------------------------------- проверяем WareOptions
    SetLength(tmpar, 0);   // коды Update WOArhived='F'
    SetLength(tmpar1, 0);  // коды для Update WOArhived='T'
    j:= 0;  // счетчик для tmpar
    jj:= 0;  // счетчик для tmpar1
    ss:= '';
    ibs.SQL.Text:= 'Select WOWARECODE, WOArhived, woHasModAuto, woHasModMoto'+
      ' from WareOptions order by WOWARECODE, WOArhived';
    ibs.ExecQuery; // проверяем те коды, что уже есть в WareOptions
    while not ibs.Eof do begin
      i:= ibs.FieldByName('WOWARECODE').AsInteger;
      fl:= GetBoolGB(ibs, 'WOArhived');

      if WareExist(i) then begin
        if fl and not arWareInfo[i].IsArchive then begin
          if High(tmpar)<j then SetLength(tmpar, j+1000);
          tmpar[j]:= i;
          inc(j);
        end else if not fl and arWareInfo[i].IsArchive then begin
          if High(tmpar1)<jj then SetLength(tmpar1, jj+1000);
          tmpar1[jj]:= i;
          inc(jj);
        end;

        with arWareInfo[i] do try
          CS_wares.Enter;
          if not arWareInfo[i].IsArchive then begin
            HasModelAuto:= GetBoolGB(ibs, 'woHasModAuto');
            HasModelMoto:= GetBoolGB(ibs, 'woHasModMoto');
          end;
          State:= True;
        finally
          CS_wares.Leave;
        end; // with arWareInfo[i]

      end else if not fl then begin
        if High(tmpar1)<jj then SetLength(tmpar1, jj+1000);
        tmpar1[jj]:= i;
        inc(jj);
      end;

      cntsORD.TestSuspendException;
      ibs.Next;
    end;
    ibs.Close;
    fnSetTransParams(ibs.Transaction, tpWrite);

    if j>0 then begin // снимаем признак архивности в WareOptions
      with ibs.Transaction do if not InTransaction then StartTransaction;
      ibs.SQL.Text:= 'update WareOptions set WOArhived="F" where WOWARECODE=:WARECODE';
      for i:= 0 to j-1 do begin
        with ibs.Transaction do if not InTransaction then StartTransaction;
        ibs.ParamByName('WARECODE').AsInteger:= tmpar[i];
        for ii:= 0 to RepeatCount do with IBS.Transaction do try
          IBS.Close;
          if not InTransaction then StartTransaction;
          IBS.ExecQuery;
          Commit;
          break;
        except
          on E: Exception do begin
            RollbackRetaining;
            if (ii<RepeatCount) then sleep(RepeatSaveInterval)
            else prMessageLOGS(nmProc+'(upd_F/'+IntToStr(tmpar[i])+'): '+E.Message, fLogCache);
          end;
        end;
      end;
      ss:= ss+' upd_F='+intToStr(j);
      ibs.Close;
    end;

    if jj>0 then begin // проставляем признак архивности в WareOptions
      with ibs.Transaction do if not InTransaction then StartTransaction;
      ibs.SQL.Text:= 'update WareOptions set WOArhived="T" where WOWARECODE=:WARECODE';
      for i:= 0 to jj-1 do begin
        with ibs.Transaction do if not InTransaction then StartTransaction;
        ibs.ParamByName('WARECODE').AsInteger:= tmpar1[i];
        for ii:= 0 to RepeatCount do with IBS.Transaction do try
          IBS.Close;
          if not InTransaction then StartTransaction;
          IBS.ExecQuery;
          Commit;
          break;
        except
          on E: Exception do begin
            RollbackRetaining;
            if (ii<RepeatCount) then sleep(RepeatSaveInterval)
            else prMessageLOGS(nmProc+'(upd_T/'+IntToStr(tmpar1[i])+'): '+E.Message, fLogCache);
          end;
        end;
      end;
      ibs.Close;
      ss:= ss+' upd_T='+intToStr(jj);
    end;

    SetLength(tmpar, 0);   // коды для Insert
    SetLength(tmpar1, 0);  // признаки архивности для Insert
    j:= 0;  // счетчик для tmpar
    for i:= 1 to High(arWareInfo) do // проверяем добавление в WareOptions
      if WareExist(i) and not arWareInfo[i].State then begin
        if High(tmpar)<j then begin
          SetLength(tmpar, j+1000);
          SetLength(tmpar1, j+1000);
        end;
        tmpar[j]:= i;
        tmpar1[j]:= fnIfInt(arWareInfo[i].IsArchive, 1, 0);
        inc(j);
      end;
    if j>0 then begin // добавляем в WareOptions
      with ibs.Transaction do if not InTransaction then StartTransaction;
      ibs.SQL.Text:= 'insert into WareOptions (WOWARECODE, WOArhived) values (:WARECODE, :Arhived)';
      for i:= 0 to j-1 do begin
        with ibs.Transaction do if not InTransaction then StartTransaction;
        ibs.ParamByName('WARECODE').AsInteger:= tmpar[i];
        ibs.ParamByName('Arhived').AsString:= fnIfStr(tmpar1[i]=1, 'T', 'F');
        for ii:= 0 to RepeatCount do with IBS.Transaction do try
          IBS.Close;
          if not InTransaction then StartTransaction;
          IBS.ExecQuery;
          Commit;
          break;
        except
          on E: Exception do begin
            RollbackRetaining;
            if (ii<RepeatCount) then sleep(RepeatSaveInterval)
            else prMessageLOGS(nmProc+'(ins/'+IntToStr(tmpar[i])+'): '+E.Message, fLogCache);
          end;
        end;
      end;
      ibs.Close;
      ss:= ss+' ins='+intToStr(j);
    end;
    if flFill and (ss<>'') then prMessageLOGS('WareOptions - '+ss, fLogCache, false); // пишем в log
//--------------------------------------------------------
//    prMessageLOGS(nmProc+': ADDITIONDATA - '+GetLogTimeStr(LocStart), fLogDebug, false); // пишем в log

    // очистить непроверенные !!!

  except
    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  finally
    SetLength(tmpar, 0);
    SetLength(tmpar1, 0);
    prFreeIBSQL(ibs);
    cntsORD.SetFreeCnt(ibd, True);
  end;
  prMessageLOGS(nmProc+s+' - '+GetLogTimeStr(LocalStart), fLogCache, false); // пишем в log
  TestCssStopException;
end;
//==============================================================================
function TDataCache.GetWare(WareID: integer; OnlyCache: Boolean=False): TWareInfo;
// возвращает параметры товара (если в кэше его нет - заносит в кэш с PgrID=0)
const nmProc = 'GetWare'; // имя процедуры/функции/потока
var ibs: TIBSQL;
    ibd: TIBDatabase;
    fl: boolean;
    k: Integer;
    n, ss, s: String;
begin
  Result:= NoWare;
  if not Assigned(self) then Exit;
  if WareExist(WareID) then begin
    Result:= Cache.arWareInfo[WareID];
    Exit;
  end;
  if OnlyCache then Exit;
  ibd:= nil;
  ibs:= nil;
  fl:= True;
  try try
    ibd:= cntsGRB.GetFreeCnt;
    ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, WareID, tpRead, True);
    ss:= 'Select w.WAREOFFICIALNAME, w.WAREMEAS, w.WAREDIVISIBLE, w.waremastercode,'+ //' w.WARESLASHCODE,'+
      ' w.WARESUPPLIERNAME, w.warearchive, W.WARECOMMENT, w.WAREBRANDCODE, w.WAREMAINNAME,'+
      ' pg.PGRvlad KODPGR, sl.rsalekey sale, mg.REmplCode, wg1.WRGRMASTERCODE as wtype,'+
      ' WrPrProductDirection, iif(wg2.WRGRCODE is null, 0, 1) as wTOP, W.WAREBONUS,'+
//      ' bta.WrBsTpBusinessTypeCode as wAUTO, btm.WrBsTpBusinessTypeCode as wMOTO,'+
      ' iif(wg3.WRGRCODE is null, 0, 1) as wCutPrice';
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      ss:= ss+ ' , cm'+n+'.RESULTVALUE priceEUR'+n;
    end;
    ss:= ss+' from wares w'+
      ' left join VLADPGR pg on pg.KODPGR=w.waremastercode and w.WARECHILDCOUNT=0'+
      ' left join GetWareSaleKey(w.warecode, "TODAY") sl on 1=1'+
      ' left join GETWAREMANAGER(w.warecode, "TODAY") mg on 1=1'+ // код менеджера
        ' left join WareProducts on wrprregistrcode=w.wareproductscode'+
//      ' left join WareBusinessTypes bta on bta.WrBsTpWareCode=w.warecode'+
//      '   and bta.WrBsTpBusinessTypeCode='+IntToStr(constIsAuto)+
//      ' left join WareBusinessTypes btm on btm.WrBsTpWareCode=w.warecode'+
//      '   and btm.WrBsTpBusinessTypeCode='+IntToStr(constIsMoto)+
      ' left join WAREGROUP wg1 on wg1.WRGRCLASSCODE='+
      GetConstItem(pcWareTypeClassCode).StrValue+' and wg1.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg2 on wg2.WRGRCLASSCODE='+
      GetConstItem(pcWareTOPClassCode).StrValue+' and wg2.WRGRWARECODE=w.WARECODE'+
      ' left join WAREGROUP wg3 on wg3.WRGRCLASSCODE='+
      GetConstItem(pcWareCutPriceClassCode).StrValue+' and wg3.WRGRWARECODE=w.WARECODE';
    for k:= 0 to High(PriceTypes) do begin
      if k=0 then n:= '' else n:= IntToStr(k);
      s:= IntToStr(PriceTypes[k]);
      ss:= ss+ ' left join GETWAREPRICE("TODAY", w.warecode, '+s+', w.waremeas) p'+n+' on 1=1'+
        ' left join ConvertMoney(p'+n+'.RPRICEWARE, p'+n+'.RCRNCCODE, '+cStrDefCurrCode+', "TODAY") cm'+n+
        ' on exists(select * from RateCrnc where RateCrncCode=p'+n+'.RCRNCCODE)';
    end;
    ibs.SQL.Text:= ss+' where w.WARECODE='+IntToStr(WareID);
    ibs.ExecQuery;
    if (ibs.Bof and ibs.Eof) then Exit;
    if not TestCacheArrayItemExist(taWare, WareID, fl) then Exit;
    Result:= arWareInfo[WareID];
    with Result do try
      CS_wares.Enter;
      k:= ibs.FieldByName('waremastercode').AsInteger;
      if (k<>GetConstItem(pcDeliveriesMasterCode).IntValue) then
        k:= ibs.FieldByName('KODPGR').AsInteger;
      SetWareParams(k, ibs, True);
//      if IsPrize then begin
//        IsAUTOWare:= True;
//        IsMOTOWare:= True;
//      end;
      State:= True;
    finally
      CS_wares.Leave;
    end;
  finally
    prFreeIBSQL(ibs);
    cntsGRB.SetFreeCnt(ibd);
  end;
  except
//    on E: EBOBError do raise EBOBError.Create(nmProc+': '+E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;
//=========================================== сбрасываем флажки проверки товаров
procedure TDataCache.SetWaresNotTested;
var i: integer;
begin
  if not Assigned(self) then Exit;
  for i:= 1 to High(arWareInfo) do // сбросить признак проверки товара, группы, подгруппы
    if Assigned(arWareInfo[i]) then with arWareInfo[i] do begin
      State:= False;
      if assigned(AnalogLinks) then AnalogLinks.SetLinkStates(False); // сбрасываем признаки проверки аналогов
      if assigned(SatelLinks) then SatelLinks.SetLinkStates(False); // сбрасываем признаки проверки сопут.товаров
    end;
end;
//================================= убираем не проверенные элементы кэша товаров
procedure TDataCache.DelNotTestedItems;
var i: Integer;
begin
  if not Assigned(self) then Exit;
  for i:= 1 to High(arWareInfo) do if Assigned(arWareInfo[i]) then
    with arWareInfo[i] do if (not IsArchive) and (not State) then begin // если не проверен
      PgrID:= 0;                 // переносим в архив
      IsArchive:= True;
      ClearOpts;                 // очищаем связи
    end;
end;
//=================================== поиск товаров по набору значений атрибутов
function TDataCache.SearchWaresByAttrValues(attCodes, valCodes: Tai): Tai; // must Free
// возвращает массив кодов товаров, отсортированных по наименованию
const nmProc='SearchWaresByAttrValues';
var i: integer;
    lnk: TTwoLink;
  //---------------------- проверяем совпадение всех значений заданных атрибутов
  function fnAttrValEquals(aLinks: TLinks): Boolean;
  var ii: integer;
  begin
    Result:= False;
    for ii:= 0 to High(attCodes) do begin
      if not aLinks.LinkExists(attCodes[ii]) then exit;
      lnk:= aLinks[attCodes[ii]];
      if not assigned(lnk.LinkPtrTwo) then exit;
      if (lnk.LinkTwoID<>valCodes[ii]) then exit;
    end;
    Result:= True;
  end;
  //--------------------------------------
begin
  SetLength(Result, 0);
  if not Assigned(self) then Exit;
  if (length(attCodes)<1) or (length(valCodes)<length(attCodes)) then Exit;
  with fnCreateStringList(False, 100) do try
    for i:= 1 to High(arWareInfo) do if WareExist(i) then with GetWare(i) do
      if not IsArchive and (PgrID>0) and (PgrID<>pgrDeliv) // пропускаем доставки
        and (AttrLinks.LinkCount>0) and fnAttrValEquals(AttrLinks) then
        AddObject(Name, pointer(i));
    if Count>1 then Sort;
    SetLength(Result, Count);
    for i:= 0 to Count-1 do Result[i]:= integer(Objects[i]);
  finally Free; end;
end;
//================================================= поиск товаров по артикулу TD
function TDataCache.SearchWaresByTDSupAndArticle(pSup: Integer; pArticle: String; // must Free
                                                 notInfo: Boolean=False): TStringList;
// возвращает массив кодов товаров, отсортированных по наименованию
// notInfo=True - только не-ИНФО товары
const nmProc='SearchWaresByTDSupAndArticle';
var i: integer;
    Ware: TWareInfo;
begin
  Result:= fnCreateStringList(False, 10);
  if not Assigned(self) then Exit;
  if (pSup<1) or (pArticle='') then Exit;
  for i:= 1 to High(arWareInfo) do if WareExist(i) then begin
    Ware:= GetWare(i);
    if Ware.IsArchive or (Ware.PgrID<1) then Continue;
    if (Ware.PgrID=pgrDeliv) then Continue; // пропускаем доставки
    if notInfo and Ware.IsINFOgr then Continue;
    if (Ware.ArticleTD<>pArticle) or (pSup<>Ware.ArtSupTD) then Continue;
    Result.AddObject(Ware.Name, pointer(i));
  end;
  if Result.Count>1 then Result.Sort;
end;
//======== сортировка TList - приоритет desc + дата начала desc + дата окончания
function InfoBoxItemsSortCompare(Item1, Item2: Pointer): Integer;
var ib1, ib2: TInfoBoxItem;
begin
  try
    ib1:= Item1;
    ib2:= Item2;
    if ib1.Priority=ib2.Priority then begin
      if (ib1.DateFrom=ib2.DateFrom) then begin
        if (ib1.DateTo=ib2.DateTo) then Result:= 0
        else if (ib1.DateTo>ib2.DateTo) then Result:= 1 else Result:= -1;
      end else if (ib1.DateFrom<ib2.DateFrom) then Result:= 1 else Result:= -1;
    end else if (ib1.Priority<ib2.Priority) then Result:= 1 else Result:= -1;
  except
    Result:= 0;
  end;
end;
//======================================================== Заполнение инфо-блока
procedure TDataCache.FillInfoNews(flFill: Boolean=True);
const nmProc='FillInfoNews';
var ORD_IBD: TIBDatabase;
    ibs: TIBSQL;
    dd1, dd2: TDateTime;
    i, j: Integer;
    s: String;
    inItem: TInfoBoxItem;
    Item: Pointer;
    fl: Boolean;
begin
  if not Assigned(self) then Exit;
  if not AllowWeb then Exit; // заполняем только для Web
  IBS:= nil;
  try
    if not flFill then InfoNews.SetDirStates(False);
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ibs:= fnCreateNewIBSQL(ORD_IBD, 'ibs_'+nmProc, -1, tpRead, true);
      ibs.SQL.Text:= 'SELECT * from InfoBoxViews where ("TODAY" between ibvDateFrom and ibvDateTo)';
      ibs.ExecQuery;
      while not ibs.Eof do begin
        i:= ibs.fieldByName('ibvCODE').AsInteger; // код
        s:= ibs.fieldByName('ibvTitle').AsString; // заголовок
        j:= ibs.fieldByName('ibvPriority').AsInteger;
        if not InfoNews.ItemExists(i) then begin
          Item:= TInfoBoxItem.Create(i, 0, j, s);
          InfoNews.CheckItem(Item); // здесь inItem.State=True
        end;
        inItem:= InfoNews[i];
        if not inItem.State then begin
          if (inItem.Title<>s)    then inItem.Title:= s;    // заголовок
          if (inItem.Priority<>j) then inItem.Priority:= j; // приоритет
        end;
        dd1:= ibs.fieldByName('ibvDateFrom').AsDateTime;    // дата начала
        if inItem.DateFrom<>dd1 then inItem.DateFrom:= dd1;
        dd2:= ibs.fieldByName('ibvDateTo').AsDateTime;      // дата окончания
        if inItem.DateTo<>dd2   then inItem.DateTo:= dd2;
        fl:= GetBoolGB(ibs, 'ibvVisible');                  // показывать в окне
        if inItem.InWindow<>fl then inItem.InWindow:= fl;
        fl:= GetBoolGB(ibs, 'ibvVisAuto');                  // видимость для системы авто
        if inItem.VisAuto<>fl then inItem.VisAuto:= fl;
        fl:= GetBoolGB(ibs, 'ibvVisMoto');                  // видимость для системы мото
        if inItem.VisMoto<>fl then inItem.VisMoto:= fl;
        s:= ibs.fieldByName('ibvLinkToSite').AsString;      // ссылка на сайт / окно описания
        if inItem.LinkToSite<>s then inItem.LinkToSite:= s;
        s:= ibs.fieldByName('ibvLinkToPict').AsString;      // ссылка на рисунок
        if inItem.LinkToPict<>s then inItem.LinkToPict:= s;
        if not inItem.State then inItem.State:= True;
        cntsOrd.TestSuspendException;
        ibs.Next;
      end;
      ibs.Close;
    finally
      prFreeIBSQL(ibs);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    if not flFill then InfoNews.DelDirNotTested;
    InfoNews.CheckLength;
    InfoNews.DirSort(InfoBoxItemsSortCompare);
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  TestCssStopException;
end;
//============================================ Заполнение / проверка уведомлений
procedure TDataCache.FillNotifications(fFill: Boolean=True);
const nmProc = 'FillNotifications'; // имя процедуры/функции
var noteID: Integer;
    sText: String;
    IBS: TIBSQL;
    IBD: TIBDatabase;
    flAdd, flNew, flAuto, flMoto: Boolean;
    item: Pointer;
    noteItem: TNotificationItem;
    pBegDate, pEndDate: TDateTime;
begin
  if not Assigned(self) then Exit;
  if not AllowWeb then Exit; // заполняем только для Web
  IBS:= nil;
  try
    if not fFill then Notifications.SetDirStates(False);
    IBD:= CntsORD.GetFreeCnt;
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, -1, tpRead, True);
      IBS.SQL.Text:= 'select NoteCODE, NoteBegDate, NoteEndDate, NoteText, NoteFilials,'+
        ' NoteClasses, NoteTypes, NoteFirms, NOTEFIRMSADDFLAG, NOTEauto, NOTEmoto from Notifications'+
        ' where NoteArchived="F" and ("TODAY" between NoteBegDate and NoteEndDate)';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        noteID  := IBS.FieldByName('NoteCODE').AsInteger;     // код уведомления
        pBegDate:= IBS.FieldByName('NoteBegDate').AsDateTime; // дата начала
        pEndDate:= IBS.FieldByName('NoteEndDate').AsDateTime; // дата окончания
        sText   := IBS.FieldByName('NoteText').AsString;      // текст уведомления
        flAdd   := GetBoolGB(ibs, 'NOTEFIRMSADDFLAG');        // флаг - добавлять/исключать коды Firms
        flAuto  := GetBoolGB(ibs, 'NOTEauto');                // флаг  рассылки к/а с авто-контрактами
        flMoto  := GetBoolGB(ibs, 'NOTEmoto');                // флаг рассылки к/а с мото-контрактами
        flNew:= not Notifications.ItemExists(noteID);
        if flNew then begin // новый
          item:= TNotificationItem.Create(noteID, sText);
          Notifications.CheckItem(item); // здесь State=True
          noteItem:= item;
        end else noteItem:= Notifications[noteID];
        Notifications.CS_DirItems.Enter;
        with noteItem do try      //--------- проверяем
          if not flNew then begin
            Name:= sText;
            State:= True;
          end;
          BegDate   := pBegDate;
          EndDate   := pEndDate;
          flFirmAdd := flAdd;
          flFirmAuto:= flAuto;
          flFirmMoto:= flMoto;
          CheckConditions(IBS.FieldByName('NoteFilials').AsString, // коды филиалов к/а
                          IBS.FieldByName('NoteClasses').AsString, // коды категорий к/а
                          IBS.FieldByName('NoteTypes').AsString,   // коды типов к/а
                          IBS.FieldByName('NoteFirms').AsString);  // коды  к/а
        finally
          Notifications.CS_DirItems.Leave;
        end;
        cntsOrd.TestSuspendException;
        IBS.Next;
      end;
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD);
    end;
    if not fFill then Notifications.DelDirNotTested;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  TestCssStopException;
end;
//========================================================= Заполнение атрибутов
procedure TDataCache.FillAttributes;
const nmProc='FillAttributes';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    parID, pID, pdID, psID, j, iZero: Integer;
//    parID, pID, pdID, psID, ind, grID, j, iZero: Integer;
    pName, s: String;
    attg: TAttrGroupItem;
    attr: TAttributeItem;
    attv: TDirItem;
    TimeProc: TDateTime;
    Item: Pointer;
    ordN: word;
    ware: TWareInfo;
    fl: Boolean;
begin
  if not Assigned(self) then Exit;
  TimeProc:= Now;
  iZero:= 0;
  ORD_IBS:= nil;
  ware:= NoWare;
  try
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
  //---------------------------------- проверяем неиспользуемые значения атрибутов
      ORD_IBS.SQL.Text:= 'select ATVLCODE from ATTRVALUES'+
        ' where not exists(select * from LINKWAREATTRVAL where LWAWATVLCODE=ATVLCODE)';
      ORD_IBS.ExecQuery;
      if not (ORD_IBS.Eof and ORD_IBS.Bof) then iZero:= 1;
      ORD_IBS.Close;
      if iZero>0 then begin // чистим неиспользуемые значения
        fnSetTransParams(ORD_IBS.Transaction, tpWrite, True);
        ORD_IBS.SQL.Text:= 'delete from ATTRVALUES'+
          ' where not exists(select * from LINKWAREATTRVAL where LWAWATVLCODE=ATVLCODE)';
        ORD_IBS.ExecQuery;
        ORD_IBS.Transaction.Commit;
        ORD_IBS.Close;
        fnSetTransParams(ORD_IBS.Transaction, tpRead);
      end;

      with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
      ORD_IBS.SQL.Text:= 'select ATGRDTSYCODE, ATGRCODE, ATGRNAME'+
        ', iif(ATGRORDERNUM is null, 99, ATGRORDERNUM) as ATGRORDERNUM'+
        ' from ATTRGROUPS order by ATGRORDERNUM, ATGRNAME'; // сортируем по порядк.№ + наименованию
      ORD_IBS.ExecQuery;
      with AttrGroups do begin // Заполнение групп атрибутов
        while not ORD_IBS.Eof do begin
          pdID := ORD_IBS.fieldByName('ATGRDTSYCODE').asInteger;
          if CheckTypeSys(pdID) then begin
            pID  := ORD_IBS.fieldByName('ATGRCODE').asInteger;
            pName:= ORD_IBS.fieldByName('ATGRNAME').asString;
            ordN := ORD_IBS.fieldByName('ATGRORDERNUM').AsInteger;
            Item:= TAttrGroupItem.Create(pID, pdID, pName, ordN);
            if CheckItem(Item) then // добавляем в справочник
              FTypeSysLists.AddTypeListItem(pdID, pID, pName); // добавляем в список по системам
          end;
          cntsORD.TestSuspendException;
          ORD_IBS.Next;
        end;
        s:= IntToStr(Count)+' гр ';
        CheckLength;        // обрезать длину по максимальному коду
        SortTypeSysList(0); // сортируем списки групп атрибутов
      end; // with AttrGroups
      ORD_IBS.Close;

      with Attributes do begin
        ORD_IBS.SQL.Text:= 'select ATTRCODE, ATTRGROUPCODE, ATTRNAME, ATTRTYPECODE, ATTRPRECISION,'+
          ' iif(ATTRORDERNUM is null, 99, ATTRORDERNUM) as ATTRORDERNUM'+
          ' from ATTRIBUTES order by ATTRGROUPCODE, ATTRORDERNUM, ATTRNAME'; // сортируем по группе + порядк.№ + наименованию
        ORD_IBS.ExecQuery;
        while not ORD_IBS.Eof do begin         // Заполнение справочника атрибутов
          parID:= ORD_IBS.fieldByName('ATTRGROUPCODE').asInteger;
          if not AttrGroups.ItemExists(parID) then begin
            while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('ATTRGROUPCODE').asInteger) do ORD_IBS.Next;
            Continue;
          end;
          attg:= Cache.AttrGroups.GetAttrGroup(parID);
          while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('ATTRGROUPCODE').asInteger) do begin
            pID  := ORD_IBS.fieldByName('ATTRCODE').asInteger;
            pName:= ORD_IBS.fieldByName('ATTRNAME').asString;
            ordN := ORD_IBS.fieldByName('ATTRORDERNUM').asInteger;
            Item:= TAttributeItem.Create(pID, parID, ORD_IBS.fieldByName('ATTRPRECISION').AsShort,
                   ORD_IBS.fieldByName('ATTRTYPECODE').AsShort, ordN, pName);
            if CheckItem(Item) then               // добавляем в справочник
              attg.Links.CheckLink(pID, 0, Item); // добавляем в список линков группы
            cntsORD.TestSuspendException;
            ORD_IBS.Next;
          end;
          attg.Links.SortByLinkOrdNumAndName; // сортируем по порядк.№ + наименованию
        end;
        ORD_IBS.Close;
        s:= s+IntToStr(Count)+' атр ';

        ORD_IBS.SQL.Text:= 'select ATVLCODE, ATVLATTRCODE, ATVLVALUESTR'+
          ' from ATTRVALUES order by ATVLATTRCODE, ATVLVALUESTR';
        ORD_IBS.ExecQuery;
        j:= 0; // счетчик
        while not ORD_IBS.Eof do begin    // Заполнение списков значений атрибутов
          parID:= ORD_IBS.fieldByName('ATVLATTRCODE').asInteger;
          if not ItemExists(parID) then begin
            while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('ATVLATTRCODE').asInteger) do ORD_IBS.Next;
            Continue;
          end;

          with GetAttr(parID) do begin
            while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('ATVLATTRCODE').asInteger) do begin
              pID  := ORD_IBS.fieldByName('ATVLCODE').asInteger;
              pName:= ORD_IBS.fieldByName('ATVLVALUESTR').AsString;
              if TypeAttr=constDouble then CheckAttrStrValue(pName); // проверяем значение
              Item:= TDirItem.Create(pID, pName);
              if FAttrValues.CheckItem(Item) then // добавляем в справочник значений
                FListValues.AddObject(pName, Pointer(pID)); // добавляем в список значений атрибута
              Inc(j);
              cntsORD.TestSuspendException;
              ORD_IBS.Next;
            end;
            FListValues.CustomSort(AttrValuesSortCompare); // сортируем в зав-ти от типа
          end; // with GetAttr(parID)
        end; // while not ORD_IBS.Eof
        ORD_IBS.Close;
        s:= s+IntToStr(j)+' зн/а ';
        CheckLength;        // обрезать длину по максимальному коду
      end; // with Attributes

      ORD_IBS.SQL.Text:= 'select LWAWWARECODE, LWAWATTRCODE, LWAWATVLCODE, LWAWSRCLECODE'+
//        ', ATTRGROUPCODE, iif(ATTRORDERNUM is null, 99, ATTRORDERNUM) as ATTRORDERNUM'+
        ' from LINKWAREATTRVAL'+
        ' inner join WareOptions on wowarecode=LWAWWARECODE and WOARHIVED="F"'+
        ' inner join ATTRIBUTES on ATTRCODE=LWAWATTRCODE'+
//        ' inner join ATTRGROUPS on ATGRCODE=ATTRGROUPCODE'+
        ' where LWAWWRONG="F"'+
        ' order by LWAWWARECODE, ATTRORDERNUM, ATTRNAME'; // сортируем по товару + группе + порядк.№ + наименованию атр.
//        ' order by LWAWWARECODE, ATTRGROUPCODE, ATTRORDERNUM, ATTRNAME'; // сортируем по товару + группе + порядк.№ + наименованию атр.
      ORD_IBS.ExecQuery;
      j:= 0; // счетчик
      while not ORD_IBS.Eof do begin // Заполнение значений атрибутов товаров
        parID:= ORD_IBS.fieldByName('LWAWWARECODE').asInteger;
        fl:= WareExist(parID);
        if fl then begin
          ware:= GetWare(parID, True);
          fl:= (ware<>NoWare) and not ware.IsArchive and not ware.IsINFOgr;
        end;
        if not fl then begin
          while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('LWAWWARECODE').asInteger) do ORD_IBS.Next;
          Continue;
        end;

        while not ORD_IBS.Eof and (parID=ORD_IBS.fieldByName('LWAWWARECODE').asInteger) do begin
          pID := ORD_IBS.fieldByName('LWAWATTRCODE').asInteger;
          pdID:= ORD_IBS.fieldByName('LWAWATVLCODE').asInteger;
          psID:=  ORD_IBS.fieldByName('LWAWSRCLECODE').asInteger;
//          grID:=  ORD_IBS.fieldByName('ATTRGROUPCODE').asInteger; // код группы
//          ind:= -1;
          if Attributes.ItemExists(pID) and Attributes.FAttrValues.ItemExists(pdID) then begin
            attr:= Attributes[pID];              // ссылка на атрибут
            attv:= Attributes.FAttrValues[pdID]; // ссылка на значение атрибута

            if (ware.AttrLinks.LinkCount>0) and (ware.AttrGroupID<>attr.SubCode) then
              prMessageLOGS('wareID='+IntToStr(ware.ID)+' - AttrGroup='+IntToStr(ware.AttrGroupID)+
                ', attrID='+IntToStr(attr.ID)+' - AttrGroup='+IntToStr(attr.SubCode), 'errattr', false)
            else begin
              ware.AttrLinks.AddLinkItem(TTwoLink.Create(psID, attr, attv));  // линк на атрибут и значение
              Inc(j);
            end;
            //---------------------------------------------- атрибуты по группам
//            ind:= ware.FWareOpts.FAttrGrCodes.IndexOf(attr.SubCode);
//            if (ind<0) then ind:= ware.FWareOpts.FAttrGrCodes.Add(attr.SubCode);
//              ware.FWareOpts.FArSysAttrs[sysID].AddLinkListItem(TTwoLink.Create(psID, attr, attv), lkLnkByID, ware.CS_wlinks);
          end; // if Attributes.ItemExists(pID)
          cntsORD.TestSuspendException;
          ORD_IBS.Next;
        end; //
      end; // while not ORD_IBS.Eof
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    s:= s+IntToStr(j)+' зн/а/т ';
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  prMessageLOGS(nmProc+': '+s+' - '+GetLogTimeStr(TimeProc), fLogCache, false);
  TestCssStopException;
end;
//============================================ проверка значения атрибута товара
function TDataCache.CheckWareAttrValue(WareID, AttrID, srcID, userID: Integer;
         Value: String; var ResCode: Integer): String;
const nmProc='CheckWareAttrValue';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    newatv, oldatv, j: Integer;
    attr: TAttributeItem;
    attv: TDirItem;
    attlink: TTwoLink;
    Ware: TWareInfo;
    Item: Pointer;
    flinkEx: Boolean;
    sValue: String;
begin
  Result:= '';
  ResCode:= resError;
  newatv:= 0;
  oldatv:= 0;
  ORD_IBS:= nil;
  try
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrProcess));
    if not WareExist(WareID) then // проверяем код товара
      raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));
    if not Attributes.ItemExists(AttrID) then // проверяем код атрибута
      raise EBOBError.Create('Не найден атрибут, код='+IntToStr(AttrID));

    Ware:= GetWare(WareID);                  // ссылка на товар
    if Ware.IsArchive then
      raise EBOBError.Create(MessText(mtkNotFoundWare, IntToStr(WareID)));
    Value:= trim(Value);
    flinkEx:= Ware.AttrLinks.LinkExists(AttrID); // признак наличия у товара линка на атрибут
    if not flinkEx and (Value='') then begin // если линка нет и пришло пустое значение
      ResCode:= resDoNothing;
      raise EBOBError.Create('Не найдено '+MessText(mtkWareAttrValue));
    end;

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite);

      if (Value='') then begin // если пришло пустое значение - удаляем связи
        with ORD_ibs.Transaction do if not InTransaction then StartTransaction;
        ORD_IBS.SQL.Text:= 'delete from LINKWAREATTRVAL'+ // удаляем связку из базы
          ' where LWAWWARECODE=:LWAWWARECODE and LWAWATTRCODE=:LWAWATTRCODE';
        ORD_IBS.ParamByName('LWAWWARECODE').AsInteger:= WareID;
        ORD_IBS.ParamByName('LWAWATTRCODE').AsInteger:= AttrID;
        ORD_IBS.ExecQuery;
        ORD_IBS.Close;
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;

        Ware.AttrLinks.DeleteLinkItem(AttrID); // удаляем линк из кеша
        ResCode:= resDeleted;
        raise EBOBError.Create(MessText(mtkWareAttrValue)+' удалено');
      end;
//------------------------ пустое значение (удаление) отработали

      sValue:= Value; // запоминаем принятое значение
      attr:= Attributes.GetAttr(AttrID); // ссылка на атрибут
      if attr.TypeAttr=constDouble then attr.CheckAttrStrValue(sValue); // проверяем значение

      j:= attr.FListValues.IndexOf(sValue); // ищем новое значение атрибута
      if (j>-1) then newatv:= Integer(attr.FListValues.Objects[j]); // код нового значения

      if flinkEx then begin
        attlink:= Ware.AttrLinks[AttrID];
        with attlink do if assigned(LinkPtrTwo) then oldatv:= LinkTwoID; // код старого значения
      end else attlink:= nil;

      if (oldatv>0) then begin // если старое значение есть
        if (newatv>0) and (oldatv=newatv) then begin // если значение то же
          ResCode:= resDoNothing;
          raise EBOBError.Create(MessText(mtkWareAttrValue)+' не изменилось');
        end;
        if assigned(attlink) then attlink.LinkPtrTwo:= nil;  // удаляем старое значение  ???
      end;
//------------------------ совпадаюшие значения отработали

      if newatv<1 then begin // если нет такого значения атрибута - добавляем в базу
        if (attr.TypeAttr=constDouble) and (FormatSettings.DecimalSeparator<>'.') then
          Value:= StringReplace(sValue, FormatSettings.DecimalSeparator, '.', [rfReplaceAll]); // в базу пишем с '.'
        with ORD_ibs.Transaction do if not InTransaction then StartTransaction;
        ORD_IBS.SQL.Text:= 'insert into ATTRVALUES (ATVLATTRCODE, ATVLVALUESTR, ATVLUSERID)'+
          ' values (:ATVLATTRCODE, :ATVLVALUESTR, :ATVLUSERID) returning ATVLCODE';
        ORD_IBS.ParamByName('ATVLATTRCODE').AsInteger:= AttrID;
        ORD_IBS.ParamByName('ATVLVALUESTR').AsString := Value;
        ORD_IBS.ParamByName('ATVLUSERID').AsInteger  := userID;
        ORD_IBS.ExecQuery;
        if not (ORD_IBS.Bof and ORD_IBS.Eof) then newatv:= ORD_IBS.Fields[0].AsInteger; // код значения
        ORD_IBS.Close;
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;
      end;
      if newatv<1 then raise EBOBError.Create(MessText(mtkErrAddRecord));

      if Attributes.FAttrValues.ItemExists(newatv) then
        attv:= Attributes.FAttrValues[newatv] // ссылка на значение атрибута
      else begin
        Item:= TDirItem.Create(newatv, sValue);
        if not Attributes.FAttrValues.CheckItem(Item) then // добавляем в справочник значений
           raise EBOBError.Create(MessText(mtkErrAddRecord));
        attv:= Item;
      end;

      with attr.FListValues do if (IndexOfObject(Pointer(newatv))<0) then begin
        AddObject(sValue, Pointer(newatv));  // добавляем в список значений атрибута
        CustomSort(AttrValuesSortCompare);   // сортируем список значений атрибута
      end;
//------------------------ справочники значений отработали

      if not flinkEx then begin // если не было линка на атрибут - добавляем

        if (Ware.AttrLinks.LinkCount>0) and (Ware.AttrGroupID<>attr.SubCode) then // проверка группы
           raise EBOBError.Create('товар имеет атрибуты другой группы');

        with ORD_ibs.Transaction do if not InTransaction then StartTransaction;
        ORD_IBS.SQL.Text:= 'insert into LINKWAREATTRVAL'+
          ' (LWAWWARECODE, LWAWATTRCODE, LWAWATVLCODE, LWAWSRCLECODE, LWAWUSERID) values'+
          ' ('+IntToStr(WareID)+', '+IntToStr(AttrID)+', '+IntToStr(newatv)+', '+
          IntToStr(srcID)+', '+IntToStr(userID)+') returning LWAWATVLCODE';
        ORD_IBS.ExecQuery;
        if (ORD_IBS.Bof and ORD_IBS.Eof) or (ORD_IBS.Fields[0].AsInteger<1) then
          raise EBOBError.Create(MessText(mtkErrAddRecord));
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;

        attlink:= TTwoLink.Create(srcID, attr, attv);
        with Ware.AttrLinks do begin
          AddLinkItem(attlink);    // добавляем линк на атрибут в кэш
          SortByLinkOrdNumAndName; // сортируем по порядк.№ + наименованию
        end;

        ResCode:= resAdded;
        Result:= MessText(mtkWareAttrValue)+' добавлено';

      end else begin // если линк был - меняем значение
        with ORD_ibs.Transaction do if not InTransaction then StartTransaction;
        ORD_IBS.SQL.Text:= 'update LINKWAREATTRVAL set LWAWATVLCODE='+IntToStr(newatv)+
          ' where LWAWWARECODE='+IntToStr(WareID)+' and LWAWATTRCODE='+IntToStr(AttrID);
        ORD_IBS.ExecQuery;
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;

        if assigned(attlink) then attlink.LinkPtrTwo:= attv; // новое значение

        ResCode:= resEdited;
        Result:= MessText(mtkWareAttrValue)+' изменено';
      end;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
end;

//================= добавление / удаление связки производителей Grossbe и Tecdoc
function TDataCache.CheckWareBrandReplace(brID, brTD, userID: Integer; var ResCode: Integer): String;
// возвращает сообщение о результате выполнения
// вид операции - ResCode - на входе (resAdded, resDeleted)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось, resAdded - добавлено, resDeleted - удалено
const nmProc='CheckWareBrandReplace';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    OpCode, index: Integer;
    fAdd: Boolean;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  ORD_IBS:= nil;
  try
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrProcess));
    if not (OpCode in [resAdded, resDeleted]) then       // проверяем код операции
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if not WareBrands.ItemExists(brID) then
      raise EBOBError.Create(MessText(mtkNotFoundManuf, IntToStr(brID)));

    fAdd:= OpCode<>resDeleted;
    index:= fnInIntArray(brTD, TBrandItem(WareBrands[brID]).TDMFcodes);
    if fAdd and (index>-1) then begin            // если добавление
      ResCode:= resDoNothing;
      raise EBOBError.Create('Такое соответствие производителей уже есть');
    end else if not fAdd and (index<0) then begin     // если удаление
      ResCode:= resDoNothing;
      raise EBOBError.Create('Не найдено такое соответствие производителей');
    end;

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      if fAdd then begin  // если добавление
        ORD_IBS.SQL.Text:= 'insert into BRANDREPLACE (BRRPGBCODE, BRRPTDCODE, BRRPUSERID)'+
          ' values ('+IntToStr(brID)+', '+IntToStr(brTD)+', '+IntToStr(userID)+
          ') returning BRRPCODE';
        ORD_IBS.ExecQuery;
        if (ORD_IBS.Bof and ORD_IBS.Eof) or (ORD_IBS.Fields[0].AsInteger<1) then
          raise EBOBError.Create(MessText(mtkErrAddRecord));
        ORD_IBS.Close;
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;

        prAddItemToIntArray(brTD, TBrandItem(WareBrands[brID]).FTDMFcodes);
        ResCode:= resAdded;
        Result:= 'соответствие производителей добавлено';

      end else begin      // если удаление
        ORD_IBS.SQL.Text:= 'delete from BRANDREPLACE'+ // удаляем связку из базы
          ' where BRRPGBCODE='+IntToStr(brID)+' and BRRPTDCODE='+IntToStr(brTD);
        ORD_IBS.ExecQuery;
        ORD_IBS.Close;
        if ORD_IBS.Transaction.InTransaction then ORD_IBS.Transaction.Commit;

        prDelItemFromArray(index, TBrandItem(WareBrands[brID]).FTDMFcodes);
        ResCode:= resDeleted;
        Result:= 'соответствие производителей удалено';
      end;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
end;
//======================= добавление / удаление связки главной и дублирующей нод
function TDataCache.CheckLinkMainAndDupNodes(NodeID, MainNodeID, userID: Integer; var ResCode: Integer): String;
// возвращает сообщение о результате выполнения, вид операции - ResCode - на входе (resAdded, resDeleted)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось, resAdded - добавлено, resDeleted - удалено
const nmProc='CheckLinkMainAndDupNodes';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    OpCode, i, j, j3, ModelID, WareID, res, utID, uID, SysID: Integer;
    flag, fLinkEx, fMainLinkEx: Boolean;
    Node, NodeMain: TAutoTreeNode;
    NodeName, MainNodeName, s: String;
    Model: TModelAuto;
    link2, link2main: TSecondLink;
    link3: TLink;
    links3: TLinkList;
    codes: Tai;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  SysID:= 0;
  ModelID:= 0;
  WareID:= 0;
  utID:= 0;
  uID:= 0;
  Node:= nil;
  SetLength(codes, 0);
  ORD_IBS:= nil;
  try try
//------------------------------------------------------------- сначала проверки
    if not Assigned(self) then raise EBOBError.Create(MessText(mtkErrProcess));
    if not (OpCode in [resAdded, resDeleted]) then       // проверяем код операции
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if (userID<1) then raise EBOBError.Create(MessText(mtkErrorUserID)); // проверяем userID

    flag:= OpCode<>resDeleted; // flag - флаг привязки

    with SysTypes do for i:= 0 to Count-1 do begin // определяем тип системы
      j:= GetDirItemID(ItemsList[i]);
      if Assigned(FDCA.AutoTreeNodesSys[j]) then with FDCA.AutoTreeNodesSys[j] do
        if NodeGet(NodeID, Node) then begin // проверяем заданную ноду
          if (NodeID<>MainNodeID) and not NodeExists(MainNodeID) then // проверяем главную ноду
            raise Exception.Create('У узлов разные системы учета');
          SysID:= j;
          Break;
        end;
    end; // for i:= 0 to Count-1
    if (SysID<1) then raise Exception.Create(MessText(mtkNotFoundTypeSys));

    if (NodeID=MainNodeID) then NodeMain:= Node
    else NodeMain:= FDCA.AutoTreeNodesSys[SysID][MainNodeID];
    NodeName:= Node.NameSys;
    MainNodeName:= NodeMain.NameSys;
    if not Node.IsEnding then // нода должна быть конечной
      raise Exception.Create('Узел ('+IntToStr(NodeID)+')'+NodeName+' не конечный');
    if (NodeID<>MainNodeID) and not NodeMain.IsEnding then // главная нода должна быть конечной
      raise Exception.Create('Узел ('+IntToStr(MainNodeID)+')'+MainNodeName+' не конечный');

    if flag then begin // проверяем возможность привязки
      j:= Node.MainCode;
      if (NodeID=j) then begin
                               // нода не должна быть главной с дублирующими узлами
        with FDCA.AutoTreeNodesSys[SysID].GetDuplicateNodes(NodeID) do try
          if (Count>0) then
            raise Exception.Create('Узел ('+IntToStr(NodeID)+')'+NodeName+' имеет дублирующие узлы');
        finally Free; end;

      end else if (FDCA.AutoTreeNodesSys[SysID].NodeExists(j)) then // нода должна быть непривязанной
        raise Exception.Create('Узел ('+IntToStr(NodeID)+')'+NodeName+' привязан к узлу ('+
          IntToStr(j)+')'+FDCA.AutoTreeNodesSys[SysID][j].NameSys);

    end else if (Node.MainCode<>MainNodeID) then // проверяем возможность отвязки
      raise Exception.Create('Узел ('+IntToStr(NodeID)+')'+NodeName+
        ' не привязан к узлу ('+IntToStr(MainNodeID)+')'+MainNodeName);

//--------------------------------------------------------- отрабатываем отвязку
    if not flag then begin
      flag:= False; // теперь flag - флаг ошибок
      SetLength(codes, 100);
      j:= 0;
      ORD_IBD:= cntsOrd.GetFreeCnt;
      try
        ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
        ORD_IBS.SQL.Text:= 'update TREENODESAUTO set TRNAMAINCODE=TRNACODE'+
          ', TRNAUSERID='+IntToStr(userID)+' where TRNACODE='+IntToStr(NodeID);
        ORD_IBS.ExecQuery;
        ORD_IBS.Transaction.Commit;
        ORD_IBS.Close;

        fnSetTransParams(ORD_IBS.Transaction, tpRead, True);
        ORD_IBS.SQL.Text:= 'select LDEMDMOSCODE from LINKDETAILMODEL'+
          ' where LDEMTRNACODE='+IntToStr(NodeID)+' group by LDEMDMOSCODE';
        ORD_IBS.ExecQuery;
        while not ORD_IBS.Eof do begin // выбираем коды моделей, которые надо проработать
          if Length(codes)<(j+1) then SetLength(codes, j+100);
          codes[j]:= ORD_IBS.FieldByName('LDEMDMOSCODE').AsInteger;
          inc(j);
          cntsORD.TestSuspendException;
          ORD_IBS.Next;
        end;
      finally
        prFreeIBSQL(ORD_IBS);
        cntsOrd.SetFreeCnt(ORD_IBD);
      end;
      if Length(codes)>j then SetLength(codes, j);

      for j:= 0 to High(codes) do try //-------------------- перебираем модели
        ModelID:= codes[j];
        if not FDCA.Models.ModelExists(ModelID) then Continue;
        Model:= FDCA.Models[ModelID];
        if not Assigned(Model.NodeLinks) or // ищем связки 2 на нашу ноду
          not Model.NodeLinks.LinkExists(NodeID) then Continue;

        link2:= Model.NodeLinks[NodeID];         // фиксируем связку 2 ноды
        if link2.IsLinkNode and
          Assigned(link2.DoubleLinks) then Continue; // если есть связки 3 - пропускаем

        Model.NodeLinks.DeleteLinkItem(NodeID); // удаляем связку 2
      except
        on E: Exception do begin
          flag:= True;
          prMessageLOGS(nmProc+': ModelID='+IntToStr(ModelID)+
            ', NodeID='+IntToStr(NodeID)+': '+E.Message, 'import', False);
        end;
      end; // for j:= 0 to High(codes)

      if not flag then begin //------------------------------- отвязываем ноду
        Node.MainCode:= NodeID;
        ResCode:= resDeleted;
        Result:= 'Узел ('+IntToStr(NodeID)+')'+NodeName+
          ' отвязан от узла ('+IntToStr(MainNodeID)+')'+MainNodeName;
      end;
      Exit;
    end;

//---- переносим линки условий и текстов к связкам 3, линки товар - нода - текст
//---- перенос линков условий и текстов к связкам 3, товар - нода - текст - триггеры
    flag:= False; // теперь flag - флаг ошибок
    SetLength(codes, 100);
    j:= 0;
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'update TREENODESAUTO set TRNAMAINCODE='+IntToStr(MainNodeID)+
        ', TRNAUSERID='+IntToStr(userID)+' where TRNACODE='+IntToStr(NodeID);
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;
      ORD_IBS.Close;

      fnSetTransParams(ORD_IBS.Transaction, tpRead, True);
      ORD_IBS.SQL.Text:= 'select LDEMDMOSCODE from LINKDETAILMODEL'+
        ' where LDEMTRNACODE in ('+IntToStr(NodeID)+', '+IntToStr(MainNodeID)+
        ') group by LDEMDMOSCODE';
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin // выбираем коды моделей, которые надо проработать
        if Length(codes)<(j+1) then SetLength(codes, j+100);
        codes[j]:= ORD_IBS.FieldByName('LDEMDMOSCODE').AsInteger;
        inc(j);
        cntsORD.TestSuspendException;
        ORD_IBS.Next;
      end;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    if Length(codes)>j then SetLength(codes, j);

   //------------------------------------------------ перебираем модели
    for j:= 0 to High(codes) do try
      ModelID:= codes[j];
      if not FDCA.Models.ModelExists(ModelID) then Continue;
      Model:= FDCA.Models[ModelID];
      if not Assigned(Model.NodeLinks) then Continue; // ищем связки 2 на нашу ноду

      fLinkEx:= Model.NodeLinks.LinkExists(NodeID);
      fMainLinkEx:= Model.NodeLinks.LinkExists(MainNodeID);
      if not fLinkEx and not fMainLinkEx then Continue;

   //------------------------------------------------ объединяем связки 2
      link2main:= nil;
      link2:= nil; // связка 2
      if not fLinkEx then begin
        link2main:= Model.NodeLinks[MainNodeID]; // фиксируем связку 2 главной ноды
        s:= FDCA.CheckModelNodeLinkDup(ModelID, NodeID, FloatToStr(link2main.Qty), res, link2main.SrcID, userID);
        if (res=resError) then raise Exception.Create(s);
      end;
      if not fMainLinkEx then begin
        link2:= Model.NodeLinks[NodeID];         // фиксируем связку 2 ноды
        s:= FDCA.CheckModelNodeLinkDup(ModelID, MainNodeID, FloatToStr(link2.Qty), res, link2.SrcID, userID);
        if (res=resError) then raise Exception.Create(s);
      end;
      if not Assigned(link2) then link2:= Model.NodeLinks[NodeID];             // фиксируем связку 2 ноды
      if not Assigned(link2main) then link2main:= Model.NodeLinks[MainNodeID]; // фиксируем связку 2 главной ноды
      if not Assigned(link2) or not Assigned(link2main) then
        raise Exception.Create('error create link');

      if (link2.Qty>link2main.Qty) then begin // переносим кол-во на главную ноду
        s:= FDCA.CheckModelNodeLinkDup(ModelID, MainNodeID, FloatToStr(link2.Qty), res, link2.SrcID, userID);
        if (res=resError) then raise Exception.Create(s);
      end;

      if not link2.IsLinkNode or
        not Assigned(link2.DoubleLinks) then Continue; // ищем связки 3 по связке 2 ноды

      links3:= link2.DoubleLinks;
      for j3:= links3.Count-1 downto 0 do try //---- перебираем связки 3
        link3:= links3[j3]; // фиксируем связку 3 ноды
        WareID:= TDirItem(link3).ID;
        res:= resAdded;  // добавляем связку 3 к линкам главной ноды (если такой нет)
        s:= FDCA.CheckWareModelNodeLink(WareID, ModelID, MainNodeID, res, link3.srcID, userID);
        if (res=resError) then raise Exception.Create(s);

   //------------------------------------ удаляем связку 3 из связок ноды
        res:= resDeleted;
        s:= FDCA.CheckWareModelNodeLink(WareID, ModelID, NodeID, res);
        if (res=resError) then raise Exception.Create(s);
      except
        on E: Exception do begin
          flag:= True;
          prMessageLOGS(nmProc+': ModelID='+IntToStr(ModelID)+
            ', NodeID='+IntToStr(NodeID)+', WareID='+IntToStr(WareID)+': '+E.Message, 'import', False);
        end;
      end; // for j3:= links3.ListLinks.Count-1 downto 0

    except
      on E: Exception do begin
        flag:= True;
        prMessageLOGS(nmProc+': ModelID='+IntToStr(ModelID)+
          ', NodeID='+IntToStr(NodeID)+': '+E.Message, 'import', False);
      end;
    end; // for j:= 0 to High(codes)

    if not flag then begin //-------------------------------- привязываем ноду
      Node.MainCode:= MainNodeID;
      ResCode:= resAdded;
      Result:= 'Узел ('+IntToStr(NodeID)+')'+NodeName+
        ' привязан к узлу ('+IntToStr(MainNodeID)+')'+MainNodeName;
    end;
  finally
    SetLength(codes, 0);
  end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
end;
{//================================== проверка ссответствия систем фирмы и товара
function TDataCache.CheckWareAndFirmEqualSys(WareID, FirmID: Integer; contID: Integer=0): Boolean;
var i, k: integer;
    Contract: TContract;
begin
  Result:= (FirmID=isWe);
  if Result or not Assigned(self)
    or not WareExist(WareID) or not FirmExist(FirmID) then exit;
  if (contID>0) and arFirmInfo[FirmID].CheckContract(contID) then
    Contract:= Contracts[contID]
  else Contract:= nil;

  with arWareInfo[WareID] do begin
    if IsArchive then exit;
    Result:= Assigned(Contract) and (Contract.SysID=0);
    if Result then Exit;

    with SysTypes do for i:= 0 to Count-1 do begin // набор типов систем
      k:= GetDirItemID(ItemsList[i]);
      if Assigned(Contract) then Result:= CheckWareTypeSys(k) and (Contract.SysID=k)
      else Result:= CheckWareTypeSys(k) and arFirmInfo[FirmID].CheckSysType(k);
      if Result then Exit;
    end;
  end;
end;  }
//==================================== проверка ссответствия систем двух товаров
function TDataCache.CheckWaresEqualSys(WareID1, WareID2: Integer): Boolean;
var i, k: integer;
    ware1, ware2: TWareInfo;
begin
  Result:= False;
  if not Assigned(self) or not WareExist(WareID1) or not WareExist(WareID2) then exit;
  ware1:= arWareInfo[WareID1];
  if ware1.IsArchive then exit;
  ware2:= arWareInfo[WareID2];
  if ware2.IsArchive then exit;
  with SysTypes do for i:= 0 to Count-1 do begin // набор типов систем
    k:= GetDirItemID(ItemsList[i]);
    Result:= ware1.CheckWareTypeSys(k) and ware2.CheckWareTypeSys(k);
    if Result then break;
  end;
end;
// сортированный список товаров (Object-ID) по системе и/или менеджеру и/или бренду
function TDataCache.GetSysManagerWares(SysID: Integer=0; ManID: Integer=0;
         Brand: integer=0; Sort: boolean=True): TStringList; // must Free Result
var i: Integer;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  if (Brand>0) and not WareBrands.ItemExists(Brand) then Exit;
//    raise EBOBError.Create('Не найден бренд с кодом '+IntToStr(Brand));
  if (ManID>0) and not EmplExist(ManID) then Exit;
//    raise EBOBError.Create('Не найден менеджер с кодом '+IntToStr(ManID));
  if (SysID>0) and not CheckTypeSys(SysID) then Exit;
//    raise EBOBError.Create('Не найдена система учета с кодом '+IntToStr(SysID));
  Result.Capacity:= length(ArWareInfo);
  for i:= 1 to High(arWareInfo) do
    if not WareExist(i) then Continue else with GetWare(i) do begin
      if IsArchive or (PgrID<1) then Continue;
      if (PgrID=pgrDeliv) then Continue; // пропускаем доставки
      if (ManID>0) and (ManID<>ManagerID) then Continue;
      if (SysID>0) and not CheckWareTypeSys(SysID) then Continue;
      if (Brand>0) and (WareBrandID<>Brand) then Continue;
      Result.AddObject(Name, Pointer(ID));
    end;
  if Sort and (Result.Count>1) then Result.Sort;
end;
//============================================= Возвращает список брендов TecDoc
function TDataCache.FillBrandTDList: TStringList;
const nmProc = 'FillBrandTDList';
var IBD: TIBDatabase;
    IBS: TIBSQL;
    sBrand: String;
    iMF: Integer;
begin
  Result:= fnCreateStringList(True, dupIgnore);
  IBS:= nil;
  try
    IBD:= cntsTDT.GetFreeCnt;
  except
    Exit;
  end;
  try
    IBS:= fnCreateNewIBsql(IBD, 'IBS_'+nmProc, -1, tpRead, True);
    IBS.SQL.Text:= 'select DS_MF_ID mfID,'+
      ' iif(ICN_NEWDESCR is null, DS_BRA, ICN_NEWDESCR) mfName'+
      ' from DATA_SUPPLIERS'+
      ' left join IMPORT_CHANGE_NAMES on ICN_TAB_ID = 100 and ICN_KE_KEY = DS_MF_ID'+
      ' order by mfName';
    IBS.ExecQuery;
    while not IBS.Eof do begin
      sBrand:= Trim(IBS.FieldByName('mfName').asString);
      iMF:= IBS.FieldByName('mfID').asInteger;
      Result.AddObject(sBrand, Pointer(iMF));
      cntsTDT.TestSuspendException;
      IBS.Next;
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
  prFreeIBSQL(IBS);
  cntsTDT.SetFreeCnt(IBD);
  TestCssStopException;
end;
//===================================== время последнего обн.кеша для коммандера
function TDataCache.GetLastTimeCache: Double;
begin
  if WareCacheTested then Result:= -1 else Result:= LastTimeCache;
end;
//=================== список текстов и условий по узлам к связке товара и модели
function TDataCache.GetWareModelUsesAndTextsView(WareID, ModelID: Integer): TStringList; // must Free Result
const nmProc = 'GetWareModelUsesAndTextsView';
var iType, iPart, pCount, NodeID: integer;
    s, TypeName, nodeDelim, partDelim: String;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    Model: TModelAuto;
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  try
    if not WareExist(WareID) then Exit;

    if not TestRDB(cntsORD, trkProc, 'GetModelWareTextUses') then Exit;

    with FDCA do begin
      if not Models.ModelExists(ModelID) then Exit;
      Model:= Models[ModelID];
      nodes:= AutoTreeNodesSys[Model.TypeSys];
    end;
    nodeDelim:= brcWebDelim; // разделитель узлов
    partDelim:= '---------- или ----------';     // разделитель порций
    partDelim:= brcWebBoldBlackBegin+partDelim+brcWebBoldEnd;  // жирный черный шрифт
    try
      ORD_IBD:= cntsOrd.GetFreeCnt;
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
      ORD_IBS.SQL.Text:= 'select rNodeID, Rpart, Rtype, RtypeName, Rtext'+
        ' from GetModelWareTextUses('+IntToStr(ModelID)+', '+IntToStr(WareID)+')';
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        NodeID:= ORD_IBS.FieldByName('rNodeID').AsInteger; // код узла

        if nodes.NodeExists(NodeID) then begin
          node:= nodes[NodeID];
          if not node.IsEnding then node:= nil;
        end else node:= nil;

        if not Assigned(node) then begin
          while not ORD_IBS.Eof and (NodeID=ORD_IBS.FieldByName('rNodeID').AsInteger) do ORD_IBS.Next;
          Continue;
        end;

        if (Result.Count>0) then Result.Add(nodeDelim); // разделитель узлов
        s:= 'Узел - '+node.Name+': ';
        s:= brcWebColorBlueBegin+s+brcWebColorEnd; // синий шрифт
        Result.Add(s); // название узла

        pCount:= 0; // счетчик порций
        while not ORD_IBS.Eof and (NodeID=ORD_IBS.FieldByName('rNodeID').AsInteger) do begin // собираем тексты по 1-му узлу
          iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // порция
          if pCount>0 then Result.Add(partDelim);   // разделитель порций

          while not ORD_IBS.Eof and (NodeID=ORD_IBS.FieldByName('rNodeID').AsInteger)
            and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
            iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
            TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
            s:= '';
            while not ORD_IBS.Eof and (NodeID=ORD_IBS.FieldByName('rNodeID').AsInteger)
              and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
              and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
              s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
              cntsORD.TestSuspendException;
              ORD_IBS.Next;
            end;
            s:= TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
            Result.Add(s);
          end; // while not ORD_IBS.Eof and (NodeID=... and (iPart=

          inc(pCount); // счетчик порций
        end; // while not ORD_IBS.Eof and (NodeID=
      end; //  while not ORD_IBS.Eof
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;
//======================= список текстов и условий к связкам 3, Objects - WareID
function TDataCache.GetWaresModelNodeUsesAndTextsView(ModelID, NodeID: Integer;
         WareCodes: Tai; var sFilters: String): TStringList; // must Free Result
const nmProc = 'GetWaresModelNodeUsesAndTextsView';
var iType, i, ii, NodeCount, iPart, pCount: integer;
    s, TypeName, str, nodeDelim, partDelim: String;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    lst: TStringList;
    arNodeCodes: Tai;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    Model: TModelAuto;
    flNotEndNode, flPart0: Boolean;
  //---------------------------------
  procedure AddCodes(inode: integer);
  var j: Integer;
  begin
    if not nodes.NodeExists(inode) then exit;
    node:= nodes[inode];
    if node.IsEnding then begin // если конечная нода
      if Model.NodeLinks.LinkExists(inode) then begin
        if fnInIntArray(node.MainCode, arNodeCodes)>-1 then exit;        // если уже есть
        if Length(arNodeCodes)<=NodeCount then SetLength(arNodeCodes, NodeCount+10);
        arNodeCodes[NodeCount]:= node.MainCode;                          // запоминаем код главной ноды
        inc(NodeCount);
      end;
    end else with node.Children do
      for j:= 0 to Count-1 do AddCodes(TAutoTreeNode(Objects[j]).ID);
  end;
  //---------------------------------
begin
  Result:= TStringList.Create;
  if not Assigned(self) or (length(WareCodes)<1) then Exit;
  lst:= TStringList.Create;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  NodeCount:= 0;
  SetLength(arNodeCodes, 0);
  try
    with FDCA do begin
      if not Models.ModelExists(ModelID) then
        raise Exception.Create(MessText(mtkNotFoundModel, IntToStr(ModelID)));
      Model:= Models[ModelID];
      nodes:= AutoTreeNodesSys[Model.TypeSys];
    end;

    if not nodes.NodeExists(NodeID) then
      raise Exception.Create(MessText(mtkNotFoundNode, IntToStr(NodeID)));
    node:= nodes[NodeID];
    flNotEndNode:= not node.IsEnding;

    try
      AddCodes(NodeID);         // собираем коды всех главных конечных нод
      if NodeCount<1 then Exit; // если нет нод

      if flNotEndNode then str:= cWebSpace+cWebSpace+cWebSpace else str:= ''; // отступ, если исх.нода не конечная
      nodeDelim:= brcWebDelim; // разделитель узлов / 0-й порции
      partDelim:= '---------- или ----------';     // разделитель порций
      partDelim:= brcWebBoldBlackBegin+partDelim+brcWebBoldEnd;  // жирный черный шрифт
//      partDelim:= cWebItalBegin+cWebBoldBlackBegin+partDelim+cWebBoldEnd+cWebItalEnd; // жирный черный курсив

      ORD_IBD:= cntsOrd.GetFreeCnt;
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, true);
      ORD_IBS.SQL.Text:= 'select Rpart, Rtype, RtypeName, Rtext'+
        ' from GetModelNodeWareFiltTextUses_n('+IntToStr(ModelID)+', :NodeID, :WareID, :sFilters)';
      ORD_IBS.ParamByName('sFilters').AsString:= sFilters;

      for i:= 0 to High(WareCodes) do begin
        ORD_IBS.ParamByName('WareID').AsInteger:= WareCodes[i];
        if lst.Count>0 then lst.Clear;

        flPart0:= False;
        for ii:= 0 to NodeCount-1 do begin
          NodeID:= arNodeCodes[ii];
          ORD_IBS.ParamByName('NodeID').AsInteger:= NodeID;
          ORD_IBS.ExecQuery;
          // если по ноде что-то есть и исх.нода не конечная - пишем название ноды
          if flNotEndNode and not (ORD_IBS.Bof and ORD_IBS.Eof) then begin
            if lst.Count>0 then lst.Add(nodeDelim);                    // разделитель узлов
            s:= 'Узел - '+nodes[NodeID].Name+': ';
            s:= brcWebColorBlueBegin+s+brcWebColorEnd; // синий шрифт
            lst.Add(s);
          end;

          pCount:= 0; // счетчик порций
          while not ORD_IBS.Eof do begin // собираем тексты по 1-му узлу
            iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // порция

            if (iPart<0) and (ORD_IBS.FieldByName('Rtext').AsString<>'') then begin
              sFilters:= ORD_IBS.FieldByName('Rtext').AsString; // строка значений фильтров
              ORD_IBS.Next;
              Continue;
            end;

            if (iPart=0) then flPart0:= True; // флаг 0-й порции (значение критерия фильтра товара)
            if pCount>0 then
              if flPart0 then begin
                lst.Add(brcWebDelim); // разделитель 0-й порции
                flPart0:= False;
              end else lst.Add(partDelim);   // разделитель порций

            while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
              iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
              TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
              s:= '';
              while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
                and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
                s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
                cntsORD.TestSuspendException;
                ORD_IBS.Next;
              end;

              s:= str+TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
              if (iPart=0) then  // выделяем строки 0-й порции
                s:= brcWebColorRedBegin+s+brcWebColorEnd; // красный шрифт

              lst.Add(s);
            end; // while not ORD_IBS.Eof and (iPart=

            inc(pCount); // счетчик порций
          end; //  while not ORD_IBS.Eof
          ORD_IBS.Close;
        end; // for ii:= 0 to High(arNodeCodes)

        if lst.Count>0 then Result.AddObject(lst.Text, Pointer(WareCodes[i]));
      end; // for i:= 0 to High(WareCodes)
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
      SetLength(arNodeCodes, 0);
      prFree(lst);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
end;
//=== фильтр.список товаров с текстами и условиями к связкам 3, Objects - WareID
function TDataCache.GetModelNodeWaresWithUsesByFilters(ModelID, NodeID: Integer;
         withChildNodes: boolean; var sFilters: String): TStringList; // must Free Result
// sFilters - коды значений критериев через запятую
const nmProc = 'GetModelNodeWaresWithUsesByFilters';
var iType, i, ii, NodeCount, iPart, pCount, wareID: integer;
    s, TypeName, str, nodeDelim, partDelim: String;
    ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    lst: TStringList;
    arNodeCodes: Tai;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    Model: TModelAuto;
    flNotEndNode, flPart0, flFromBase: Boolean;
    WareCodes: Tai;
    nlinks: TLinks;
  //---------------------------------
  procedure AddCodes(inode: integer);
  var j: Integer;
  begin
    if not nodes.NodeExists(inode) then exit;
    node:= nodes[inode];
    if node.IsEnding then begin // если конечная нода
      if nlinks.LinkExists(inode) then begin
        if fnInIntArray(node.MainCode, arNodeCodes)>-1 then exit;        // если уже есть
        if Length(arNodeCodes)<=NodeCount then SetLength(arNodeCodes, NodeCount+10);
        arNodeCodes[NodeCount]:= node.MainCode;                          // запоминаем код главной ноды
        inc(NodeCount);
      end;
    end else with node.Children do
      for j:= 0 to Count-1 do AddCodes(TAutoTreeNode(Objects[j]).ID);
  end;
  //---------------------------------
begin
  Result:= TStringList.Create;
  if not Assigned(self) then Exit;
  lst:= TStringList.Create;
  ORD_IBD:= nil;
  ORD_IBS:= nil;
  NodeCount:= 0;
  SetLength(arNodeCodes, 0);
  SetLength(WareCodes, 0);
  try
    with FDCA do begin
      if not Models.ModelExists(ModelID) then
        raise Exception.Create(MessText(mtkNotFoundModel, IntToStr(ModelID)));
      Model:= Models[ModelID];
      nodes:= AutoTreeNodesSys[Model.TypeSys];
    end;

    if not nodes.NodeExists(NodeID) then
      raise Exception.Create(MessText(mtkNotFoundNode, IntToStr(NodeID)));
    node:= nodes[NodeID];
    flNotEndNode:= not node.IsEnding;

    nodeDelim:= brcWebDelim;      // разделитель узлов / 0-й порции
    partDelim:= '---------- или ----------';           // разделитель порций
    partDelim:= brcWebBoldBlackBegin+partDelim+brcWebBoldEnd;  // жирный черный шрифт
    if flNotEndNode then str:= cWebSpace+cWebSpace+cWebSpace else str:= ''; // отступ, если исх.нода не конечная
//    partDelim:= cWebItalBegin+cWebBoldBlackBegin+partDelim+cWebBoldEnd+cWebItalEnd; // жирный черный курсив
    try
      ORD_IBD:= cntsOrd.GetFreeCnt;
      sFilters:= StringReplace(sFilters, ' ', '', [rfReplaceAll]); // убираем все пробелы
//------------------------------------------ если заданы фильтры (нода конечная)
      if not flNotEndNode and (sFilters<>'') then begin
        ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
        ORD_IBS.SQL.Text:= 'select RWare, Rpart, Rtype, RtypeName, Rtext'+
          ' from GetModNodFiltWaresWithUseParts_('+
          IntToStr(ModelID)+', '+IntToStr(NodeID)+', :sFilters)';
        ORD_IBS.ParamByName('sFilters').AsString:= sFilters;
        ORD_IBS.ExecQuery;
        while not ORD_IBS.Eof do begin
          if (ORD_IBS.FieldByName('Rpart').AsInteger<0)
            and (ORD_IBS.FieldByName('Rtext').AsString<>'') then begin
            sFilters:= ORD_IBS.FieldByName('Rtext').AsString; // строка значений фильтров
            ORD_IBS.Next;
            Continue;
          end;

          wareID:= ORD_IBS.FieldByName('RWare').AsInteger; // код товара
          if not WareExist(wareID) or GetWare(wareID).IsArchive then begin
            while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('RWare').AsInteger) do ORD_IBS.Next;
            Continue;
          end;

          if (ORD_IBS.FieldByName('RtypeName').AsString='') then begin // если только код товара
            Result.AddObject('', Pointer(wareID));
            ORD_IBS.Next;
            Continue;
          end;

          pCount:= 0; // счетчик порций
          if lst.Count>0 then lst.Clear;
          flPart0:= False;                    // собираем тексты по 1-му товару
          while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('RWare').AsInteger) do begin
            iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // порция

            if (iPart<0) and (ORD_IBS.FieldByName('Rtext').AsString<>'') then begin
              sFilters:= ORD_IBS.FieldByName('Rtext').AsString; // строка значений фильтров
              ORD_IBS.Next;
              Continue;
            end;

            if (iPart=0) then flPart0:= True; // флаг 0-й порции (значение критерия фильтра товара)
            if pCount>0 then
              if flPart0 then begin
                lst.Add(brcWebDelim); // разделитель 0-й порции
                flPart0:= False;
              end else lst.Add(partDelim); // разделитель порций

            while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('RWare').AsInteger)
              and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
              iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
              TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
              s:= '';
              while not ORD_IBS.Eof and (wareID=ORD_IBS.FieldByName('RWare').AsInteger)
                and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
                and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
                s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
                cntsORD.TestSuspendException;
                ORD_IBS.Next;
              end;
              s:= str+TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
              if (iPart=0) then  // выделяем строки 0-й порции
                s:= brcWebColorRedBegin+s+brcWebColorEnd; // красный шрифт
              lst.Add(s);
            end; // while not ORD_IBS.Eof and (wareID=... and (iPart=

            inc(pCount); // счетчик порций
          end; // while not ORD_IBS.Eof and (wareID=

          Result.AddObject(lst.Text, Pointer(wareID));
        end; // while not ORD_IBS.Eof
        ORD_IBS.Close;
        if Result.Count>1 then Result.CustomSort(ObjWareNameSortCompare); // сортировка по наименованию товара

//------------------------------------------------------- если не заданы фильтры
      end else begin
        flFromBase:= not Cache.WareLinksUnLocked; // пока кеш связок не заполнен - берем из базы
        WareCodes:= Model.GetModelNodeWares(NodeId, withChildNodes, flFromBase); // коды товаров по ноде модели
        if Length(WareCodes)<1 then Exit;

        try
          if flFromBase then nlinks:= Model.GetModelNodesLinks
          else nlinks:= Model.NodeLinks;
          AddCodes(NodeID);         // собираем коды всех главных конечных нод
          if NodeCount<1 then begin // если нет нод
            for i:= 0 to High(WareCodes) do Result.AddObject('', Pointer(WareCodes[i]));
            Exit;
          end;
        finally
          if flFromBase then nlinks.Free;
        end;

        ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpRead, True);
        ORD_IBS.SQL.Text:= 'select Rpart, Rtype, RtypeName, Rtext'+
          ' from GetWareModelNodeUseTextParts_n('+IntToStr(ModelID)+', :NodeID, :WareID)';
        for i:= 0 to High(WareCodes) do begin
          if lst.Count>0 then lst.Clear;
          ORD_IBS.ParamByName('WareID').AsInteger:= WareCodes[i];

          for ii:= 0 to NodeCount-1 do begin
            NodeID:= arNodeCodes[ii];
            ORD_IBS.ParamByName('NodeID').AsInteger:= NodeID;
            ORD_IBS.ExecQuery;
            // если по ноде что-то есть и исх.нода не конечная - пишем название ноды
            if flNotEndNode and not (ORD_IBS.Bof and ORD_IBS.Eof) then begin
              if lst.Count>0 then lst.Add(nodeDelim);    // разделитель узлов
              s:= 'Узел - '+nodes[NodeID].Name+': ';
              s:= brcWebColorBlueBegin+s+brcWebColorEnd; // синий шрифт
              lst.Add(s);
            end;

            pCount:= 0; // счетчик порций
            while not ORD_IBS.Eof do begin // собираем тексты по 1-му узлу
              iPart:= ORD_IBS.FieldByName('Rpart').AsInteger; // порция
              if pCount>0 then lst.Add(partDelim);            // разделитель порций

              while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger) do begin // тексты по 1 порции
                iType:= ORD_IBS.FieldByName('Rtype').AsInteger;
                TypeName:= ORD_IBS.FieldByName('RtypeName').AsString;
                s:= '';
                while not ORD_IBS.Eof and (iPart=ORD_IBS.FieldByName('Rpart').AsInteger)
                  and (iType=ORD_IBS.FieldByName('Rtype').AsInteger) do begin // тексты по 1 типу текста
                  s:= s+fnIfStr(s='', '', ', ')+ORD_IBS.FieldByName('Rtext').AsString;
                  cntsORD.TestSuspendException;
                  ORD_IBS.Next;
                end;
                s:= str+TypeName+fnIfStr(s='', '', ': '+s);  // строка по 1-му типу текста
                lst.Add(s);
              end; // while not ORD_IBS.Eof and (iPart=

              inc(pCount); // счетчик порций
            end; //  while not ORD_IBS.Eof
            ORD_IBS.Close;
          end; // for ii:= 0 to High(arNodeCodes)

          Result.AddObject(lst.Text, Pointer(WareCodes[i]));
        end; // for i:= 0 to High(WareCodes)

      end;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
      SetLength(arNodeCodes, 0);
      SetLength(WareCodes, 0);
      prFree(lst);
    end;
  except
    on E: Exception do prMessageLOGS(nmProc+': ModelID='+IntToStr(ModelID)+
      ' NodeID='+IntToStr(NodeID)+' sFilters='+sFilters+#10+E.Message, fLogCache);
  end;
end;
//===================== добавить/удалить линк товара с аналогом (Excel, вручную)
function TDataCache.CheckWareCrossLink(pWareID, pCrossID: Integer;
         var ResCode: Integer; srcID: Integer; UserID: Integer=0): String;
const nmProc = 'CheckWareCrossLink';
// ResCode на входе - вид операции (resAdded, resDeleted, resWrong, resNotWrong)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось, resAdded - добавлена,
// resDeleted - удалена, resWrong - отмечена, как неверная, resNotWrong - восстановлена
// ограничения: удалять можно связки только с источником (Excel или вручную)
//              пометить Wrong можно только связки с источником (TD)
var ibd: TIBDatabase;
    ibs: TIBSQL;
    Ware: TWareInfo;
    OpCode, LinkSrc: Integer;
    fex: Boolean;
    mess, s, sWare, sCross, sUser, mess1: string;
    pool: TIBCntsPool;
    empl: TEmplInfoItem;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  OpCode:= ResCode;
  ResCode:= resError;
  ibs:= nil;
  mess1:= '';
  try
    if not (OpCode in [resAdded, resDeleted, resWrong, resNotWrong]) then // проверяем код операции
      raise Exception.Create(MessText(mtkNotValidParam)+' операции');
    if (pCrossID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' аналога');

    Ware:= GetWare(pWareID, True);
    if (Ware=NoWare) or Ware.IsArchive then                   // проверяем товар
      raise Exception.Create(MessText(mtkNotFoundWare, IntToStr(pWareID)));

    fex:= Ware.AnalogLinks.LinkExists(pCrossID) // проверка существования кросса
          and TAnalogLink(Ware.AnalogLinks[pCrossID]).IsCross;
    if fex then begin
      mess:= '';
      case OpCode of
        resAdded   : mess:= 'Такая '+MessText(mtkWareAnalogLink)+' есть';
        resNotWrong: mess:= MessText(mtkWareAnalogLink)+' не отмечена, как ошибочная';
      end; // case
      if mess<>'' then begin
        ResCode:= resDoNothing;
        raise Exception.Create(mess);
      end;
    end else if (OpCode in [resDeleted, resWrong]) then begin
      ResCode:= resDoNothing;
      raise Exception.Create('Не найдена '+MessText(mtkWareAnalogLink));
    end;
                       // проверка необходимых параметров и доступности операции
    if (OpCode in [resAdded, resNotWrong, resWrong]) and (userID<1) then
      raise Exception.Create(MessText(mtkNotValidParam)+' юзера')
    else if (OpCode in [resAdded]) and (srcID<1) then
      raise Exception.Create(MessText(mtkNotValidParam)+' источника')
    else if (OpCode in [resDeleted, resWrong]) then begin
      LinkSrc:= GetLinkSrc(Ware.AnalogLinks[pCrossID]);
      case OpCode of
      resDeleted: // удалять можно связки только с источником (Excel, GrossBee или вручную)
        if not Cache.CheckLinkAllowDelete(LinkSrc) then begin
          if not Cache.CheckLinkAllowWrong(LinkSrc) then
            raise Exception.Create(MessText(mtkFuncNotAvailabl));
          if (userID<1) then raise Exception.Create(MessText(mtkNotValidParam)+' юзера');
          OpCode:= resWrong; // связки TecDoc не удаляем, а отмечаем неверными
          mess1:= ' (TecDoc)';
        end;
      resWrong:  // пометить Wrong можно только связки с источником (TD)
        if not Cache.CheckLinkAllowWrong(LinkSrc) then
          raise Exception.Create(MessText(mtkFuncNotAvailabl));
      end; // case
    end;

    if CheckNotValidUser(userID, isWe, s) then raise EBOBError.Create(s); // проверка юзера
    empl:= Cache.arEmplInfo[userID];
//--------------------------------------------------- отрабатываем запись в базу
    pool:= cntsGRB;
    ibd:= pool.GetFreeCnt(empl.GBLogin, cDefPassword, cDefGBrole);
    LinkSrc:= FDCA.GetSourceGBcode(srcID);
    sWare:= IntToStr(pWareID);
    sCross:= IntToStr(pCrossID);
    sUser:= IntToStr(UserID);
    try
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpWrite, true);

      case OpCode of
      resAdded: begin                // добавляем
          ibs.SQL.Text:= 'select rCrossID, errLink from Vlad_CSS_AddWareCross('+
            sWare+', '+sCross+', '+sUser+', '+IntToStr(LinkSrc)+')';
          ibs.ExecQuery;
          if (ibs.Eof and ibs.Bof) then
            raise EBOBError.Create(MessText(mtkErrAddRecord))
          else if (ibs.Fields[1].AsInteger>0) then
            raise EBOBError.Create('связь товара с аналогом в базе отмечена, как неверная')
          else if (ibs.Fields[1].AsInteger<0) then begin
            with Ware do if not AnalogLinks.LinkExists(pCrossID) and
              CheckAnalogLink(pCrossID, srcID) then SortAnalogsByName; // на всяк.случай
            ResCode:= resDoNothing;
            raise EBOBError.Create('Такая '+MessText(mtkWareAnalogLink)+' есть');
          end else if (ibs.Fields[0].AsInteger<1) then
            raise Exception.Create('error add cross Ware='+sWare+' Cross='+sCross);
        end; // resAdded

      resWrong, resNotWrong: begin // меняем признак Wrong
          s:= fnIfStr(OpCode=resWrong, 'T', 'F');
          ibs.SQL.Text:= 'update PMWAREANALOGS set PMWAISWRONG="'+s+'", PMWAUSERCODE='+sUser+
            ' where PMWAWARECODE='+sWare+' and PMWAWAREANALOGCODE='+sCross;
          ibs.ExecQuery;
        end; // resWrong, resNotWrong

      resDeleted: begin              // удаляем
          ibs.SQL.Text:= 'select rCrossID from Vlad_CSS_DelWareCross('+
            sWare+', '+sCross+', '+IntToStr(LinkSrc)+')';
          ibs.ExecQuery;
          if (ibs.Bof and ibs.Eof) or (ibs.Fields[0].AsInteger<1) then
            raise Exception.Create('error del cross Ware='+sWare+' Cross='+sCross);
        end; // resDeleted
      end; // case
      ibs.Transaction.Commit;
    finally
      prFreeIBSQL(ibs);
      pool.SetFreeCnt(ibd);
    end;

//------------------------------------------------------------- отрабатываем кэш
    with Ware do case OpCode of
      resAdded, resNotWrong:                               // добавляем
        if CheckAnalogLink(pCrossID, srcID) then SortAnalogsByName;
      resDeleted, resWrong: DelAnalogLink(pCrossID, True); // удаляем
    end; // case

    mess:= MessText(mtkWareAnalogLink);
    case OpCode of
      resAdded:    Result:= mess+' добавлена';
      resDeleted:  Result:= mess+' удалена';
      resWrong:    Result:= mess+mess1+' отмечена, как неверная';
      resNotWrong: Result:= mess+' восстановлена';
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
end;
//==== добавить/удалить линки товара с аналогами по 1 артикулу (загрузка из TDT)
function TDataCache.CheckWareArtCrossLinks(pWareID: Integer; CrossArt: String; crossMF: Integer;
         var ResCode: Integer; srcID: Integer; UserID: Integer=0; ibsORD: TIBSQL=nil): String;
const nmProc = 'CheckWareArtCrossLinks';
// вид операции - ResCode - на входе (resAdded, resDeleted)
// ResCode на выходе: resError- ошибка, resAdded - добавлены, resDeleted - удалены
var ibd: TIBDatabase;
    ibs: TIBSQL;
    Ware: TWareInfo;
    OpCode, i, j, srcGB: Integer;
    mess: string;
    ArCross: array of TCrossInfo; // список аналогов по артикулу CrossArt
begin
  Result:= '';
  if not Assigned(self) then Exit;
  SetLength(ArCross, 0);
  OpCode:= ResCode;
  ResCode:= resError;
  ibs:= nil;
  ibd:= nil;
  srcGB:= FDCA.GetSourceGBcode(srcID);
  try
    if not (OpCode in [resAdded, resDeleted]) then // проверяем код операции
      raise Exception.Create(MessText(mtkNotValidParam)+' операции');

    if (crossMF<1) or (CrossArt='') then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' артикула');

    Ware:= GetWare(pWareID, True);
    if (Ware=NoWare) or Ware.IsArchive then        // проверяем товар
      raise Exception.Create(MessText(mtkNotFoundWare, IntToStr(pWareID)));

    if OpCode=resAdded then begin
      if (userID<1) then raise Exception.Create(MessText(mtkNotValidParam)+' юзера');
      if (srcID<1) then raise Exception.Create(MessText(mtkNotValidParam)+' источника');
    end; // resAdded

    j:= 0; // счетчик аналогов по артикулу CrossArt
//--------------------------------------------------- отрабатываем запись в базу
    if Assigned(ibsORD) then begin
      ibs:= ibsORD;
      with ibs.Transaction do if not InTransaction then StartTransaction;
    end else begin
      ibd:= cntsOrd.GetFreeCnt; // коды товаров, привязанных к артикулу CrossArt, из базы dbOrder
      ibs:= fnCreateNewIBSQL(ibd, 'ibsOrd_'+nmProc, -1, tpRead, true);
    end;

    try
      if IBS.SQL.Text='' then
        IBS.SQL.Text:= 'select WATDWARECODE from WAREARTICLETD'+
          ' inner join wareoptions on wowarecode=WATDWARECODE and woarhived="F"'+
          ' where WATDARTSUP=:crossMF and WATDARTICLE=:CrossArt and WATDWRONG="F"';
      ibs.ParamByName('crossMF').AsInteger:= crossMF;
      ibs.ParamByName('CrossArt').AsString:= CrossArt;  // артикул TD
      ibs.ExecQuery;
      while not ibs.Eof do begin
        i:= ibs.Fields[0].AsInteger;  // код товара по артикулу-аналогу
        if WareExist(i) then begin
          if Length(ArCross)<(j+1) then SetLength(ArCross, j+100);
          ArCross[j].cross:= i;  // код товара по артикулу-аналогу
          inc(j);
        end;
        ibs.Next;
      end;
    finally
      if Assigned(ibsORD) then ibs.Close
      else begin
        prFreeIBSQL(ibs);
        cntsOrd.SetFreeCnt(ibd);
      end;
    end;
    if Length(ArCross)>j then SetLength(ArCross, j);

    ibd:= cntsGRB.GetFreeCnt;                         // пишем в базу Grossbee
    try
      ibs:= fnCreateNewIBSQL(ibd, 'ibsGRB_'+nmProc, -1, tpWrite, true);

      case OpCode of
      resAdded: begin         // добавляем / проверяем аналоги по списку кодов
          ibs.SQL.Text:= 'select rCrossID, errLink from Vlad_CSS_AddWareCross('+
            IntToStr(pWareID)+', :CrossID, '+IntToStr(UserID)+', '+IntToStr(srcGB)+')';
          for j:= 0 to High(ArCross) do if (ArCross[j].cross>0) then begin
            ibs.ParamByName('CrossID').AsInteger:= ArCross[j].cross;
            ibs.ExecQuery;
            if not (ibs.Bof and ibs.Eof) and (ibs.Fields[0].AsInteger>0) then begin
              ArCross[j].wrong:= ibs.Fields[1].AsInteger>0; // признак неправильной связки
              ArCross[j].exist:= ibs.Fields[1].AsInteger<0; // признак - уже есть
            end else ArCross[j].cross:= 0; // если линк не записался - обнуляем код
            ibs.Close;
          end;
        end; // resAdded

      resDeleted: begin              // удаляем аналоги по списку кодов
          ibs.SQL.Text:= 'select rCrossID from Vlad_CSS_DelWareCross('+
            IntToStr(pWareID)+', :CrossID, '+IntToStr(srcGB)+')';
          for j:= 0 to High(ArCross) do if (ArCross[j].cross>0) then begin
            ibs.ParamByName('CrossID').AsInteger:= ArCross[j].cross;
            ibs.ExecQuery;
            if not (ibs.Bof and ibs.Eof) or (ibs.Fields[0].AsInteger<1) then
              ArCross[j].cross:= 0; // если линк не удалился - обнуляем код
            ibs.Close;
          end;

        end; // resDeleted
      end; // case
      ibs.Transaction.Commit;
    finally
      prFreeIBSQL(ibs);
      cntsGRB.SetFreeCnt(ibd);
    end;

//------------------------------------------------------------- отрабатываем кэш
    case OpCode of
      resAdded: begin  // добавляем / сверяем
          i:= 0; // счетчик добавленных связок
          for j:= 0 to High(ArCross) do if (ArCross[j].cross>0) then with ArCross[j] do
            if wrong then Ware.DelAnalogLink(cross, True)
            else if (not exist or not Ware.AnalogLinks.LinkExists(cross)) and
              Ware.CheckAnalogLink(cross, srcID) then inc(i);
          if i>0 then Ware.SortAnalogsByName; // если добавляли - сортируем
        end; // resAdded

      resDeleted:
        for j:= 0 to High(ArCross) do if (ArCross[j].cross>0) then
          Ware.DelAnalogLink(ArCross[j].cross, True);
    end; // case

    mess:= 'связи товара с аналогами по артикулу ';
    case OpCode of
      resAdded:    Result:= mess+'добавлены';
      resDeleted:  Result:= mess+'удалены';
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
  SetLength(ArCross, 0);
end;
//============================ добавить линк товара со значением критерия в базу
function TDataCache.CheckWareCriValueLink(pWareID, criTD, UserID, srcID: Integer;
         CriName, CriValue: String; ORD_IBS: TIBSQL=nil): String;
const nmProc = 'CheckWareCriValueLink';
var ORD_IBD: TIBDatabase;
    flCreate: Boolean;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBD:= nil;
  try
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if (CriName='') then raise EBOBError.Create(MessText(mtkNotValidParam)+' критерия');
    flCreate:= not assigned(ORD_IBS);
    try
      if flCreate then begin
        ORD_IBD:= cntsOrd.GetFreeCnt;                 // пишем в базу
        ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      end else
        with ORD_IBS.Transaction do if not InTransaction then StartTransaction;

      if ORD_IBS.SQL.Text='' then
        ORD_IBS.SQL.Text:= 'select linkID, errLink from AddWareCriLink('+
          IntToStr(pWareID)+', '+IntToStr(criTD)+', :CriName, :CriValue, '+
          IntToStr(UserID)+', '+IntToStr(srcID)+')';
      ORD_IBS.ParamByName('CriName').AsString:= CriName;
      ORD_IBS.ParamByName('CriValue').AsString:= CriValue;
      ORD_IBS.ExecQuery;
      if (ORD_IBS.Eof and ORD_IBS.Bof) then
        raise EBOBError.Create(MessText(mtkErrAddRecord))
      else if (ORD_IBS.Fields[1].AsInteger>0) then
        raise EBOBError.Create('связь товара с критерием в базе отмечена, как неверная')
      else if (ORD_IBS.Fields[1].AsInteger<0) then raise EBOBError.Create('exists')
      else if (ORD_IBS.Fields[0].AsInteger<1) then
        raise Exception.Create('error add cri link Ware='+IntToStr(pWareID)+
          ' CriName='+CriName+' CriValue='+CriValue);
      ORD_IBS.Transaction.Commit;
      ORD_IBS.Close;
    finally
      if assigned(ORD_IBS) then begin
        with ORD_IBS.Transaction do if InTransaction then Rollback;
        ORD_IBS.Close;
      end;
      if flCreate then begin
        prFreeIBSQL(ORD_IBS);
        cntsOrd.SetFreeCnt(ORD_IBD);
      end;
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//================================== добавить/редактировать доп.параметры бренда
function TDataCache.CheckBrandAdditionData(pBrandID, UserID: Integer;
         pNameWWW, pPrefix, pAdressWWW: String; pDownLoadEx: Boolean): String;
const nmProc = 'CheckBrandAdditionData';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    brand: TBrandItem;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBD:= nil;
  try
    if not Cache.WareBrands.ItemExists(pBrandID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' бренда');

    pPrefix:= trim(pPrefix);
    pAdressWWW:= trim(pAdressWWW);
    pNameWWW:= trim(pNameWWW);

    brand:= Cache.WareBrands[pBrandID];
    if (pNameWWW=brand.NameWWW) and (pPrefix=brand.WarePrefix)
      and (pAdressWWW=brand.adressWWW) and (pDownLoadEx=brand.DownLoadExclude) then Exit;

    try
      ORD_IBD:= cntsOrd.GetFreeCnt;                 // пишем в базу
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);

      ORD_IBS.SQL.Text:= 'update or insert into BRANDADDITIONDATA'+
        ' (BRADCODE, BRADNAMEWWW, BRADprefix, BRADaddress, BRADUSERID, BRADNotPriceLoad)'+
        ' values ('+IntToStr(pBrandID)+', :nameWW, :pref, :adr, '+IntToStr(UserID)+', :loadEx)'+
        ' matching (BRADCODE)';
      ORD_IBS.ParamByName('nameWW').AsString:= pNameWWW;
      ORD_IBS.ParamByName('pref').AsString:= pPrefix;
      ORD_IBS.ParamByName('adr').AsString:= pAdressWWW;
      ORD_IBS.ParamByName('loadEx').AsString:= fnIfStr(pDownLoadEx, 'T', 'F');
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;

      with brand do begin
        NameWWW:= pNameWWW;
        WarePrefix:= pPrefix;
        adressWWW:= pAdressWWW;
        DownLoadExclude:= pDownLoadEx;
      end;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message);
  end;
end;
//=========================== номер порции значений условий связки 3 (заготовка)
function TDataCache.GetModelNodeWareUseListNumber(pModelID, pNodeID, pWareID: Integer;
         UseList: TStringList): Integer;
const nmProc = 'GetModelNodeWareUseListNumber';
// UseList - список строк <критерий>cStrValueDelim<значение>, в Object - <код TecDoc критерия>
// при посадке из Excel <код TecDoc критерия>=0
// в Result - номер найденной порции, иначе -1
var ORD_IBD: TIBDatabase;
    ORD_IBSr: TIBSQL;
    criTD, iUseList, i, j, ii: Integer;
    UseName, UseValue, s: String;
    ordUses: TStringList;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  ORD_IBSr:= nil;
  ordUses:= TStringList.Create;
  j:= -1;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not Assigned(UseList) or (UseList.Count<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой список условий');

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBSr:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBSr_'+nmProc);
                                                   // условия к связкe 3 из ORD
      with ORD_IBSr.Transaction do if not InTransaction then StartTransaction;
      if ORD_IBSr.SQL.Text='' then
        ORD_IBSr.SQL.Text:= 'select LWMNUPART, WCRITDCODE, WCRIDESCRUP, WCVSVALUEUP'+
          ' from (select LWMNUPART, LWMNUWCVSCODE'+
          '   from (select ldmwcode from (select LDEMCODE from LINKDETAILMODEL'+
          '     where LDEMTRNACODE='+IntToStr(pNodeID)+' and LDEMDMOSCODE='+IntToStr(pModelID)+')'+   // and LDEMWRONG="F"
          '     inner join LINKDETMODWARE on LDMWLDEMCODE=LDEMCODE'+
          '       and LDMWWARECODE='+IntToStr(pWareID)+')'+                               // and LDMWWRONG="F"
          '   inner join LinkWareModelNodeUsage on LWMNULDMWCODE=ldmwcode)'+ // and LWMNUWRONG="F"
          ' left join WARECRIVALUES on WCVSCODE=LWMNUWCVSCODE'+
          ' left join WARECRITERIES on WCRICODE=WCVSWCRICODE order by LWMNUPART';
      ORD_IBSr.ExecQuery;
      while not ORD_IBSr.Eof do begin
        iUseList:= ORD_IBSr.FieldByName('LWMNUPART').AsInteger; // 1 порция
        if ordUses.Count>0 then ordUses.Clear;

        while not ORD_IBSr.Eof and (iUseList=ORD_IBSr.FieldByName('LWMNUPART').AsInteger) do begin
          UseName:= ORD_IBSr.FieldByName('WCRIDESCRUP').AsString;
          UseValue:= ORD_IBSr.FieldByName('WCVSVALUEUP').AsString;
          criTD:= ORD_IBSr.FieldByName('WCRITDCODE').AsInteger;
          ordUses.AddObject(UseName+cStrValueDelim+UseValue, Pointer(criTD));
          TestCssStopException; // проверка остановки системы
          ORD_IBSr.Next;
        end;
        if (ordUses.Count<>UseList.Count) then Continue; // не совпадает кол-во в порции

        for i:= 0 to UseList.Count-1 do begin
          j:= -1; // искомый индекс элемента порции в списке из нашей базы
          criTD:= Integer(UseList.Objects[i]); // код критерия TD
          s:= fnGetBefore(cStrValueDelim, UseList[i]);
          if s='' then begin
            UseName:= AnsiUpperCase(UseList[i]);
            UseValue:= '';
          end else begin
            UseName:= AnsiUpperCase(s);
            UseValue:= AnsiUpperCase(fnGetAfter(cStrValueDelim, UseList[i]));
          end;
          if criTD>0 then begin // если есть код TD
            for ii:= 0 to ordUses.Count-1 do
              if (criTD=Integer(ordUses.Objects[ii])) then begin
                s:= fnGetAfter(cStrValueDelim, ordUses[ii]); // ищем значение
                if s=UseValue then j:= ii;
              end;
          end;
          if j<0 then begin // если не нашли значение критерия
            s:= UseName+cStrValueDelim+UseValue; // ищем строку <критерий>=<значение>
            j:= ordUses.IndexOf(s);
          end;
          if (j<0) then Break;  // если никак не нашли
        end; // for i:= 0 to UseList.Count-1

        if (j>-1) then begin
          Result:= iUseList; // если все нашли - возвращаем номер порции
          Exit;
        end;
      end;
    finally
      prFreeIBSQL(ORD_IBSr);
      cntsOrd.SetFreeCnt(ORD_IBD);
      prFree(ordUses);
    end;
  except
    on E: Exception do begin
      Result:= -1;
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//=================================================== получить текст уведомления
function TDataCache.GetNotificationText(noteID: Integer): String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  if Notifications.ItemExists(noteID) then Result:= Notifications[noteID].Name;
end;
//================== записать время показа/ознакомления уведомления пользователю
function TDataCache.SetClientNotifiedKind(userID, noteID, kind: Integer): String;
// kind=0 - показ уведомления, kind>0 - ознакомление
const nmProc='SetClientNotifiedKind';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    sUser, sNote: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try // самые простые проверки
    if not Notifications.ItemExists(noteID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' уведомления');
    if not ClientExist(userID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' пользователя');
    sUser:= IntToStr(userID);
    sNote:= IntToStr(noteID);

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      case kind of
      0: ORD_IBS.SQL.Text:= 'UPDATE OR INSERT INTO NOTIFIEDCLIENTS'+    // показ
           ' (NOCLSHOWTIME, NOCLCLIENT, NOCLNOTE) VALUES (current_timestamp, '+
           sUser+', '+sNote+') MATCHING (NOCLCLIENT, NOCLNOTE)';
      else                                                       // ознакомление
        ORD_IBS.SQL.Text:= 'UPDATE NOTIFIEDCLIENTS set NOCLVIEWTIME=current_timestamp'+
                           ' where NOCLCLIENT='+sUser+' and NOCLNOTE='+sNote;
      end; // case
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrProcess);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//==================== добавить линки связки 3 с порцией значений условий в базу
function TDataCache.AddModelNodeWareUseListLinks(pModelID, pNodeID, pWareID,
         UserID, srcID: Integer; var UseList: TStringList; var pPart: Integer): String;
const nmProc = 'AddModelNodeWareUseListLinks';
// проверка существования 3-й связки и отсутствия порции - до вызова функции !!!
// UseList - список строк <критерий>cStrValueDelim<значение>, в Object - <код TecDoc критерия>
// при посадке из Excel <код TecDoc критерия> = 0
// pPart на выходе - номер порции (нужен для связи с инфо-текстами)
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    criTD, iUseList, i: Integer;
    UseName, UseValue, s: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try // самые простые проверки
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not Assigned(UseList) or (UseList.Count<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой список условий');

    iUseList:= pPart;
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'select partID, errLink from AddModelNodeWarePartUsageLink('+
        IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', :iUseList,'+
        ' :criTD, :CriName, :CriValue, '+IntToStr(UserID)+', '+IntToStr(srcID)+')';

      for i:= 0 to UseList.Count-1 do begin
        if not Assigned(UseList.Objects[i]) then criTD:= 0
        else criTD:= Integer(UseList.Objects[i]);
        UseName:= fnGetBefore(cStrValueDelim, UseList[i]);
        if UseName='' then begin
          UseName:= UseList[i];
          UseValue:= '';
        end else UseValue:= fnGetAfter(cStrValueDelim, UseList[i]);

        ORD_IBS.ParamByName('criTD').AsInteger:= criTD;
        ORD_IBS.ParamByName('CriName').AsString:= UseName;
        ORD_IBS.ParamByName('CriValue').AsString:= UseValue;
        ORD_IBS.ParamByName('iUseList').AsInteger:= iUseList; // номер порции (может быть <1)
        ORD_IBS.ExecQuery;
        if (ORD_IBS.Eof and ORD_IBS.Bof) then
          raise EBOBError.Create(MessText(mtkErrAddRecord))
        else begin
          if ORD_IBS.FieldByName('errLink').AsInteger>0 then
            raise EBOBError.Create(MessText(mtkWareModNodeUse)+' в базе отмечено, как неверное');
          if (ORD_IBS.FieldByName('partID').AsInteger<1) then begin
            s:= 'error add use part: Model='+IntToStr(pModelID)+' Node='+IntToStr(pNodeID)+
                ' Ware='+IntToStr(pWareID)+' Cri='+UseName+' Value='+UseValue;
            raise Exception.Create(s);
          end;
          if iUseList<1 then iUseList:= ORD_IBS.FieldByName('partID').AsInteger;
        end;
        ORD_IBS.Close;
      end; // for

      ORD_IBS.Transaction.Commit;
      pPart:= iUseList; // возвращаем номер порции
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do if E.Message<>'duplicate' then begin
      Result:= MessText(mtkErrAddRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//==================== удалить линки связки 3 с порцией значений условий из базы
function TDataCache.DelModelNodeWareUseListLinks(pModelID, pNodeID, pWareID, iUseList: Integer): String;
const nmProc = 'DelModelNodeWareUseListLinks';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if (iUseList<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' номера списка условий');

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'execute procedure DelModelNodeWarePartUsageLinks('+IntToStr(pModelID)+
        ', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+IntToStr(iUseList)+')';
      ORD_IBS.ExecQuery;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrDelRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//==================== заменить линки связки 3 с порцией значений условий в базе
function TDataCache.ChangeModelNodeWareUsesPart(pModelID, pNodeID, pWareID,
         UserID, srcID: Integer; UseList: TStringList; var pPart: Integer): String;
const nmProc = 'ChangeModelNodeWareUsesPart';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    criTD, i: Integer;
    UseName, UseValue, s: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');

    if (pPart<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' номера списка условий');
    if not Assigned(UseList) or (UseList.Count<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой список условий');

    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      ORD_IBS.SQL.Text:= 'execute procedure DelModelNodeWarePartUsageLinks('+IntToStr(pModelID)+
        ', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+IntToStr(pPart)+')';
      ORD_IBS.ExecQuery;
      ORD_IBS.Close;

      ORD_IBS.SQL.Text:= 'select partID, errLink from AddModelNodeWarePartUsageLink('+
        IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', :iUseList,'+
        ' :criTD, :CriName, :CriValue, '+IntToStr(UserID)+', '+IntToStr(srcID)+')';

      for i:= 0 to UseList.Count-1 do begin
        if not Assigned(UseList.Objects[i]) then criTD:= 0
        else criTD:= Integer(UseList.Objects[i]);
        UseName:= fnGetBefore(cStrValueDelim, UseList[i]);
        if UseName='' then begin
          UseName:= UseList[i];
          UseValue:= '';
        end else UseValue:= fnGetAfter(cStrValueDelim, UseList[i]);

        ORD_IBS.ParamByName('criTD').AsInteger:= criTD;
        ORD_IBS.ParamByName('CriName').AsString:= UseName;
        ORD_IBS.ParamByName('CriValue').AsString:= UseValue;
        ORD_IBS.ParamByName('iUseList').AsInteger:= pPart; // номер порции
        ORD_IBS.ExecQuery;
        if (ORD_IBS.Eof and ORD_IBS.Bof) then
          raise EBOBError.Create(MessText(mtkErrAddRecord))
        else begin
          if ORD_IBS.FieldByName('errLink').AsInteger>0 then
            raise EBOBError.Create(MessText(mtkWareModNodeUse)+' в базе отмечено, как неверное');
          if (ORD_IBS.FieldByName('partID').AsInteger<1) then begin
            s:= 'error add use part: Model='+IntToStr(pModelID)+' Node='+IntToStr(pNodeID)+
                ' Ware='+IntToStr(pWareID)+' Cri='+UseName+' Value='+UseValue;
            raise Exception.Create(s);
          end;
          if pPart<>ORD_IBS.FieldByName('partID').AsInteger then
            raise EBOBError.Create('несовпадение номеров порций');            // ???
        end;
        ORD_IBS.Close;
      end; // for

      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrEditRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//==================================== номер порции текстов связки 3 (заготовка)
function TDataCache.GetModelNodeWareTextListNumber(pModelID, pNodeID, pWareID: Integer;
         TxtList: TStringList; nTxtList: Integer=0; ORD_IBSr: TIBSQL=nil): Integer;
const nmProc = 'GetModelNodeWareTextListNumber';
// ORD_IBSr передается при пакетной загрузке для увеличения скорости обработки
// TxtList - список, в Object - <код supTD текста>
// String - <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
// при посадке из Excel <идентификатор TecDoc>='', <код supTD текста>=0
// в Result - номер найденной порции, иначе -1
// если задан nTxtList - проверяем только заданную порцию
var ORD_IBD: TIBDatabase;
    flCreate, flNo: Boolean;
    supTD, iTxtList, i, j: Integer;
    TxtValue, TypeStr: String;
    ordTxts: TStringList;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  ORD_IBD:= nil;
  flCreate:= not assigned(ORD_IBSr);
  ordTxts:= TStringList.Create;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not Assigned(TxtList) or (TxtList.Count<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой список текстов');
    try
      if flCreate then begin
        ORD_IBD:= cntsOrd.GetFreeCnt;
        ORD_IBSr:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBSr_'+nmProc);
      end else ORD_IBSr.Close;
                                                   // тексты к связкe 3 из ORD
      with ORD_IBSr.Transaction do if not InTransaction then StartTransaction;
      if ORD_IBSr.SQL.Text='' then
        ORD_IBSr.SQL.Text:= 'select LWNMTPART, LWNMTinfotype, WITSUPTD, WITTMTD, ITTEXT'+
          ' from (select LWNMTPART, LWNMTWIT, LWNMTinfotype'+
          '   from (select ldmwcode from (select LDEMCODE from LINKDETAILMODEL'+
          '     where LDEMTRNACODE='+IntToStr(pNodeID)+' and LDEMDMOSCODE='+IntToStr(pModelID)+')'+ // and LDEMWRONG="F"
          '     inner join LINKDETMODWARE on LDMWLDEMCODE=LDEMCODE'+
          '       and LDMWWARECODE='+IntToStr(pWareID)+')'+                             // and LDMWWRONG="F"
          '   inner join LinkWareNodeModelText on LWNMTLDMW=ldmwcode)'+    // and LWNMTWRONG="F"
          ' left join WareInfoTexts on WITCODE=LWNMTWIT'+
          ' left join INFOTEXTS on ITCODE = WITTEXTCODE'+
          fnIfStr(nTxtList>0, ' where LWNMTPART='+IntToStr(nTxtList), ' order by LWNMTPART');
      ORD_IBSr.ExecQuery;
      while not ORD_IBSr.Eof do begin
        iTxtList:= ORD_IBSr.FieldByName('LWNMTPART').AsInteger; // 1 порция
        if ordTxts.Count>0 then ordTxts.Clear;
        ordTxts.Sorted:= False;
        while not ORD_IBSr.Eof and (iTxtList=ORD_IBSr.FieldByName('LWNMTPART').AsInteger) do begin
          supTD   := ORD_IBSr.FieldByName('WITSUPTD').AsInteger;
          TypeStr := ORD_IBSr.FieldByName('LWNMTinfotype').AsString;
          TxtValue:= ORD_IBSr.FieldByName('WITTMTD').AsString+cSpecDelim+
                     ORD_IBSr.FieldByName('ITTEXT').AsString;
          ordTxts.AddObject(TypeStr+cStrValueDelim+TxtValue, Pointer(supTD));
                   // <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
          TestCssStopException; // проверка остановки системы
          ORD_IBSr.Next;
        end;
        if (ordTxts.Count<>TxtList.Count) then Continue; // не совпадает кол-во в порции

        ordTxts.Sort;
        ordTxts.Sorted:= True;
        flNo:= False;
        for i:= 0 to TxtList.Count-1 do begin
          flNo:= not ordTxts.Find(TxtList[i], j); // ищем строку <тип текста>=<идентиф.>+cSpecDelim+<текст>
          if flNo then Break;
          supTD:= Integer(TxtList.Objects[i]); // проверяем код supTD
          flNo:= (supTD<>Integer(ordTxts.Objects[j]));
          if flNo then Break;
        end;
        if flNo then Continue; // не совпадает список порции

        Result:= iTxtList; // если порция найдена - возвращаем номер порции
        Break;
      end;
      ORD_IBSr.Close;
    finally
      if assigned(ORD_IBSr) then begin
        with ORD_IBSr.Transaction do if InTransaction then Rollback;
        ORD_IBSr.Close;
      end;
      if flCreate then begin
        prFreeIBSQL(ORD_IBSr);
        cntsOrd.SetFreeCnt(ORD_IBD);
      end;
      prFree(ordTxts);
    end;
  except
    on E: Exception do begin
      Result:= -1;
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//===================================== номера порций условий и текстов связки 3
function TDataCache.FindModelNodeWareUseAndTextListNumbers(pModelID, pNodeID, pWareID: Integer;
         var UseLists: TASL; var TxtLists: TASL; var ListNumbers: Tai; var ErrUseNums: Tai;
         var ErrTxtNums: Tai; FromTDT: Boolean=False; CheckTexts: Boolean=False): String;
const nmProc = 'FindModelNodeWareUseAndTextListNumbers';
// FromTDT=True - только с источником из TDT, CheckTexts - обязательно проверять тексты
// ListNumbers - массив номеров порций (индекс соотв. UseLists, TxtLists)
// ErrUseNums  - массив номеров порций условий, кот.надо удалять
// ErrTxtNums  - массив номеров порций текстов, кот.надо удалять
// UseLists - массив списков строк <критерий>=<значение>, в Object - <код TecDoc критерия>
//   при посадке из Excel <код TecDoc критерия>=0
// TxtLists - массив списков текстов, в Object - <код supTD текста>
//   String - <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
//   при посадке из Excel <идентификатор TecDoc>='', <код supTD текста>=0
// в Result - сообщение об ошибке
// на выходе в найденных UseLists[i] - Delimiter=LCharGood, в ненайденных - Delimiter=LCharUpdate
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    flErr, fl, flKod: Boolean;
    kodTD, TypeID, iUseList, ij, iAr, iTxtList: Integer;
    s, UseName, UseValue, TxtValue, TypeStr, TxtTM: String;
    ArOrdUses: TarCriInfo;
    ArOrdTexts: TarTextInfo;
  //---------------------------------------------------- проверка порции условий
  function CheckUseList(index: Integer; var ArOrdUses: TarCriInfo): Boolean;
  var i, ii, j: Integer;
  begin
    j:= -1;
    with UseLists[index] do for i:= 0 to Count-1 do try  // сверяем порцию с ArOrdUses
      j:= -1; // искомый индекс элемента порции в списке из нашей базы
      if Assigned(Objects[i]) then kodTD:= Integer(Objects[i]) else kodTD:= 0; // код критерия TD
      UseValue:= fnGetAfter(cStrValueDelim, Strings[i]);
      flKod:= (kodTD>0);
      if flKod then UseName:= ''  // если есть код - нужно только значение
      else begin
        UseName:= fnGetBefore(cStrValueDelim, Strings[i]);
        if UseName='' then UseName:= Strings[i];
      end;
      if (UseValue<>'') then UseValue:= AnsiUpperCase(UseValue);
      if (UseName<>'') then UseName:= AnsiUpperCase(UseName);
      for ii:= 0 to iAr-1 do begin
        if flKod then fl:= (kodTD=ArOrdUses[ii].CRITD) // если есть код - проверяем код и значение
        else fl:= (UseName=ArOrdUses[ii].CriNameUp);   // иначе проверяем наименование и значение
        if fl and (UseValue=ArOrdUses[ii].ValueUp) then begin
          j:= ii;
          Break;
        end;
      end; // for ii:= 0 to iAr-1
      if (j<0) then Break;  // если строка не найдена
    except end; // with UseLists[index] do for i:= 0 to Count-1
    Result:= (j>-1);
  end;
  //---------------------------------------------------- проверка порции текстов
  function CheckTxtList(index: Integer; var ArOrdTexts: TarTextInfo): Boolean;
  var i, ii, j: Integer;
  begin
    j:= -1;
    with TxtLists[index] do for i:= 0 to Count-1 do try  // ищем такую же порцию в ArOrdTexts
      j:= -1; // индекс элемента TxtLists[index] в списке из нашей базы
      if Assigned(Objects[i]) then kodTD:= Integer(Objects[i]) else kodTD:= 0; // код supTD
      // <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
      TypeStr:= fnGetBefore(cStrValueDelim, Strings[i]);
      TypeID:= StrToIntDef(TypeStr, 0);
      s:= fnGetAfter(cStrValueDelim, Strings[i]);
      TxtTM:= fnGetBefore(cSpecDelim, s);
      flKod:= (kodTD>0) and (TxtTM<>'');  // если есть supTD и идентификатор и CheckTexts=False - текст не нужен
      if flKod and not CheckTexts then TxtValue:= ''
      else TxtValue:= AnsiUpperCase(StringReplace(fnGetAfter(cSpecDelim, s), ' ', '', [rfReplaceAll]));

      for ii:= 0 to iAr-1 do begin
        if (TypeID<>ArOrdTexts[ii].infotype) then Continue; // если тип не тот
        fl:= False;
        if flKod then          // если есть supTD и идентификатор - проверяем их
          fl:= (kodTD=ArOrdTexts[ii].supTD) and (TxtTM=ArOrdTexts[ii].tmTD);
        if not fl or CheckTexts then fl:= (TxtValue=ArOrdTexts[ii].search); // проверяем поисковый текст
        if fl then begin
          j:= ii;
          Break;
        end;
      end; // for ii:= 0 to iAr-1
      if (j<0) then Break;  // если строка не найдена
    except end; // with TxtLists[index] do for i:= 0 to Count-1
    Result:= (j>-1);
  end;
  //--------------------------------------------------
begin
  Result:= '';
  if not Assigned(self) then Exit;
  SetLength(ErrUseNums, 0);
  SetLength(ErrTxtNums, 0);
  ORD_IBS:= nil;
  try
    if (pModelID<1) then raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    if (pNodeID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');
    if (pWareID<1)  then raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if (Length(UseLists)<1) and (Length(TxtLists)<1) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой набор условий');
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try                                    // сбрасываем признаки
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBSr_'+nmProc);
      if not Assigned(ORD_IBS) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
      for ij:= 0 to High(UseLists) do UseLists[ij].Delimiter:= LCharUpdate;
      for ij:= 0 to High(TxtLists) do TxtLists[ij].Delimiter:= LCharUpdate;
      for ij:= 0 to High(ListNumbers) do ListNumbers[ij]:= 0;
      //----------------------------------- все порции условий к связкe 3 из ORD
      SetLength(ArOrdUses, 10);
      with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
      ORD_IBS.SQL.Text:= 'select LWMNUPART, WCRITDCODE, WCRIDESCRUP, WCVSVALUEUP'+
        ' from (select LWMNUPART, LWMNUWCVSCODE'+
        '   from (select ldmwcode from (select LDEMCODE from LINKDETAILMODEL'+
        '     where LDEMTRNACODE=:pNodeID and LDEMDMOSCODE=:pModelID)'+   // and LDEMWRONG="F"
        '     inner join LINKDETMODWARE on LDMWLDEMCODE=LDEMCODE and LDMWWARECODE=:pWareID)'+ // and LDMWWRONG="F"
        '   inner join LinkWareModelNodeUsage on LWMNULDMWCODE=ldmwcode'+ // and LWMNUWRONG="F"
        fnIfStr(FromTDT, ' and LWMNUSRCLECODE in ('+IntToStr(soTecDocBatch)+', '+
        IntToStr(soTDparts)+', '+IntToStr(soTDsupersed)+')', '')+
        ') left join WARECRIVALUES on WCVSCODE=LWMNUWCVSCODE'+
        ' left join WARECRITERIES on WCRICODE=WCVSWCRICODE order by LWMNUPART';
      ORD_IBS.ParamByName('pModelID').AsInteger:= pModelID;
      ORD_IBS.ParamByName('pNodeID').AsInteger:= pNodeID;
      ORD_IBS.ParamByName('pWareID').AsInteger:= pWareID;
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        iUseList:= ORD_IBS.FieldByName('LWMNUPART').AsInteger; // номер порции
        iAr:= 0; // счетчик условий в ArOrdUses
        while not ORD_IBS.Eof and (iUseList=ORD_IBS.FieldByName('LWMNUPART').AsInteger) do begin
          if High(ArOrdUses)<iAr then SetLength(ArOrdUses, iAr+10);
          ArOrdUses[iAr].CriNameUp:= ORD_IBS.FieldByName('WCRIDESCRUP').AsString;
          ArOrdUses[iAr].ValueUp  := ORD_IBS.FieldByName('WCVSVALUEUP').AsString;
          ArOrdUses[iAr].CRITD    := ORD_IBS.FieldByName('WCRITDCODE').AsInteger;
          inc(iAr);
          TestCssStopException; // проверка остановки системы
          ORD_IBS.Next;
        end;

        flErr:= True;
        for ij:= 0 to High(UseLists) do begin
          if (iAr<>UseLists[ij].Count) then Continue; // не совпадает кол-во в порции
          if (ListNumbers[ij]>0) then Continue;       // порция уже определена
          if CheckUseList(ij, ArOrdUses) then begin // если нашли
            ListNumbers[ij]:= iUseList; // запоминаем номер порции
            UseLists[ij].Delimiter:= LCharGood; // признак найденной порции
            flErr:= False;
            Break;
          end;
        end; // for ij:= 0 to High(UseLists)

        if flErr and (fnInIntArray(iUseList, ErrUseNums)<0) then begin // если не нашли
          ij:= Length(ErrUseNums);
          SetLength(ErrUseNums, ij+1);
          ErrUseNums[ij]:= iUseList;
        end;
      end; // while not ORD_IBSr.Eof
      ORD_IBS.Close;

      //----------------------------------------------- тексты к связкe 3 из ORD
      SetLength(ArOrdTexts, 10);
      with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
      ORD_IBS.SQL.Text:= 'select LWNMTPART, LWNMTinfotype, WITSUPTD, WITTMTD, ITTEXT, ITSEARCH'+
        ' from (select LWNMTPART, LWNMTWIT, LWNMTinfotype'+
        '   from (select ldmwcode from (select LDEMCODE from LINKDETAILMODEL'+
        '     where LDEMTRNACODE=:pNodeID and LDEMDMOSCODE=:pModelID)'+ // and LDEMWRONG="F"
        '     inner join LINKDETMODWARE on LDMWLDEMCODE=LDEMCODE and LDMWWARECODE=:pWareID)'+ // and LDMWWRONG="F"
        '   inner join LinkWareNodeModelText on LWNMTLDMW=ldmwcode'+    // and LWNMTWRONG="F"
        fnIfStr(FromTDT, ' and LWNMTSRCLECODE in ('+IntToStr(soTecDocBatch)+', '+
        IntToStr(soTDparts)+', '+IntToStr(soTDsupersed)+')', '')+
        ') left join WareInfoTexts on WITCODE=LWNMTWIT'+
        ' left join INFOTEXTS on ITCODE=WITTEXTCODE order by LWNMTPART';
      ORD_IBS.ParamByName('pModelID').AsInteger:= pModelID;
      ORD_IBS.ParamByName('pNodeID').AsInteger:= pNodeID;
      ORD_IBS.ParamByName('pWareID').AsInteger:= pWareID;
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        iTxtList:= ORD_IBS.FieldByName('LWNMTPART').AsInteger; // номер порции текстов

        if (fnInIntArray(iTxtList, ErrUseNums)>-1) then begin // если соотв.порция условий помечена на удаление
          if (fnInIntArray(iTxtList, ErrTxtNums)<0) then begin
            ij:= Length(ErrTxtNums);
            SetLength(ErrTxtNums, ij+1);
            ErrTxtNums[ij]:= iTxtList;
          end;                                                // прокручиваем
          while not ORD_IBS.Eof and (iTxtList=ORD_IBS.FieldByName('LWNMTPART').AsInteger) do ORD_IBS.Next;
          Continue;
        end;

        iAr:= 0; // счетчик текстов в ArOrdTexts
        while not ORD_IBS.Eof and (iTxtList=ORD_IBS.FieldByName('LWNMTPART').AsInteger) do begin
          if High(ArOrdTexts)<iAr then SetLength(ArOrdTexts, iAr+10);
          ArOrdTexts[iAr].supTD   := ORD_IBS.FieldByName('WITSUPTD').AsInteger;
          ArOrdTexts[iAr].infotype:= ORD_IBS.FieldByName('LWNMTinfotype').AsInteger;
          ArOrdTexts[iAr].tmTD    := ORD_IBS.FieldByName('WITTMTD').AsString;
          ArOrdTexts[iAr].text    := ORD_IBS.FieldByName('ITTEXT').AsString;
          ArOrdTexts[iAr].search  := ORD_IBS.FieldByName('ITSEARCH').AsString;
          inc(iAr);
          TestCssStopException; // проверка остановки системы
          ORD_IBS.Next;
        end;
        ij:= fnInIntArray(iTxtList, ListNumbers); // ищем индекс порции в найденных порциях условий

        flErr:= True;
        if (ij<0) then begin // если индекс <0 (не найдены условия) - ищем порцию только с текстом
          for ij:= 0 to High(TxtLists) do begin
            if (ListNumbers[ij]>0) then Continue;       // уже найдена порция условий или текстов
            if (UseLists[ij].Count>0) then Continue;    // есть условия
            if (TxtLists[ij].Count<1) then Continue;    // нет текстов
            if (iAr<>TxtLists[ij].Count) then Continue; // не совпадает кол-во в порции
            if CheckTxtList(ij, ArOrdTexts) then begin
              ListNumbers[ij]:= iTxtList;
              TxtLists[ij].Delimiter:= LCharGood;       // признак найденной порции
              flErr:= False;
              Break;
            end;
          end; // for ij:= 0 to High(TxtLists)

        end else if (TxtLists[ij].Count>0) and (iAr=TxtLists[ij].Count)
          and CheckTxtList(ij, ArOrdTexts) then begin
          TxtLists[ij].Delimiter:= LCharGood; // если все совпало - признак найденной порции
          flErr:= False;
        end;

        if flErr and (fnInIntArray(iTxtList, ErrTxtNums)<0) then begin // если не нашли
          ij:= Length(ErrTxtNums);
          SetLength(ErrTxtNums, ij+1);
          ErrTxtNums[ij]:= iTxtList;
        end; // if flErr
      end; // while not ORD_IBSr.Eof
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
      SetLength(ArOrdUses, 0);
      SetLength(ArOrdTexts, 0);
    end;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= 'ошибка сверки условий и текстов';
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//========================== добавить / удалить линки связки 3 с порцией текстов
function TDataCache.CheckModelNodeWareTextListLinks(var ResCode: Integer;
         pModelID, pNodeID, pWareID: Integer; TxtList: TStringList;
         UserID: Integer=0; srcID: Integer=0; PartID: Integer=0): String;
const nmProc = 'CheckModelNodeWareTextListLinks';
// TxtList - список, в Object - <код supTD текста>
// String - <IntToStr(код типа текста)>+cSpecDelim+<название типа>=<идентификатор TecDoc>+cSpecDelim+<текст>
// если задан  <IntToStr(код типа текста)> - <название типа> может быть ''
// при посадке из Excel <идентификатор TecDoc>='', <код supTD текста>=0
// srcID, userID нужны только при добавлении
// ResCode на входе - вид операции (resAdded, resDeleted)
// ResCode на выходе - результат: resError - ошибка, resDoNothing - не менялось,
// resAdded - порция текстов добавлена, resDeleted - порция текстов удалена
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    OpCode, SysID, i, pSupID: Integer;
    s, TextValue, tmTD, TypeStr: String;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try
//-------------------------------------------------------------------- проверяем
    if not (OpCode in [resAdded, resDeleted]) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if (OpCode=resAdded) then begin
      if ((userID<1) or (srcID<1)) then  // если добавление
        raise EBOBError.Create(MessText(mtkNotParams));
      if not Assigned(TxtList) or (TxtList.Count<1) then
        raise EBOBError.Create(MessText(mtkNotValidParam)+'- пустой список текстов');
    end;
    if (OpCode=resDeleted) and (PartID<1) then  // если удаление
      raise EBOBError.Create(MessText(mtkNotValidParam)+' номера списка текстов');

    if not WareExist(pWareID) or GetWare(pWareID).IsArchive then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not FDCA.Models.ModelExists(pModelID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    SysID:= FDCA.Models[pModelID].TypeSys;
    if not FDCA.AutoTreeNodesSys[SysID].NodeExists(pNodeID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' узла');

//--------------------------------------------------- отрабатываем запись в базу
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);

      if OpCode=resAdded then begin // добавляем
        ORD_IBS.SQL.Text:= 'select PartID, errLink from AddModelNodeWarePartTextLink_n('+
          IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+
          ', :PartID, :TypeID, :pSupID, :tmTD, :pText, '+IntToStr(UserID)+', '+IntToStr(srcID)+')';

        for i:= 0 to TxtList.Count-1 do begin
          if not Assigned(TxtList.Objects[i]) then pSupID:= 0
          else pSupID:= Integer(TxtList.Objects[i]);
          TypeStr:= fnGetBefore(cStrValueDelim, TxtList[i]);  // код типа текста символьный
          s:= fnGetAfter(cStrValueDelim, TxtList[i]);         // часть TxtList[i] с текстом
          tmTD:= fnGetBefore(cSpecDelim, s);                  // идентификатор TecDoc
          TextValue:= fnGetAfter(cSpecDelim, s);              // текст
          ORD_IBS.ParamByName('TypeID').AsString:= TypeStr;
          ORD_IBS.ParamByName('PartID').AsInteger:= PartID;
          ORD_IBS.ParamByName('tmTD').AsString:= tmTD;
          ORD_IBS.ParamByName('pText').AsString:= TextValue;
          ORD_IBS.ParamByName('pSupID').AsInteger:= pSupID;
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Eof and ORD_IBS.Bof) then
            raise EBOBError.Create(MessText(mtkErrAddRecord))
          else if (ORD_IBS.Fields[1].AsInteger>0) then
            raise EBOBError.Create(MessText(mtkWareModNodeText)+' в базе отмечена, как неверная')
          else begin
  //          if (ORD_IBS.Fields[1].AsInteger<0) or (ORD_IBS.Fields[0].AsInteger<1) then begin
            if (ORD_IBS.Fields[0].AsInteger<1) then begin
              s:= 'Model='+IntToStr(pModelID)+' Node='+IntToStr(pNodeID)+
                  ' Ware='+IntToStr(pWareID)+' TypeID='+TypeStr+' Text='+TextValue;
  //            if (ORD_IBS.Fields[1].AsInteger<0) then s:= 'duplicate' else
              s:= 'error add use link: '+s;
              raise Exception.Create(s);
            end;
            if PartID<1 then PartID:= ORD_IBS.Fields[0].AsInteger;
          end;
          ORD_IBS.Close;
        end; // for i:= 0 to TxtList.Count-1
        Result:= MessText(mtkWareModNodeTexts)+' добавлен';

      end else begin // удаляем из базы
        ORD_IBS.SQL.Text:= 'execute procedure DelModelNodeWarePartTextLinks('+
          IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+IntToStr(PartID)+')';
        ORD_IBS.ExecQuery;
        Result:= MessText(mtkWareModNodeTexts)+' удален';
      end;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do if E.Message<>'duplicate' then begin
      if OpCode=resAdded then Result:= MessText(mtkErrAddRecord)
      else Result:= MessText(mtkErrDelRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//==== добавить / удалить линк связки 3 с текстом (порция 1 - загрузка из Excel)
function TDataCache.CheckModelNodeWareTextLink(var ResCode: Integer;
         pModelID, pNodeID, pWareID: Integer; TextValue: String; TypeID: Integer=0;
         TypeName: String=''; UserID: Integer=0; srcID: Integer=0): String;
// srcID, userID нужны только при добавлении, если задан TypeID - TypeName игнорируется !!!
const nmProc = 'CheckModelNodeWareTextLink';
// ResCode на входе - вид операции (resAdded, resDeleted)
// ResCode на выходе - результат: resError - ошибка, resDoNothing - не менялось, 
// resAdded - связка добавлена, resDeleted - связка удалена
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    OpCode, SysID, i: Integer;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try
//-------------------------------------------------------------------- проверяем
    if not (OpCode in [resAdded, resDeleted]) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if (TextValue='') then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' текста');
    if ((TypeID<1) and (TypeName='')) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' типа текста');
    if not WareExist(pWareID) or GetWare(pWareID).IsArchive then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not FDCA.Models.ModelExists(pModelID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' модели');
    SysID:= FDCA.Models[pModelID].TypeSys;
    if not FDCA.AutoTreeNodesSys[SysID].NodeExists(pNodeID) then
      raise EBOBError.Create(MessText(mtkNotEnoughParams));

    if (OpCode=resAdded) and ((userID<1) or (srcID<1)) then  // если добавление
      raise EBOBError.Create(MessText(mtkNotParams));

    with FDCA.TypesInfoModel do if not ItemExists(TypeID) then begin // ищем тип текста
      i:= InfoModelList[11].IndexOf(TypeName);
      if i<0 then raise EBOBError.Create('не найден вид текста');
      TypeID:= Integer(InfoModelList[11].Objects[i]);
    end;

//--------------------------------------------------- отрабатываем запись в базу
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, True);
      if OpCode=resAdded then begin // добавляем
        ORD_IBS.SQL.Text:= 'select linkID, errLink from AddModelNodeWareTextLink_new('+
          IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+
          IntToStr(TypeID)+', 0, "", :pText, '+IntToStr(UserID)+', '+IntToStr(srcID)+')';
        ORD_IBS.ParamByName('pText').AsString:= TextValue;
        ORD_IBS.ExecQuery;
        if (ORD_IBS.Eof and ORD_IBS.Bof) or (ORD_IBS.Fields[0].AsInteger<1) then
          raise EBOBError.Create(MessText(mtkErrAddRecord))
        else if (ORD_IBS.Fields[1].AsInteger>0) then
          raise EBOBError.Create(MessText(mtkWareModNodeText)+' в базе отмечена, как неверная')
        else if (ORD_IBS.Fields[1].AsInteger<0) then begin
          ResCode:= resDoNothing;
          raise EBOBError.Create(MessText(mtkWareModNodeText)+' есть')
        end else Result:= MessText(mtkWareModNodeText)+' добавлена';

      end else begin // удаляем из базы
        ORD_IBS.SQL.Text:= 'execute procedure DelModelNodeWareTextLink_new('+
          IntToStr(pModelID)+', '+IntToStr(pNodeID)+', '+IntToStr(pWareID)+', '+
          IntToStr(TypeID)+', 0, 0, "", :pText)';
        ORD_IBS.ParamByName('pText').AsString:= TextValue;
        ORD_IBS.ExecQuery;
        Result:= MessText(mtkWareModNodeText)+' удалена';
      end;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrAddRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//=================================== найти код элемента списка по имени и SupID
function TDataCache.SearchWareFileBySupAndName(pSup: Integer; pFileName: String): Integer;
var i: Integer;
    wf: TWareFile;
begin
  Result:= 0;
  with FWareFiles do for i:= 0 to ItemsList.Count-1 do begin
    wf:= ItemsList[i];
    if (wf.supID=pSup) and (wf.FileName=pFileName) then begin
      Result:= wf.ID;
      exit;
    end;
  end;
end;
//=================================================== добавить файл в базу и кеш
function TDataCache.AddWareFile(var fID: Integer; pFname: String;
         pSup, pHeadID, pUserID, pSrcID: Integer): String;
const nmProc = 'AddWareFile';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    p: Pointer;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  fID:= 0;
  with FWareFiles do try
    if (pFname='') or (pUserID<1) then raise EBOBError.Create(MessText(mtkNotEnoughParams));
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      ORD_IBS.SQL.Text:= 'insert into WareGraFiles'+
        ' (WGFSupTD, WGFHeadID, WGFFileName, '+fnIfStr(pSrcID>0, 'WGFSRCLECODE, ', '')+
        'WGFUSERID) values ('+IntToStr(pSup)+', '+IntToStr(pHeadID)+', :Fname, '+
        fnIfStr(pSrcID>0, IntToStr(pSrcID)+', ', '')+IntToStr(pUserID)+') returning WGFCODE';
      ORD_IBS.ParamByName('Fname').AsString:= pFname;
      ORD_IBS.ExecQuery;
      if not (ORD_IBS.Eof and ORD_IBS.Bof) then fID:= ORD_IBS.Fields[0].AsInteger;
      if fID<1 then raise Exception.Create(MessText(mtkErrAddRecord));
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;

    p:= TWareFile.Create(fID, pSup, pHeadID, pFname, pSrcID);
    CheckItem(p);
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrAddRecord);
      prMessageLOGS(nmProc+': '+E.Message, fLogCache);
    end;
  end;
end;
//=============================================== удаление неиспользуемых файлов
function TDataCache.CheckWareFiles(var delCount: Integer): String;
const nmProc = 'CheckWareFiles';
// штатно вызывается в AddLoadWaresInfoFromTDT после окончания загрузки
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    fID: Integer;
begin
  Result:= '';
  delCount:= 0;
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;
  try
    ORD_IBD:= cntsOrd.GetFreeCnt;
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      ORD_IBS.SQL.Text:= 'select delCode from CheckGraFiles';
      ORD_IBS.ExecQuery;
      while not ORD_IBS.Eof do begin
        fID:= ORD_IBS.Fields[0].AsInteger;
        FWareFiles.DeleteItem(fID);
        inc(delCount);
        ORD_IBS.Next;
      end;
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;
  except
    on E: Exception do begin
      delCount:= 0;
      Result:= nmProc+': '+E.Message;
    end;
  end;
end;
//=============== добавить/удалить линк товара с файлом (toCache=True - и в кеше)
function TDataCache.CheckWareFileLink(var ResCode: Integer; pFileID, pWareID: Integer;
         pSrcID: Integer=0; UserID: Integer=0; toCache: Boolean=True; linkURL: Boolean=True): String;
const nmProc = 'CheckWareFileLink';
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    p: Pointer;
    OpCode: Integer;
    Ware: TWareInfo;
    s: String;
begin
  Result:= '';
  OpCode:= ResCode;
  ResCode:= resError;
  if not Assigned(self) then Exit;
  ORD_IBS:= nil;

  with FWareFiles do try
    if not (OpCode in [resAdded, resDeleted]) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' операции');
    if not WareExist(pWareID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');
    if not FWareFiles.ItemExists(pFileID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' файла');

    Ware:= GetWare(pWareID);
    if Ware.IsArchive then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' товара');

    case OpCode of
    resAdded: begin
        if Ware.FileLinks.LinkExists(pFileID) then begin
          ResCode:= resDoNothing;
          raise EBOBError.Create('Такая связка товара с файлом уже есть');
        end;
        if (UserID<1) or (pSrcID<1) then
          raise EBOBError.Create(MessText(mtkNotEnoughParams));
      end;
    resDeleted: begin
        if not Ware.FileLinks.LinkExists(pFileID) then begin
          ResCode:= resDoNothing;
          raise EBOBError.Create('Не найдена связка товара с файлом');
        end;
        if (pSrcID>0) and (GetLinkSrc(Ware.FileLinks[pFileID])<>pSrcID) then
          raise EBOBError.Create('не совпадает источник');
      end;
    end; // case

    ORD_IBD:= cntsOrd.GetFreeCnt;                 // пишем в базу
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
      case OpCode of
      resAdded: begin
          ORD_IBS.ParamCheck:= False;
          s:= 'from LinkWareGraFiles where LWGFWareID='+IntToStr(pWareID)+
              ' and LWGFWGFCODE='+IntToStr(pFileID);
          ORD_IBS.SQL.Add('execute block returns(flag integer) as begin flag=0;');
          ORD_IBS.SQL.Add('if (exists(select * '+s+')) then');
          ORD_IBS.SQL.Add(' select iif(LWGFWRONG="T", -1, 0) '+s+' into :flag;');
          ORD_IBS.SQL.Add('else insert into LinkWareGraFiles');
          ORD_IBS.SQL.Add(' (LWGFWareID, LWGFWGFCODE, LWGFUSERID, LWGFSRCLECODE');
          ORD_IBS.SQL.Add(fnIfStr(linkURL, '', ', LWGFLinkURL')+') values (');
          ORD_IBS.SQL.Add(IntToStr(pWareID)+', '+IntToStr(pFileID)+', '+IntToStr(UserID)+', ');
          ORD_IBS.SQL.Add(IntToStr(pSrcID)+fnIfStr(linkURL, '', ', "F"')+')');
          ORD_IBS.SQL.Add(' returning LWGFCODE into :flag; suspend; end');
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Eof and ORD_IBS.Bof) then
            raise EBOBError.Create(MessText(mtkErrAddRecord))
          else if (ORD_IBS.Fields[0].AsInteger<0) then
            raise EBOBError.Create('связка товара с файлом отмечена, как ошибочная')
//          else if (ORD_IBS.Fields[0].AsInteger<1) then
//            raise Exception.Create('связка товара с файлом уже есть')
          ;
        end;
      resDeleted: begin
          ORD_IBS.SQL.Text:= 'delete from LinkWareGraFiles'+
            ' where LWGFWareID='+IntToStr(pWareID)+' and LWGFWGFCODE='+IntToStr(pFileID);
          ORD_IBS.ExecQuery;
        end;
      end; // case
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;

    if toCache then with Ware.FileLinks do begin // добавляем в кеш / удаляем из кеша линк товара с файлом
      case OpCode of
      resAdded: begin
          p:= FWareFiles[pFileID];
          AddLinkItem(TFlagLink.Create(pSrcID, p, linkURL));
        end;
      resDeleted: DeleteLinkItem(pFileID);
      end; // case
    end; // if toCache

    case OpCode of
    resAdded  : Result:= 'связка товара с файлом добавлена';
    resDeleted: Result:= 'связка товара с файлом удалена';
    end; // case
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do begin
      Result:= MessText(mtkErrProcess);
      prMessageLOGS(nmProc+': '+E.Message, 'import');
    end;
  end;
end;
//================ добавить/удалить линк товара с сопут.товаром (Excel, вручную)
function TDataCache.CheckWareSatelliteLink(pWareID, pSatelID: Integer;
         var ResCode: Integer; srcID: Integer=0; UserID: Integer=0): String;
const nmProc = 'CheckWareSatelliteLink';
// ResCode на входе - вид операции (resAdded, resDeleted, resWrong, resNotWrong)
// ResCode на выходе: resError- ошибка, resDoNothing - не менялось, resAdded - добавлена,
// resDeleted - удалена, resWrong - отмечена, как неверная, resNotWrong - восстановлена
var ORD_IBD: TIBDatabase;
    ORD_IBS: TIBSQL;
    Ware, Satel: TWareInfo;
    OpCode: Integer;
    mess: string;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  OpCode:= ResCode;
  ResCode:= resError;
  ORD_IBS:= nil;
  try
    if not (OpCode in [resAdded, resDeleted, resWrong, resNotWrong]) then // проверяем код операции
      raise Exception.Create(MessText(mtkNotValidParam)+' операции');

    Ware:= GetWare(pWareID, True);
    if (Ware=NoWare) or Ware.IsArchive then                   // проверяем товар
      raise Exception.Create(MessText(mtkNotFoundWare, IntToStr(pWareID)));
    if Ware.IsINFOgr then                   // проверяем товар
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - инфо-товар');

    Satel:= GetWare(pSatelID, True);
    if (Satel=NoWare) or Satel.IsArchive then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' сопут.товара');
    if Satel.IsINFOgr then                   // проверяем товар
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - сопут.инфо-товар');

    if not CheckWaresEqualSys(pWareID, pSatelID) then
      raise EBOBError.Create(MessText(mtkNotValidParam)+' - разные бизнес-направления');

    if Ware.SatelLinks.LinkExists(pSatelID) then begin // проверка существования сопут.товара
      mess:= '';
      case OpCode of
        resAdded   : mess:= 'Такая '+MessText(mtkWareSatelLink)+' есть';
        resNotWrong: mess:= MessText(mtkWareSatelLink)+' не отмечена, как ошибочная';
      end; // case
      if mess<>'' then begin
        ResCode:= resDoNothing;
        raise Exception.Create(mess);
      end;
    end else if (OpCode in [resDeleted, resWrong]) then begin
      ResCode:= resDoNothing;
      raise Exception.Create('Не найдена '+MessText(mtkWareSatelLink));
    end;
                       // проверка необходимых параметров и доступности операции
    if (OpCode in [resAdded, resNotWrong, resWrong]) and (userID<1) then
      raise Exception.Create(MessText(mtkNotValidParam)+' юзера')
    else if (OpCode in [resAdded]) and (srcID<1) then
      raise Exception.Create(MessText(mtkNotValidParam)+' источника');

//--------------------------------------------------- отрабатываем запись в базу
    ORD_IBD:= cntsOrd.GetFreeCnt;                 // пишем в базу
    try
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);

      case OpCode of
      resAdded: begin                // добавляем
          ORD_IBS.SQL.Text:= 'select linkID, errLink from AddWareSatellite('+
            IntToStr(pWareID)+', '+IntToStr(pSatelID)+', '+IntToStr(UserID)+', '+IntToStr(srcID)+')';
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Eof and ORD_IBS.Bof) then
            raise EBOBError.Create(MessText(mtkErrAddRecord))
          else if (ORD_IBS.Fields[1].AsInteger>0) then
            raise EBOBError.Create(MessText(mtkWareSatelLink)+' в базе отмечена, как неверная')
          else if (ORD_IBS.Fields[1].AsInteger<0) then begin
            with Ware do if not SatelLinks.LinkExists(pSatelID) then begin // на всяк.случай
              SatelLinks.CheckLink(pSatelID, srcID, Satel);
              SatelLinks.SortByLinkName;
            end;
            ResCode:= resDoNothing;
            raise EBOBError.Create('Такая '+MessText(mtkWareSatelLink)+' есть');
          end else if (ORD_IBS.Fields[0].AsInteger<1) then
            raise Exception.Create('error add link Ware='+IntToStr(pWareID)+
                                   ' satellite='+IntToStr(pSatelID));
        end; // resAdded

      resWrong, resNotWrong: begin // меняем признак Wrong
          ORD_IBS.SQL.Text:= 'update LinkWareSatellites set LWSWRONG="'+
            fnIfStr(OpCode=resWrong, 'T', 'F')+'", LWSUSERID='+IntToStr(UserID)+
            ' where LWSWARECODE='+IntToStr(pWareID)+' and LWSSatel='+IntToStr(pSatelID);
          ORD_IBS.ExecQuery;
        end; // resWrong, resNotWrong

      resDeleted: begin              // удаляем
          ORD_IBS.SQL.Text:= 'delete from LinkWareSatellites where LWSWARECODE='+
            IntToStr(pWareID)+' and LWSSatel='+IntToStr(pSatelID);
          ORD_IBS.ExecQuery;
        end; // resDeleted
      end; // case
      ORD_IBS.Transaction.Commit;
    finally
      prFreeIBSQL(ORD_IBS);
      cntsOrd.SetFreeCnt(ORD_IBD);
    end;

//------------------------------------------------------------- отрабатываем кэш
    with Ware do case OpCode of
      resAdded, resNotWrong: begin                         // добавляем
          SatelLinks.CheckLink(pSatelID, srcID, Satel);
          SatelLinks.SortByLinkName;
        end;
      resDeleted, resWrong: SatelLinks.DeleteLinkItem(pSatelID); // удаляем
    end; // case

    mess:= MessText(mtkWareAnalogLink);
    case OpCode of
      resAdded:    Result:= mess+' добавлена';
      resDeleted:  Result:= mess+' удалена';
      resWrong:    Result:= mess+' отмечена, как неверная';
      resNotWrong: Result:= mess+' восстановлена';
    end;
    ResCode:= OpCode;
  except
    on E: EBOBError do Result:= E.Message;
    on E: Exception do Result:= nmProc+': '+CutEMess(E.Message, ResCode);
  end;
end;

//******************************************************************************
//                               TClients
//******************************************************************************
constructor TClients.Create;
begin
  SetLength(FarClientInfo, 0);
//  SetLength(FarClientInfo, 1);
//  FarClientInfo[0]:= TClientInfo.Create(0, 'Неизв.клиент');
//  FarClientInfo[0].Arhived:= True;
  FcalcStart:= 0;
  FcalcDelta:= 0;
  CS_clients:= TCriticalSection.Create;
  FWorkLogins:= fnCreateStringList(True, 100);
end;
//=========================================
destructor TClients.Destroy;
var j: Integer;
begin
  for j:= Low(FarClientInfo) to High(FarClientInfo) do
    try prFree(FarClientInfo[j]); except end;
  SetLength(FarClientInfo, 0);
  prFree(CS_clients);
  prFree(FWorkLogins);
  inherited;
end;
//=========================================
function TClients.GetClient(pID: integer): TClientInfo;
var i: Integer;
begin
  i:= GetIndex(pID);
  if (i<Low(FarClientInfo)) or (i>High(FarClientInfo)) then Result:= nil // FarClientInfo[0]
  else Result:= FarClientInfo[i];
end;
//=========================================
procedure TClients.TestMaxCode(MaxCode: Integer);
var i, ii, jj: Integer;
begin
  i:= GetIndex(MaxCode);
  if Length(FarClientInfo)>i then exit;
  try // если надо менять длину
    CS_clients.Enter;
    jj:= Length(FarClientInfo);        // добавляем длину массива
    SetLength(FarClientInfo, i+100);   // и инициируем элементы
    for ii:= jj to High(FarClientInfo) do FarClientInfo[ii]:= nil;
  finally
    CS_clients.Leave;
  end;
end;
//=========================================
procedure TClients.AddClient(pID: integer);
var i: Integer;
begin
  TestMaxCode(pID);
  i:= GetIndex(pID);
  FarClientInfo[i]:= TClientInfo.Create(pID, '');
end;
//=========================================
procedure TClients.CutEmptyCode;
var i, j: Integer;
//    Client: TClientInfo;
begin
  j:= Length(FarClientInfo);
  for i:= High(FarClientInfo) downto 1 do begin
//    Client:= FarClientInfo[i];
    if Assigned(FarClientInfo[i]) then begin
      j:= i+1;
      break;
    end;
  end;
  if Length(FarClientInfo)>j then try
    CS_clients.Enter;
    SetLength(FarClientInfo, j); // обрезаем по мах.коду
  finally
    CS_clients.Leave;
  end;
end;
//=========================================
function TClients.GetMaxIndex: integer;
begin
  Result:= High(FarClientInfo);
end;
//=========================================
function TClients.ClientExists(pID: Integer): Boolean;
var i: Integer;
begin
  Result:= False;
  if not Assigned(self) then exit;
  i:= GetIndex(pID);
  Result:= (i>0) and (length(FarClientInfo)>i) and Assigned(FarClientInfo[i]);
end;
//=========================================
procedure TClients.SetCalcBounds(iStart, iEnd: integer);
begin
  FcalcStart:= iStart+1;
  FcalcDelta:= iEnd-iStart-5;
end;
//=========================================
function TClients.GetIndex(pID: integer): integer;
begin
  if (FcalcStart<1) or (pID<FcalcStart) then Result:= pID else Result:= pID-FcalcDelta;
end;

//******************************************************************************
//                               TFirms
//******************************************************************************
constructor TFirms.Create;
begin
  SetLength(FarFirmInfo, 0);
//  SetLength(FarFirmInfo, 1);
//  FarFirmInfo[0]:= TFirmInfo.Create(0, 'Неизв.клиент');
//  FarFirmInfo[0].Arhived:= True;
  CS_firms:= TCriticalSection.Create;
end;
//=========================================
destructor TFirms.Destroy;
var j: Integer;
begin
  for j:= Low(FarFirmInfo) to High(FarFirmInfo) do
    try prFree(FarFirmInfo[j]); except end;
  SetLength(FarFirmInfo, 0);
  prFree(CS_firms);
  inherited;
end;
//=========================================
function TFirms.GetFirm(pID: integer): TFirmInfo;
begin
  if (pID<Low(FarFirmInfo)) or (pID>High(FarFirmInfo)) then Result:= nil // FarFirmInfo[0]
  else Result:= FarFirmInfo[pID];
end;
//=========================================
procedure TFirms.AddFirm(pID: integer);
var ii, jj: Integer;
begin
  if High(FarFirmInfo)<pID then try
    CS_firms.Enter;
    jj:= Length(FarFirmInfo);         // добавляем длину массива
    SetLength(FarFirmInfo, pID+100);  // и инициируем элементы
    for ii:= jj to High(FarFirmInfo) do FarFirmInfo[ii]:= nil;
  finally
    CS_firms.Leave;
  end;
  FarFirmInfo[pID]:= TFirmInfo.Create(pID, '');
end;
//=========================================
procedure TFirms.CutEmptyCode;
var i, j: Integer;
begin
  j:= Length(FarFirmInfo);
  for i:= High(FarFirmInfo) downto 1 do if Assigned(FarFirmInfo[i]) then begin
    j:= i+1;
    break;
  end;
  if Length(FarFirmInfo)>j then try
    CS_firms.Enter;
    SetLength(FarFirmInfo, j); // обрезаем по мах.коду
  finally
    CS_firms.Leave;
  end;
end;
//=========================================
function TFirms.FirmExists(pID: Integer): Boolean;
begin
  Result:= False;
  if not Assigned(self) then exit;
  Result:= (pID>0) and (length(FarFirmInfo)>pID) and Assigned(FarFirmInfo[pID]);
end;

//******************************************************************************
//                             TInfoBoxItem
//******************************************************************************
//============================================================== получить строку
function TInfoBoxItem.GetStrI(const ik: T8InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then exit;
  case ik of
    ik8_1: Result:= FName;       // заголовок
    ik8_2: Result:= FLinkToPict; // ссылка на рисунок
    ik8_3: Result:= FLinkToSite; // ссылка на сайт
  end;
end;
//============================================================= записать строку
procedure TInfoBoxItem.SetStrI(const ik: T8InfoKinds; Value: String);
begin
  if not Assigned(self) then exit;
  case ik of
    ik8_1: if (FName      <>Value) then FName      := Value; // заголовок
    ik8_2: if (FLinkToPict<>Value) then FLinkToPict:= Value; // ссылка на рисунок
    ik8_3: if (FLinkToSite<>Value) then FLinkToSite:= Value; // ссылка на сайт / окно описания
  end;
end;

//******************************************************************************
//                             TEmplRole
//******************************************************************************
constructor TEmplRole.Create(pID: Integer; pName: String);
begin
  inherited Create(pID, pName, True);
  FConstLinks:= TLinks.Create(nil);
end;
//==============================================
destructor TEmplRole.Destroy;
begin
  prFree(FConstLinks);
  inherited;
end;

//******************************************************************************
//                             TConstItem
//******************************************************************************
constructor TConstItem.Create(pID: Integer; pName: String; pType: Integer=1;
            pUserID: Integer=0; pPrecision: Integer=0; WithLinks: Boolean=False);
begin
  inherited Create(pID, pUserID, pPrecision, pName, pType, WithLinks);
  case ItemType of
    constString: begin
        StrValue   := '';
        maxStrValue:= '';
        minStrValue:= '';
      end;
    else begin
        StrValue   := '0';
        maxStrValue:= '0';
        minStrValue:= '0';
      end;
  end;
  NotEmpty:= False;
  LastTime:= Now;
  Grouping:= '';
end;
//============================================== проверяем корректность значения
function TConstItem.CheckConstValue(var pValue: String): String;
var d: double;
    i: Integer;
    ValueStart: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  ValueStart:= pValue;
  pValue:= trim(pValue);

  if pValue='' then begin
    if NotEmpty then Result:= MessText(mtkNotValidParam)+' - пустое значение';
    case ItemType of
      constInteger, constDouble, constDateTime: pValue:= '0';
    end;

  end else try
    case ItemType of
      constInteger: begin  // целое значение
          i:= StrToInt(pValue);
          pValue:= IntToStr(i);
        end;
      constDouble: begin  // вещественное значение
          d:= StrToFloat(StrWithFloatDec(pValue)); // проверяем DecimalSeparator
          pValue:= FormatFloat('#0.'+StringOfChar('0', Precision), d);
        end;
      constDateTime: begin  // значение даты
          d:= StrToDateTimeDef(pValue, 0);
          if d=0 then pValue:= '0'
          else case Precision of
            0: pValue:= FormatDateTime(cDateFormatY4, d);
            1: pValue:= FormatDateTime(cDateTimeFormatY4S, d);
          end;
        end;
    end; // case ItemType of
  except
    Result:= MessText(mtkNotValidParam)+': constID='+IntToStr(ID)+' ValueStart='+ValueStart+' ValueEnd='+pValue;
    case ItemType of
      constInteger, constDouble, constDateTime: pValue:= '0';
    end;
  end;
end;
//================================================== получить строковое значение
function TConstItem.GetStrCI(const ik: T8InfoKinds): String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: Result:= FValue;
    ik8_2: Result:= FMaxValue;
    ik8_3: Result:= FMinValue;
    ik8_4: Result:= FGrouping;
  end;
end;
//================================================== записать строковое значение
procedure TConstItem.SetStrCI(const ik: T8InfoKinds; pValue: String);
var s: string;
begin
  if not Assigned(self) then Exit;
  try
    if ik in [ik8_1, ik8_2, ik8_3] then begin 
      s:= CheckConstValue(pValue);          // проверяем корректность значения
      if s<>'' then raise Exception.Create(s);
    end;
    case ik of
      ik8_1: if (FValue   <>pValue) then FValue   := pValue;
      ik8_2: if (FMaxValue<>pValue) then FMaxValue:= pValue;
      ik8_3: if (FMinValue<>pValue) then FMinValue:= pValue;
      ik8_4: if (FGrouping<>pValue) then FGrouping:= pValue;
    end;
  except
    on E: Exception do prMessageLOGS('ConstItem.SetStrCI: '+E.Message, fLogCache);
  end;
end;
//======================================================= получить вещ. значение
function TConstItem.GetDoubCI(const ik: T8InfoKinds): Double;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  case ItemType of
    constDouble: case ik of
        ik8_1: Result:= StrToFloatDef(StrValue, 0);
        ik8_2: Result:= StrToFloatDef(FMaxValue, 0);
        ik8_3: Result:= StrToFloatDef(FMinValue, 0);
      end;
    constDateTime: case ik of
        ik8_1: Result:= StrToDateTimeDef(StrValue, 0);
        ik8_2: Result:= StrToDateTimeDef(FMaxValue, 0);
        ik8_3: Result:= StrToDateTimeDef(FMinValue, 0);
      end;
  end; // case ItemType of
end;
//======================================================= получить значение даты
function TConstItem.GetDateCI(const ik: T8InfoKinds): TDateTime;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: if (ItemType=constDateTime) then Result:= StrToDateTimeDef(StrValue, 0);
    ik8_2: if (ItemType=constDateTime) then Result:= StrToDateTimeDef(FMaxValue, 0);
    ik8_3: if (ItemType=constDateTime) then Result:= StrToDateTimeDef(FMinValue, 0);
    ik8_4: Result:= FLastTime;
  end;
end;
//======================================================= записать значение даты
procedure TConstItem.SetDateCI(const ik: T8InfoKinds; pValue: TDateTime);
begin
  if not Assigned(self) then Exit;
  case ik of
    ik8_4: if (FLastTime<>pValue) then FLastTime:= pValue; // время посл.изменения
  end;
end;

//====================================================== получить целое значение
function TConstItem.GetIntCI(const ik: T8InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: if (ItemType=constInteger) then Result:= StrToIntDef(StrValue, 0);
    ik8_2: if (ItemType=constInteger) then Result:= StrToIntDef(FMaxValue, 0);
    ik8_3: if (ItemType=constInteger) then Result:= StrToIntDef(FMinValue, 0);
    ik8_4: Result:= FSrcID;     // Тип
    ik8_5: Result:= FOrderNum;  // кол-во знаков после запятой в типе Double
    ik8_6: Result:= FSubCode;   // код юзера посл.изменений
  end;
end;
//====================================================== записать целое значение
procedure TConstItem.SetIntCI(const ik: T8InfoKinds; pValue: Integer);
begin
  if not Assigned(self) then Exit;
  case ik of
    ik8_4: if (FSrcID    <>pValue) then FSrcID   := pValue; // Тип
    ik8_5: if (FOrderNum <>pValue) then FOrderNum:= pValue; // кол-во знаков после запятой в типе Double
    ik8_6: if (FSubCode  <>pValue) then FSubCode := pValue; // код юзера посл.изменений
  end;
end;

//******************************************************************************
//                             TAnalogLink
//******************************************************************************
constructor TAnalogLink.Create(pSrcID: Integer; pWarePtr: Pointer; pAnalog, pCross: Boolean);
begin
  inherited Create(pSrcID, pWarePtr);
  IsOldAnalog:= pAnalog;
  IsCross := pCross;
end;

//******************************************************************************
//                              TImportType
//******************************************************************************
constructor TImportType.Create(pID: Integer; pName: String; pReport, pImport: Boolean);
begin
  inherited Create(pID, pName, True);
  ApplyReport:= pReport;
  ApplyImport:= pImport;
end;

//******************************************************************************
//                             TEmplVisRule
//******************************************************************************
constructor TEmplVisRule.Create(pID: Integer; pName: String);
begin
  inherited Create(pID, pName, True);
  FStoreLinks:= TLinks.Create; // набор связок со складами
end;
//======================================================
destructor TEmplVisRule.Destroy;
begin
  prFree(FStoreLinks);
  inherited;
end;
//===================================== заполняем/проверяем набор прав видимости
procedure TEmplVisRule.CheckVisRules(rName, rules: String; flnew: Boolean=False);
const nmProc = 'CheckVisRules';
var s: String;
    AllowDprts, AllowFirms, dprts, firms: Tai;
    iw, k, ipos, posDeny, posAllow, idprt: Integer;
    Store: TDprtInfo;
    firm: TFirmInfo;
    list: TStringList;
    ibsGB: TIBSQL;
    ibGB: TIBDatabase;
    ar: Tai;
  //----------------------------------------- вынимаем код из строки
  function ExtractCode(ss: String; ip: Integer=1): Integer;
  begin
    try
      if ip>1 then ss:= copy(ss, ip);
      ipos:= pos(')', ss); // проверяем закрывающую скобку
      if ipos>0 then ss:= copy(ss, 1, ipos-1);
      Result:= StrToIntDef(ss, 0);
    except
      Result:= 0;
    end;
  end;
  //----------------------------------------- вынимаем коды фирм в группе
  function GetGroupFirms(fgrp: Integer=-1): Tai;
  var i: Integer;
  begin
    SetLength(Result, 100);
    try
      if not Assigned(ibsGB) then
        ibsGB:= fnCreateNewIBSQL(ibGB, 'ibsGB_'+nmProc, -1, tpRead, True);
        ibsGB.SQL.Text:= 'select rFirmCode from getfirmtree('+
          fnIfStr(fgrp<1, 'null', IntToStr(fgrp))+
          ') left join firms f on f.firmcode = rFirmCode'+
          ' where f.firmchildcount=0 order by firmmainname';
      ibsGB.ExecQuery;
      i:= 0;
      while not ibsGB.Eof do begin
        if High(Result)<i then SetLength(Result, i+100);
        Result[i]:= ibsGB.FieldByName('rFirmCode').AsInteger;
        Inc(i);
        ibsGB.Next;
      end;
      if Length(Result)>i then SetLength(Result, i);
    except
      on E: Exception do begin
        SetLength(Result, 0);
        prMessageLOGS(nmProc+'(fgrp='+IntToStr(fgrp)+'): '+E.Message, fLogCache);
      end;
    end;
    if Assigned(ibsGB) then ibsGB.Close;
  end;
  //-----------------------------------------
begin
  if not Assigned(self) or ((rName='') and (rules='')) then Exit;
  ibsGB:= nil;
  list:= nil;
  SetLength(AllowDprts, 0); // формируем список видимых складов
  SetLength(AllowFirms, 0); // формируем список видимых контрагентов
  try
    if not flnew then Name:= rName; // проверяем название схемы

    ibGB:= cntsGRB.GetFreeCnt;
    try
      list:= fnSplit(';', rules);
      for iw:= 0 to list.Count-1 do begin // идем по строкам запретов / разрешений
        posDeny:= pos('deny', list[iw]);
        posAllow:= pos('allow', list[iw]);
        if (posDeny>0) then begin           // строка запретов
          s:= copy(list[iw], posDeny+4);
        end else if (posAllow>0) then begin // строка разрешений
          s:= copy(list[iw], posAllow+5);
        end else Continue; // другие пропускаем

        SetLength(dprts, 0);
        SetLength(firms, 0);
        if (s='') then begin // все
          Dprts:= Cache.GetGroupDprts(0, True);
          Firms:= GetGroupFirms(-1);

        end else if (s=' if (ObjectType = 3)') then begin // все склады
          Dprts:= Cache.GetGroupDprts(0, True);
        end else if copy(s, 1, 16)=' if (DprtCode = ' then begin // склад
          idprt:= ExtractCode(s, 17);
          if (idprt>0) then prAddItemToIntArray(idprt, Dprts);
        end else if copy(s, 1, 37)=' if (ObjectType = 3) and (DprtCode = ' then begin // склад
          idprt:= ExtractCode(s, 38);
          if (idprt>0) then prAddItemToIntArray(idprt, Dprts);
        end else if copy(s, 1, 17)=' if (DprtCode in ' then begin // группа складов
          idprt:= ExtractCode(s, 18);
          Dprts:= Cache.GetGroupDprts(idprt, True);
        end else if copy(s, 1, 38)=' if (ObjectType = 3) and (DprtCode in ' then begin // группа складов
          idprt:= ExtractCode(s, 39);
          Dprts:= Cache.GetGroupDprts(idprt, True);

        end else if (s=' if (ObjectType = 4)') then begin // все контрагенты
          Firms:= GetGroupFirms(-1);
        end else if copy(s, 1, 16)=' if (FirmCode = ' then begin // контрагент
          idprt:= ExtractCode(s, 17);
          if (idprt>0) then prAddItemToIntArray(idprt, Firms);
        end else if copy(s, 1, 37)=' if (ObjectType = 4) and (FirmCode = ' then begin // контрагент
          idprt:= ExtractCode(s, 38);
          if (idprt>0) then prAddItemToIntArray(idprt, Firms);
        end else if copy(s, 1, 17)=' if (FirmCode in ' then begin // группа контрагентов
          idprt:= ExtractCode(s, 18);
          Firms:= GetGroupFirms(idprt);
        end else if copy(s, 1, 38)=' if (ObjectType = 4) and (FirmCode in ' then begin // группа контрагентов
          idprt:= ExtractCode(s, 39);
          Firms:= GetGroupFirms(idprt);
        end else if copy(s, 1, 19)=' if (ManagerCode = ' then begin // контрагенты менеджера продаж
          idprt:= ExtractCode(s, 20); // EmplCode
          Firms:= Cache.GetRegFirmCodes(idprt);
        end;

        if (posDeny>0) then begin // строка запретов
          for k in Dprts do begin // удаляем склады
            ipos:= fnInIntArray(k, AllowDprts);
            prDelItemFromArray(ipos, AllowDprts);
          end;
          for k in Firms do begin // удаляем контрагентов
            ipos:= fnInIntArray(k, AllowFirms);
            prDelItemFromArray(ipos, AllowFirms);
          end;
        end;

        if (posAllow>0) then begin // строка разрешений
          for k in Dprts do // добавляем склады
            prAddItemToIntArray(k, AllowDprts);
          for k in Firms do // добавляем контрагентов
            prAddItemToIntArray(k, AllowFirms);
        end;
      end; // for iw:= 0 to list.Count-1
    finally
      prFreeIBSQL(ibsGB);
      cntsGRB.SetFreeCnt(ibGB);
    end;
                              //------------------------------- отрабатываем кеш
    ar:= Cache.GetConstEmpls(pcFictiveEmplCodes); // коды фиктивных менеджеров (ИНФО, ЯяяАРХИВ и т.п.

    if not flnew then begin // при проверке - сбрасываем флажки проверки
      StoreLinks.SetLinkStates(False);
      FirmLinks.SetLinkStates(False);
    end;

    for iw:= 0 to High(AllowDprts) do begin // склады
      idprt:= AllowDprts[iw];
      if not Cache.DprtExist(idprt) then Continue;
      Store:= Cache.arDprtInfo[idprt];
      if (Store.IsStoreHouse or Store.IsStoreRoad) then
        StoreLinks.CheckLink(idprt, 2, Store);
    end;

    for iw:= 0 to High(AllowFirms) do begin // контрагенты
      idprt:= AllowFirms[iw];
      if not Cache.FirmExist(idprt) then Continue;
      firm:= Cache.arFirmInfo[idprt];
      if firm.Arhived then Continue; // отсекаем архивных к/а
//      if (firm.FirmManagers.Count<1) then Continue; // отсекаем к/а без менеджера
      if (firm.FirmManagers.Count=1) then begin
        ipos:= firm.FirmManagers[0]; // отсекаем к/а с фиктивными менеджерами  ???
        if (fnInIntArray(ipos, ar)>-1) then Continue;
      end;
      FirmLinks.CheckLink(idprt, soGrossBee, firm);
    end;

    if not flnew then begin // при проверке - удаляем непроверенные
      StoreLinks.DelNotTestedLinks;
      FirmLinks.DelNotTestedLinks;
    end;

//    StoreLinks.LinkSort(VisStoresSortCompare); // сортировка по филиалам ??? неудачная
    StoreLinks.SortByLinkName; // сортировка по наименованию
    FirmLinks.SortByLinkName;

//--------------------------------------------------------- для отладки
{    if flDebug then begin
      prMessageLOGS('----------------------------------', fLogDebug, False);
      prMessageLOGS('схема видимости '+IntToStr(ID)+': '+Name, fLogCache+'_test1', False);
      prMessageLOGS('----------------------------------', fLogDebug, False);
      with StoreLinks do for k:= 0 to LinkCount-1 do begin
        Store:= GetLinkPtr(ListLinks[k]);
        prMessageLOGS('     '+Store.MainName, fLogDebug, False);
      end;
      prMessageLOGS('-----------------', fLogDebug, False);
      with FirmLinks do for k:= 0 to LinkCount-1 do begin
        firm:= GetLinkPtr(ListLinks[k]);
        prMessageLOGS('     '+firm.Name, fLogDebug, False);
      end;
    end;  }
//---------------------------------------------------------
  except
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, fLogCache);
  end;
//  SetLength(ars, 0);
  SetLength(AllowDprts, 0);
  SetLength(dprts, 0);
  SetLength(AllowFirms, 0);
  SetLength(firms, 0);
  prFree(list);
  SetLength(ar, 0);
// (ObjectType = 3)    - (Тип объекта = "Подразделения")
// (ObjectType = 4)    - (Тип объекта = "Контрагенты")
// (ObjectType = 6)    - (Тип объекта = "Товары")
// (ObjectType = 97)   - (Тип объекта = "Накладная  передачи")
// (ObjectType = 8270) - (Тип объекта = "Запрос на возврат")
// allow if (ManagerCode = 180);
{
....deny;
allow if (ObjectType = 6);
allow if (FirmCode in 9618);
allow if (ObjectType = 4) and (FirmCode in 7670);
allow if (FirmCode in 10788);
allow if (FirmCode in 2937);
allow if (FirmCode in 8505);
allow if (FirmCode in 8942);
allow if (FirmCode in 1887);
allow if (FirmCode in 22453);
allow if (ObjectType = 97);
deny if (ObjectType = 97) and (SorcDprtCode <> 1) and not (SorcDprtCode in 68);
deny if (ObjectType = 97) and (DestDprtCode <> 1) and not (DestDprtCode in 68);
allow if (ObjectType = 97) and (SorcDprtCode = 77) and (DestDprtCode = 72);
allow if (ObjectType = 97) and (SorcDprtCode = 59) and (DestDprtCode = 77);
allow if (ObjectType = 97) and (SorcDprtCode = 132) and (DestDprtCode = 136);
allow if (ObjectType = 97) and (SorcDprtCode = 136) and (DestDprtCode = 72);
allow if (ObjectType = 97) and (SorcDprtCode = 170) and (DestDprtCode = 211);
allow if (ObjectType = 97) and (SorcDprtCode = 211) and (DestDprtCode = 72);
allow if (ObjectType = 3) and (DprtCode = 170);
allow if (ObjectType = 3) and (DprtCode = 211);
allow if (ObjectType = 3) and (DprtCode in 68);
allow if (ObjectType = 3) and (DprtCode = 1);
allow if (ObjectType = 3) and (DprtCode = 77);
allow if (ObjectType = 3) and (DprtCode = 59);
allow if (ObjectType = 3) and (DprtCode = 132);
allow if (ObjectType = 3) and (DprtCode = 34);
allow if (ObjectType = 3) and (DprtCode = 51);
allow if (ObjectType = 3) and (DprtCode = 136);
allow if (ObjectType = 8270) and (DprtCode in 68);............;
}
end;

//******************************************************************************
//                              TContract
//******************************************************************************
constructor TContract.Create(pID, pFirmCode, pSysID: Integer; pNumber: String);
begin
  inherited Create(pID, pFirmCode, 0, pNumber, pSysID);
  SetLength(ContProcDprts, 0);
  SetLength(ContStorages, 0);
  CS_cont        := TCriticalSection.Create;    // для изменения параметров
  ContDestPoints:= TObjectList.Create;        // торговые точки контракта
  FLegalEntity:= 0;
end;
//==============================================================================
destructor TContract.Destroy;
var j: Integer;
begin
  if not Assigned(self) then Exit;
  SetLength(ContProcDprts, 0);
  for j:= 0 to High(ContStorages) do prFree(ContStorages[j]);
  SetLength(ContStorages, 0);
  prFree(CS_cont);
  prFree(ContDestPoints);
  inherited Destroy;
end;
//================================================================= получить код
function TContract.GetIntFC(const ik: T16InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik16_1 : Result:= FSubCode;       // ContFirm
    ik16_2 : Result:= FCurrency;
    ik16_3 : Result:= FDutyCurrency;
//    ik16_4 : Result:= FSrcID;
    ik16_5 : Result:= FWhenBlocked;
    ik16_6 : Result:= FCredDelay;
    ik16_7 : Result:= FCredCurrency;
    ik16_8 : Result:= FOrderNum;      // MainStorage
    ik16_9 : Result:= GetContManager;
    ik16_10: if Cache.DprtExist(FOrderNum) then // код филиала (по главному складу)
               Result:= Cache.arDprtInfo[FOrderNum].FilialID;
    ik16_11: Result:= FFacCenter;
    ik16_12: Result:= FPayType;
    ik16_13: Result:= GetContFaccParent;
    ik16_14: Result:= FContPriceType;
    ik16_15: Result:= FLegalEntity;
  end;
end;
//================================================================= записать код
procedure TContract.SetIntFC(const ik: T16InfoKinds; Value: Integer);
begin
  if not Assigned(self) then Exit else case ik of
    ik16_1 : if (FSubCode      <>Value) then FSubCode      := Value; // ContFirm
    ik16_2 : if (FCurrency     <>Value) then FCurrency     := Value;
    ik16_3 : if (FDutyCurrency <>Value) then FDutyCurrency := Value;
//    ik16_4 : if (FSrcID        <>Value) then FSrcID        := Value;
    ik16_5 : if (FWhenBlocked  <>Value) then FWhenBlocked  := Value;
    ik16_6 : if (FCredDelay    <>Value) then FCredDelay    := Value;
    ik16_7 : if (FCredCurrency <>Value) then FCredCurrency := Value;
    ik16_8 : if (FOrderNum     <>Value) then FOrderNum     := Value; // MainStorage
//    ik16_9 : if (FContManager  <>Value) then FContManager  := Value;
    ik16_11: if (FFacCenter    <>Value) then FFacCenter    := Value;
    ik16_12: if (FPayType      <>Value) then FPayType      := Value;
    ik16_14: if (FContPriceType<>Value) then FContPriceType:= Value;
    ik16_15: if (FLegalEntity  <>Value) then FLegalEntity  := Value;
  end;
end;
//======================================================== получить вещ.значение
function TContract.GetDoubFC(const ik: T8InfoKinds): Single;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FContSumm;
    ik8_2: Result:= FCredLimit;
    ik8_3: Result:= FDebtSum;
    ik8_4: Result:= FOrderSum;
    ik8_5: Result:= FPlanOutSum;
  end;
end;
//======================================================== записать вещ.значение
procedure TContract.SetDoubFC(const ik: T8InfoKinds; Value: Single);
begin
  Value:= RoundToHalfDown(Value);
  if not Assigned(self) then Exit else case ik of
    ik8_1: if not fnNotZero(FContSumm)   or fnNotZero(FContSumm  -Value) then FContSumm  := Value;
    ik8_2: if not fnNotZero(FCredLimit)  or fnNotZero(FCredLimit -Value) then FCredLimit := Value;
    ik8_3: if not fnNotZero(FDebtSum)    or fnNotZero(FDebtSum   -Value) then FDebtSum   := Value;
    ik8_4: if not fnNotZero(FOrderSum)   or fnNotZero(FOrderSum  -Value) then FOrderSum  := Value;
    ik8_5: if not fnNotZero(FPlanOutSum) or fnNotZero(FPlanOutSum-Value) then FPlanOutSum:= Value;
  end;
end;
//============================================================== записать строку
procedure TContract.SetStrFC(const ik: T8InfoKinds; Value: String);
begin
  if not Assigned(self) then Exit;
  Value:= fnDelEndOfStr(Value);
  case ik of
    ik8_2: if (FContEmail  <>Value) then FContEmail  := Value;
    ik8_3: if (FWarnMessage<>Value) then FWarnMessage:= Value;
  end;
end;
//============================================================== получить строку
function TContract.GetStrFC(const ik: T8InfoKinds): String;
var i: Integer;
    le: TBaseDirItem;
    firma: TFirmInfo;
begin
  Result:= '';
  if not Assigned(self) then Exit else case ik of
    ik8_2: Result:= FContEmail;
    ik8_3: Result:= FWarnMessage;
    ik8_4: Result:= IntToStr(MainStorage);  // код склада по умолчанию символьный
//    ik8_5: Result:= GetSysTypeName(SysID);  // название системы учета
    ik8_5: if Cache.FirmExist(FSubCode) then begin
             firma:= Cache.arFirmInfo[FSubCode];
             for i:= 0 to firma.LegalEntities.Count-1 do begin
               le:= TBaseDirItem(firma.LegalEntities[i]);
               if (le.ID=LegalEntity) then begin
                 Result:= le.Name;
                 Exit;
               end;
             end;
           end;
    ik8_6: Result:= IntToStr(CredCurrency); // CredCurrency символьный
    ik8_7: Result:= GetContFaccName;        // наименование ЦФУ
    ik8_8: Result:= GetContFaccParentName;  // наименование ЦФУ
  end;
end;
//==================================================== поиск менеджера контракта
function TContract.FindContManager(var Empl: TEmplInfoItem): boolean;
var i, emplID: Integer;
begin
  Result:= False;
  Empl:= nil;
  emplID:= 0;
  if not Assigned(self) then Exit;
  if not flContManagerBKEonly and (FContManager>0) then begin
    emplID:= FContManager;
    if not Cache.EmplExist(emplID) then Cache.TestEmpls(emplID);
    Result:= Cache.EmplExist(emplID) and not Cache.arEmplInfo[emplID].Arhived;
  end;
  if not Result then with GetContBKEempls do for i:= 0 to Count-1 do begin // по BKE ищем первого
    emplID:= Items[i];
    if not Cache.EmplExist(emplID) then Cache.TestEmpls(emplID);
    Result:= Cache.EmplExist(emplID) and not Cache.arEmplInfo[emplID].Arhived;
    if Result then break;
  end;
  if Result then Empl:= Cache.arEmplInfo[emplID];  // регионал
end;
//================================================= проверка менеджера контракта
function TContract.CheckContManager(emplID: Integer): Boolean;
var i: Integer;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  Result:= (not flContManagerBKEonly and (FContManager=emplID));
  if not Result then with GetContBKEempls do for i:= 0 to Count-1 do begin
    Result:= (emplID=Items[i]);
    if Result then break;
  end;
end;
//====================================================== код менеджера контракта
function TContract.GetContManager: Integer;
var Empl: TEmplInfoItem;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  if FindContManager(empl) then Result:= Empl.ID; // код менеджера
end;
//============================================================= наименование ЦФУ
function TContract.GetContFaccName: String;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  if not Cache.FiscalCenters.ItemExists(FacCenter) then Exit;
  Result:= TFiscalCenter(Cache.FiscalCenters[FacCenter]).Name;
end;
//============================================================= код верхнего ЦФУ
function TContract.GetContFaccParent: Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  if not Cache.FiscalCenters.ItemExists(FacCenter) then Exit;
  Result:= TFiscalCenter(Cache.FiscalCenters[FacCenter]).Parent;
end;
//==================================================== наименование верхнего ЦФУ
function TContract.GetContFaccParentName: String;
var i: Integer;
begin
  Result:= '';
  if not Assigned(self) then Exit;
  i:= GetContFaccParent;
  if not Cache.FiscalCenters.ItemExists(i) then Exit;
  Result:= TFiscalCenter(Cache.FiscalCenters[i]).Name;
end;
//============================================= коды менеджеров контракта по ЦФУ
function TContract.GetContBKEempls: TIntegerList; // not Free !!!
begin
  Result:= EmptyIntegerList;
  if not Assigned(self) then Exit;
  if not Cache.FiscalCenters.ItemExists(FacCenter) then Exit;
  Result:= TFiscalCenter(Cache.FiscalCenters[FacCenter]).BKEempls;
end;
//================================================== получить торг.точку по коду
function TContract.GetContDestPoint(destID: integer): TDestPoint;
var i: Integer;
begin
  Result:= nil;
  for i:= 0 to ContDestPoints.Count-1 do begin
    Result:= TDestPoint(ContDestPoints[i]);
    if (Result.ID=destID) then break else Result:= nil;
  end;
end;
//============================================= проверяем длину массивов складов
procedure TContract.TestStoreArrayLength(kind: TArrayKind; len: integer; ChangeOnlyLess: boolean=True; inCS: boolean=True);
// len- нужная длина массива, inCS=True - изменять длину в CriticalSection
// ChangeOnlyLess=True - изменять только, если длина меньше, False - если не равна
var fl: boolean;
    i, j: integer;
begin
  if not Assigned(self) then Exit;
  i:= -1;
  case kind of
     taCurr: i:= Length(ContStorages);
     taDprt: i:= Length(ContProcDprts);
  end;
  if i<0 then Exit;
  if ChangeOnlyLess then fl:= (i<len) else fl:= (i<>len);
  if fl then try // если надо менять длину
    if inCS then CS_cont.Enter;

    case kind of
      taDprt: if i<len then prCheckLengthIntArray(ContProcDprts, len-1) else SetLength(ContProcDprts, len);
      taCurr: begin  // если обрезаем - надо очистить элементы
                if (i>len) then for j:= len to High(ContStorages) do prFree(ContStorages[j]);
                SetLength(ContStorages, len);
                if (i<len) then for j:= i to High(ContStorages) do ContStorages[j]:= nil;
              end;
    end; // case
  finally
    if inCS then CS_cont.Leave;
  end;
end;
//========================================= индекс склада в массиве ContStorages
function TContract.GetСontStoreIndex(StorageID: integer): integer;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  for Result:= 0 to High(ContStorages) do
    if (ContStorages[Result].DprtID=StorageID) then exit;
  Result:= -1;
end;
//******************************************************************************
//                               TContracts
//******************************************************************************
function TContracts.GetContract(pID: integer): TContract;
begin
  Result:= TContract(inherited GetItem(pID));
end;

//******************************************************************************
//                            TNotificationItem
//******************************************************************************
constructor TNotificationItem.Create(pID: Integer; pText: String);
begin
  inherited Create(pID, pText);
  FFirmFilials:= TIntegerList.Create; // коды филиалов к/а
  FFirmClasses:= TIntegerList.Create; // коды категорий к/а
  FFirmTypes  := TIntegerList.Create; // коды типов к/а
  FFirms      := TIntegerList.Create; // коды  к/а
end;
//==============================================================
destructor TNotificationItem.Destroy;
begin
  prFree(FFirmFilials);
  prFree(FFirmClasses);
  prFree(FFirmTypes);
  prFree(FFirms);
  inherited;
end;
//================================================================ получить дату
function TNotificationItem.GetDateN(const ik: T8InfoKinds): TDateTime;
begin
  Result:= 0;
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FBegDate;
    ik8_2: Result:= FEndDate;
  end;
end;
//================================================================ записать дату
procedure TNotificationItem.SetDateN(const ik: T8InfoKinds; Value: TDateTime);
begin
  if not Assigned(self) then Exit else case ik of
    ik8_1: if fnNotZero(FBegDate-Value) then FBegDate:= Value;
    ik8_2: if fnNotZero(FEndDate-Value) then FEndDate:= Value;
  end;
end;
//======================================================== получить список кодов
function TNotificationItem.GetIntListN(const ik: T8InfoKinds): TIntegerList;
begin
  Result:= nil;
  if not Assigned(self) then Exit else case ik of
    ik8_1: Result:= FFirmFilials;
    ik8_2: Result:= FFirmClasses;
    ik8_3: Result:= FFirmTypes;
    ik8_4: Result:= FFirms;
  end;
end;
//================================================= проверить условия фильтрации
procedure TNotificationItem.CheckConditions(sFil, sClas, sTyp, sFirm: String);
begin
  if not Assigned(self) then Exit;
  prCheckIntegerListByCodesString(FFirmFilials, sFil);
  prCheckIntegerListByCodesString(FFirmClasses, sClas);
  prCheckIntegerListByCodesString(FFirmTypes, sTyp);
  prCheckIntegerListByCodesString(FFirms, sFirm);
end;
//******************************************************************************
//                             TNotifications
//******************************************************************************
function TNotifications.GetNotification(pID: integer): TNotificationItem;
begin
  Result:= TNotificationItem(inherited GetItem(pID));
end;
//===================================================== список уведомлений фирмы
function TNotifications.GetFirmNotifications(FirmID: integer): TIntegerList; // must Free
var i: Integer;
    note: TNotificationItem;
begin
  Result:= TIntegerList.Create;
  for i:= 0 to ItemsList.Count-1 do begin
    note:= ItemsList[i];
    with note do if CheckFirmFilterConditions(FirmID, flFirmAdd, flFirmAuto, flFirmMoto,
      FirmFilials, FirmClasses, FirmTypes, Firms) then Result.Add(ID);
  end;
end;

//******************************************************************************
//                                   TFiscalCenter
//******************************************************************************
constructor TFiscalCenter.Create(pID, pParent: Integer; pName: String);
begin
  inherited Create(pID, pName);
  FParent:= pParent;
  BKEempls:= TIntegerList.Create;
end;
//==============================================================================
destructor TFiscalCenter.Destroy;
begin
  prFree(BKEempls);
  inherited;
end;
//================================================================= номер округа
function TFiscalCenter.GetRegion: Integer;
var i: Integer;
begin
  Result:= 0;
  if not IsAutoSale then Exit; // только AUTO
  if (copy(FName, 1, 1)='0') then Exit;
  i:= pos('-', FName);
  if (i<2) then Exit;
  Result:= StrToIntDef(copy(FName, 1, i-1), 0);
end;
//========================================================= код ЦФУ РОП-а округа
function TFiscalCenter.GetROPfacc: Integer;
var i: Integer;
begin
  Result:= -1;
  i:= GetRegion;           // 1-й не берем
  if (i<2) then Exit;
  if (i<Length(Cache.arRegionROPFacc)) then Result:= Cache.arRegionROPFacc[i];
end;
//===================================================== признак ЦФУ РОП-а округа
function TFiscalCenter.CheckIsROPFacc: Boolean;
begin
  Result:= (pos('-00-01', FName)>1);
end;
//============================================================ продажи AUTO/MOTO
function TFiscalCenter.GetSaleType: Integer;
var i, iAUTO, iMOTO: Integer;
    fc: TFiscalCenter;
begin
  Result:= 0;
  iAUTO:= Cache.GetConstItem(pcFaccAUTOSaleCode).IntValue;
  iMOTO:= Cache.GetConstItem(pcFaccMOTOSaleCode).IntValue;
  i:= ID;
  fc:= nil;
  try
    while (i>0) do begin
      if (i=iAUTO) then Result:= constIsAUTO
      else if (i=iMOTO) then Result:= constIsMOTO;
      if (Result>0) then Exit;
      if (i=ID) then fc:= self
      else if Cache.FiscalCenters.ItemExists(i) then fc:= Cache.FiscalCenters[i]
      else Exit;
      i:= fc.Parent;
    end;
  except
  end;
end;

//******************************************************************************
//                           TMarginGroups
//******************************************************************************
// в TLinks - TLinkLink: LinkPtr- ссылка на группу(TWareInfo), State- признак проверки группы,
// в DoubleLinks - TLink: LinkPtr- ссылка на подгруппу(TWareInfo), State- признак проверки подгруппы
//====================================================== получить группу наценки
//==================================================== получить TWareInfo группы
function TMarginGroups.GetWareGroup(grID: integer): TWareInfo;
var grLink: TLinkLink;
begin
  Result:= NoWare;
  if not Assigned(self) then Exit;
  grLink:= GetLinkItemByID(grID);
  if Assigned(grLink) and Assigned(grLink.LinkPtr) then Result:= grLink.LinkPtr;
end;
//================================================= получить TWareInfo подгруппы
function TMarginGroups.GetWareSubGroup(grID, pgrID: integer): TWareInfo;
var pgrLinks: TLinkList;
    pgrLink: TLink;
begin
  Result:= NoWare;
  if not Assigned(self) then Exit;
  pgrLinks:= GetDoubleLinks(grID);
  if not Assigned(pgrLinks) then Exit;
  pgrLink:= pgrLinks.GetLinkListItemByID(pgrID, lkDirNone);
  if Assigned(pgrLink) and Assigned(pgrLink.LinkPtr) then Result:= pgrLink.LinkPtr;
end;
//================================================ проверка существования группы
function TMarginGroups.GroupExists(grID: integer): Boolean;
begin
  Result:= False;
  if Assigned(self) then Result:= LinkExists(grID);
end;
//==================================== проверка существования подгруппы в группе
function TMarginGroups.SubGroupExists(grID, pgrID: integer): Boolean;
begin
  Result:= False;
  if Assigned(self) then Result:= DoubleLinkExists(grID, pgrID);
end;
//==================================================== проверить/добавить группу
function TMarginGroups.CheckGroup(grID: integer; SortAdd: Boolean=False): Boolean;
var grLink: TLinkLink;
    Grp: TWareInfo;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  if not Cache.GrpExists(grID) then Exit;
  Grp:= Cache.arWareInfo[grID];
  grLink:= GetLinkItemByID(grID);
  if not Assigned(grLink) then begin
    grLink:= TLinkLink.Create(0, Grp);
    AddLinkItem(grLink);
    if SortAdd then SortByName(0);
  end else try
    CS_Links.Enter;
    if grLink.LinkPtr<>Grp then grLink.LinkPtr:= Grp;
    grLink.State:= True;
  finally
    CS_Links.Leave;
  end;
end;
//================================================= проверить/добавить подгруппу
function TMarginGroups.CheckSubGroup(grID, pgrID: integer; SortAdd: Boolean=False): Boolean;
var grLink: TLinkLink;
    pgrLink: TLink;
    Pgr: TWareInfo;
begin
  Result:= False;
  if not Assigned(self) then Exit;
  if not Cache.PgrExists(pgrID) then Exit;
  Pgr:= Cache.arWareInfo[pgrID];
  grLink:= GetLinkItemByID(grID);
  if not Assigned(grLink) then Exit;
  pgrLink:= grLink.DoubleLinks.GetLinkListItemByID(pgrID, lkDirNone);
  if not Assigned(pgrLink) then begin
    pgrLink:= TLink.Create(0, Pgr);
    grLink.CheckDoubleLinks(CS_Links);
    grLink.DoubleLinks.AddLinkListItem(pgrLink, lkLnkNone, CS_Links); // связка
    if SortAdd then SortByName(grID);
  end else try
    CS_Links.Enter;
    if pgrLink.LinkPtr<>Pgr then pgrLink.LinkPtr:= Pgr;
    pgrLink.State:= True;
  finally
    CS_Links.Leave;
  end;
end;
//=========================================== список ссылок на группы по системе
function TMarginGroups.GetGroupList(TypeSys: Integer=constIsAuto): TList; // must Free
var i: Integer;
    Grp: TWareInfo;
begin
  Result:= TList.Create;
  if not Assigned(self) then Exit;
  for i:= 0 to ListLinks.Count-1 do begin
    Grp:= GetLinkPtr(ListLinks[i]);
    if not Grp.IsGrp then Continue;
    if (TypeSys>0) and not Grp.CheckWareTypeSys(TypeSys) then Continue;
    Result.Add(Grp);
  end;
end;
//=============================== список ссылок на подгруппы в группе по системе
function TMarginGroups.GetSubGroupList(grID: integer; TypeSys: Integer=constIsAuto): TList; // must Free
var i: Integer;
    pgrLinks: TLinkList;
    Pgr: TWareInfo;
begin
  Result:= TList.Create;
  if not Assigned(self) then Exit;
  if not GroupExists(grID) then Exit;
  pgrLinks:= GetDoubleLinks(grID);
  if not Assigned(pgrLinks) then Exit;
  for i:= 0 to pgrLinks.Count-1 do begin
    Pgr:= GetLinkPtr(pgrLinks[i]);
    if not Pgr.IsPgr then Continue;
    if (TypeSys>0) and not Pgr.CheckWareTypeSys(TypeSys) then Continue;
    Result.Add(Pgr);
  end;
end;
//============================= сортирует связки с группами/подгруппами по имени
procedure TMarginGroups.SortByName(grID: integer=0);
// grID<0 - сортирует все, grID=0 - сортирует связки с группами,
// grID>0 - сортирует связки с подруппами группы grID
var pgrLinks: TLinkList;
    i: Integer;
begin
  if not Assigned(self) then Exit;
  if (grID<1) and (LinkCount>1) then SortByLinkName; // все или группы
  if (grID=0) then Exit; // только группы

  if (grID>0) then begin // подгруппы заданной группы
    if not LinkExists(grID) then Exit;
    pgrLinks:= GetDoubleLinks(grID);
    if not Assigned(pgrLinks) then Exit;
    if (pgrLinks.Count>1) then pgrLinks.Sort(LinkNameSortCompare);

  end else for i:= 0 to ListLinks.Count-1 do begin
    grID:= GetLinkID(ListLinks[i]);
    pgrLinks:= GetDoubleLinks(grID);
    if not Assigned(pgrLinks) then Continue;
    if (pgrLinks.Count>1) then pgrLinks.Sort(LinkNameSortCompare);
  end;
end;
//=================================== устанавливает флаг проверки всем элементам
procedure TMarginGroups.SetLinkStatesAll(pState: Boolean);
var i, grID: Integer;
    pgrLinks: TLinkList;
begin
  SetLinkStates(pState);
  for i:= 0 to ListLinks.Count-1 do begin
    grID:= GetLinkID(ListLinks[i]);
    pgrLinks:= GetDoubleLinks(grID);
    pgrLinks.SetLinkStates(pState, CS_links);
  end;
end;
//=========================================== удаляет все элементы с State=False
procedure TMarginGroups.DelNotTestedLinksAll;
var i, grID: Integer;
    pgrLinks: TLinkList;
begin
  DelNotTestedLinks;
  for i:= 0 to ListLinks.Count-1 do begin
    grID:= GetLinkID(ListLinks[i]);
    pgrLinks:= GetDoubleLinks(grID);
    pgrLinks.DelNotTestedLinks(CS_links);
  end;
end;

//******************************************************************************
//                              TCurrency
//******************************************************************************
constructor TCurrency.Create(pID: Integer; pName, pCliName: String; pRate: Single; pArh: Boolean);
begin
  inherited Create(pID, pName);
  FCliName:= pCliName;
  FCurrRate:= pRate;
  Arhived:= pArh;
end;

//******************************************************************************
//                              TCurrencies
//******************************************************************************
function TCurrencies.GetCurrency(pCurrID: Integer): TCurrency;
begin
  Result:= nil;
  if not Assigned(self) or not ItemExists(pCurrID) then Exit;
  Result:= TCurrency(GetItem(pCurrID));
end;
//==============================================================================
function TCurrencies.GetCurrRate(pCurrID: Integer): Single;
begin
  Result:= 0;
  if not Assigned(self) or not ItemExists(pCurrID) then Exit;
  Result:= GetCurrency(pCurrID).CurrRate;
end;

//******************************************************************************
//                              TDiscModel
//******************************************************************************
//==============================================================================
constructor TDiscModel.Create(pID, pDirect, pRate, pSales: Integer; pName: String);
begin
  inherited Create(pID, pName);
  FDirectInd:= pDirect;
  FRating:= pRate;
  FSales:= pSales;
end;
//==============================================================================
destructor TDiscModel.Destroy;
begin

  inherited;
end;
//====================================================== получить целое значение
function TDiscModel.GetIntDM(const ik: T8InfoKinds): Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: Result:= FDirectInd; // индекс направления
    ik8_2: Result:= FRating;   // рейтинг
    ik8_3: Result:= FSales;    // мин.оборот
  end;
end;
//====================================================== записать целое значение
procedure TDiscModel.SetIntDM(const ik: T8InfoKinds; pValue: Integer);
begin
  if not Assigned(self) then Exit;
  case ik of
    ik8_1: if (FDirectInd<>pValue) then FDirectInd:= pValue; // индекс направления
    ik8_2: if (FRating   <>pValue) then FRating   := pValue; // рейтинг
    ik8_3: if (FSales    <>pValue) then FSales    := pValue; // мин.оборот
  end;
end;

//******************************************************************************
//                              TDiscModels
//******************************************************************************
constructor TDiscModels.Create;
begin
  inherited Create;
  EmptyModel:= TDiscModel.Create(0, 0, 0, 0, '');
  FDiscModels:= TObjectList.Create;
  FProdDirects:= fnCreateStringList(True, 3); // сортировка по наименованию
  CS_DiscModels:= TCriticalSection.Create;
end;
//==============================================================================
destructor TDiscModels.Destroy;
begin
  prFree(EmptyModel);
  prFree(FDiscModels);
  prFree(FProdDirects);
  prFree(CS_DiscModels);
  inherited Destroy;
end;
//=============================================== добавить/проверить направление
procedure TDiscModels.CheckProdDirect(pdID: Integer; pdName: String);
var j: Integer;
begin
  if not Assigned(self) then Exit;
  j:= GetDirectIndex(pdID);
  if (j<0) then FProdDirects.AddObject(pdName, Pointer(pdID))
  else if (FProdDirects[j]<>pdName) then begin
    CS_DiscModels.Enter;
    try
      FProdDirects[j]:= pdName;
    finally
      CS_DiscModels.Leave;
    end;
  end;
end;
//========================================================== удалить направление
procedure TDiscModels.DelProdDirect(pdID: Integer);
var i, j: Integer;
    dm: TDiscModel;
begin
  if not Assigned(self) then Exit;
  j:= GetDirectIndex(pdID);
  if (j<0) then exit;
  CS_DiscModels.Enter;
  try
    for i:= FDiscModels.Count-1 downto 0 do begin
      dm:= TDiscModel(FDiscModels[i]);
      if (dm.DirectInd=j) then begin
        FDiscModels.Delete(i);
        dm.Free;
      end;
    end;
    FProdDirects.Delete(j);
  finally
    CS_DiscModels.Leave;
  end;
end;
//==================================================== добавить/проверить шаблон
procedure TDiscModels.CheckDiscModel(dmID, pdID, pRate, pSales: Integer; dmName: String);
var j: Integer;
    dm: TDiscModel;
begin
  if not Assigned(self) then Exit;
  j:= GetDirectIndex(pdID);
  if (j<0) then exit;
  dm:= GetDiscModel(dmID);
  if (dm=EmptyModel) then begin
    dm:= TDiscModel.Create(dmID, j, pRate, pSales, dmName);
    FDiscModels.Add(dm);
  end else begin
    dm.DirectInd:= j;
    dm.Rating:= pRate;
    dm.Sales:= pSales;
    dm.State:= True;
  end;
end;
//=============================================================== удалить шаблон
procedure TDiscModels.DelDiscModel(dmID: Integer);
var i: Integer;
    dm: TDiscModel;
begin
  if not Assigned(self) then Exit;
  CS_DiscModels.Enter;
  try
    for i:= FDiscModels.Count-1 downto 0 do begin
      dm:= TDiscModel(FDiscModels[i]);
      if (dm.ID=dmID) then begin
        FDiscModels.Delete(i);
        dm.Free;
        Exit;
      end;
    end;
  finally
    CS_DiscModels.Leave;
  end;
end;
//======================================================= удалить лишние шаблоны
procedure TDiscModels.DelNotTestedDiscModels;
var i: Integer;
    dm: TDiscModel;
begin
  if not Assigned(self) then Exit;
  CS_DiscModels.Enter;
  try
    for i:= FDiscModels.Count-1 downto 0 do begin
      dm:= TDiscModel(FDiscModels[i]);
      if not dm.State then begin
        FDiscModels.Delete(i);
        dm.Free;
      end;
    end;
  finally
    CS_DiscModels.Leave;
  end;
end;
//======================================================================= шаблон
function TDiscModels.GetDiscModel(pID: Integer): TDiscModel;
var i: Integer;
begin
  Result:= nil;
  if not Assigned(self) then Exit;
  for i:= 0 to FDiscModels.Count-1 do begin
    Result:= TDiscModel(FDiscModels[i]);
    if (Result.ID=pID) then Exit;
  end;
  Result:= EmptyModel;
end;
//=========================================== код следующего шаблона направления
function TDiscModels.GetNextDirectModel(dmID: Integer): Integer;
var i, direct, ind: Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  ind:= -1;
  direct:= 0;
  for i:= 0 to FDiscModels.Count-1 do with TDiscModel(FDiscModels[i]) do
    if (ID=dmID) then begin // нашли вх.шаблон
      ind:= i;
      direct:= DirectInd;
    end else if (ind<0) then Continue
    else if (DirectInd=direct) then begin // следующий по направлению
      Result:= ID;
      Exit;
    end;
end;
//================================================== список шаблонов направления
function TDiscModels.GetDirectModelsList(pdID: Integer): TList; // must Free !!!
var i, j: Integer;
begin
  Result:= TList.Create;
  if not Assigned(self) then Exit;
  j:= GetDirectIndex(pdID);
  if (j<0) then exit;
  for i:= 0 to FDiscModels.Count-1 do
    if (TDiscModel(FDiscModels[i]).DirectInd=j) then
      Result.Add(FDiscModels[i]);
end;
//================================================== кол-во шаблонов направления
function TDiscModels.GetDirectModelsCount(pdID: Integer): Integer;
var i, j: Integer;
begin
  Result:= 0;
  if not Assigned(self) then Exit;
  j:= GetDirectIndex(pdID);
  if (j<0) then exit;
  for i:= 0 to FDiscModels.Count-1 do
    if (TDiscModel(FDiscModels[i]).DirectInd=j) then inc(Result);
end;
//========================================================== сортировать шаблоны
procedure TDiscModels.SortDiscModels;
begin
  if not Assigned(self) then Exit;
  CS_DiscModels.Enter;
  try
    FDiscModels.Sort(DiscModelsSortCompare);
  finally
    CS_DiscModels.Leave;
  end;
end;
//=========================================================== индекс направления
function TDiscModels.GetDirectIndex(pdID: Integer): Integer;
begin
  Result:= -1;
  if not Assigned(self) then Exit;
  Result:= FProdDirects.IndexOfObject(Pointer(pdID));
end;

//******************************************************************************
{function CheckCacheTestAvailable: Boolean;
begin
  Result:= fnTestExistsFiles('*'+FlagCacheFile+'*', FlagCachePath)='';
end; }
{ на имени метода класса -> Ctrl+Shift+C -> шаблончик для будущей процедуры }

{ TDiscModels }


//******************************************************************************
//                                TDestPoint
//******************************************************************************
constructor TDestPoint.Create(pID: Integer; pName, pAdress: String);
begin
  inherited Create(pID, pName);
  FAdress:= pAdress;
end;

end.


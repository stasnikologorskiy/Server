unit n_TD_functions;

interface
uses Windows, Classes, Types, SysUtils, IniFiles, DateUtils, Math, DB, ADODB,
     ActiveX, Forms, Contnrs, IBDatabase, IBQuery, IBSQL, OleServer, Excel_TLB, Variants,
     n_free_functions, v_constants, v_DataTrans, n_constants, n_LogThreads,
     n_DataCacheInMemory, n_DataCacheAddition, n_DataCacheObjects, n_DataSetsManager;

type TarMps = array [0..17] of Integer; // массив для параметров модели

  TKeyTab = record // для инфо-списков
    KtCodeTDT   : Integer; // код KeyTable TDT
    TypeCodeORD : Integer; // код типа списка ORD
    FieldNameTDT: String;  // имя поля TDT
    KtNameTDT   : String;  // название KeyTable TDT
    InfoCodesORD: Tai;     // индекс - код Key TDT, значение - код DIRINFOTYPEMODEL (ORD)
    KeNamesTDT  : Tas;     // индекс - код Key TDT, значение - наименование TDT
  end;
  TarKeyTabs = array of TKeyTab; // массив для кодов элементов списков

  TLinkInfo = record
    nodeORD, nodTD, modORD, modelTD, Src, ldmw: Integer;
    PartLagts: Tai;  // коды связок TD
    PartNums: Tai;   // номера порций условий и текстов
    PartLists: TASL; // списки порций условий
    TextLists: TASL; // списки порций текстов
  end;
  TArLinkInfo = array of TLinkInfo; // для передачи через параметр функции

  TEngLinkInfo = record
    nodeORD, engORD, xLenw: Integer;
    PartLages: Tai;  // коды связок TD
    PartNums: Tai;   // номера порций условий
    ArUseParts: array of array of TCriInfo; // порции условий
  end;

const cDelim = '-------------;';
      cTabDelim = '-------------'#9;
      cTab = #9;
  arMpsTitles: array [0..17] of String = ('От/м', 'От/г', 'До/м', 'До/г',
    'кВт', 'ЛС', 'Т/об', 'Цил', 'Клап', 'Кузов', 'Привод', 'Двиг', 'Топл',
    'Впрыск', 'Тип/ТС', 'ТС', 'Катал', 'К/пер');
  ModelSheetName = 'Модели';
  sActionAdd = 'добавить';
  sActionUpd = 'изменить';
  sActionDel = 'удалить';

//var arSearchArticleMF: Tai;
//    arSearchArticleLists: TASL;
//                 отчеты и импорт данных из fb_tdt.fdb в ib_ord.gdb
(* function fnGetNewAutoManufFromTDT(pUserID: Integer;     // 13-stamp - поиск новых производителей авто в TDT
          ThreadData: TThreadData=nil): TStringList;
 function fnSetNewAutoManufFromTDT(UserID: integer;      // 13-imp - загрузка производителей авто из TDT
          FileName: string; ThreadData: TThreadData=nil): TStringList;
 function fnGetNewAutoModelLineFromTDT(pUserID: Integer; // 14-stamp - поиск новых мод.рядов авто в TDT
          ThreadData: TThreadData=nil): TStringList;
 function fnSetNewAutoModelLineFromTDT(UserID: integer;  // 14-imp - загрузка мод.рядов авто из TDT
          FileName: string; ThreadData: TThreadData=nil): TStringList;
 function fnGetNewAutoModelFromTDT(pUserID: Integer;     // 15-stamp - поиск новых моделей авто в TDT
          ThreadData: TThreadData=nil): TStringList;
procedure prSetNewAutoModelFromTDT(UserID: integer;      // 15-imp - загрузка моделей авто из TDT
          FileName: string; ThreadData: TThreadData=nil);   *)

 function AddLoadWaresInfoFromTDT(UserID: Integer;       // 24-stamp - must Free - пакетная доп.загрузка связок, критериев, текстов, файлов и ОН товаров из TDT
          ThreadData: TThreadData=nil; filter_data: String=''): TStringList;
procedure prDeleteAutoModels(UserID: integer;            // 24-imp - удаление моделей авто из базы по файлу Excel (xls)
          FileName: string; ThreadData: TThreadData=nil);

 function fnGetNewAutoMfMlModFromTDT(pUserID: Integer;   // 25-stamp - must Free - поиск новых производителей, м.р., моделей авто из TDT
          ThreadData: TThreadData=nil): TStringList;
procedure prSetNewAutoMfMlModFromTDT(UserID: integer;    // 25-imp - загрузка моделей авто из TDT по файлу Excel
          FileName: string; ThreadData: TThreadData=nil);

 function fnGetNewTreeNodesFromTDT(pUserID: Integer;     // 34-stamp - must Free - поиск новых узлов авто из TDT
          ThreadData: TThreadData=nil): TStringList;
procedure prSetNewTreeNodesFromTDT(UserID: Integer;      // 34-imp - загрузка / корректировка узлов авто из файла Excel
          FileName: string; ThreadData: TThreadData=nil);

procedure prGetArticlesINFOgrFromTDT(pUserID: Integer; // 36-stamp - поиск артикулов TDT для инфо-групп Гроссби
          pFileName: String; ThreadData: TThreadData=nil);

 function fnGetInfoTextsForTranslate(pUserID: Integer;   // 39-stamp - must Free - перечень инфо-текстов TecDoc для перевода
          ThreadData: TThreadData=nil): TStringList;
procedure prSetAlternativeInfoTexts(UserID: integer;     // 39-imp - загрузка альтернативных значений инфо-текстов TecDoc из файла Excel
          FileName: string; ThreadData: TThreadData=nil);

 function fnGetCheckWareTDTArticles(pUserID: Integer;    // 40-stamp - must Free, Отчет о проверке привязок товаров к артикулам
          ThreadData: TThreadData=nil): TStringList;

//             функции загрузок из TDT
 function LoadWareLinksUsesCrisTextsFromTDT(WareID, UserID: Integer; // загрузка связок, порций критериев и текстов, файлов и ОН товара из TDT
          var addLink3, addLinkON: Integer; ThreadData: TThreadData=nil;
          OnlyON: Boolean=False; CheckTexts: Boolean=False; WithEng: Boolean=True;
          OnlyCross: Boolean=False; CheckArt: Boolean=False): String;
 function LoadWareEngLinksUsesFromTDT( WareID, UserID: Integer; var addLinkEng: Integer; // загрузка связок товара с двигателями из TecDoc
          ThreadData: TThreadData=nil; CheckArt: Boolean=True): String;
procedure LoadModelNodeWareUseAndTextListsFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;       // загрузка порций условий и текстов из TecDoc
          WareID, pSupMFTD, UserID: Integer; var arInfo: TArLinkInfo;
          ThreadData: TThreadData=nil; CheckTexts: Boolean=False);
procedure LoadLinkListsFromTDT(TdtIBS: TIBSQL; WareID, UserID, pSrc: Integer;          // загрузка связок товара из TDT по 1-му источнику
          var arInfo: TArLinkInfo; var ii, addLink3: Integer; ThreadData: TThreadData=nil);
procedure LoadWareNodeInfoTextFromTDT(WareID, pSupMFTD, nodeID, UserID, pSrc: Integer; // доп.инф. по товару и ноде из TDT
          pArticleTD: String; TdtIBS, ordIBS, ordIBSr: TIBSQL; ThreadData: TThreadData=nil);
 function LoadWareGraFileNamesFromTDT(WareID, UserID: Integer): String;                // имена файлов рисунков товара из TDT
 function fnGetWareONumsFromTDT(pWareID: Integer; pArtSupTD: Integer=0;                // поиск оригинальных номеров товара в TDT
                                pArticleTD: String=''): TarWareOnumOpts;
 function CheckEnginesFromTDT(var engCodes: Tai; pUserID: integer): String; overload;  // загрузка/проверка параметров нескольких двигателей из TDT
 function CheckEnginesFromTDT(pUserID: integer): String; overload;                     // пакетная загрузка/проверка параметров двигателей из TDT
procedure LoadWareCrossFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;                        // загрузка аналогов товара из TecDoc
          WareID, pSupMFTD, UserID: Integer; pArticleTD: String; ThreadData: TThreadData=nil);
procedure LoadWareCrossesFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;
          WareID, pSupMFTD, UserID: Integer; pArticleTD: String; ThreadData: TThreadData=nil); // загрузка аналогов товара (+ по заменам) из TecDoc

//                    функции администрирования
function TestUpperWareArticleFromTDT: TStringList;                    // проверка артиклей на Upper в WAREARTICLETD
function TestNotLoadArticleLinksFromTDT(supliers: String=''): String; // проверка связок артиклей

implementation
uses n_server_common, t_ExcelXmlUse, n_xml_functions, t_ImportChecking;

const icKodMF    = 1;   icKodML    = 2;      icNameTDML = 8;    icKodTDMod = 5;
      icNameMF   = 2;   icNameML   = 3;      icFromTDML = 9;    icNameTDMod= 6;
      icVisMF    = 3;   icFromML   = 4;      icToTDML   = 10;   icModMps   = 8;
      icKodTDMF  = 4;   icToML     = 5;      icCommML   = 11;   icModMpsV  = 8;
      icNameTDMF = 5;   icVisML    = 6;      icKodMod   = 3;    icCommMod  = 26;
      icCommMF   = 6;   icKodTDML  = 7;      icVisMod   = 4;    icResMod   = 27;
//******************************************************************************
//                        вспомагательные функции
//******************************************************************************
//-------------------------------------- проверка остановки процесса или системы
procedure CheckStopExecute(pUserID: Integer; ThreadData: TThreadData);
begin
  if Assigned(ThreadData) then
    prStopProcess(pUserID, ThreadData.ID) // проверка остановки процесса
  else TestCssStopException; // проверка остановки системы
end;
//--------------------------------------------- отображение процентов выполнения
procedure SetExecutePercent(pUserID: Integer; ThreadData: TThreadData; Percent: Double);
begin
  if Assigned(ThreadData) then
    ImpCheck.SetProcessPercent(pUserID, ThreadData.ID, Percent);
end;
//------------------------------------------------ параметры модели - из массива
procedure MakeMpsFromArray(arMps: TarMps; var Result: TModelParams);
begin
  if not Assigned(Result) then Result:= TModelParams.Create;
  with Result do begin
    pMStart    := arMps[0];
    pYStart    := arMps[1];
    pMEnd      := arMps[2];
    pYEnd      := arMps[3];
    pKW        := arMps[4];
    pHP        := arMps[5];
    pCCM       := arMps[6];
    pCylinders := arMps[7];
    pValves    := arMps[8];
    pBodyID    := arMps[9];
    pDriveID   := arMps[10];
    pEngTypeID := arMps[11];
    pFuelID    := arMps[12];
    pFuelSupID := arMps[13];
    pBrakeID   := arMps[14];
    pBrakeSysID:= arMps[15];
    pCatalID   := arMps[16];
    pTransID   := arMps[17];
  end;
end;
//-------------------------------------------------- параметры модели - в массив
function MakeArrayFromMps(mps: TModelParams): TarMps;
begin
  with mps do begin
    Result[0] := pMStart;
    Result[1] := pYStart;
    Result[2] := pMEnd;
    Result[3] := pYEnd;
    Result[4] := pKW;
    Result[5] := pHP;
    Result[6] := pCCM;
    Result[7] := pCylinders;
    Result[8] := pValves;
    Result[9] := pBodyID;
    Result[10]:= pDriveID;
    Result[11]:= pEngTypeID;
    Result[12]:= pFuelID;
    Result[13]:= pFuelSupID;
    Result[14]:= pBrakeID;
    Result[15]:= pBrakeSysID;
    Result[16]:= pCatalID;
    Result[17]:= pTransID;
  end;
end;
//----------------------------------- заполняем имя поля для поиска соответствий
procedure FillKeTabRecNf(index: Integer; nmf: String; var KeyTabs: TarKeyTabs);
begin
  if (index<Low(KeyTabs)) or (index>High(KeyTabs)) then exit;
  KeyTabs[index].FieldNameTDT := nmf;          // код KeyTable TDT
  KeyTabs[index].KtCodeTDT    := 0;            // код типа списка ORD
  KeyTabs[index].KtNameTDT    := '';           // имя поля TDT
  KeyTabs[index].TypeCodeORD  := 0;            // название KeyTable TDT
// инициализируем массивы
  SetLength(KeyTabs[index].InfoCodesORD, 0);   // индекс - код Key TDT, значение - код DIRINFOTYPEMODEL (ORD)
  SetLength(KeyTabs[index].KeNamesTDT, 0);     // индекс - код Key TDT, значение - наименование TDT
end;
//-------------------------- заполняем массив соответствий нужных списков по TDT
procedure FillarKeyTabsFromTDT(var KeyTabs: TarKeyTabs; FILEID: Integer; TdtIBS: TIBSQL);
var ss, mName: string;
    pkt, pke, i, ii: integer;
begin
  try                            // вынимаем в память виды списков TDT
    TdtIBS.SQL.Text:= 'select upper(IFFIELDNAME) fn, kt_id, kt_descr'+
      ' from IMPORT_FIELDS left join KEY_TABLES on kt_id=IFBYKT'+
      ' where IFFILEID='+IntToStr(FILEID)+' and IFBYKT>0';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin // заполняем коды TDT видов списков
      ss:= TdtIBS.FieldByName('fn').AsString;
      pkt:= TdtIBS.FieldByName('kt_id').AsInteger;
      mName:= TdtIBS.FieldByName('kt_descr').AsString;
      for i:= Low(KeyTabs) to high(KeyTabs) do
        with KeyTabs[i] do if FieldNameTDT=ss then begin  // имя поля TDT
          KtCodeTDT:= pkt;            // код KEY_TABLES TDT
          KtNameTDT:= mName;          // название KEY_TABLES TDT
          SetLength(InfoCodesORD, 0); // индекс - код Key TDT, значение - код DIRINFOTYPEMODEL (ORD)
          SetLength(KeNamesTDT, 0);   // индекс - код Key TDT, значение - наименование KEY_ENTRIES TDT
          break;
        end;
      TestCssStopException;
      TdtIBS.Next;
    end;
    TdtIBS.Close;              // вынимаем в память списки TDT
    with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    TdtIBS.SQL.Text:= 'select kt_id, cast(ke_key as integer) ke,'+
      ' iif(icn_NewDescr is null, ke_descr, icn_NewDescr) ke_descr'+
      ' from IMPORT_FIELDS left join KEY_TABLES on kt_id=IFBYKT'+
      ' left join KEY_ENTRIES on ke_kt_id=kt_id'+
      ' left join import_change_names on icn_kt_ID=kt_id'+
      ' and icn_ke_key=cast(ke_key as integer)'+
      ' where IFFILEID='+IntToStr(FILEID)+' and IFBYKT>0 order by kt_id';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin // заполняем наименования KEY_ENTRIES TDT
      pkt:= TdtIBS.FieldByName('kt_id').AsInteger;
      ii:= -1;
      for i:= Low(KeyTabs) to high(KeyTabs) do with KeyTabs[i] do
        if KtCodeTDT=pkt then begin // ищем индекс нужного элемента KeyTabs
          ii:= i;
          break;
        end;
      while not TdtIBS.Eof and (pkt=TdtIBS.FieldByName('kt_id').AsInteger) do begin
        if ii>-1 then with KeyTabs[ii] do begin
          pke:= TdtIBS.FieldByName('ke').AsInteger;
          if High(KeNamesTDT)<pke then begin
            SetLength(KeNamesTDT, pke+10);   // заполняем наименование
            SetLength(InfoCodesORD, pke+10); // готовим место для кода соответствия с ORD
          end;
          KeNamesTDT[pke]:= TdtIBS.FieldByName('ke_descr').AsString;
        end;
        TestCssStopException;
        TdtIBS.Next;
      end;
    end;
  finally
    TdtIBS.Close;
    TdtIBS.SQL.Text:= '';
  end;
end;
//------------------------------------------------------------ чистка TarKeyTabs
procedure ClearArKeyTabs(var KeyTabs: TarKeyTabs);
var i: integer;
begin
  for i:= Low(KeyTabs) to high(KeyTabs) do with KeyTabs[i] do begin
    if Assigned(InfoCodesORD) then SetLength(InfoCodesORD, 0);
    if Assigned(KeNamesTDT) then SetLength(KeNamesTDT, 0);
  end;
  SetLength(KeyTabs, 0);
end;
//---------------------------------- найти код элемента инфо-списка по кодам TDT
function GetInfoCode(ke, UserID: Integer; var KeyTab: TKeyTab): Integer;  // код KEY_ENTRIES
var kt, pType: integer;
    kName, ss: string;
begin
  Result:= 0;
  if ke<1 then exit;
  with KeyTab do begin // проверяем наличие соответствия
    if high(InfoCodesORD)<ke then
      raise Exception.Create(FieldNameTDT+' некорректное значение');
    if InfoCodesORD[ke]>0 then begin
      Result:= InfoCodesORD[ke];
      exit; // если нашли - выходим
    end;
    kName:= '';
    kt:= KtCodeTDT;
    if TypeCodeORD>0 then pType:= TypeCodeORD else pType:= 0;
    with Cache.FDCA do begin               // ищем в кеше по кодам TDT
      if TypesInfoModel.FindInfoItemByTDcodes(Result, pType, ke, kt) then begin
        InfoCodesORD[ke]:= Result; // если нашли - запоминаем коды и выходим
        if TypeCodeORD<1 then TypeCodeORD:= pType;
        exit;
      end;
      kName:= KeNamesTDT[ke]; // ищем наименование нового элемента
      if kName='' then
        raise Exception.Create(FieldNameTDT+' не найдено значение');
      // добавляем новый элемент в кеш и в базу (pType - из FindInfoItemByTDcodes)
      ss:= TypesInfoModel.AddInfoModelItem(Result, pType, ke, kt, kName, UserID);
    end; // with Cache.FDCA
    if (ss<>'') then raise Exception.Create(FieldNameTDT+' '+ss)
    else if (Result<1) then raise Exception.Create(FieldNameTDT+' ID<1');
    InfoCodesORD[ke]:= Result; // запоминаем коды
    if TypeCodeORD<1 then TypeCodeORD:= pType;
  end; // with KeyTabs[index]
end;
//--------------------------------- маркировки двигателей модели - в TStringList
procedure GetEngMarks(mt, pUserID: Integer; var lst: TStringList; var TdtIBS: TIBSQL);
var engCodes: Tai;
    i: Integer;
begin
  prClearStrListWithObj(lst);
  with TdtIBS do try
    with Transaction do if not InTransaction then StartTransaction;
    if SQL.Text='' then SQL.Text:= 'select eng_ID, eng_mark'+
      ' from link_eng_model_types left join engines on eng_ID=lemt_eng_ID'+
      ' where lemt_mt_ID=:mt order by eng_mark';
    ParamByName('mt').AsInteger:= mt;
    ExecQuery;
    while not Eof do begin
      lst.AddObject(FieldByName('eng_mark').AsString,
        TTwoCodes.Create(FieldByName('eng_ID').AsInteger, 0));
      Next;
    end;
  finally
    Close;
  end;
  if lst.Count<1 then Exit;
  try
    SetLength(engCodes, lst.Count);
    for i:= Low(engCodes) to High(engCodes) do engCodes[i]:= TTwoCodes(lst.Objects[i]).ID1;
    CheckEnginesFromTDT(engCodes, pUserID); // загрузка/проверка параметров двигателей из TDT
    for i:= Low(engCodes) to High(engCodes) do TTwoCodes(lst.Objects[i]).ID2:= engCodes[i];
  finally
    SetLength(engCodes, 0);
  end;
end;
//----------------------------------------------- запись значения в ячейку index
procedure SaveValueADO(index: Word; S: String; var ADOTable: TADOTable);
begin
  ADOTable.Edit;
  ADOTable.Fields[index].Value:= S;
  ADOTable.Post;
end;
//------------------------------------ добавление строки и запись в ячейку index
procedure AddRecordADO(S: String; var ADOTable: TADOTable; index: Word=0);
begin
  ADOTable.Append;
  ADOTable.Fields[index].Value:= S;
  ADOTable.Post;
end;

//******************************************************************************
//                        поиск данных в fb_tdt.fdb
//******************************************************************************
(*//============================================ поиск новых мод.рядов авто из TDT
function fnGetNewAutoModelLineFromTDT(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает список для выгрузки в файл CSV
const nmProc = 'fnGetNewAutoModelLineFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    mlORD, manufTD, manufORD, mlTD, i, j, tdFrom, tdTo, ordFrom, ordTo: integer;
    nameTD, s, ss: string;
    lst, lstml, lsttmp: TStringList; // lstml - not Free !!!
    TimeProc: TDateTime;
    flCodes: TBooleanDynArray;
    MFcodes: Tai;
    Manuf: TManufacturer;
begin
  Result:= TStringList.Create; // новые
  TimeProc:= Now;
  lst:= TStringList.Create;
  lsttmp:= TStringList.Create;
  TdtIBS:= nil;
  TdtIBD:= nil;
  setLength(flCodes, 100);
  setLength(MFcodes, 0); // список кодов проверенных произв.
  with Cache.FDCA do try try
    Result.Add('В базу записываются данные из столбцов без обозначения (TD).');
    s:= 'Для изменения параметров модельного ряда нужно перенести данные'+
        '  из столбцов с обозначением (TD) в соответствующие столбцы слева.';
    Result.Add(s);
    Result.Add('');
    Result.Add('Мод.ряды; авто; из TecDoc');
    Result.Add('Операция;Произв.;Код;Наимен.;От;До;Видим.;Код(TD);Наимен.(TD);От(TD);До(TD);Примечание');
    Result.Add('');

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
    TdtIBS.SQL.Text:= 'select MS_ID, MS_MF_ID, MS_DESCR, MS_FROM, MS_TO'+
      ' from MODEL_SERIES left join MANUFACTURERS on MF_ID=MS_MF_ID'+
      ' where MS_PC=1 and MS_DEL=0'+               // мод.ряды легк.авто
      ' and exists(select * from MODEL_TYPES where MT_MS_ID=MS_ID)'+ // если есть модели
      ' order by MF_DESCR, MS_MF_ID, MS_DESCR';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      manufTD:= TdtIBS.fieldByName('MS_MF_ID').AsInteger;   // код произв. TecDoc
      manufORD:= Manufacturers.GetManufIDByTDcode(manufTD); // ищем ID произв. по коду TecDoc

      if (manufORD<1) or not Manufacturers.ManufExists(manufORD)
        or not Manufacturers[manufORD].CheckIsVisible(constIsAuto) then begin // загружаем только видимых произв.
        while not TdtIBS.Eof and (TdtIBS.fieldByName('MS_MF_ID').AsInteger=manufTD) do TdtIBS.Next;
        Continue;
      end;
      prAddItemToIntArray(manufORD, MFcodes);
      Manuf:= Manufacturers[manufORD];
      lstml:= Manuf.GetModelLinesList(constIsAuto, False);

      lst.Clear;
      lst.Capacity:= lstml.Count;
      lst.Add(cDelim);

      lsttmp.Clear;
      lsttmp.Capacity:= lstml.Count+100;
      lsttmp.Add(cDelim+cDelim+cDelim);
      lsttmp.Add('Произв.:;'+IntToStr(manufORD)+';'+Manuf.Name);
      lsttmp.Add(cDelim);

      while not TdtIBS.Eof and (TdtIBS.fieldByName('MS_MF_ID').AsInteger=manufTD) do begin
        mlTD  := TdtIBS.fieldByName('MS_ID').AsInteger;    // код мод.ряда TecDoc
        nameTD:= TdtIBS.fieldByName('MS_DESCR').AsString;  // наимен. мод.ряда TecDoc
        tdFrom := TdtIBS.fieldByName('MS_FROM').AsInteger; // от
        tdTo   := TdtIBS.fieldByName('MS_TO').AsInteger;   // до
        mlORD:= Manuf.GetMfMLineIDByTDcode(mlTD); // ищем ID мод.ряда по коду TecDoc

        if mlORD<1 then  // если не нашли
          lsttmp.Add(sActionAdd+';'+IntToStr(manufORD)+';;;;;0;'+IntToStr(mlTD)+';'+
//            FormatStrForCSV(nameTD)+';'+IntToStr(tdFrom)+';'+IntToStr(tdTo)+';')
            nameTD+';'+IntToStr(tdFrom)+';'+IntToStr(tdTo)+';')

        else with ModelLines[mlORD] do begin // если нашли - проверяем
          s:= '';
          if (SubCode<>mlTD) then s:= s+'код(TD)='+IntToStr(SubCode);
          if (Name<>nameTD) then s:= s+fnIfStr(s='', '', ', ')+fnIfStr(s='', '', ', ')+'Наимен.(TD)';
          ordFrom:= YStart*100+MStart;
          ordTo  := YEnd*100+MEnd;
          if (ordFrom<>tdFrom) then s:= s+fnIfStr(s='', '', ', ')+'От(TD)';
          if (ordTo<>tdTo) then s:= s+fnIfStr(s='', '', ', ')+'До(TD)';
          if s<>'' then // если нашли отличия - пишем
            lst.Add('изменить;'+IntToStr(manufORD)+';'+IntToStr(mlORD)+';'+
//              FormatStrForCSV(Name)+';'+IntToStr(ordFrom)+';'+IntToStr(ordTo)+';'+
              Name+';'+IntToStr(ordFrom)+';'+IntToStr(ordTo)+';'+
              fnIfStr(IsVisible, '1', '0')+';'+IntToStr(mlTD)+';'+
//              FormatStrForCSV(nameTD)+';'+IntToStr(tdFrom)+';'+IntToStr(tdTo)+';'+s+';');
              nameTD+';'+IntToStr(tdFrom)+';'+IntToStr(tdTo)+';'+s+';');
          if High(flCodes)<mlORD then setLength(flCodes, mlORD+100);
          flCodes[mlORD]:= True;
        end;
        CheckStopExecute(pUserID, ThreadData);
        TdtIBS.Next;
      end;
      if lst.Count>1 then for i:= 0 to lst.Count-1 do lsttmp.Add(lst[i]); // дописываем несоответствия

      lst.Clear;
      lst.Capacity:= lstml.Count;
      lst.Add(cDelim); // проверяем ненайденные по производителю
      for i:= 0 to lstml.Count-1 do begin
        mlORD:= Integer(lstml.Objects[i]);
        if not ModelLines.ModelLineExists(mlORD) then Continue;
        with ModelLines[mlORD] do begin
          if ((length(flCodes)>mlORD) and flCodes[mlORD])
            or (ModelsCount>0) or IsVisible then Continue; // проверены или отмечены, как видимые
          ordFrom:= YStart*100+MStart;
          ordTo  := YEnd*100+MEnd;
          ss     := Name;        //            ss     := FormatStrForCSV(Name);
          lst.Add('удалить;'+IntToStr(manufORD)+';'+IntToStr(mlORD)+';'+ss+';'+
            IntToStr(ordFrom)+';'+IntToStr(ordTo)+';'+fnIfStr(IsVisible, '1', '0')+';;;;;');
        end;
      end;
      if lst.Count>1 then for i:= 0 to lst.Count-1 do lsttmp.Add(lst[i]); // дописываем ненайденные

      if lsttmp.Count>3 then begin // если по производителю что-то есть - пишем
        Result.Capacity:= Result.Capacity+lsttmp.Count;
        for i:= 0 to lsttmp.Count-1 do Result.Add(lsttmp[i]);
      end;
    end;
    TdtIBS.Close;
    Result.Add(cDelim+cDelim+cDelim+cDelim+cDelim+cDelim+cDelim);
    Result.Add('Не провереные по TecDoc произв.;');
    Result.Add(cDelim+cDelim+cDelim+cDelim+cDelim+cDelim+cDelim);
                                        // проверяем тех, кого не было в TD
    with Manufacturers.GetSortedList(constIsAuto) do for i:= 0 to Count-1 do begin
      lst.Clear;
      Manuf:= TManufacturer(Objects[i]);
      manufORD:= Manuf.ID;
      if (fnInIntArray(manufORD, MFcodes)>-1) then Continue; // уже проверили

      lsttmp.Clear;
      lsttmp:= Manuf.GetModelLinesList(constIsAuto, False);
      for j:= 0 to lsttmp.Count-1 do begin
        mlORD:= Integer(lsttmp.Objects[j]);
        with ModelLines[mlORD] do begin
          if (ModelsCount>0) or IsVisible then Continue; // имеют модели или отмечены, как видимые
          ordFrom:= YStart*100+MStart;
          ordTo  := YEnd*100+MEnd;
          ss     := Name;        //            ss     := FormatStrForCSV(Name);
          lst.Add('удалить;'+IntToStr(manufORD)+';'+IntToStr(mlORD)+';'+ss+';'+
            IntToStr(ordFrom)+';'+IntToStr(ordTo)+';'+fnIfStr(IsVisible, '1', '0')+';;;;;');
        end;
      end;
      if lst.Count<1 then Continue;

      Result.Add(cDelim+cDelim+cDelim);
      Result.Add('Произв.:;'+IntToStr(manufORD)+';'+Manuf.Name);
      Result.Add(cDelim);
      for j:= 0 to lst.Count-1 do Result.Add(lst[j]); // дописываем ненайденные
    end;
    Result.Add(cDelim);
    Result.Add('время; '+FloatToStr(RoundTo((Now-TimeProc)*60*60*24,-5))+'; сек');
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFreeIBSQL(TdtIBS);
    cntsTdt.SetFreeCnt(TdtIBD);
    prFree(lst);
    prFree(lsttmp); // lstml - not Free !!!
    setLength(flCodes, 0);
    setLength(MFcodes, 0);
  end;
end;
//======================================= поиск новых производителей авто из TDT
function fnGetNewAutoManufFromTDT(pUserID: Integer; ThreadData: TThreadData=nil): TStringList;
// возвращает список для выгрузки в файл CSV
const nmProc = 'fnGetNewAutoManufFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS, TdtIBS1: TIBSQL;
    i, manufTD, manufORD: integer;
    nameTD, ss: string;
    lst: TStringList;
    TimeProc: TDateTime;
    flCodes: TBooleanDynArray;
begin
  Result:= fnCreateStringList(False, 100);
  TimeProc:= Now;
  lst:= fnCreateStringList(False, 100);
  lst.Add(cDelim);
  TdtIBS:= nil;
  TdtIBS1:= nil;
  TdtIBD:= nil;
  setLength(flCodes, 100);
  with Cache.FDCA.Manufacturers do try try
    Result.Add('Производители; авто; из TecDoc');
    Result.Add('Операция;Код;Наимен.;Видим.;Код(TD);Наимен.(TD);Примечание');

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc);
    TdtIBS1:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS1_'+nmProc, -1, tpRead, true);
    TdtIBS.SQL.Text:= 'select mf_id, mf_short, mf_descr from manufacturers'+
      ' where mf_pc=1 and mf_del=0'+                      // произв.легк.авто
      ' and exists(select * from MODEL_SERIES'+           // если есть мод.ряды легк.авто
      ' where MS_MF_ID=mf_id and MS_PC=1 and MS_DEL=0)'+
      ' order by mf_descr';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      manufTD:= TdtIBS.fieldByName('mf_id').AsInteger;   // код TecDoc
      nameTD := TdtIBS.fieldByName('mf_descr').AsString; // наимен. TecDoc

      manufORD:= GetManufIDByTDcode(manufTD); // ищем ID по коду TecDoc
      if (manufORD<1) then  // если не нашли - ищем по наимен. TecDoc
        if not ManufExistsByName(nameTD, manufORD) then manufORD:= 0;

      if manufORD<1 then  // если никак не нашли
//          Result.Add(sActionAdd+';;;0;'+IntToStr(manufTD)+';'+FormatStrForCSV(nameTD)+';')
        Result.Add(sActionAdd+';;;0;'+IntToStr(manufTD)+';'+nameTD+';')

      else with Items[manufORD] do begin
        if not CheckIsTypeSys(constIsAuto) then // если не авто
//            Result.Add(sActionAdd+';'+IntToStr(manufORD)+';'+FormatStrForCSV(Name)+';'+
          Result.Add(sActionAdd+';'+IntToStr(manufORD)+';'+Name+';'+
            fnIfStr(CheckIsVisible(constIsAuto), '1', '0')+';'+
//              IntToStr(manufTD)+';'+FormatStrForCSV(nameTD)+';не авто')
            IntToStr(manufTD)+';'+nameTD+';не авто')
        else begin
          ss:= '';
          if (Name<>nameTD) then ss:= fnIfStr(ss='', '', ',')+'Наимен.(TD)';
          if (SubCode<>manufTD) then ss:= fnIfStr(ss='', '', ',')+'Код(TD)='+IntToStr(SubCode);
          if ss<>'' then // если нашли отличия - пишем
//              lst.Add('изменить;'+IntToStr(manufORD)+';'+FormatStrForCSV(Name)+';'+
            lst.Add('изменить;'+IntToStr(manufORD)+';'+Name+';'+
              fnIfStr(CheckIsVisible(constIsAuto), '1', '0')+';'+
//                IntToStr(manufTD)+';'+FormatStrForCSV(nameTD)+';'+ss);
              IntToStr(manufTD)+';'+nameTD+';'+ss);
        end;
        if High(flCodes)<manufORD then setLength(flCodes, manufORD+100);
        flCodes[manufORD]:= True;
      end;
      CheckStopExecute(pUserID, ThreadData);
      TdtIBS.Next;
    end;
    TdtIBS.Close;

    if Result.Count>2 then Result.Insert(2, cDelim);
    if lst.Count>1 then for i:= 0 to lst.Count-1 do Result.Add(lst[i]); // дописываем изменения

    lst.Clear;
    lst.Capacity:= 100;
    lst.Add(cDelim);
    TdtIBS.SQL.Text:= 'select mf_short, mf_descr from manufacturers where mf_id=:manufTD';
    TdtIBS1.SQL.Text:= 'select mf_id from manufacturers where mf_descr=:nameTD';
    with GetNotTestedList(constIsAuto, flCodes) do try  // ???
      for i:= 0 to Count-1 do begin
        manufORD:= Integer(Objects[i]);
        if not Items[manufORD].CheckIsVisible(constIsAuto) then Continue;
        manufTD:= Items[manufORD].SubCode;
        nameTD:= '';
        if manufTD>0 then begin
          TdtIBS.ParamByName('manufTD').AsInteger:= manufTD;
          TdtIBS.ExecQuery;
          if not (TdtIBS.Eof and TdtIBS.Bof) then
            nameTD:= TdtIBS.fieldByName('mf_descr').AsString; // наимен. TecDoc
          TdtIBS.Close;
        end else begin
          TdtIBS1.ParamByName('nameTD').AsString:= Strings[i];
          TdtIBS1.ExecQuery;
          if not (TdtIBS1.Eof and TdtIBS1.Bof) then begin
            manufTD:= TdtIBS1.fieldByName('mf_id').AsInteger; // код TecDoc
            nameTD:= Strings[i];
          end;
          TdtIBS1.Close;
        end;
//            lst.Add('удалить;'+IntToStr(manufORD)+';'+FormatStrForCSV(Strings[i])+';'+
        lst.Add('удалить;'+IntToStr(manufORD)+';'+Strings[i]+';'+
          fnIfStr(Items[manufORD].CheckIsVisible(constIsAuto), '1', '0')+';'+
//              fnIfStr(manufTD<1, '', IntToStr(manufTD))+';'+FormatStrForCSV(nameTD)+';');
          fnIfStr(manufTD<1, '', IntToStr(manufTD))+';'+nameTD+';');
      end; // for
    finally Free; end;
    if lst.Count>1 then for i:= 0 to lst.Count-1 do Result.Add(lst[i]); // дописываем ненайденных
    Result.Add(cDelim);
    Result.Add('время; '+FloatToStr(RoundTo((Now-TimeProc)*60*60*24,-5))+'; сек');
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA.Manufacturers
  finally
    prFreeIBSQL(TdtIBS);
    prFreeIBSQL(TdtIBS1);
    cntsTdt.SetFreeCnt(TdtIBD);
    prFree(lst);
    setLength(flCodes, 0);
  end;
end;
//============================================== поиск новых моделей авто из TDT
function fnGetNewAutoModelFromTDT(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает список для выгрузки в файл XML
const nmProc = 'fnGetNewAutoModelFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    manufTD, manufORD, mlTD, mlORD, modTD, modORD, i, ii, j, tdFrom, tdTo: integer;
    nameTD, s, ss, marksTD, marksORD: string;
    lst, lstmf, lstml, lstm: TStringList; // lstm - not Free !!!
    mps: TModelParams;
    TimeProc: TDateTime;
    flUpd, fl: Boolean;
    arMpsORD, arMpsTDT: TarMps;
    flCodes: TBooleanDynArray;
  //---------------------------------------------
  function GetTDCodeInfo(index: Integer): Integer;
  begin
    Result:= 0;
    j:= arMpsOrd[index];
    if j<1 then exit;
    with Cache.FDCA do Result:= TTypeInfoModel(TypesInfoModel[j]).TDcode;
  end;
  //---------------------------------------------
  procedure AddStr(s: string);
  begin
    if Result.Capacity=Result.Count then Result.Capacity:= Result.Capacity+1000;
    AddXmlLine(Result, s);
  end;
  //----------------------------------------------
begin
  Result:= TStringList.Create; // новые
  TimeProc:= Now;
  lst:= TStringList.Create;
  lstmf:= TStringList.Create;
  lstml:= TStringList.Create;
  mps:= TModelParams.Create;
  TdtIBS:= nil;
  TdtIBD:= nil;
  setLength(flCodes, 100);
  CheckStyle(skTxt);
  CheckStyle(skHead);
  CheckStyle(skBold);
  with Cache.FDCA do try try
    AddXmlBookBegin(Result);
    AddXmlSheetBegin(Result, 'описание', 1);
    AddXmlLine(Result, sBoldCell('Новые модели или отличия моделей легков. авто из TecDoc'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' На листе "Модели" содержится перечень моделей с разбивкой по производителям и модельным рядам.'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' В строке с параметрами новой модели, проставлена опция "добавить".'));
    AddStr(sTxtCell(' В строке с параметрами модели, имеющей отличия от параметров TecDoc,'));
    AddStr(sTxtCell('   проставлена опция "изменить", в строке под ней с опцией "в TDT" приведены отличия.'));
    AddStr(sTxtCell(' В строке с параметрами модели, не найденной в TecDoc, проставлена опция "удалить".'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' В строках моделей, которые не требуют обработки, нужно удалить опцию.'));
    AddStr(sTxtCell(' В строке с параметрами модели, имеющей опцию "изменить",'));
    AddStr(sTxtCell('   следует вставить параметры из строки с опцией "в TDT"'));
    AddStr(sTxtCell(' При импорте обрабатываются только строки с опциями "добавить", "изменить", "удалить".'));
    AddStr(sTxtCell(' Параметры модели записываются в базу из файла.'));
    AddStr(sTxtCell(' Результат обработки строки записывается в столбец "Рез.имп.".'));
    AddStr(sTxtCell(' Результат обработки файла записывается в 1-й столбец внизу листа "Модели".'));
    AddXmlSheetEnd(Result, 0, 0);

    AddXmlSheetBegin(Result, ModelSheetName, 27);

    s:= sHeadCell('Операция')+sHeadCell('Произв.')+sHeadCell('М/ряд')+sHeadCell('Код')+
        sHeadCell('Видим.')+sHeadCell('Код(TD)')+sHeadCell('Наимен.')+sHeadCell('Марк/двиг');
    for i:= 0 to High(arMpsTitles) do s:= s+sHeadCell(arMpsTitles[i]);
    s:= s+sHeadCell('Прим.')+sHeadCell('Рез.имп.');
    AddXmlLine(Result, s);
    AddXmlLine(Result, sBoldCell('Новые модели или отличия моделей легков. авто из TecDoc'));

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
    TdtIBS.SQL.Text:= 'select MS_MF_ID, MT_MS_ID, MT_ID, MT_DESCR,'+
      ' MT_FROM, MT_TO, MT_KW, MT_HP, MT_CC_TEC, MT_CYL, MT_VLV,'+
      ' (select key_to from get_key_code (120, MT_BT, "MT_BT")) MT_BT,'+    // Тип кузова
      ' (select key_to from get_key_code (120, MT_DR, "MT_DR")) MT_DR,'+    // Тип привода
      ' (select key_to from get_key_code (120, MT_ENG, "MT_ENG")) MT_ENG,'+ // Тип двигателя
      ' (select key_to from get_key_code (120, MT_FT, "MT_FT")) MT_FT,'+    // Тип топлива
      ' (select key_to from get_key_code (120, MT_FF, "MT_FF")) MT_FF,'+    // Система впрыска
      ' (select key_to from get_key_code (120, MT_BRT, "MT_BRT")) MT_BRT,'+ // Тип тормозной системы
      ' (select key_to from get_key_code (120, MT_BRS, "MT_BRS")) MT_BRS,'+ // Тормозная система
      ' (select key_to from get_key_code (120, MT_CT, "MT_CT")) MT_CT,'+    // Тип катализатора
      ' (select key_to from get_key_code (120, MT_TT, "MT_TT")) MT_TT,'+    // Вид коробки передач
      ' (select marks from get_str_eng_marks ( MT_ID )) marks'+             // Марк/двиг модели TecDoc
      ' from MODEL_TYPES inner join MODEL_SERIES on MS_ID=MT_MS_ID and MS_PC=1'+ // мод.ряды легк.авто
      ' where MT_DEL=0'+
      ' order by MS_MF_DESCR, MS_MF_ID, MT_MS_DESCR, MT_MS_ID, MT_DESCR, MT_FROM';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      manufTD:= TdtIBS.fieldByName('MS_MF_ID').AsInteger;   // код произв. TecDoc
      manufORD:= Manufacturers.GetManufIDByTDcode(manufTD); // ищем ID произв. по коду TecDoc
      if (manufORD<1) or not Manufacturers.ManufExists(manufORD)
        or not Manufacturers[manufORD].CheckIsVisible(constIsAuto) then begin // загружаем только видимых произв.
        while not TdtIBS.Eof and (TdtIBS.fieldByName('MS_MF_ID').AsInteger=manufTD) do TdtIBS.Next;
        Continue;
      end;

      lstmf.Clear;  // список по произв.
      lstmf.Capacity:= 5;
      while not TdtIBS.Eof and (TdtIBS.fieldByName('MS_MF_ID').AsInteger=manufTD) do begin
        mlTD:= TdtIBS.fieldByName('MT_MS_ID').AsInteger;       // код мод.ряда TecDoc
        mlORD:= Manufacturers[manufORD].GetMfMLineIDByTDcode(mlTD); // ищем ID мод.ряда по коду TecDoc
        if (mlORD<1) or not ModelLines.ModelLineExists(mlORD)
          or not ModelLines[mlORD].IsVisible then begin // загружаем только видимые мод.ряды
          while not TdtIBS.Eof and (TdtIBS.fieldByName('MT_MS_ID').AsInteger=mlTD) do TdtIBS.Next;
          Continue;
        end;
        with ModelLines[mlORD] do lstm:= GetListModels; // список моделей мод.ряда
        lstml.Clear;  // список новых моделей по мод.ряду
        lstml.Capacity:= lstm.Count+100;

        lst.Clear; // список отличий моделей по мод.ряду
        lst.Capacity:= lstm.Count;

        while not TdtIBS.Eof and (TdtIBS.fieldByName('MT_MS_ID').AsInteger=mlTD) do begin
          tdTo:= TdtIBS.fieldByName('MT_TO').AsInteger;   // до

          if (tdTo>0) and (tdTo<198001) then begin // загружаем только с датой окончания от 1980 г
            TdtIBS.Next;
            Continue;
          end;

          modTD  := TdtIBS.fieldByName('MT_ID').AsInteger;    // код модели TecDoc
          nameTD := TdtIBS.fieldByName('MT_DESCR').AsString;  // наимен. модели TecDoc
          marksTD:= TdtIBS.fieldByName('marks').AsString;    // Марк/двиг модели TecDoc
          tdFrom := TdtIBS.fieldByName('MT_FROM').AsInteger; // от
          if tdFrom>0 then arMpsTDT[1]:= tdFrom div 100 else arMpsTDT[1]:= 0;      // Год начала выпуска
          if arMpsTDT[1]>0 then arMpsTDT[0]:= tdFrom mod 100 else arMpsTDT[0]:= 0; // Месяц начала выпуска
          if tdTo>0 then arMpsTDT[3]:= tdTo div 100 else arMpsTDT[3]:= 0;          // Год конца выпуска
          if arMpsTDT[3]>0 then arMpsTDT[2]:= tdTo mod 100 else arMpsTDT[2]:= 0;   // Месяц конца выпуска
          arMpsTDT[4] := TdtIBS.FieldByName('MT_KW').AsInteger;     // Мошность кВт.
          arMpsTDT[5] := TdtIBS.FieldByName('MT_HP').AsInteger;     // Мощность ЛС
          arMpsTDT[6] := TdtIBS.FieldByName('MT_CC_TEC').AsInteger; // Тех. объем куб. см.
          arMpsTDT[7] := TdtIBS.FieldByName('MT_CYL').AsInteger;    // Кол. цилиндров
          arMpsTDT[8] := TdtIBS.FieldByName('MT_VLV').AsInteger;    // Кол. клапанов на одну камеру сгорания
          arMpsTDT[9] := TdtIBS.FieldByName('MT_BT').AsInteger;     // Тип кузова
          arMpsTDT[10]:= TdtIBS.FieldByName('MT_DR').AsInteger;     // Тип привода
          arMpsTDT[11]:= TdtIBS.FieldByName('MT_ENG').AsInteger;    // Тип двигателя
          arMpsTDT[12]:= TdtIBS.FieldByName('MT_FT').AsInteger;     // Тип топлива
          arMpsTDT[13]:= TdtIBS.FieldByName('MT_FF').AsInteger;     // Система впрыска
          arMpsTDT[14]:= TdtIBS.FieldByName('MT_BRT').AsInteger;    // Тип тормозной системы
          arMpsTDT[15]:= TdtIBS.FieldByName('MT_BRS').AsInteger;    // Тормозная система
          arMpsTDT[16]:= TdtIBS.FieldByName('MT_CT').AsInteger;     // Тип катализатора
          arMpsTDT[17]:= TdtIBS.FieldByName('MT_TT').AsInteger;     // Вид коробки передач
          modORD:= ModelLines[mlORD].GetMLModelIDByTDcode(modTD); // ищем ID модели по коду TecDoc

          if modORD<1 then begin // если не нашли

            s:= sTxtCell(sActionAdd)+sIntCell(manufORD)+
              sIntCell(mlORD)+sIntCell(0)+sIntCell(1)+sIntCell(modTD)+sTxtCell(nameTD)+sTxtCell(marksTD);
            for i:= 0 to high(arMpsTDT) do s:= s+sIntCell(arMpsTDT[i]);
            s:= s+sTxtCell('')+sTxtCell('');
            lstml.Add(s);

          end else with Models[modORD] do begin // если нашли - проверяем
            arMpsORD:= MakeArrayFromMps(Params);
            marksORD:= StringReplace(MarksCommaText, ', ', ',', [rfReplaceAll]); // Марк/двиг модели

            flUpd:= (Name<>nameTD) or (marksTD<>marksORD); // проверяем наимен. и Марк/двиг
            ss:= sTxtCell('   в TDT')+sTxtCell('')+sTxtCell('')+sTxtCell('')+
                 sTxtCell('')+sTxtCell('')+sTxtCell(fnIfStr((Name<>nameTD), nameTD, ''))+
                 sTxtCell(fnIfStr((marksTD<>marksORD), marksTD, ''));

            for i:= 0 to icModMpsV do begin
              fl:= (arMpsTDT[i]<>arMpsORD[i]); // в числовых полях сравниваем значения
              flUpd:= flUpd or fl;
              ss:= ss+fnIfStr(fl, sIntCell(arMpsTDT[i]), sTxtCell(''));
            end;
            for i:= icModMpsV+1 to High(arMpsTDT) do begin
              fl:= (arMpsTDT[i]<>GetTDCodeInfo(i)); // в ссылочных полях сравниваем коды TD !!!
              flUpd:= flUpd or fl;
              ss:= ss+fnIfStr(fl, sIntCell(arMpsTDT[i]), sTxtCell(''));
            end;
            ss:= ss+sTxtCell('')+sTxtCell('');

            if flUpd then begin // если нашли отличия - пишем
              lst.Add('');
              s:= sTxtCell(sActionUpd)+sIntCell(manufORD)+sIntCell(mlORD)+
                  sIntCell(modORD)+sIntCell(fnIfInt(IsVisible, 1, 0))+
                  sIntCell(SubCode)+sTxtCell(Name)+sTxtCell(marksORD);
              for i:= 0 to icModMpsV do s:= s+sIntCell(arMpsORD[i]); // в числовых полях выводим значения
              for i:= icModMpsV+1 to high(arMpsORD) do  // в ссылочных полях выводим коды TD !!!
                s:= s+sIntCell(GetTDCodeInfo(i));
              s:= s+sTxtCell('')+sTxtCell('');

              lst.Add(s);
              lst.Add(ss); // во 2-й строке - только отличия !!!
            end; // if flUpd
            if High(flCodes)<modORD then setLength(flCodes, modORD+100);
            flCodes[modORD]:= True;
          end;
          CheckStopExecute(pUserID, ThreadData);
          TdtIBS.Next;
        end;  // цикл по мод.ряду mlTD
        if lst.Count>0 then
          for i:= 0 to lst.Count-1 do lstml.Add(lst[i]); // в список по мод.ряду дописываем несоответствия

        lst.Clear;
        lst.Capacity:= lstm.Count;
        for i:= 0 to lstm.Count-1 do begin // проверяем ненайденные по мод.ряду
          modORD:= Integer(lstm.Objects[i]);
          if Models.ModelExists(modORD) then with Models[modORD] do
            if not ((length(flCodes)>modORD) and flCodes[modORD]) then begin
              marksORD:= StringReplace(MarksCommaText, ', ', ',', [rfReplaceAll]); // Марк/двиг модели
              s:= sTxtCell(sActionDel)+sIntCell(manufORD)+sIntCell(mlORD)+
                  sIntCell(modORD)+sIntCell(fnIfInt(IsVisible, 1, 0))+
                  sIntCell(SubCode)+sTxtCell(Name)+sTxtCell(marksORD);

              for ii:= 0 to high(arMpsORD) do s:= s+sIntCell(arMpsORD[ii]);
              s:= s+sTxtCell('')+sTxtCell('');
              lst.Add(s);
            end;
        end;
        if lst.Count>1 then begin
          lstml.Add('');
          for i:= 0 to lst.Count-1 do lstml.Add(lst[i]); // в список по мод.ряду дописываем ненайденные
        end;

        if lstml.Count>0 then begin // если по мод.ряду что-то есть - пишем в список по произв.
          lstmf.Capacity:= lstmf.Capacity+lstml.Count+10;
          lstmf.Add('');
          with ModelLines[mlORD] do
            lstmf.Add(sTxtCell('')+sTxtCell('')+sIntCell(mlORD)+sTxtCell('')+
              sTxtCell('')+sTxtCell('')+sBoldCell('Мод.ряд: '+Name+' ('+IntToStr(MStart)+
              '/'+IntToStr(YStart)+' - '+IntToStr(MEnd)+'/'+IntToStr(YEnd)+')'));
          for i:= 0 to lstml.Count-1 do lstmf.Add(lstml[i]);
        end;
      end; // цикл по произв. manufTD

      if lstmf.Count>0 then begin // если по производителю что-то есть - пишем в общий список
        Result.Capacity:= Result.Capacity+lstmf.Count+5;
        AddXmlLine(Result, '');
        AddXmlLine(Result, sTxtCell('')+sIntCell(manufORD)+sTxtCell('')+
          sTxtCell('')+sTxtCell('')+sTxtCell('')+sBoldCell('Произв.: '+Manufacturers[manufORD].Name));
        for i:= 0 to lstmf.Count-1 do AddXmlLine(Result, lstmf[i]);
      end;
    end;
    AddXmlLine(Result, '');
    AddXmlLine(Result, sTxtCell('время:      '+GetLogTimeStr(TimeProc)));
    AddXmlSheetEnd(Result, 1, 1);
    AddXmlBookEnd(Result);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFreeIBSQL(TdtIBS);
    cntsTdt.SetFreeCnt(TdtIBD);
    prFree(lst);
    prFree(lstmf);
    prFree(lstml);
    prFree(mps);
    setLength(flCodes, 0);
  end;
end; *)
//====================================== поиск оригинальных номеров товара в TDT
function fnGetWareONumsFromTDT(pWareID: Integer; pArtSupTD: Integer=0; pArticleTD: String=''): TarWareOnumOpts;
// возвращает массив - OE + если произв.найден - MFAUCODE и MFAUNAME,
// если нет - код=0 и наименование TecDoc
// Exception передает вызывающей процедуре
const nmProc = 'fnGetWareONumsFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    mfTD, j, i: integer;
    mfName: string;
    fl: Boolean;
    arMFORD: Tai;
begin
  setLength(Result, 10);
  setLength(arMFORD, 0);
  TdtIBS:= nil;
  TdtIBD:= nil;
  with Cache.FDCA do try try
    if (pArtSupTD=0) or (pArticleTD='') then with Cache.GetWare(pWareID) do
      if (ArticleTD='') or (ArtSupTD<1) then
        raise EBOBError.Create(MessText(mtkNotEnoughParams))
      else begin
        pArtSupTD:= ArtSupTD;
        pArticleTD:= ArticleTD;
      end;
    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
    TdtIBS.SQL.Text:= 'select RN_MF_ID mfID, RN_REF_NR Onum,'+
      ' iif(ICN_NEWDESCR is null, mf_descr, ICN_NEWDESCR) mfName'+
      ' from REF_NUMBERS left join data_suppliers on RN_SUP_ID = DS_ID'+
      ' left join manufacturers on mf_id = RN_MF_ID'+
      ' left join IMPORT_CHANGE_NAMES on ICN_TAB_ID = 100 and ICN_KE_KEY = mf_id'+
      ' where RN_ART_NR = "'+pArticleTD+'" and ds_mf_id = '+IntToStr(pArtSupTD)+
      ' and mf_pc=1 and mf_del=0 order by mfName, mfID, Onum'; // только произв.легк.авто
    TdtIBS.ExecQuery;
    j:= 0; // счетчик
    while not TdtIBS.Eof do begin
      mfTD  := TdtIBS.fieldByName('mfID').AsInteger;   // код произв.TecDoc
      mfName:= TdtIBS.fieldByName('mfName').AsString;  // наимен. произв.TecDoc
      case mfTD of // раскидываем ОН "составных" произв.
       248: begin // AUSTIN/MG
              setLength(arMFORD, 2); // задаем длину
              arMFORD[0]:= 505; // AUSTIN
              arMFORD[1]:= 554; // MG
            end;
       249: begin // ROVER/AUSTIN
              setLength(arMFORD, 2); // задаем длину
              arMFORD[0]:= 505; // AUSTIN
              arMFORD[1]:= 568; // ROVER
            end;
       250: begin // ROVER/TRIUMPH/AUSTIN
              setLength(arMFORD, 3); // задаем длину
              arMFORD[0]:= 505; // AUSTIN
              arMFORD[1]:= 568; // ROVER
              arMFORD[2]:= 580; // TRIUMPH
            end;
       251: begin // ROV/TRIU/JAGU/AUSTIN
              setLength(arMFORD, 4); // задаем длину
              arMFORD[0]:= 505; // AUSTIN
              arMFORD[1]:= 540; // JAGUAR
              arMFORD[2]:= 568; // ROVER
              arMFORD[3]:= 580; // TRIUMPH
            end;
       252: begin // ROV/TRI/JAG/AUS/MG
              setLength(arMFORD, 5); // задаем длину
              arMFORD[0]:= 505; // AUSTIN
              arMFORD[1]:= 540; // JAGUAR
              arMFORD[2]:= 554; // MG
              arMFORD[3]:= 568; // ROVER
              arMFORD[4]:= 580; // TRIUMPH
            end;
       253: begin // VAG
              setLength(arMFORD, 4); // задаем длину
              arMFORD[0]:=   5; // AUDI
              arMFORD[1]:= 106; // SKODA
              arMFORD[2]:= 573; // SEAT
              arMFORD[3]:= 587; // VW
            end;
       254: begin // FIAT / LANCIA
              setLength(arMFORD, 2); // задаем длину
              arMFORD[0]:= 524; // FIAT
              arMFORD[1]:= 546; // LANCIA
            end;
       255: begin // ALFAROME/FIAT/LANCI
              setLength(arMFORD, 3); // задаем длину
              arMFORD[0]:= 502; // ALFA ROMEO
              arMFORD[1]:= 524; // FIAT
              arMFORD[2]:= 546; // LANCIA
            end;
       804: begin // CITROEN/PEUGEOT
              setLength(arMFORD, 2); // задаем длину
              arMFORD[0]:= 514; // CITROEN
              arMFORD[1]:= 563; // PEUGEOT
            end;
       805: begin // VW/SEAT
              setLength(arMFORD, 2); // задаем длину
              arMFORD[0]:= 573; // SEAT
              arMFORD[1]:= 587; // VW
            end;
        else begin
          setLength(arMFORD, 1); // задаем длину
          arMFORD[0]:= Manufacturers.GetManufIDByTDcode(mfTD); // ищем ID произв. по коду TecDoc
        end;
      end; // case

      while not TdtIBS.Eof and (TdtIBS.fieldByName('mfID').AsInteger=mfTD) do begin
        for i:= 0 to High(arMFORD) do begin
          fl:= (arMFORD[i]>0) and Manufacturers.ManufExists(arMFORD[i]);
          if High(Result)<j then setLength(Result, j+10);
          Result[j].ONum:= TdtIBS.fieldByName('Onum').AsString;
          if fl then begin
            Result[j].mfau  := arMFORD[i];
            Result[j].mfName:= Manufacturers[arMFORD[i]].Name;
          end else begin
            Result[j].mfau  := 0;
            Result[j].mfName:= mfName;
          end;
          inc(j);
        end; // for
        TestCssStopException;
        TdtIBS.Next;
      end; // цикл по произв. mfTD
    end;
    if Length(Result)>j then setLength(Result, j);
  except
    on E: Exception do begin
      setLength(Result, 0);
      raise Exception.Create(nmProc+'(WareID='+IntToStr(pWareID)+'): '+E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFreeIBSQL(TdtIBS);
    cntsTdt.SetFreeCnt(TdtIBD);
    setLength(arMFORD, 0);
  end;
end;
//=============================================== сортировка TList бренд + товар
function WareListSortCompare(Item1, Item2: Pointer): Integer;
var w1, w2: TWareInfo;
    s1, s2: String;
begin
  try
    w1:= TWareInfo(Item1);
    w2:= TWareInfo(Item2);
    if w1.WareBrandID<>w2.WareBrandID then begin
      if w1.WareBrandName='' then s1:= 'Не определен' else s1:= w1.WareBrandName;
      if w2.WareBrandName='' then s2:= 'Не определен' else s2:= w2.WareBrandName;
      if s1<>s2 then Result:= AnsiCompareText(s1, s2)
      else if w1.ArtSupTD>w2.ArtSupTD then Result:= 1
      else if w1.ArtSupTD<w2.ArtSupTD then Result:= -1 else Result:= 0;
    end else Result:= AnsiCompareText(w1.Name, w2.Name)
  except
    Result:= 0;
  end;
end;
//===================== 40-stamp - Отчет о проверке привязок товаров к артикулам
function fnGetCheckWareTDTArticles(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
const nmProc = 'fnGetCheckWareTDTArticles'; // имя процедуры/функции
      xChars = 'ABCDEFGHIJKLMNOPQRSTUVWYYZ';
// возвращает список для выгрузки в файл XML
type Rflags = record
    flONs, flAnals, flLinks, flCris: Integer;
  end;
var IBD: TIBDatabase;
    IBS: TIBSQL;
    Widths: Tai;
    Ncolumns, iposWW, iRows, i, WareID, supMF, j, PercentStep, k, ii: integer;
    Percent: real;
    lst1, lst2, lst3, lst4: TStringList;
    lstWares: TList;
    str, sm, sbt, sbg, stw, Art, sEnd1, sEnd2, sTitle, s, ss, sEmpty, wSearch, sGa: String;
    ware: TWareInfo;
    arWareFlags: array of Rflags;
    arTDBrands: Tas;
    flSleep: Boolean;
  //----------------------------------------------
  procedure AddStrWW(s: string);
  begin
    AddXmlLineWW(Result, s, 100);
  end;
  //----------------------------------------------
  procedure CheckStep;
  begin
    CheckStopExecute(pUserID, ThreadData);
    if j>PercentStep then begin
      SetExecutePercent(pUserID, ThreadData, Percent);
      j:= 0;
    end;
  end;
  //----------------------------------------------
begin
  Result:= fnCreateStringList(False, 100);
//  IBD:= nil;
  IBS:= nil;
  lst1:= fnCreateStringList(False, 100);
  lst2:= fnCreateStringList(False, 100);
  lst3:= fnCreateStringList(False, 100);
  lst4:= fnCreateStringList(False, 100);
  lstWares:= TList.Create;
  lstWares.Capacity:= 100000;
  Setlength(arTDBrands, 0);
  SetLength(arWareFlags, 0);
  Ncolumns:= 13;        // кол-во столбцов
  SetLength(Widths, Ncolumns); // задаем ширину столбцов, 0 - AutoFitWidth
  Widths[0]:= 150;  // Товар GrossBee
  Widths[1]:= 90;   // Бренд ТесDoc
  Widths[2]:= 100;  // Артикул TecDoc
  Widths[3]:= 42;   // Статус привязки
  Widths[4]:= 90;   // Менеджер
  Widths[5]:= 40;   // ОН TecDoc
  Widths[6]:= 40;   // Анал.TecDoc
  Widths[7]:= 40;   // Связ.TecDoc
  Widths[8]:= 40;   // Парам.TecDoc
  Widths[9]:= 90;   // Бренд GrossBee
  Widths[10]:= 0;   // Код товара
  Widths[11]:= 180; // Комментарий
  Widths[12]:= 0;   // SupMF TecDoc
  CheckStyle(skHeadBlue);     // задаем нужные стили
  CheckStyle(skTxtWW);
  CheckStyle(skTxtGreenWW);
  CheckStyle(skTxtYellowWW);
  CheckStyle(skTxtRoseWW);
  CheckStyle(skTxtBlueWW);
  Percent:= 0.5;
  PercentStep:= 100;
  flSleep:= not flDebug and (SleepFillLinksInt>0) and not fnGetActionTimeEnable(caeSmallWork);
  with Cache do try try
    SetLength(arWareFlags, Length(arWareInfo)); // составляем список привязанных товаров
    for WareID:= 1 to High(arWareInfo) do if WareExist(WareID) then begin
      ware:= GetWare(WareID);
      if (ware.ArticleTD='') or (ware.ArtSupTD<1) then Continue;
      lstWares.Add(Ware);
      with arWareFlags[WareID] do begin
        flONs  := 0;
        flAnals:= 0;
        flLinks:= 0;
        flCris := 0;
      end;
      CheckStopExecute(pUserID, ThreadData);
    end;
    lstWares.Sort(WareListSortCompare); // сортируем - бренд + товар

    for i:= 0 to BrandTDList.Count-1 do begin // наименования брендов TD
      k:= Integer(BrandTDList.Objects[i]);
      if High(arTDBrands)<k then begin
        j:= length(arTDBrands);
        Setlength(arTDBrands, k+100);
        for WareID:= j to High(arTDBrands) do arTDBrands[WareID]:= '';
      end;
      arTDBrands[k]:= BrandTDList[i];
    end;
    SetExecutePercent(pUserID, ThreadData, Percent);

    Percent:= 1.5;
    IBD:= cntsORD.GetFreeCnt;       // флаги наличия связок TecDoc товаров в ORD
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, -1, tpRead, True);
      IBS.SQL.Text:= 'select rWare, flONs, flAnals, flLinks, flCris from GetWaresHasTDinfo';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        WareID:= IBS.FieldByName('rWare').AsInteger;
        if WareExist(WareID) and (WareID<Length(arWareFlags)) then with arWareFlags[WareID] do begin
          flONs  := IBS.FieldByName('flONs').AsInteger;
          flLinks:= IBS.FieldByName('flLinks').AsInteger;
          flCris := IBS.FieldByName('flCris').AsInteger;
        end;
        IBS.Next;
      end;
      IBS.Close;
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD, True);
    end;
    SetExecutePercent(pUserID, ThreadData, Percent);

    IBD:= cntsGRB.GetFreeCnt; // флаги наличия аналогов TecDoc товаров в Grossbee
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      s:= 'AnDtSyncCode-'+Cache.GetConstItem(pcCrossAnalogsDeltaSync).StrValue+
           ') in ('+IntToStr(soTecDocBatch)+', '+IntToStr(soTDsupersed)+'))';

      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, -1, tpRead, True);
      IBS.SQL.Text:= 'select WareCode from wares w'+
        ' where (exists(select * from pmwareanalogs a1'+ // w.warearchive="F" and
        '  left join AnalitDict d1 on d1.andtcode = a1.pmwasourcecode'+
        ' where a1.pmwawarecode=w.WareCode and (d1.'+s+
        ' or exists(select * from pmwareanalogs a2'+
        '  left join AnalitDict d2 on d2.andtcode = a2.pmwasourcecode'+
        ' where a2.pmwawareanalogcode=w.WareCode and (d2.'+s+') order by WareCode';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        WareID:= IBS.FieldByName('WareCode').AsInteger;
        if (WareID>0) and WareExist(WareID) and (WareID<Length(arWareFlags)) then
          arWareFlags[WareID].flAnals:= 1;
        IBS.Next;
      end;
      IBS.Close;
    finally
      prFreeIBSQL(IBS);
      cntsGRB.SetFreeCnt(IBD, True);
    end;
    SetExecutePercent(pUserID, ThreadData, Percent);

    IBD:= cntsTDT.GetFreeCnt;
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS_'+nmProc, -1, tpRead, True);
      IBS.SQL.Text:= 'select flag, SupMF_find, art_find, trade_find, GaName'+
                        ' from SearchWareArticles(:Sup, :Art, :Wname)';
      IBS.Prepare;
      sEmpty:= sTxtWWCell('');
      sEnd2:= sEmpty+sEmpty+sEmpty+sEmpty+sEmpty+sEmpty+sEmpty+sEmpty; // для строк без товара
      if lstWares.Count>0 then Percent:= 90*PercentStep/lstWares.Count else Percent:= 1;
      j:= 0; // счетчик для процентов
      for k:= 0 to lstWares.Count-1 do begin
        ware:= lstWares[k];
        WareID:= Ware.ID;
        inc(j);
        i:= Ware.ManagerID;
        if (i<1) or not EmplExist(i) or CheckEmplIsFictive(i) then // Менеджер
          sm:= 'Не определен'
        else sm:= arEmplInfo[i].EmplShortName;
        sbg:= ware.WareBrandName;                          // Бренд GrossBee
        if sbg='' then sbg:= 'Не определен';
        i:= ware.ArtSupTD;
        ss:= IntToStr(i);
        if (i>High(arTDBrands)) or (arTDBrands[i]='') then // Бренд ТесDoc
          sbt:= 'Не определен'
        else sbt:= arTDBrands[i];
        with arWareFlags[WareID] do begin // Наличие связок TecDoc
          if flONs=1 then str:= sTxtGreenCellWW('1') else str:= sEmpty;
          if flAnals=1 then str:= str+sTxtGreenCellWW('1') else str:= str+sEmpty;
          if flLinks=1 then str:= str+sTxtGreenCellWW('1') else str:= str+sEmpty;
          if flCris=1 then str:= str+sTxtGreenCellWW('1') else str:= str+sEmpty;
        end;
        stw:= ware.TypeName;
        if stw<>'' then stw:= sTxtGreenCellWW('GR-тип: '+stw) else stw:= sEmpty;
        sEnd1:= sTxtWWCell(sm)+str+sTxtWWCell(sbg)+sTxtWWCell(IntToStr(WareID))+stw+sTxtWWCell(ss);

        if (sbt='Не определен') then begin // Бренд ТесDoc
          str:= sTxtGreenCellWW(ware.Name)+sTxtYellowCellWW(sbt)+       //  Товар GrossBee, Бренд ТесDoc
                sTxtYellowCellWW(ware.ArticleTD)+sTxtYellowCellWW('1')+sEnd1; // Артикул TecDoc, Статус привязки
          lst4.Add(str); // 4-й лист - артикул не нашли - не определен (старый) Бренд ТесDoc
          CheckStep;
          if flSleep then sleep(SleepFillLinksInt);
          Continue;
        end;

        wSearch:= trim(ware.Name);
        if (pos(wSearch[1], xChars)>0) then begin // если 1-й символ-буква
          i:= pos(' ', wSearch); // обрезаем приставку до 1-го пробела
          if (i>0) then wSearch:= copy(wSearch, i+1);
        end;
        i:= pos('     ', wSearch); // обрезаем наименование справа от 5-ти пробелов
        if (i>0) then wSearch:= copy(wSearch, 1, i-1);

        try
          IBS.ParamByName('Sup').AsInteger:= ware.ArtSupTD;
          IBS.ParamByName('Art').AsString:= ware.ArticleTD;
          IBS.ParamByName('Wname').AsString:= wSearch;
          IBS.ExecQuery;
          while not IBS.Eof do begin
            i:= IBS.FieldByName('flag').AsInteger;
            Art:= IBS.FieldByName('art_find').AsString;
            SupMF:= IBS.FieldByName('SupMF_find').AsInteger;
            ss:= IBS.FieldByName('trade_find').AsString;
            sGa:= IBS.FieldByName('GaName').AsString;
// за 1 проход фасуем в списки по листам
            if (i=999) then begin // 1-й лист
              str:= sTxtGreenCellWW(ware.Name)+sTxtYellowCellWW(sbt)+       //  Товар GrossBee, Бренд ТесDoc
                    sTxtYellowCellWW(ware.ArticleTD)+sTxtYellowCellWW('1')+sEnd1; // Артикул TecDoc, Статус привязки
              lst1.Add(str); // 1-й лист - артикул не нашли, искали варианты

            end else if (i=1) or (i=-1) then begin   // 2-й или 3-й лист
              s:= AnsiUpperCase(fnDelSpcAndSumb(ware.ArticleTD));
              with Ware do if (pos(s, NameBS)>0) then
                str:= sTxtGreenCellWW(Name)+sTxtGreenCellWW(sbt)+
                      sTxtGreenCellWW(ArticleTD)+sTxtGreenCellWW('1')+sEnd1
              else str:= sTxtRoseCellWW(Name)+sTxtRoseCellWW(sbt)+
                         sTxtRoseCellWW(ArticleTD)+sTxtRoseCellWW('1')+sEnd1;
              if (i=-1) then lst3.Add(str) // 3-й лист - нашли артикул, варианты не искали
              else lst2.Add(str);          // 2-й лист - нашли артикул и варианты

            end else if (i>1) then begin                 // найденные варианты
              if (SupMF=ware.ArtSupTD) then s:= sbt
              else begin // если другой бренд - проверяем соответствие
                ii:= ware.WareBrandID;
                if (ii>1) and Cache.WareBrands.ItemExists(ii) and // бренд TD не соответствует Grossbee
                  (fnInIntArray(SupMF, TBrandItem(Cache.WareBrands[ii]).TDMFcodes)<0) then s:= ''
                else if (SupMF>High(arTDBrands)) then s:= '' // бренд TD не найден
                else s:= arTDBrands[SupMF];
              end;
              if s<>'' then begin
                str:= sEmpty+sTxtBlueCellWW(s)+sTxtBlueCellWW(Art)+sEnd2;
                if sGa<>'' then sGa:= 'TD-группа: '+sGa;
                if ss='' then ss:= sGa
                else ss:= 'TD-номер польз.: '+ss+fnIfStr(sGa='', '', '                 ')+sGa;
                if (ss<>'') then ss:= sTxtBlueCellWW(ss) else ss:= sEmpty;
                str:= str+ss+sEmpty;
                if (i>999) then lst1.Add(str) // 1-й лист - варианты (не нашли артикул)
                else lst2.Add(str);           // 2-й лист - варианты (нашли артикул)
              end;
            end;
            IBS.Next;
          end;
        finally
          IBS.Close;
        end;
        CheckStep;
        if flSleep then sleep(SleepFillLinksInt);
      end; // for WareID:= 1 to High(arWareInfo)
    finally
      prFreeIBSQL(IBS);
      cntsTDT.SetFreeCnt(IBD, True);
    end;

    Percent:= 5;
    sTitle:= sHeadBlueCell('Товар GrossBee')+sHeadBlueCell('Бренд ТесDoc')+ // 1, 2 - индекс ячейки
      sHeadBlueCell('Артикул TecDoc')+sHeadBlueCell('Статус привяз.')+      // 3, 4 - индекс ячейки
      sHeadBlueCell('Менеджер')+sHeadBlueCell('ОН TecDoc')+                 // 5, 6 - индекс ячейки
      sHeadBlueCell('анал. TecDoc')+sHeadBlueCell('связки TecDoc')+         // 7, 8 - индекс ячейки
      sHeadBlueCell('парам. TecDoc')+sHeadBlueCell('Бренд GrossBee')+       // 9, 10 - индекс ячейки
      sHeadBlueCell('Код товара')+sHeadBlueCell('Комментарий')+sHeadBlueCell('SupMF TecDoc'); // 11, 12, 13 - индекс ячейки
// 1-й лист
    j:= 0; // счетчик для процентов
    if lst1.Count>0 then Percent:= 4*PercentStep/lst1.Count else Percent:= 1;
    AddXmlBookBegin(Result);
    iposWW:= AddXmlSheetBegin(Result, 'не найдены', Ncolumns, Widths); // индекс строки с <Table...>
    iRows:= 1; // счетчик строк листа
    AddStrWW(sTitle);
    for i:= 0 to lst1.Count-1 do begin
      AddStrWW(lst1[i]);
      inc(iRows);
      CheckStep;
    end;
    SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
    AddXmlSheetEnd(Result, 1, 1);
    SetExecutePercent(pUserID, ThreadData, Percent);
// 2-й лист
    j:= 0; // счетчик для процентов
    if lst2.Count>0 then Percent:= 4*PercentStep/lst2.Count else Percent:= 1;
    iposWW:= AddXmlSheetBegin(Result, 'найдены варианты', Ncolumns, Widths); // индекс строки с <Table...>
    iRows:= 1; // счетчик строк листа
    AddStrWW(sTitle);
    for i:= 0 to lst2.Count-1 do begin
      AddStrWW(lst2[i]);
      inc(iRows);
      CheckStep;
    end;
    SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
    AddXmlSheetEnd(Result, 1, 1);
    SetExecutePercent(pUserID, ThreadData, Percent);
// 3-й лист
    j:= 0; // счетчик для процентов
    if lst3.Count>0 then Percent:= 4*PercentStep/lst3.Count else Percent:= 1;
    iposWW:= AddXmlSheetBegin(Result, 'найдены (проверить)', Ncolumns, Widths); // индекс строки с <Table...>
    iRows:= 1; // счетчик строк листа
    AddStrWW(sTitle);
    for i:= 0 to lst3.Count-1 do begin
      AddStrWW(lst3[i]);
      inc(iRows);
      CheckStep;
    end;
    SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
    AddXmlSheetEnd(Result, 1, 1);
    SetExecutePercent(pUserID, ThreadData, Percent);
// 4-й лист
    j:= 0; // счетчик для процентов
    if lst4.Count>0 then Percent:= 4*PercentStep/lst4.Count else Percent:= 1;
    iposWW:= AddXmlSheetBegin(Result, 'не найден бренд TD', Ncolumns, Widths); // индекс строки с <Table...>
    iRows:= 1; // счетчик строк листа
    AddStrWW(sTitle);
    for i:= 0 to lst4.Count-1 do begin
      AddStrWW(lst4[i]);
      inc(iRows);
      CheckStep;
    end;
    SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
    AddXmlSheetEnd(Result, 1, 1);
    SetExecutePercent(pUserID, ThreadData, Percent);

  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache
  finally
    AddXmlBookEnd(Result);
    Setlength(arTDBrands, 0);
    SetLength(arWareFlags, 0);
    Setlength(Widths, 0);
    prFree(lst1);
    prFree(lst2);
    prFree(lst3);
    prFree(lst4);
    prFree(lstWares);
  end;
end;
//==================================== перечень инфо-текстов TecDoc для перевода
function fnGetInfoTextsForTranslate(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает список для выгрузки в файл XML                             // переделать !!!
const nmProc = 'fnGetInfoTextsForTranslate'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    Widths: Tai;
    Ncolumns, iposWW, iRows, i, j, iSup: integer;
    Percent: real;
    lstProblems: TStringList;
    str, sTitle, sArt, sSup: String;
  //----------------------------------------------
  procedure AddStr(s: string);
  begin
    AddXmlLine(Result, s, 100);
  end;
  //----------------------------------------------
  procedure AddStrWW(s: string);
  begin
    AddXmlLineWW(Result, s, 100);
  end;
  //----------------------------------------------
begin
  Result:= fnCreateStringList(False, 100);
  IBS:= nil;
  lstProblems:= fnCreateStringList(False, 100);
  Ncolumns:= 6;        // кол-во столбцов
  Setlength(Widths, Ncolumns);
  Widths[0]:= 0;       // задаем ширину столбцов, 0 - AutoFitWidth
  Widths[1]:= 250;
  Widths[2]:= 250;
  Widths[3]:= 0;
  Widths[4]:= 150;
  Widths[5]:= 250;
  CheckStyle(skHeadBlue);     // задаем нужные стили
  CheckStyle(skTxtWW);
  CheckStyle(skTxtGreenWW);
  CheckStyle(skTxtYellowWW);
  CheckStyle(skTxt);
  CheckStyle(skBold);
  Percent:= 1;
  SetExecutePercent(pUserID, ThreadData, Percent);
  with Cache do try try
    IBD:= cntsORD.GetFreeCnt('', '', '', True);
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS(ORD)_'+nmProc);
      AddXmlBookBegin(Result);
  //------------------------------------------------------------- лист с описанием
      AddXmlSheetBegin(Result, 'описание', 1);
      AddStr(sBoldCell('          замены текстов TecDoc для отображения в системе заказов'));
      AddStr(sTxtCell(''));
      AddStr(sBoldCell('на листе "ЗАМЕНЫ" - тексты TecDoc, не имеющие перевода,'));
      AddStr(sTxtCell('    в строках, где перевод не нужен (аббревиатуры, правильный русский текст и т.п.),'+
                           ' должна стоять опция "/-1", в дальнейшем такие тексты обрабатываться не будут,'));
      AddStr(sTxtCell('    в строках с новыми переводами должна стоять опция "/1",'+
                           ' НЕЛЬЗЯ переименовывать лист и менять на нем порядок столбцов,'));
      AddStr(sTxtCell('    изменять МОЖНО ТОЛЬКО ячейки в столбцах "перевод" и "опция" (выделены цветом),'+
                           ' МОЖНО удалить строки, в которых не задана опция'));
      AddStr(sBoldCell('на листе "вопросы" - тексты TecDoc с переводами из базы, требующие проверки,'));
      AddStr(sTxtCell('    лист информационный, не обрабатывается,'));
      AddStr(sTxtCell('    если перевод в строке заменяется, эту строку необходимо'+
                           ' скопировать/переместить на лист "ЗАМЕНЫ" с опцией "/3",'));
      AddStr(sTxtCell('    изменять МОЖНО ТОЛЬКО ячейки в столбцах "перевод" и "опция" (выделены цветом),'+
                           ' НЕЛЬЗЯ менять порядок столбцов на листе'));
      AddStr(sBoldCell('на листе "проблемы" - тексты TecDoc, не представляющие возможность перевода,'));
      AddStr(sTxtCell('    лист информационный, не обрабатывается,'));
      AddStr(sTxtCell('    под строками с текстами могут быть указаны артикулы TecDoc,'+
                           ' по которым встречаются такие тексты'));
      AddStr(sTxtCell('       (и модели, если текст можно увидеть только при выборе модели),'+
                              ' для поиска оригинальных текстов в англоязычной версии TecDoc,'));
      AddStr(sTxtCell('    если перевод найден, строку необходимо скопировать/переместить'+
                           ' на лист "ЗАМЕНЫ" с опцией "/1",'));
      AddStr(sTxtCell('    изменять МОЖНО ТОЛЬКО ячейки в столбцах "перевод" и "опция" (выделены цветом),'+
                           ' НЕЛЬЗЯ менять порядок столбцов на листе'));
      AddStr(sBoldCell('на листе "переводы" - тексты TecDoc с переводами из базы для сравнения,'));
      AddStr(sTxtCell('    лист информационный, не обрабатывается,'));
      AddStr(sTxtCell('    если требуется замена перевода, строку с изменениями'+
                           ' необходимо скопировать/переместить на лист "ЗАМЕНЫ" с опцией "/3",'));
      AddStr(sTxtCell('    изменять МОЖНО ТОЛЬКО ячейки в столбцах "перевод" и "опция" (выделены цветом),'+
                           ' НЕЛЬЗЯ менять порядок столбцов на листе'));
      AddStr(sTxtCell('на листе "без перевода" - тексты TecDoc, отмеченные как не требующие перевода,'));
      AddStr(sTxtCell('    лист информационный, не обрабатывается,'));
      AddStr(sTxtCell('    если требуется перевод, строку необходимо скопировать/переместить на лист "ЗАМЕНЫ" с опцией "/1",'));
      AddStr(sTxtCell(''));
      AddStr(sBoldCell(' При импорте:'));
      AddStr(sTxtCell(' - в файле импорта не должно быть скрытых строк или столбцов, фильтра и т.п.,'));
      AddStr(sTxtCell(' - форматы файла импорта - ".xml", ".xls"(Excel2003),'));
      AddStr(sTxtCell(' - обрабатывается только лист "ЗАМЕНЫ" и строки с опциями "/1", "/-1", "/3",'));
      AddStr(sTxtCell(' - результат обработки строки записывается в столбец "Результат",'));
      AddStr(sTxtCell(' - при успешной обработке строки ячейка "опция" заменяется на "/0".'));
      AddXmlSheetEnd(Result, 0, 0);

      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.SQL.Text:= 'select count(*) from wareinfotexts';
      IBS.ExecQuery;
      if not (IBS.Eof and IBS.Bof) and (IBS.fields[0].AsInteger>1) then
        Percent:= 90/IBS.fields[0].AsInteger;
      IBS.Close;
      sTitle:= sHeadBlueCell('ITCODE')+sHeadBlueCell('текст TecDoc')+
        sHeadBlueCell('перевод')+ sHeadBlueCell('опция')+
        sHeadBlueCell('Результат')+sHeadBlueCell('ittext3');

  //----------------------------------------------- лист с текстами для перевода
      iposWW:= AddXmlSheetBegin(Result, 'ЗАМЕНЫ', Ncolumns, Widths); // индекс строки с <Table...>
      iRows:= 1; // счетчик строк листа
      AddStr(sTitle);
      IBS.SQL.Text:= 'select ITCODE, ITTEXT'+       // new txt
        ' from infotexts where italtern=0 order by ITTEXT';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        str:= sTxtWWCell(IBS.fieldByName('ITCODE').AsString)+
              sTxtYellowCellWW(IBS.fieldByName('ITTEXT').AsString)+
              sTxtGreenCellWW('')+sTxtGreenCellWW('/1')+sTxtWWCell('')+sTxtWWCell('');
        if (pos('????', IBS.fieldByName('ITTEXT').AsString)>0) then begin
          i:= IBS.fieldByName('ITCODE').AsInteger;
          lstProblems.AddObject(str, Pointer(i)); // собираем проблемы
        end else begin
          AddStrWW(str);
          inc(iRows);
        end;
        IBS.Next;
        CheckStopExecute(pUserID, ThreadData);
        SetExecutePercent(pUserID, ThreadData, Percent);
      end; // while not IBS.Eof and (id1=
      IBS.Close;
      SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
      AddXmlSheetEnd(Result, 1, 1);

  //--- лист с вопросами (тексты с переводами, измененные при последней заливке)
      iposWW:= AddXmlSheetBegin(Result, 'вопросы', Ncolumns, Widths);
      AddStr(sTitle);
      iRows:= 1; // счетчик строк листа
(*      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.SQL.Text:= 'select WITCODE, WITSUPTD, "#"||WITTMTD WITTMTD, WITTEXT, vittext'+
        ' from wareinfotexts left join linkinfotextvalues'+
        '   on litvsuptd=witsuptd and litvtmtd=wittmtd and LITVWRONG="F"'+
        ' left join valuesinfotexts on vitcode=litvvit'+
        ' where witaltern=1 and '+sPeriod+' order by WITTEXT';
      IBS.ParamByName('TestTime1').AsDateTime:= TestTime1;
      IBS.ParamByName('TestTime2').AsDateTime:= TestTime2;
      IBS.ExecQuery;
      while not IBS.Eof do begin
        AddStrWW(sTxtWWCell(IBS.fieldByName('WITCODE').AsString)+
                 sTxtWWCell(IBS.fieldByName('WITSUPTD').AsString)+
                 sTxtWWCell(IBS.fieldByName('WITTMTD').AsString)+
                 sTxtWWCell(IBS.fieldByName('WITTEXT').AsString)+
                 sTxtGreenCellWW(IBS.fieldByName('vittext').AsString)+
                 sTxtGreenCellWW('/3')+sTxtWWCell('')+sTxtWWCell(''));
        inc(iRows);
        IBS.Next;
        CheckStopExecute(pUserID, ThreadData);
        SetExecutePercent(pUserID, ThreadData, Percent);
      end; // while not IBS.Eof and (id1=
      IBS.Close;    *)
      SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
      AddXmlSheetEnd(Result, 1, 1);

  //---------------------------------------------------------- лист с проблемами
      iposWW:= AddXmlSheetBegin(Result, 'проблемы', Ncolumns, Widths);
      AddStr(sTitle);
      iRows:= 1; // счетчик строк листа
      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.SQL.Text:= 'select rWare, rMod, rNod from GetWaresForBadTexts('+
        '(select first 1 witcode from wareinfotexts where wittextcode=:it))'; // new txt
      for i:= 0 to lstProblems.Count-1 do begin
        AddStrWW(lstProblems[i]);
        inc(iRows);
        j:= Integer(lstProblems.Objects[i]);
        IBS.ParamByName('it').AsInteger:= j;
        IBS.ExecQuery;
        while not IBS.Eof do begin // артикулы для проблемных текстов
          j:= IBS.fieldByName('rWare').AsInteger;
          sArt:= '';
          sSup:= '';
          iSup:= 0;
          if (j>0) and WareExist(j) then with GetWare(j) do begin
            iSup:= ArtSupTD;
            sArt:= ArticleTD;
          end;
          if iSup>0 then for j:= 0 to BrandTDList.Count-1 do  // наименования бренда TD
            if Integer(BrandTDList.Objects[j])=iSup then begin
              sSup:= BrandTDList[j];
              break;
            end;
          if (sArt<>'') and (sSup<>'') then begin
            sArt:= sTxtWWCell('')+sTxtWWCell(sSup+', '+sArt+', '+IBS.fieldByName('rMod').AsString);
            str:= IBS.fieldByName('rNod').AsString;
            j:= pos(' (TD', str);
            if (j>0) then str:= copy(str, 1, j-1);
            AddStrWW(sArt+sTxtWWCell(str)+sTxtWWCell('')+sTxtWWCell('')+sTxtWWCell(''));
            inc(iRows);
          end;
          IBS.Next;
        end; // while not IBS.Eof
        IBS.Close;
        CheckStopExecute(pUserID, ThreadData);
      end;
      SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
      AddXmlSheetEnd(Result, 1, 1);

  //------------------------------------ лист с переводами из базы для сравнения
      iposWW:= AddXmlSheetBegin(Result, 'переводы', Ncolumns, Widths);
      AddStr(sTitle);
      iRows:= 1; // счетчик строк листа
      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.SQL.Text:= 'select ITCODE, ITTEXT, itatext'+                      // new txt
        ' from infotexts left join infotextsaltern on itacode=italtern'+
        ' where italtern>0 order by ITTEXT';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        AddStrWW(sTxtWWCell(IBS.fieldByName('ITCODE').AsString)+
                 sTxtWWCell(IBS.fieldByName('ITTEXT').AsString)+
                 sTxtGreenCellWW(IBS.fieldByName('itatext').AsString)+
                 sTxtGreenCellWW('')+sTxtWWCell('')+sTxtWWCell(''));
        inc(iRows);
        IBS.Next;
        CheckStopExecute(pUserID, ThreadData);
        SetExecutePercent(pUserID, ThreadData, Percent);
      end; // while not IBS.Eof and (id1=
      IBS.Close;
      SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
      AddXmlSheetEnd(Result, 1, 1);

  //--------------------------------------- лист с текстами без перевода из базы
      iposWW:= AddXmlSheetBegin(Result, 'без перевода', Ncolumns, Widths);
      iRows:= 1; // счетчик строк листа
      AddStr(sTitle);

      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.SQL.Text:= 'select ITCODE, ITTEXT from infotexts'+              // new txt
        ' where italtern=-1 order by ITTEXT';
      IBS.ExecQuery;
      while not IBS.Eof do begin
        AddStrWW(sTxtWWCell(IBS.fieldByName('ITCODE').AsString)+
                 sTxtWWCell(IBS.fieldByName('ITTEXT').AsString)+
                 sTxtGreenCellWW('')+sTxtGreenCellWW('')+sTxtWWCell('')+sTxtWWCell(''));
        inc(iRows);
        IBS.Next;
        CheckStopExecute(pUserID, ThreadData);
        SetExecutePercent(pUserID, ThreadData, Percent);
      end; // while not IBS.Eof and (id1=
      IBS.Close;
      SetXmlSheetWWoptions(Result, iposWW, Ncolumns, iRows); // устанавливаем опции worksheet для WordWrap
      AddXmlSheetEnd(Result, 1, 1);
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD, True);
      AddXmlBookEnd(Result);
    end;
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache
  finally
    Setlength(Widths, 0);
    prFree(lstProblems);
  end;
end;
//================================================ поиск новых узлов авто из TDT
function fnGetNewTreeNodesFromTDT(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает список для выгрузки в файл XML
const nmProc = 'fnGetNewTreeNodesFromTDT'; // имя процедуры/функции
var IBD: TIBDatabase;
    IBS: TIBSQL;
    nodeGA, ParGA, nodeORD, Ncolumns, id1, id2, id3, id4: integer;
    nameGA, nameSys, name1, name2, name3, name4, Sname1, Sname2, Sname3, Sname4: string;
    Widths: Tai;
    nodes: TAutoTreeNodes;
    Percent: real;
  //----------------------------------------------
  procedure AddStr(s: string);
  begin
    if Result.Capacity=Result.Count then Result.Capacity:= Result.Capacity+1000;
    AddXmlLine(Result, s);
  end;
  //----------------------------------------------
begin
  Result:= fnCreateStringList(False, 1000);
  IBS:= nil;
//  IBD:= nil;
  Ncolumns:= 13;
  Setlength(Widths, Ncolumns);
  Widths[1]:= 150;
  Widths[2]:= 150;
  Widths[3]:= 150;
  Widths[4]:= 150;
  Widths[8]:= 150;
  Widths[9]:= 150;
  CheckStyle(skTxt);
  CheckStyle(skHead);
  CheckStyle(skBold);
  CheckStyle(skTxtGreen);
  CheckStyle(skBoldGreen);
  Percent:= 1;
  SetExecutePercent(pUserID, ThreadData, Percent);
  with Cache.FDCA do try try
    nodes:= AutoTreeNodesSys[constIsAuto];
    Percent:= 90/nodes.NodesList.Count/2;
    AddXmlBookBegin(Result);
//------------------------------------------------------------- лист с описанием
    AddXmlSheetBegin(Result, 'описание', 1);
    AddStr(sBoldCell('   Узлы легковых авто'));
    AddStr(sTxtCell(' На листе "узлы авто" содержится перечень конечных узлов с 4 уровнями родительских узлов.'));
    AddStr(sTxtCell(' Если в TecDoc найдены новые узлы, строки с новыми конечными и родительскими узлами расположены'));
    AddStr(sTxtCell('   в начале листа с опцией "добавить", параметры новых узлов выделены цветовой заливкой ячеек.'));
    AddStr(sTxtCell(' Перечень узлов в нашей базе - без заливки.'));
    AddStr(sBoldCell(' В строках с новыми узлами:'));
    AddStr(sTxtCell(' - наименования родительских узлов - в столбце соответствующего уровня, конечных узлов - в столбце "Конечный узел",'));
    AddStr(sTxtCell(' - жирным шрифтом выделены изменяемые ячейки, значения которых при импорте будут записываться в базу из файла:'));
    AddStr(sTxtCell('   наименование и видимость, в строках конечных узлов - глав.код узла (из перечня узлов в нашей базе).'));
    AddStr(sBoldCell(' В строках существующих узлов:'));
    AddStr(sTxtCell('  - можно изменить значения в столбцах "Конечный узел"(наименование), "Видим."(видимость)'));
    AddStr(sTxtCell('    и "Главн."(глав.код конечного узла), значения в столбце "Код" изменять нельзя,'));
    AddStr(sTxtCell('  - изменение глав.кода возможно 2-х видов - сделать главный узел дублирующим или сделать дублирующий узел главным,'));
    AddStr(sTxtCell('    переподчинение (замена глав.кода у дублирующего узла) не предусмотрено, при необходимости это можно сделать в 2 этапа:'));
    AddStr(sTxtCell('    сделать дублирующий узел главным, а затем сделать его дублирующим с другим глав.кодом,'));
    AddStr(sTxtCell('  - для обработки изменения параметров узла нужно в столбец "опция" записать значение "изменить".'));
    AddStr(sBoldCell(' При подготовке импорта:'));
    AddStr(sTxtCell(' - строки с новыми конечными узлами можно переставить на нужное место в перечне узлов, строки с новыми родительскими узлами'));
    AddStr(sTxtCell('   желательно оставить в начале листа, т.к. строки с родительскими узлами должны быть выше строк с конечными узлами,'));
    AddStr(sTxtCell(' - при перестановке нужно переносить всю строку, чтобы сохранить соответствие с кодами TD,'));
    AddStr(sTxtCell(' - в случае сортировки данных необходимо выделять все столбцы до столбца "Результат", перед импортом жедательно отменить сортировку,'));
    AddStr(sTxtCell(' - значения в строках с опцией "добавить", кроме перечисленных выше, изменять нельзя,'));
    AddStr(sTxtCell(' - на листе "узлы авто" нельзя менять порядок столбцов, изменение цвета ячеек допускается.'));
    AddStr(sBoldCell(' При импорте:'));
    AddStr(sTxtCell(' - в файле импорта не должно быть скрытых строк или столбцов, фильтра и т.п.,'));
    AddStr(sTxtCell(' - формат файла импорта - для Excel2003 ".xls", для Excel2007 и выше ".xlsx",'));
    AddStr(sTxtCell(' - обрабатываются только листы, в наименовании которых есть слово "узлы", и строки с опциями "добавить" или "изменить",'));
    AddStr(sTxtCell(' - все значения в строках с опцией "изменить", кроме перечисленных выше, игнорируются,'));
    AddStr(sTxtCell(' - результат обработки строки записывается в столбец "Результат", при успешной обработке строки ячейка "опция" очищается.'));
    AddXmlSheetEnd(Result, 0, 0);
//---------------------------------------------------------------- лист с узлами
    AddXmlSheetBegin(Result, 'узлы авто', Ncolumns, Widths);
//                       0                 1                  2                  3          индекс поля ADOTable
    AddStr(sHeadCell('опция')+sHeadCell('уровень 1')+sHeadCell('уровень 2')+sHeadCell('уровень 3')+
//                 4                 5                6                 7               8   индекс поля ADOTable
      sHeadCell('уровень 4')+sHeadCell('Код')+sHeadCell('Главн.')+sHeadCell('Видим.')+sHeadCell('Конечный узел')+
//                 9                 10                 11                 12               индекс поля ADOTable
      sHeadCell('Сист.наимен.')+sTxtCell('kodTD')+sTxtCell('ParTD')+sHeadCell('Результат'));
//------------------------------------------- недостающие узлы
    IBD:= cntsTDT.GetFreeCnt('', '', '', True);
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS(TDT)_'+nmProc, -1, tpRead, true);
      IBS.ParamCheck:= False;
      IBS.SQL.Add('execute block returns (name4 varchar(60), name3 varchar(60), name2 varchar(60),');
      IBS.SQL.Add('  name1 varchar(60), ga_id integer, ga_name varchar(60), id1 integer, id2 integer,');
      IBS.SQL.Add('  id3 integer, id4 integer) as declare variable xType integer = 1;'); // 1- легк.авто
      IBS.SQL.Add('begin id4 = 0; name4 = ""; for select st.st_id, st.st_descr from SEARCH_TREE st');
      IBS.SQL.Add('  where st.ST_TYP = :xType and st_parent = 0 order by st_descr into :id4, :name4');
      IBS.SQL.Add('  do begin id3 = 0; id2 = 0; id1 = 0; ga_id = 0; name3 = ""; name2 = ""; name1 = ""; ga_name  = "";');
      IBS.SQL.Add('    if (not exists(select * from SEARCH_TREE st where st.ST_TYP = :xType and st_parent = :id4 )) then');
      IBS.SQL.Add('    begin if ( exists( select * from LINK_GA_TO_TREE where LGT_ST_ID = :id4 ) ) then begin');
      IBS.SQL.Add('      for select LGT_GA_ID, LGT_GA_DESCR from LINK_GA_TO_TREE where LGT_ST_ID = :id4');
      IBS.SQL.Add('        order by LGT_GA_DESCR into :ga_id, :ga_name do suspend; end');
      IBS.SQL.Add('    end else begin for select st.st_id, st.st_descr from SEARCH_TREE st');
      IBS.SQL.Add('      where st.ST_TYP = :xType and st_parent = :id4 order by st_descr into :id3, :name3');
      IBS.SQL.Add('    do begin name2 = ""; name1 = ""; ga_name  = ""; id2 = 0; id1 = 0; ga_id = 0;');
      IBS.SQL.Add('      if (not exists(select * from SEARCH_TREE st where st.ST_TYP = :xType and st_parent = :id3 )) then');
      IBS.SQL.Add('      begin if ( exists( select * from LINK_GA_TO_TREE where LGT_ST_ID = :id3 ) ) then begin');
      IBS.SQL.Add('        for select LGT_GA_ID, LGT_GA_DESCR from LINK_GA_TO_TREE where LGT_ST_ID = :id3');
      IBS.SQL.Add('          order by LGT_GA_DESCR into :ga_id, :ga_name do suspend; end');
      IBS.SQL.Add('      end else begin for select st.st_id, st.st_descr from SEARCH_TREE st');
      IBS.SQL.Add('        where st.ST_TYP = :xType and st_parent = :id3 order by st_descr into :id2, :name2');
      IBS.SQL.Add('      do begin name1 = ""; ga_name  = ""; id1 = 0; ga_id = 0;');
      IBS.SQL.Add('        if (not exists(select * from SEARCH_TREE st where st.ST_TYP = :xType and st_parent = :id2 )) then');
      IBS.SQL.Add('        begin if ( exists( select * from LINK_GA_TO_TREE where LGT_ST_ID = :id2 ) ) then begin');
      IBS.SQL.Add('          for select LGT_GA_ID, LGT_GA_DESCR from LINK_GA_TO_TREE where LGT_ST_ID = :id2');
      IBS.SQL.Add('            order by LGT_GA_DESCR into :ga_id, :ga_name do suspend; end');
      IBS.SQL.Add('        end else begin for select st.st_id, st.st_descr from SEARCH_TREE st');
      IBS.SQL.Add('          where st.ST_TYP = :xType and st_parent = :id2 order by st_descr into :id1, :name1');
      IBS.SQL.Add('        do begin if ( exists( select * from LINK_GA_TO_TREE where LGT_ST_ID = :id1 ) ) then begin');
      IBS.SQL.Add('          for select LGT_GA_ID, LGT_GA_DESCR from LINK_GA_TO_TREE where LGT_ST_ID = :id1');
      IBS.SQL.Add('            order by LGT_GA_DESCR into :ga_id, :ga_name do suspend; end end end end end end end end end');
      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.ExecQuery;
      while not IBS.Eof do begin
        id4    := IBS.fieldByName('id4').AsInteger; //------- узел TD 1-го уровня
        nodeORD:= Nodes.GetNodeIDByTDcodes(id4, 0, False);
        if nodeORD<1 then begin // если узла в ORD нет
          name4  := IBS.fieldByName('name4').AsString;
          Sname4 := sTxtGreenCell(name4);
          nameSys:= AnsiUpperCase(name4)+' (TD '+IntToStr(id4)+')';
          AddStr(sTxtGreenCell(sActionAdd)+sBoldGreenCell(name4)+sTxtCell('')+sTxtCell('')+
            sTxtCell('')+sIntCell(0)+sIntCell(0)+sIntBoldGreenCell(1)+sTxtCell('')+
            sTxtGreenCell(nameSys)+sIntGreenCell(id4)+sIntGreenCell(0)+sTxtGreenCell(''));
        end else begin
          name4 := Nodes[nodeORD].Name;
          Sname4:= sTxtCell(name4);
        end;
        ParGA:= id4;

        while not IBS.Eof and (id4=IBS.fieldByName('id4').AsInteger) do begin
          id3  := IBS.fieldByName('id3').AsInteger;
          name3:= IBS.fieldByName('name3').AsString;
          if id3>0 then begin //------------------ если есть узел TD 2-го уровня
            nodeORD:= Nodes.GetNodeIDByTDcodes(id3, id4, False);
            if nodeORD<1 then begin // если узла в ORD нет
              nameSys:= AnsiUpperCase(name3)+' (TD '+IntToStr(id3)+')';
              Sname3 := sTxtGreenCell(name3);
              AddStr(sTxtGreenCell(sActionAdd)+Sname4+sBoldGreenCell(name3)+sTxtCell('')+
                sTxtCell('')+sIntCell(0)+sIntCell(0)+sIntBoldGreenCell(1)+sTxtCell('')+
                sTxtGreenCell(nameSys)+sIntGreenCell(id3)+sIntGreenCell(id4)+sTxtGreenCell(''));
            end else begin
              name3 := Nodes[nodeORD].Name;
              Sname3:= sTxtCell(name3);
            end;
            ParGA:= id3;
          end else Sname3:= sTxtCell(name3);

          while not IBS.Eof and (id4=IBS.fieldByName('id4').AsInteger)
            and (id3=IBS.fieldByName('id3').AsInteger) do begin
            id2  := IBS.fieldByName('id2').AsInteger;
            name2:= IBS.fieldByName('name2').AsString;
            if id2>0 then begin //---------------- если есть узел TD 3-го уровня
              nodeORD:= Nodes.GetNodeIDByTDcodes(id2, id3, False);
              if nodeORD<1 then begin // если узла в ORD нет
                nameSys:= AnsiUpperCase(name2)+' (TD '+IntToStr(id2)+')';
                Sname2 := sTxtGreenCell(name2);
                AddStr(sTxtGreenCell(sActionAdd)+Sname4+Sname3+sBoldGreenCell(name2)+
                  sTxtCell('')+sIntCell(0)+sIntCell(0)+sIntBoldGreenCell(1)+sTxtCell('')+
                  sTxtGreenCell(nameSys)+sIntGreenCell(id2)+sIntGreenCell(id3)+sTxtGreenCell(''));
              end else begin
                name2 := Nodes[nodeORD].Name;
                Sname2:= sTxtCell(name2);
              end;
              ParGA:= id2;
            end else Sname2:= sTxtCell(name2);

            while not IBS.Eof and (id4=IBS.fieldByName('id4').AsInteger)
              and (id3=IBS.fieldByName('id3').AsInteger)
              and (id2=IBS.fieldByName('id2').AsInteger) do begin
              id1  := IBS.fieldByName('id1').AsInteger;
              name1:= IBS.fieldByName('name1').AsString;
              if id1>0 then begin //-------------- если есть узел TD 4-го уровня
                nodeORD:= Nodes.GetNodeIDByTDcodes(id1, id2, False);
                if nodeORD<1 then begin // если узла в ORD нет
                  nameSys:= AnsiUpperCase(name1)+' (TD '+IntToStr(id1)+')';
                  Sname1 := sTxtGreenCell(name1);
                  AddStr(sTxtGreenCell(sActionAdd)+Sname4+Sname3+Sname2+sBoldGreenCell(name1)+
                    sIntCell(0)+sIntCell(0)+sIntBoldGreenCell(1)+sTxtCell('')+
                    sTxtGreenCell(nameSys)+sIntGreenCell(id1)+sIntGreenCell(id2)+sTxtGreenCell(''));
                end else begin
                  name1 := Nodes[nodeORD].Name;
                  Sname1:= sTxtCell(name1);
                end;
                ParGA:= id1;
              end else Sname1:= sTxtCell(name1);

              while not IBS.Eof and (id4=IBS.fieldByName('id4').AsInteger)
                and (id3=IBS.fieldByName('id3').AsInteger)
                and (id2=IBS.fieldByName('id2').AsInteger)
                and (id1=IBS.fieldByName('id1').AsInteger) do begin
                nodeGA := IBS.fieldByName('ga_id').AsInteger; //---- группа TD
                nodeORD:= Nodes.GetNodeIDByTDcodes(nodeGA, ParGA, True);
                if nodeORD<1 then begin // если конечного узла в ORD нет
                  nameGA := IBS.fieldByName('ga_name').AsString;
                  nameSys:= AnsiUpperCase(nameGA)+' (TD '+IntToStr(ParGA)+' GA '+IntToStr(nodeGA)+')';
                  AddStr(sTxtGreenCell(sActionAdd)+Sname4+Sname3+Sname2+Sname1+
                    sIntCell(0)+sIntBoldGreenCell(0)+sIntBoldGreenCell(1)+sBoldGreenCell(nameGA)+
                    sTxtGreenCell(nameSys)+sIntGreenCell(nodeGA)+sIntGreenCell(ParGA)+sTxtGreenCell(''));
                end;
                IBS.Next;
                CheckStopExecute(pUserID, ThreadData);
                SetExecutePercent(pUserID, ThreadData, Percent);
              end; // while not IBS.Eof and (id1=
            end; // while not IBS.Eof and (id2=
          end; // while not IBS.Eof and (id3=
        end; // while not IBS.Eof and (id4=
      end; // while not IBS.Eof
    finally
      prFreeIBSQL(IBS);
      cntsTDT.SetFreeCnt(IBD, True);
    end;
//------------------------------------------- узлы в нашей базе
    AddStr(sTxtCell(''));

    IBD:= cntsORD.GetFreeCnt('', '', '', True);
    if not Assigned(IBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      IBS:= fnCreateNewIBSQL(IBD, 'IBS(ORD)_'+nmProc, -1, tpRead, true);
      IBS.ParamCheck:= False;
      IBS.SQL.Add('execute block returns (nm4 varchar(100), nm3 varchar(100), nm2 varchar(100),');
      IBS.SQL.Add('  nm1 varchar(100), node integer, Main integer, nvis varchar(1), name varchar(100),');
      IBS.SQL.Add('  nmSys varchar(100), parent integer, kodTD integer)');
      IBS.SQL.Add('as declare variable node1 integer = 0; declare variable node2 integer = 0;');
      IBS.SQL.Add('  declare variable node3 integer = 0; declare variable node4 integer = 0;');
      IBS.SQL.Add('  declare variable Sys integer = 1; begin nmSys = ""; parent = 0; kodTD = 0;');
      IBS.SQL.Add('  parent = 0; node = 0; Main = 0; nm1 = ""; nm2 = ""; nm3 = ""; nm4 = ""; name = "";');
      IBS.SQL.Add('  for select t4.trnacode, t4.trnaname from TREENODESAUTO t4');
      IBS.SQL.Add('    where t4.trnadtsycode = :Sys and (t4.trnacodeparent is null or t4.trnacodeparent=0) order by t4.trnaname');
      IBS.SQL.Add('  into :node4, :nm4 do begin nm1=""; nm2=""; nm3=""; name="";');
      IBS.SQL.Add('    if (not exists(select * from TREENODESAUTO t3 where t3.trnadtsycode = :Sys');
      IBS.SQL.Add('      and t3.trnacodeparent = :node4 and t3.trnatdga="F")) then begin');
      IBS.SQL.Add('      if (exists(select * from TREENODESAUTO t3 where t3.trnadtsycode = :Sys');
      IBS.SQL.Add('        and t3.trnacodeparent = :node4 and t3.trnatdga="T" )) then begin parent = node4;');
      IBS.SQL.Add('        for select t3.trnacode, t3.trnatdcode, t3.trnamaincode, IIF (t3.trnavisible="T", 1, 0),');
      IBS.SQL.Add('          t3.trnaname, t3.trnanamesys from TREENODESAUTO t3 where t3.trnadtsycode = :Sys');
      IBS.SQL.Add('          and t3.trnacodeparent = :node4 and t3.trnatdga="T" order by t3.trnaname');
      IBS.SQL.Add('        into :node, :kodTD, :Main, :nvis, :name, :nmSys do suspend; end');
      IBS.SQL.Add('    end else begin for select t3.trnacode, t3.trnaname from TREENODESAUTO t3');
      IBS.SQL.Add('      where t3.trnadtsycode = :Sys and t3.trnacodeparent = :node4 and t3.trnatdga="F"');
      IBS.SQL.Add('      order by t3.trnaname into :node3, :nm3 do begin nm1 = ""; nm2 = "";');
      IBS.SQL.Add('      if (not exists(select * from TREENODESAUTO t2 where t2.trnadtsycode = :Sys');
      IBS.SQL.Add('        and t2.trnacodeparent = :node3 and t2.trnatdga="F")) then begin');
      IBS.SQL.Add('        if (exists(select * from TREENODESAUTO t2 where t2.trnadtsycode = :Sys');
      IBS.SQL.Add('          and t2.trnacodeparent = :node3 and t2.trnatdga="T" )) then begin parent = node3;');
      IBS.SQL.Add('          for select t2.trnacode, t2.trnatdcode, t2.trnamaincode, IIF (t2.trnavisible="T", 1, 0),');
      IBS.SQL.Add('            t2.trnaname, t2.trnanamesys from TREENODESAUTO t2 where t2.trnadtsycode = :Sys');
      IBS.SQL.Add('            and t2.trnacodeparent = :node3 and t2.trnatdga="T" order by t2.trnaname');
      IBS.SQL.Add('          into :node, :kodTD, :Main, :nvis, :name, :nmSys do suspend; end');
      IBS.SQL.Add('      end else begin for select t2.trnacode, t2.trnaname from TREENODESAUTO t2');
      IBS.SQL.Add('        where t2.trnadtsycode = :Sys and t2.trnacodeparent = :node3 and t2.trnatdga="F"');
      IBS.SQL.Add('        order by t2.trnaname into :node2, :nm2 do begin nm1 = "";');
      IBS.SQL.Add('        if (not exists(select * from TREENODESAUTO t1 where t1.trnadtsycode = :Sys');
      IBS.SQL.Add('          and t1.trnacodeparent = :node2 and t1.trnatdga="F")) then begin');
      IBS.SQL.Add('          if (exists(select * from TREENODESAUTO t1 where t1.trnadtsycode = :Sys');
      IBS.SQL.Add('            and t1.trnacodeparent = :node2 and t1.trnatdga="T" )) then begin parent = node2;');
      IBS.SQL.Add('            for select t1.trnacode, t1.trnatdcode, t1.trnamaincode, IIF (t1.trnavisible="T", 1, 0),');
      IBS.SQL.Add('              t1.trnaname, t1.trnanamesys from TREENODESAUTO t1 where t1.trnadtsycode = :Sys');
      IBS.SQL.Add('              and t1.trnacodeparent = :node2 and t1.trnatdga="T" order by t1.trnaname');
      IBS.SQL.Add('            into :node, :kodTD, :Main, :nvis, :name, :nmSys do suspend; end');
      IBS.SQL.Add('        end else begin for select t1.trnacode, t1.trnaname from TREENODESAUTO t1');
      IBS.SQL.Add('          where t1.trnadtsycode = :Sys and t1.trnacodeparent = :node2 and t1.trnatdga="F"');
      IBS.SQL.Add('          order by t1.trnaname into :node1, :nm1 do begin');
      IBS.SQL.Add('          if (exists(select * from TREENODESAUTO t0 where t0.trnadtsycode = :Sys');
      IBS.SQL.Add('            and t0.trnacodeparent = :node1 and t0.trnatdga="T" )) then begin parent = node1;');
      IBS.SQL.Add('            for select t0.trnacode, t0.trnatdcode, t0.trnamaincode, IIF (t0.trnavisible="T", 1, 0),');
      IBS.SQL.Add('              t0.trnaname, t0.trnanamesys from TREENODESAUTO t0 where t0.trnadtsycode = :Sys');
      IBS.SQL.Add('              and t0.trnacodeparent = :node1 and t0.trnatdga="T" order by t0.trnaname');
      IBS.SQL.Add('            into :node, :kodTD, :Main, :nvis, :name, :nmSys do suspend; end end end end end end end end end');
      with IBS.Transaction do if not InTransaction then StartTransaction;
      IBS.ExecQuery;
      while not IBS.Eof do begin
        name4  := IBS.fieldByName('nm4').AsString;
        name3  := IBS.fieldByName('nm3').AsString;
        name2  := IBS.fieldByName('nm2').AsString;
        name1  := IBS.fieldByName('nm1').AsString;
        nameGA := IBS.fieldByName('name').AsString;
        nameSys:= IBS.fieldByName('nmSys').AsString;
        nodeORD:= IBS.fieldByName('node').AsInteger;
        nodeGA := IBS.fieldByName('Main').AsInteger;
        ParGA  := IBS.fieldByName('nvis').AsInteger;
        AddStr(sTxtCell('')+sTxtCell(name4)+sTxtCell(name3)+sTxtCell(name2)+
          sTxtCell(name1)+sIntCell(nodeORD)+sIntCell(nodeGA)+sIntCell(ParGA)+
          sTxtCell(nameGA)+sTxtCell(nameSys)+sIntCell(0)+sIntCell(0)+sTxtCell(''));
        IBS.Next;
        CheckStopExecute(pUserID, ThreadData);
        SetExecutePercent(pUserID, ThreadData, Percent);
      end; // while not IBS.Eof
    finally
      prFreeIBSQL(IBS);
      cntsORD.SetFreeCnt(IBD, True);
    end;
//-------------------------------------------
    AddXmlSheetEnd(Result, 1, 1);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    AddXmlBookEnd(Result);
    Setlength(Widths, 0);
  end;
end;
//======================== поиск новых производителей, м.р., моделей авто из TDT
function fnGetNewAutoMfMlModFromTDT(pUserID: Integer; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает список для выгрузки в файл XML
const nmProc = 'fnGetNewAutoMfMlModFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    manufTD, manufORD, mlTD, mlORD, modTD, modORD,
      tdFrom, tdTo, tdHP, Ncolumns: integer;
    nameTD, s, marksTD: string;
    flMF, flMFex, flML, flMod: Boolean;
    Widths: Tai;
    mdl: TModelAuto;
    mps: TModelParams;
    tim: TTypesInfoModel;
    Percent: real;
  //----------------------------------------------
  procedure AddStr(s: string);
  begin
    if Result.Capacity=Result.Count then Result.Capacity:= Result.Capacity+1000;
    AddXmlLine(Result, s);
  end;
  //----------------------------------------------
  function EmptyStrCell(n: integer=1): string;
  var i: integer;
  begin
    Result:= '';
    if n<1 then Exit;
    for i:= 1 to n do Result:= Result+sTxtCell('');
  end;
  //----------------------------------------------
  function EmptyIntCell(n: integer=1): string;
  var i: integer;
  begin
    Result:= '';
    if n<1 then Exit;
    for i:= 1 to n do Result:= Result+sIntCell(0);
  end;
  //----------------------------------------------
begin
  Result:= TStringList.Create;
  Result.Capacity:= 1000;
  TdtIBS:= nil;
  TdtIBD:= nil;
  Ncolumns:= 28;
  Percent:= 1;
  SetExecutePercent(pUserID, ThreadData, Percent);
  Setlength(Widths, Ncolumns);
  Widths[2] := 150; // М/ряд
  Widths[3] := 200; // Модель
  Widths[7] := 200; // Марк/двиг
  Widths[14]:= 100; // Результат
  Widths[19]:= 100; // Тип кузова
  Widths[20]:= 150; // Тип привода
  Widths[21]:= 150; // Тип двигателя
  Widths[22]:= 100; // Тип топлива
  Widths[23]:= 270; // Система впрыска
  Widths[24]:= 120; // Тип торм.системы
  Widths[25]:= 120; // Торм.система
  Widths[26]:= 250; // Тип катализат.
  Widths[27]:= 250; // Вид кор.передач
  CheckStyle(skTxt);
  CheckStyle(skHead);
  CheckStyle(skBold);
  CheckStyle(skCBold);
  with Cache.FDCA do try try
    AddXmlBookBegin(Result);
    AddXmlSheetBegin(Result, 'описание', 1);
    AddStr(sBoldCell('Модели легковых авто из TecDoc'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' В файле содержится перечень моделей с разбивкой по листам производителей,'));
    AddStr(sTxtCell('   наименование производителя указано в имени листа,'));
    AddStr(sTxtCell('   строка производителя расположена в 1-й строке таблицы листа,'));
    AddStr(sTxtCell('   в 1-м столбце находится опция обработки строки.'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' На листе строки отсортированы по наименованиям модельных рядов и моделей.'));
    AddStr(sTxtCell(' Опцией "/2" и жирным шрифтом обозначены данные, видимые при авто-подборе'));
    AddStr(sTxtCell('   в системе заказов, в таких строках приведены наименования из системы заказов.'));
    AddStr(sTxtCell(' В строках с пустой опцией - приведены данные из TecDoc, которых нет'));
    AddStr(sTxtCell('   в системе заказов или они невидимы при авто-подборе.'));
    AddStr(sTxtCell(' Столбцы между "Марк/двиг" и "Результат"- служебные (для загрузки данных из файла).'));
    AddStr(sTxtCell(' Столбцы после столбца "Результат" - информационные (параметры моделей в системе заказов).'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' В строках моделей с пустой опцией, которые должны быть видимыми при авто-подборе'));
    AddStr(sTxtCell('   в системе заказов, нужно проставить опцию "/1". Если в строке модели проставлена опция "/1",'));
    AddStr(sTxtCell('   то в строках ее модельного ряда и ее производителя должна быть опция "/1" или "/2".'));
    AddStr(sTxtCell(' В строках моделей / модельных рядов с опцией "/1" можно изменить наименование.'));
    AddStr(sTxtCell(''));
    AddStr(sTxtCell(' При импорте обрабатываются только строки с опцией "/1", при этом'));
    AddStr(sTxtCell('   наименование модели / модельного ряда записывается в базу из файла,'));
    AddStr(sTxtCell('   устанавливается видимость модели / модельного ряда / производителя,'));
    AddStr(sTxtCell('   все остальные параметры новых моделей / модельных рядов записываются из базы TecDoc.'));
    AddStr(sTxtCell(' Новые модельные ряды / производители записываются в базу системы заказов'));
    AddStr(sTxtCell('   только при наличии у них моделей с опцией "/1".'));
    AddStr(sTxtCell(' Результат обработки строки записывается в столбец "Результат".'));
    AddStr(sTxtCell(''));
    AddStr(sBoldCell('ВНИМАНИЕ! В файле допускается только изменение пустых ячеек опций в 1-м столбце'));
    AddStr(sBoldCell('          и изменение ячеек с наименованием модельного ряда / модели с опцией "/1"!'));
    AddStr(sBoldCell('          Ячейки, области, листы нельзя удалять, сортировать, форматировать и т.п.!'));
    AddXmlSheetEnd(Result, 0, 0);

    TdtIBD:= cntsTDT.GetFreeCnt('', '', '', True);
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

    TdtIBS.SQL.Text:= 'select count(*) from (select MS_MF_ID from MODEL_TYPES'+
      ' inner join MODEL_SERIES on MS_ID=MT_MS_ID and MS_PC=1 and MT_DEL=0'+ // кол-во производителей
      ' group by MS_MF_ID)';
    TdtIBS.ExecQuery;
    if not (TdtIBS.Bof and TdtIBS.Eof) then Percent:= 90/TdtIBS.Fields[0].AsInteger;
    TdtIBS.Close;

    TdtIBS.SQL.Text:= 'select MT_MS_ID, MT_MS_DESCR, MT_ID, MT_DESCR, MT_FROM, MT_TO, MT_HP,'+
      ' MS_MF_ID, iif(icn_NewDescr is null, MS_MF_DESCR, icn_NewDescr) MF_DESCR,'+
      ' (select marks from get_str_eng_marks(MT_ID)) marks'+
      ' from MODEL_TYPES inner join MODEL_SERIES on MS_ID=MT_MS_ID and MS_PC=1 and MT_DEL=0'+ // мод.ряды легк.авто
      ' left join import_change_names on ICN_TAB_ID=100 and ICN_KE_KEY=MS_MF_ID'+
      ' order by MS_MF_DESCR, MS_MF_ID, MT_MS_DESCR, MT_MS_ID, MT_DESCR, MT_FROM';
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      manufTD:= TdtIBS.fieldByName('MS_MF_ID').AsInteger;   // код произв. TecDoc
      manufORD:= Manufacturers.GetManufIDByTDcode(manufTD); // ищем ID произв. по коду TecDoc
      if manufORD<1 then manufORD:= 0;
      flMFex:= (manufORD>0) and Manufacturers.ManufExists(manufORD);
      flMF:= flMFex and Manufacturers[manufORD].CheckIsVisible(constIsAuto);
      if flMFex then s:= Manufacturers[manufORD].Name
      else s:= TdtIBS.fieldByName('MF_DESCR').AsString;

      AddXmlSheetBegin(Result, s, Ncolumns, Widths);
//                        0                  1                  2                    3      индекс поля ADOTable
      AddStr(sHeadCell('Опция')+sHeadCell('Произв.')+sHeadCell('М/ряд')+sHeadCell('Модель')+
//                 4                  5               6                   7                 индекс поля ADOTable
          sHeadCell('От')+sHeadCell('До')+sHeadCell('Л/с')+sHeadCell('Марк/двиг')+
//                    8                  9                 10                 11            индекс поля ADOTable
          sTxtCell('mf_TD')+sTxtCell('mf_ORD')+sTxtCell('ml_TD')+sTxtCell('ml_ORD')+
//                    12                 13                  14                             индекс поля ADOTable
          sTxtCell('mod_TD')+sTxtCell('mod_ORD')+sHeadCell('Результат')+
//                    15                  16                17                18            индекс поля ADOTable
          sHeadCell('Тех.об.')+sHeadCell('кВт')+sHeadCell('Цил.')+sHeadCell('Клап.')+
//                    19                      20                      21                    индекс поля ADOTable
          sHeadCell('Тип кузова')+sHeadCell('Тип привода')+sHeadCell('Тип двигателя')+
//                    22                        23                          24              индекс поля ADOTable
          sHeadCell('Тип топлива')+sHeadCell('Система впрыска')+sHeadCell('Тип торм.системы')+
//                    25                        26                          27              индекс поля ADOTable
          sHeadCell('Торм.система')+sHeadCell('Тип катализат.')+sHeadCell('Вид кор.передач'));

      AddStr(fnIfStr(flMF, sCBoldCell('/2'), EmptyStrCell)+fnIfStr(flMF, sBoldCell(s), sTxtCell(s))+
             EmptyStrCell(6)+sIntCell(manufTD)+sIntCell(manufORD)+EmptyIntCell(4));

      while not TdtIBS.Eof and (TdtIBS.fieldByName('MS_MF_ID').AsInteger=manufTD) do begin
        mlTD:= TdtIBS.fieldByName('MT_MS_ID').AsInteger;       // код мод.ряда TecDoc
        if not flMFex then mlORD:= 0
        else mlORD:= Manufacturers[manufORD].GetMfMLineIDByTDcode(mlTD); // ищем ID мод.ряда по коду TecDoc
        if mlORD<1 then mlORD:= 0;
        flML:= (mlORD>0) and ModelLines.ModelLineExists(mlORD) and ModelLines[mlORD].IsVisible;

        if (mlORD>0) and ModelLines.ModelLineExists(mlORD) then
          s:= ModelLines[mlORD].Name // наше наименование
        else s:= TdtIBS.fieldByName('MT_MS_DESCR').AsString;
        AddStr(fnIfStr(flML, sCBoldCell('/2'), EmptyStrCell)+EmptyStrCell+
               fnIfStr(flML, sBoldCell(s), sTxtCell(s))+EmptyStrCell(5)+
               EmptyIntCell(2)+sIntCell(mlTD)+sIntCell(mlORD)+EmptyIntCell(2));

        while not TdtIBS.Eof and (TdtIBS.fieldByName('MT_MS_ID').AsInteger=mlTD) do begin
          modTD  := TdtIBS.fieldByName('MT_ID').AsInteger;   // код модели TecDoc
          nameTD := TdtIBS.fieldByName('MT_DESCR').AsString; // наимен. модели TecDoc
          marksTD:= TdtIBS.fieldByName('marks').AsString;    // Марк/двиг модели TecDoc (информ.поле)
          tdFrom := TdtIBS.fieldByName('MT_FROM').AsInteger; // от
          tdTo   := TdtIBS.fieldByName('MT_TO').AsInteger;   // до
          tdHP   := TdtIBS.FieldByName('MT_HP').AsInteger;   // Мощность ЛС

          if not flML then modORD:= 0
            else modORD:= ModelLines[mlORD].GetMLModelIDByTDcode(modTD); // ищем ID модели по коду TecDoc
          if modORD<1 then modORD:= 0;
          flMod:= (modORD>0) and Models.ModelExists(modORD);
          if flMod then s:= Models[modORD].Name else s:= nameTD; // наше наименование или TD
          flMod:= flMod and Models[modORD].IsVisible; // выделяем только видимые
          if flMod then begin
            mdl:= Models[modORD];
            mps:= mdl.Params;
            tim:= TypesInfoModel;
            AddStr(sCBoldCell('/2')+EmptyStrCell(2)+sBoldCell(s)+                            // наимен. модели
              fnIfStr(mps.pYStart<1, EmptyStrCell, sBoldCell(IntToStr(mps.pYStart)+          // от
                fnMakeAddCharStr(IntToStr(mps.pMStart), 2, '0')))+
              fnIfStr(mps.pYEnd<1, EmptyStrCell, sBoldCell(IntToStr(mps.pYEnd)+              // до
                fnMakeAddCharStr(IntToStr(mps.pMEnd), 2, '0')))+
              fnIfStr(mps.pHP<1, EmptyStrCell, sBoldCell(IntToStr(mps.pHP)))+                // Мощность ЛС
              fnIfStr(mdl.EngLinks.LinkCount<1, EmptyStrCell,sBoldCell(mdl.MarksCommaText))+ // Марк/двиг
              EmptyIntCell(4)+sIntCell(modTD)+sIntCell(modORD)+EmptyStrCell+
              fnIfStr(mps.pCCM       <1, EmptyStrCell, sBoldCell(IntToStr(mps.pCCM)))+       // Тех.об.куб.см.
              fnIfStr(mps.pKW        <1, EmptyStrCell, sBoldCell(IntToStr(mps.pKW)))+        // Мощность кВт
              fnIfStr(mps.pCylinders <1, EmptyStrCell, sBoldCell(IntToStr(mps.pCylinders)))+ // Количество цилиндров
              fnIfStr(mps.pValves    <1, EmptyStrCell, sBoldCell(IntToStr(mps.pValves)))+    // Количество клапанов
              fnIfStr(mps.pBodyID    <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pBodyID].Name))+     // тип кузова
              fnIfStr(mps.pDriveID   <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pDriveID].Name))+    // тип привода
              fnIfStr(mps.pEngTypeID <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pEngTypeID].Name))+  // тип двигателя
              fnIfStr(mps.pFuelID    <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pFuelID].Name))+     // тип топлива
              fnIfStr(mps.pFuelSupID <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pFuelSupID].Name))+  // система впрыска
              fnIfStr(mps.pBrakeID   <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pBrakeID].Name))+    // тип тормозной системы
              fnIfStr(mps.pBrakeSysID<1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pBrakeSysID].Name))+ // тип тормозная система
              fnIfStr(mps.pCatalID   <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pCatalID].Name))+    // тип катализатора
              fnIfStr(mps.pTransID   <1, EmptyStrCell, sBoldCell(tim.InfoItems[mps.pTransID].Name)));   // тип коробки передач
          end else
            AddStr(EmptyStrCell(3)+sTxtCell(s)+
              fnIfStr(tdFrom<1, EmptyStrCell, sTxtCell(IntToStr(tdFrom)))+
              fnIfStr(tdTo<1, EmptyStrCell, sTxtCell(IntToStr(tdTo)))+
              fnIfStr(tdHP<1, EmptyStrCell, sTxtCell(IntToStr(tdHP)))+
              sTxtCell(marksTD)+EmptyIntCell(4)+sIntCell(modTD)+sIntCell(modORD));
          TdtIBS.Next;
          CheckStopExecute(pUserID, ThreadData);
        end;  // цикл по мод.ряду mlTD
      end; // цикл по произв. manufTD
      AddXmlSheetEnd(Result, 1, 2);
      SetExecutePercent(pUserID, ThreadData, Percent);
    end;
    AddXmlBookEnd(Result);
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFreeIBSQL(TdtIBS);
    cntsTdt.SetFreeCnt(TdtIBD, True);
    Setlength(Widths, 0);
  end;
end;
//======================== 36-stamp - поиск артикулов TDT для инфо-групп Гроссби
procedure prGetArticlesINFOgrFromTDT(pUserID: Integer;
          pFileName: String; ThreadData: TThreadData=nil);
const nmProc = 'fnGetArticlesINFOgrFromTDT'; // имя процедуры/функции
      DelimChars = [' ', '=', '/', '\']; // разделители в наименовании товара
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    lstSups, lstCross, lstNotArtWares, lstSearch: TStringList;
    iSup, kodMF, i, ii, j, jj, iCount: Integer;
    Brand, Article, GAdescr, cross, SupFrom, WareName, s, ss, sbs, ssbs: String;
    tcodes: TTwoCodes;
    arMF: Tai;
    arSups: Tas;
    Percent: real;
    Ware: TWareInfo;
    wBrand: TBrandItem;
    arLstWareArticles: TASL;
    flSkipArt, fl, flSingle, flSupFrom, flSupsOnly, flSupsAll: Boolean;
    //--------------------- проверка "чистого" вхождения артикула в наименование
    function CheckArtInName(sArt, sName: String): Boolean;
    var ipos, ibefore, iafter: Integer;
    begin
      Result:= (sArt=sName);
      if Result then Exit;
      ipos:= pos(sArt, sName);    // позиция начала артикула
      if (ipos<1) then Exit;      // наименование не содержит артикула
      ibefore:= ipos-1;           // позиция перед артикулом
      if (ibefore>0) and                    // если не разделитель - не подходит
        not SysUtils.CharInSet(sName[ibefore], DelimChars) then Exit;
      iafter:= ipos+length(sArt); // 1-я позиция после артикула
      if (iafter<=length(sName)) and        // если не разделитель - не подходит
        not SysUtils.CharInSet(sName[iafter], DelimChars) then Exit;
      inc(iafter);                // 2-я позиция после артикула
      if (iafter<=length(sName)) and        // если не разделитель - не подходит
        not SysUtils.CharInSet(sName[iafter], DelimChars) then Exit;
      Result:= true;
    end;
    //------------------------------------- поиск соответствия с товаром Гроссби
    function FindWaresByArticle: String;
    var ii, br: Integer;
    begin
      Result:= ';';
      if lstSearch.Count>0 then lstSearch.Clear;
      s:= AnsiUpperCase(Article);                      // UPPER артикула
      sbs:= StringReplace(s, ' ', '', [rfReplaceAll]); // артикул без пробелов
      if (kodMF=531) and (copy(s, 1, 3)='AVX') then begin // CONTITECH
        ss:= fnGetAfter('AVX', s);
        ssbs:= fnGetAfter('AVX', sbs);
      end else ss:= '';
      for ii:= 0 to lstNotArtWares.Count-1 do begin // идем по списку непривязанных товаров
        Ware:= TWareInfo(lstNotArtWares.Objects[ii]);
        if lstCross.Find(Ware.Name, br) then Continue; // товар есть в аналогах
        br:= Ware.WareBrandID;      // проверяем соответствие брендов
        if {not Ware.IsINFOgr and} (br>1) and Cache.WareBrands.ItemExists(br) then begin  // ???
          wBrand:= Cache.WareBrands[br];
          if fnInIntArray(kodMF, wBrand.TDMFcodes)<0 then Continue; // бренд не подходит
        end;
        fl:= CheckArtInName(s, Ware.WareSupName) or // ищем артикул
             CheckArtInName(sbs, Ware.WareSupName) or
             CheckArtInName(s, Ware.Name) or CheckArtInName(sbs, Ware.Name);
        if not fl and (ss<>'') then // ищем артикул CONTITECH без префикса
          fl:= CheckArtInName(ss, Ware.WareSupName) or
               CheckArtInName(ssbs, Ware.WareSupName) or
               CheckArtInName(ss, Ware.Name) or CheckArtInName(ssbs, Ware.Name);
        if not fl then Continue;
        if flSingle and (lstSearch.Count>0) then begin
          lstSearch.Clear; // если нужно 1 соответствие и есть еще - не подходит
          Exit;
        end;
        lstSearch.Add(Ware.Name+';'+Ware.PgrName);
      end;
      if lstSearch.Count>0 then Result:= lstSearch[0];
    end;
    //---------------------------------------------- запись строки в файл
    procedure SaveStrToFile;
    var ii: Integer;
    begin
      WareName:= FindWaresByArticle; // ищем соответствие с артикулом
      cross:= '';
      if lstCross.Count>1 then lstCross.Sort;
      for ii:= 0 to lstCross.Count-1 do cross:= cross+lstCross[ii]+';';
      prMessageLOGn(WareName+';'+Brand+';'+Brand+' '+Article+';'+GAdescr+';'+cross, pFileName);
      if (lstSearch.Count>1) then // если > 1 соответствия
        for ii:= 1 to lstSearch.Count-1 do prMessageLOGn(lstSearch[ii]+';;;;', pFileName);
      Inc(iCount);
      lstCross.Clear;
      lstCross.Capacity:= 100;
    end;
    //----------------------------------------------
begin
  lstSups:= fnCreateStringList(False, 100); // список брендов
  lstCross:= fnCreateStringList(True, 100); // список товаров-аналогов 1 артикула, сортированный (для Find)
  lstNotArtWares:= fnCreateStringList(False, 1000); // список непривязанных товаров
  lstSearch:= fnCreateStringList(True, 10); // список товаров, найденных по артикулу
  TdtIBS:= nil;
  Percent:= 1;
  iCount:= 0;
  SetLength(arMF, 0);
  SetLength(arLstWareArticles, 0);

  SupFrom:= GetIniParam(nmIniFileBOB, 'reports', 'SupFrom'); // условия выборки брендов
  s:= GetIniParam(nmIniFileBOB, 'reports', 'SupsOnly');
  if s='' then SetLength(arSups, 0) else arSups:= fnSplitString(s, ',');
  flSingle:= GetIniParamInt(nmIniFileBOB, 'reports', 'SearchSingleWare')=1;
  flSupFrom:= (SupFrom<>'');
  flSupsOnly:= (length(arSups)>0);
  flSupsAll:= (not flSupFrom and not flSupsOnly);

  try
    TdtIBD:= cntsTDT.GetFreeCnt('', '', '', True);
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));

    s:= 'Проверить товар Gr;Группа товара Gr;Бренд TD;Бренд TD + артикул TD;Предметная группа TD;Аналоги-товары Gr (по TD);';
    prMessageLOGn(s, pFileName);
    SetExecutePercent(pUserID, ThreadData, Percent);
    try                                         // выбираем бренды для обработки
      TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
      TdtIBS.SQL.Text:= 'select d.ds_mf_id, d.DS_ID,'+
        ' iif(ICN_NEWDESCR is null, d.DS_BRA, ICN_NEWDESCR) bra from data_suppliers d'+
        ' left join IMPORT_CHANGE_NAMES on ICN_TAB_ID=100 and ICN_KE_KEY=d.DS_MF_ID';
      TdtIBS.ExecQuery;
      while not TdtIBS.Eof do begin
        s:= TdtIBS.FieldByName('bra').AsString;
        if flSupsAll or (flSupFrom and (s>=SupFrom))
          or (flSupsOnly and (fnInStrArray(s, arSups, False)>-1)) then
          lstSups.AddObject(s, TTwoCodes.Create(TdtIBS.FieldByName('DS_ID').AsInteger,      // ID1
                                                TdtIBS.FieldByName('ds_mf_id').AsInteger)); // ID2
        CheckStopExecute(pUserID, ThreadData); // проверка остановки процесса или системы
        TdtIBS.Next;
      end;
      TdtIBS.Close;

      Percent:= 3;
      SetExecutePercent(pUserID, ThreadData, Percent);
      if lstSups.Count>1 then begin
        lstSups.Sort;
        Percent:= 90/lstSups.Count; // процент на 1-го произв.
      end;
      //------------------ готовим инструменты для поиска артикулов
      SetLength(arMF, lstSups.Count);              // массив кодов MF брендов TD
      SetLength(arLstWareArticles, lstSups.Count); // массив списков артикулов с товарами Grossbee, по брендам
      for i:= 0 to lstSups.Count-1 do begin
        arLstWareArticles[i]:= fnCreateStringList(False, dupAccept, 1000); // инициируем
        arMF[i]:= TTwoCodes(lstSups.Objects[i]).ID2;                       // заполняем массив (ds_mf_id)
      end;
      //-------------------- заполняем списки для поиска
      for i:= 1 to High(Cache.arWareInfo) do if Cache.WareExist(i) then begin
        Ware:= Cache.GetWare(i);
        if Ware.IsArchive or (Ware.PgrID<1) then Continue; // архивный товар пропускаем
        if (Ware.ArtSupTD>0) and (Ware.ArticleTD<>'') then begin
          j:= fnInIntArray(Ware.ArtSupTD, arMF);    // артикул с привязанным товаром - в список бренда
          if j>-1 then arLstWareArticles[j].AddObject(Ware.ArticleTD, Ware);
        end else if Ware.IsAUTOWare then             // только авто-товары                             ???
          lstNotArtWares.AddObject(Ware.Name, Ware); // непривязанный товар - в отдельный список
      end;
      for i:= 0 to lstSups.Count-1 do begin // сортируем списки артикулов
        if arLstWareArticles[i].Count>1 then arLstWareArticles[i].Sort;
        arLstWareArticles[i].Sorted:= True; // устанавливаем сортировку (для Find)
      end;

      TdtIBS.SQL.Text:= 'select RcrossMF, RcrossNR, Rdescr from get_SupArticlesINFOgr(:xDs)';
      // процедура возвращает порции: строку с артикулом и группой, затем строки с кроссами этого артикула

      for iSup:= 0 to lstSups.Count-1 do try // идем по брендам
        tcodes:= TTwoCodes(lstSups.Objects[iSup]);
        kodMF:= tcodes.ID2; // код MF бренда
        Brand:= lstSups[iSup];
        prMessageLOGS(nmProc+': загрузка артикулов '+Brand, 'import_test', False); // debug
        lstCross.Clear;
        lstCross.Capacity:= 100;
        flSkipArt:= False;
        try
          with TdtIBS.Transaction do if not InTransaction then StartTransaction;
          TdtIBS.ParamByName('xDs').AsInteger:= tcodes.ID1;
          TdtIBS.ExecQuery; // вынимаем артикулы бренда без товаров и кроссы из TD
          while not TdtIBS.Eof do begin
            if (TdtIBS.FieldByName('RcrossMF').AsInteger=0) then begin // строка с артикулом и группой

              if lstCross.Count>0 then SaveStrToFile; // если есть товары-аналоги предыдущего артикула

              Article:= TdtIBS.FieldByName('RcrossNR').AsString; // следующий артикул
              WareName:= '';                 // проверяем артикул на привязанный товар (по Grossbee, на всяк.случай)
              flSkipArt:= arLstWareArticles[iSup].Find(Article, ii); // если нашли - артикул пропускаем
              if not flSkipArt then GAdescr:= TdtIBS.FieldByName('Rdescr').AsString;

            end else if (TdtIBS.FieldByName('Rdescr').AsString='') // строка с кроссом TD
              and not flSkipArt then begin // признак непривязанного артикула

              cross:= TdtIBS.FieldByName('RcrossNR').AsString;  // артикул кросса
              jj:= fnInIntArray(TdtIBS.FieldByName('RcrossMF').AsInteger, arMF); // определяем индекс бренда кросса
              if (jj>-1) and arLstWareArticles[jj].Find(cross, ii) then // если нашли артикул - перебираем его товары
                while (ii<arLstWareArticles[jj].Count) and (arLstWareArticles[jj][ii]=cross) do begin
                  Ware:= TWareInfo(arLstWareArticles[jj].Objects[ii]);
                  if not Ware.IsINFOgr then  // здесь инфо-товары пропускаем
                    if not lstCross.Find(Ware.Name, j) then // проверяем на дубляж
                      lstCross.AddObject(Ware.Name, Pointer(Ware.ID));
                  inc(ii);
                end; // while (ii<...Count) and (...=cross)
            end;
            CheckStopExecute(pUserID, ThreadData); // проверка остановки процесса или системы
            TdtIBS.Next;
          end;
        finally
          TdtIBS.Close;
        end;
        if lstCross.Count>0 then SaveStrToFile; // если есть товары-аналоги последнего артикула
        SetExecutePercent(pUserID, ThreadData, Percent);
      except
        on E: EBOBError do begin
          cross:= 'загрузка остановлена - ';
          prMessageLOGS(nmProc+': '+cross+'('+Brand+') '+E.Message, 'import');
          prMessageLOGn(cross+'ошибка при загрузке артикулов бренда '+Brand, pFileName);
          break;
        end;
        on E: Exception do begin
          prMessageLOGS(nmProc+': ('+Brand+') '+E.Message, 'import');
          prMessageLOGn('ошибка при загрузке артикулов бренда '+Brand, pFileName);
        end;
      end; // for iSup
      if iCount<1 then raise Exception.Create(MessText(mtkNotFoundData));
    finally
      prFreeIBSQL(TdtIBS);
      cntsTdt.SetFreeCnt(TdtIBD, True);
      prFree(lstSups);
      prFree(lstCross);
      prFree(lstNotArtWares);
      prFree(lstSearch);
      for i:= 0 to Length(arLstWareArticles) do prFree(arLstWareArticles[i]);
      SetLength(arLstWareArticles, 0);
      SetLength(arMF, 0);
      SetLength(arSups, 0);
    end;
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end;
end;

//******************************************************************************
//                   импорт данных из fb_tdt.fdb в ib_ord.gdb
//******************************************************************************
//================================== загрузка моделей авто из TDT из файла Excel
procedure prSetNewAutoMfMlModFromTDT(UserID: integer; FileName: string; ThreadData: TThreadData=nil);
const nmProc = 'prSetNewAutoMfMlModFromTDT'; // имя процедуры/функции
var mlORD, mlTD, mORD, mTD, mfORD, mfTD, iAdd, iErr, iUpd, ii,
      tdFrom, tdTo, mFrom, yFrom, mTo, yTo, iLine, SheetCount, SheetID, rows: integer;
    fVis, fTop, fAddMf, fAddMl, fUpdMf, fUpdMl, fAddMod, fUpdMod: Boolean;
    mName, mlName, mfName, ss, s, SheetName: string;
    arMpsORD: TarMps;
    TdtIBD: TIBDatabase;
    TdtIBS, TdtIBSm: TIBSQL;
    KeyTabs: TarKeyTabs; // Tai: индекс - код TDT, значение - код ORD
    mps: TModelParams;
    marks: TStringList;
    Percent: real;
    XL: TExcelApplication;
    WorkBook: Excel_TLB._Workbook;
    WorkSheet: Excel_TLB._Worksheet;
begin
  TdtIBS:= nil;
  TdtIBSm:= nil;
  TdtIBD:= nil;
  mps:= nil;
  XL:= nil;
  WorkBook:= nil;
  marks:= TStringList.Create;
  SetLength(KeyTabs, 9);
  SetExecutePercent(UserID, ThreadData, 1);
  with Cache.FDCA do try try // заполняем имена полей для поиска соответствий
    FillKeTabRecNf(0, 'MT_BT' , KeyTabs);  // Тип кузова
    FillKeTabRecNf(1, 'MT_DR' , KeyTabs);  // Тип привода
    FillKeTabRecNf(2, 'MT_ENG', KeyTabs);  // Тип двигателя
    FillKeTabRecNf(3, 'MT_FT' , KeyTabs);  // Тип топлива
    FillKeTabRecNf(4, 'MT_FF' , KeyTabs);  // Система впрыска
    FillKeTabRecNf(5, 'MT_BRT', KeyTabs);  // Тип тормозной системы
    FillKeTabRecNf(6, 'MT_BRS', KeyTabs);  // Тормозная система
    FillKeTabRecNf(7, 'MT_CT' , KeyTabs);  // Тип катализатора
    FillKeTabRecNf(8, 'MT_TT' , KeyTabs);  // Вид коробки передач

    TdtIBD:= cntsTDT.GetFreeCnt('', '', '', True);
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));

    TdtIBSm:= fnCreateNewIBSQL(TdtIBD, 'TdtIBSm_'+nmProc, -1, tpRead); // для маркировок (GetEngMarks)
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

    FillarKeyTabsFromTDT(KeyTabs, 120, TdtIBS); // вынимаем в KeyTabs нужные списки TDT

    try
      OpenWorkBookNotVisible(FileName, XL, WorkBook); // открыть файл Excel для импорта
      SheetCount:= WorkBook.Worksheets.Count; //количество листов excel
      Percent:= 90/SheetCount;
  //      for i:= 1 to SheetCount do prMessageLOGS(nmProc+': '+(WorkBook.Sheets.Item[i] as Excel_TLB._Worksheet).Name, 'import', False);
      for SheetID:= 1 to SheetCount do try
        WorkSheet:= WorkBook.Sheets.Item[SheetID] as Excel_TLB._Worksheet;
        SheetName:= AnsiUpperCase(WorkSheet.Name);
        if pos('ОПИСАНИЕ', SheetName)>0 then Continue; // пропускаем лист "Описание"
        if pos('ЛИСТ', SheetName)>0 then Continue;     // пропускаем стандартные листы

        GetWorkSheetCounts(WorkSheet, rows, ii); // получить кол-во строк и столбцов на листе
        if rows<2 then Continue;                // переходим к следующему листу
        if ii<15 then // проверяем кол-во столбцов
          raise Exception.Create(MessText(mtkNotEnoughParams)+' - мало столбцов');
        CheckStopExecute(UserID, ThreadData);

        fAddMl:= False;
        fUpdMl:= False;
        fAddMf:= False;
        fUpdMf:= False;
        mfTD:= 0;
        mfORD:= 0;
        mlTD:= 0;
        mlORD:= 0;
        mORD:= 0;
        iAdd:= 0;
        iErr:= 0;
        iUpd:= 0;
  //     1          2          3         4         5      6      7          8      индекс ячейки
  // ('Опция')+('Произв.')+('М/ряд')+('Модель')+('От')+('До')+('Л/с')+('Марк/двиг')+
  //     9         10        11         12         13         14         15        индекс ячейки
  // ('mf_TD')+('mf_ORD')+('ml_TD')+('ml_ORD')+('mod_TD')+('mod_ORD')+('result')

        for iLine:= 2 to rows do try // считываем строки файла (1-я строка - заголовок)
  //--------------------------------------------------------- строка производителя
          s:= GetCellStrValue(WorkSheet, CellSigns[2], iLine);
          if (s<>'') then begin
            mfTD:= GetCellIntValue(WorkSheet, CellSigns[9], iLine);  // код TecDoc произв.
            mfORD:= GetCellIntValue(WorkSheet, CellSigns[10], iLine); // ID произв.
            mfName:= s;
            fAddMf:= True;
            fUpdMf:= True;  // оба флага = True - сигнал проверки
            Continue;
          end;
  //-------------------------------------------------------------- строка мод.ряда
          s:= GetCellStrValue(WorkSheet, CellSigns[3], iLine);
          if (s<>'') then begin
            mlTD := GetCellIntValue(WorkSheet, CellSigns[11], iLine); // код TecDoc мод.ряда
            mlORD:= GetCellIntValue(WorkSheet, CellSigns[12], iLine); // ID мод.ряда
            mlName:= s;
            fAddMl:= True;
            fUpdMl:= True;  // оба флага = True - сигнал проверки
            Continue;
          end;
  //---------------------------------------------------------------- строка модели
          s:= GetCellStrValue(WorkSheet, CellSigns[4], iLine);
          if (s='') then Continue;  // если не строка модели - пропускаем

          ss:= GetCellStrValue(WorkSheet, CellSigns[1], iLine);
          if (ss<>'/1') then Continue; // если опция <> "/1" - пропускаем

  //------------------------------------------------------ обработка строки модели
          mTD := GetCellIntValue(WorkSheet, CellSigns[13], iLine); // код TecDoc модели
          mORD:= GetCellIntValue(WorkSheet, CellSigns[14], iLine); // ID модели
          mName:= s;

          if ((mORD<1) and (mTD<1)) then   // не определена модель
            raise Exception.Create(MessText(mtkNotValidParam)+' - модель');
          if ((mlORD<1) and (mlTD<1)) then // не определен мод.ряд
            raise Exception.Create(MessText(mtkNotValidParam)+' - мод.ряд');
          if ((mfORD<1) and (mfTD<1)) then // не определен произв.
            raise Exception.Create(MessText(mtkNotValidParam)+' - произв.');

          if fAddMf and fUpdMf then begin // 2 флага = True - сигнал проверки произв.
            if not fAddMf and (mfORD<1) then
              mfORD:= Manufacturers.GetManufIDByTDcode(mfTD);
            fAddMf:= not Manufacturers.ManufExists(mfORD);     // надо добавлять
            fUpdMf:= not fAddMf and                            // надо открыть видимость
              (not Manufacturers[mfORD].CheckIsTypeSys(constIsAuto) or
              not Manufacturers[mfORD].CheckIsVisible(constIsAuto));
          end;

          if fAddMl and fUpdMl then begin // 2 флага = True - сигнал проверки мод.ряда
            if not fAddMf and (mlORD<1) then
              mlORD:= Manufacturers[mfORD].GetMfMLineIDByTDcode(mlTD);
            fAddMl:= not ModelLines.ModelLineExists(mlORD);          // надо добавлять
            fUpdMl:= not fAddMl and not ModelLines[mlORD].IsVisible; // надо редактировать
              // если мод.ряд был невидим - проверяем наименование
            if fUpdMl then fUpdMl:= fUpdMl or (ModelLines[mlORD].Name<>mlName);
          end;

          if not fAddMl and (mORD<1) then                    // проверяем модель
            mORD:= ModelLines[mlORD].GetMLModelIDByTDcode(mTD);
          fAddMod:= (mORD<1) or not Models.ModelExists(mORD);   // надо добавлять
          fUpdMod:= not fAddMod and not Models[mORD].IsVisible; // надо редактировать
            // если модель была невидима - проверяем наименование
          if fUpdMod then fUpdMod:= fUpdMod or (Models[mORD].Name<>mName);

          if not fAddMod and not fUpdMod then begin
            SetCellStrValue(WorkSheet, CellSigns[1], iLine, '/2');
            SetCellStrValue(WorkSheet, CellSigns[15], iLine, 'модель уже есть'); // вписываем результат
            Continue;
          end;

  //-------------------------------------------------- отрабатываем редактирование
          fVis:= True;
          ss:= '';
          if fUpdMf then begin //--------------- если надо - редактируем произв.
            with Manufacturers[mfORD] do begin
              fTop:= CheckIsTop(constIsAuto);
  //                if mfName='' then
              mfName:= Name;
            end;
            s:= Manufacturers.ManufEdit(mfORD, constIsAuto, UserID, fTop, fVis, mfName, mfTD);
            if s=MessText(mtkNotParams) then s:= ''
            else if (s='') then s:= 'уст.видим.произв.'
            else raise Exception.Create(s);
            if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;
            fUpdMf:= False;
          end; // отредактировали произв.

          if fUpdMl then begin //--------------- если надо - редактируем мод.ряд
            with ModelLines[mlORD] do begin
              if mlName='' then mlName:= Name;
              yFrom:= YStart;
              mFrom:= MStart;
              yTo:= YEnd;
              mTo:= MEnd;
              fTop:= IsTop;
            end;
            s:= Manufacturers[mfORD].ModelLineEdit(mlORD, yFrom, mFrom,
              yTo, mTo, UserID, fTop, fVis, mlName, mlTD);
            if s=MessText(mtkNotParams) then s:= ''
            else if (s='') then s:= 'уст.видим.мод.ряда'
            else raise Exception.Create(s);
            if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;
            fUpdMl:= False;
          end; // отредактировали мод.ряд

          if fUpdMod then with Models[mORD] do begin //------ редактируем модель
            if (Name<>mName) then
              s:= ModelEdit(mName, fVis, IsTop, UserID, Params)
            else s:= SetModelVisible(fVis);
            if s=MessText(mtkNotParams) then s:= ''
            else if (s='') then begin
              s:= 'устан.видим.модели';
              inc(iUpd);
            end else raise Exception.Create(s);
            if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;

  //------------------------------------------------------ отрабатываем добавление
          end else if fAddMod then try
            with TdtIBS.Transaction do if not InTransaction then StartTransaction;
            if TdtIBS.SQL.Text='' then
              TdtIBS.SQL.Text:= 'select MT_MS_ID, MT_MS_DESCR, MT_ID, MT_DESCR, MS_MF_ID,'+
                ' iif(icn_NewDescr is null, MS_MF_DESCR, icn_NewDescr) MF_DESCR,'+
                ' MS_FROM, MS_TO, MT_FROM, MT_TO, MT_KW, MT_HP, MT_CC_TEC, MT_CYL, MT_VLV,'+
                ' (select key_to from get_key_code (120, MT_BT, "MT_BT")) MT_BT,'+    // Тип кузова
                ' (select key_to from get_key_code (120, MT_DR, "MT_DR")) MT_DR,'+    // Тип привода
                ' (select key_to from get_key_code (120, MT_ENG, "MT_ENG")) MT_ENG,'+ // Тип двигателя
                ' (select key_to from get_key_code (120, MT_FT, "MT_FT")) MT_FT,'+    // Тип топлива
                ' (select key_to from get_key_code (120, MT_FF, "MT_FF")) MT_FF,'+    // Система впрыска
                ' (select key_to from get_key_code (120, MT_BRT, "MT_BRT")) MT_BRT,'+ // Тип тормозной системы
                ' (select key_to from get_key_code (120, MT_BRS, "MT_BRS")) MT_BRS,'+ // Тормозная система
                ' (select key_to from get_key_code (120, MT_CT, "MT_CT")) MT_CT,'+    // Тип катализатора
                ' (select key_to from get_key_code (120, MT_TT, "MT_TT")) MT_TT'+     // Вид коробки передач
                ' from MODEL_TYPES left join MODEL_SERIES on MS_ID=MT_MS_ID'+
                ' left join import_change_names on ICN_TAB_ID=100 and ICN_KE_KEY=MS_MF_ID'+
                ' where MT_ID=:mt';
            TdtIBS.ParamByName('mt').AsInteger:= mTD;
            TdtIBS.ExecQuery;
            if (TdtIBS.Bof and TdtIBS.Eof) then
              raise Exception.Create(MessText(mtkNotValidParam)+' - модель TD');
            if mfTD<>TdtIBS.fieldByName('MS_MF_ID').AsInteger then
              raise Exception.Create(MessText(mtkNotValidParam)+' - произв. TD');
            if mlTD<>TdtIBS.fieldByName('MT_MS_ID').AsInteger then
              raise Exception.Create(MessText(mtkNotValidParam)+' - мод.ряд TD');

            if fAddMf then begin //--------------- если надо - добавляем произв.
  //              if mfName='' then
                mfName:= TdtIBS.fieldByName('MF_DESCR').AsString;  // наимен. произв.
              fTop:= False;
              s:= Manufacturers.ManufAdd(mfORD, mfName, constIsAuto, UserID, fTop, fVis, mfTD);
              if s=MessText(mtkNotParams) then s:= ''
              else if (s='') then s:= 'доб.произв.'
              else raise Exception.Create(s);
              if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;
              fAddMf:= False;
              if (mfORD<1) then // не определен ID произв.
                raise Exception.Create(MessText(mtkNotValidParam)+' - произв.');
            end; // добавили произв.

            if fAddMl then begin //--------------- если надо - добавляем мод.ряд
              if mlName='' then
                mlName:= TdtIBS.fieldByName('MT_MS_DESCR').AsString;    // наимен. мод.ряда
              tdFrom := TdtIBS.fieldByName('MS_FROM').AsInteger;      // от
              tdTo:= TdtIBS.fieldByName('MS_TO').AsInteger;           // до
              if tdFrom>0 then yFrom:= tdFrom div 100 else yFrom:= 0; // Год начала выпуска
              if yFrom>0 then mFrom:= tdFrom mod 100 else mFrom:= 0;  // Месяц начала выпуска
              if tdTo>0 then yTo:= tdTo div 100 else yTo:= 0;         // Год конца выпуска
              if yTo>0 then mTo:= tdTo mod 100 else mTo:= 0;          // Месяц конца выпуска
              fTop:= False;
              s:= Manufacturers[mfORD].ModelLineAdd(mlORD, mlName, constIsAuto,
                mFrom, yFrom, mTo, yTo, UserID, fTop, fVis, mlTD);
              if s=MessText(mtkNotParams) then s:= ''
              else if (s='') then s:= 'доб.мод.ряд'
              else raise Exception.Create(s);
              if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;
              fAddMl:= False;
              if (mlORD<1) then // не определен ID мод.ряда
                raise Exception.Create(MessText(mtkNotValidParam)+' - мод.ряд');
            end; // добавили мод.ряд

            if mName='' then   //------------------------ добавляем новую модель
              mName:= TdtIBS.fieldByName('MT_DESCR').AsString;  // наимен. модели TecDoc
            tdFrom := TdtIBS.fieldByName('MT_FROM').AsInteger; // от
            tdTo:= TdtIBS.fieldByName('MT_TO').AsInteger;      // до
            if tdFrom>0 then arMpsORD[1]:= tdFrom div 100 else arMpsORD[1]:= 0;      // Год начала выпуска
            if arMpsORD[1]>0 then arMpsORD[0]:= tdFrom mod 100 else arMpsORD[0]:= 0; // Месяц начала выпуска
            if tdTo>0 then arMpsORD[3]:= tdTo div 100 else arMpsORD[3]:= 0;          // Год конца выпуска
            if arMpsORD[3]>0 then arMpsORD[2]:= tdTo mod 100 else arMpsORD[2]:= 0;   // Месяц конца выпуска
            arMpsORD[4]:= TdtIBS.FieldByName('MT_KW').AsInteger;     // Мошность кВт.
            arMpsORD[5]:= TdtIBS.FieldByName('MT_HP').AsInteger;     // Мощность ЛС
            arMpsORD[6]:= TdtIBS.FieldByName('MT_CC_TEC').AsInteger; // Тех. объем куб. см.
            arMpsORD[7]:= TdtIBS.FieldByName('MT_CYL').AsInteger;    // Кол. цилиндров
            arMpsORD[8]:= TdtIBS.FieldByName('MT_VLV').AsInteger;    // Кол. клапанов на одну камеру сгорания
            for ii:= Low(KeyTabs) to High(KeyTabs) do arMpsORD[ii+9]:=  // Тип кузова .. Вид коробки передач
              GetInfoCode(TdtIBS.FieldByName(KeyTabs[ii].FieldNameTDT).AsInteger, UserID, KeyTabs[ii]);
            fTop:= False;
            MakeMpsFromArray(arMpsORD, mps);
            GetEngMarks(mTD, UserID, marks, TdtIBSm); // маркировки двигателей
            s:= Models.ModelAdd(mORD, mName, fVis, fTop, UserID, mlORD, mps, -1, mTD, marks);
            if s=MessText(mtkNotParams) then s:= ''
            else if (s='') then begin
              s:= 'доб.модель';
              inc(iAdd);
            end else raise Exception.Create(s);
            if s<>'' then ss:= ss+fnIfStr(ss='', '', ', ')+s;
          finally
            TdtIBS.Close;
          end; // if fAddMod

          if (GetCellStrValue(WorkSheet, CellSigns[1], iLine)='/1') then  // если опция = "/1" - заменяем на '/2'
            SetCellStrValue(WorkSheet, CellSigns[1], iLine, '/2');
          if (GetCellIntValue(WorkSheet, CellSigns[14], iLine)=0) and (mORD>0) then // если добавили модель
            SetCellIntValue(WorkSheet, CellSigns[14], iLine, mORD);            // вписываем код модели
          if ss<>'' then SetCellStrValue(WorkSheet, CellSigns[15], iLine, ss); // вписываем результат

          CheckStopExecute(UserID, ThreadData);
        except
          on E: EBOBError do begin
            if (E.Message<>'') or (ss<>'') then
              SetCellStrValue(WorkSheet, CellSigns[15], iLine, fnIfStr(ss='', '', ss+', ')+E.Message); // вписываем сообщение
            raise EBOBError.Create('строка '+IntToStr(iLine)+': '+E.Message);
          end;
          on E: Exception do begin
            inc(iErr);
            prMessageLOGS(nmProc+': строка '+IntToStr(iLine)+' листа ['+WorkSheet.Name+'] - '+E.Message, 'import', False);
            if (E.Message<>'') or (ss<>'') then
              SetCellStrValue(WorkSheet, CellSigns[15], iLine, fnIfStr(ss='', '', ss+', ')+E.Message); // вписываем сообщение
          end;
        end; // for iLine:= 2 to rows

        try                           //--------------------------- итоги по листу
          iLine:= rows+1;
          SetCellStrValue(WorkSheet, CellSigns[2], iLine, '----------------------');
          inc(iLine);
          SetCellStrValue(WorkSheet, CellSigns[2], iLine, 'обработано:   '+IntToStr(iLine)+' строк');
          inc(iLine);
          if iAdd>0 then begin
            SetCellStrValue(WorkSheet, CellSigns[2], iLine, 'добавлено :   '+IntToStr(iAdd)+' моделей');
            inc(iLine);
          end;
          if iUpd>0 then begin
            SetCellStrValue(WorkSheet, CellSigns[2], iLine, 'уст.видим.:   '+IntToStr(iUpd)+' моделей');
            inc(iLine);
          end;
          if iErr>0 then begin
            SetCellStrValue(WorkSheet, CellSigns[2], iLine, 'ошибки    :   '+IntToStr(iErr)+' строк');
            inc(iLine);
          end;
          SetCellStrValue(WorkSheet, CellSigns[2], iLine, '----------------------');
        except
          on E: Exception do
            prMessageLOGS(nmProc+': ошибка в итогах на листе ['+WorkSheet.Name+'] '+E.Message, 'import', False);
        end;
       CheckStopExecute(UserID, ThreadData);
       SetExecutePercent(UserID, ThreadData, Percent);
      except
        on E: EBOBError do raise Exception.Create('лист ['+WorkSheet.Name+']: '+E.Message);
        on E: Exception do
          prMessageLOGS(nmProc+': лист ['+WorkSheet.Name+'] '+E.Message, 'import', False);
      end; // for SheetID:= 1 to SheetCount
    finally
      SaveAndCloseWorkBook(XL, WorkBook);
    end;
  except
    on E: Exception do begin
      E.Message:= nmProc+': '+E.Message;
      prMessageLOGS(E.Message, 'import', False);
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFreeIBSQL(TdtIBS);
    prFreeIBSQL(TdtIBSm);
    cntsTDT.SetFreeCnt(TdtIBD, True);
    ClearArKeyTabs(KeyTabs);
    prFreeAndNilStrListWithObj(marks);
    prFree(mps);
  end;
end;
//=========================== загрузка / корректировка узлов авто из файла Excel
procedure prSetNewTreeNodesFromTDT(UserID: Integer; FileName: string; ThreadData: TThreadData=nil);
const nmProc = 'prSetNewTreeNodesFromTDT'; // имя процедуры/функции
var nodeTD, ParTD, nodeORD, mainORD, ParORD, iAdd, SheetID, iErr, iUpd,
      iLine, iVis, SheetCount, rows, ii, iWork: integer;
    NodeName, nameSys, name1, name2, name3, name4, s, SheetName: string;
    nodes: TAutoTreeNodes;
    node: TAutoTreeNode;
    flVis, flGA, flAdd, flUpd: Boolean;
    Percent: Single;
    XL: Excel_TLB.TExcelApplication;
    WorkBook: Excel_TLB._Workbook;
    WorkSheet: Excel_TLB._Worksheet;
begin
  iAdd:= 0;
  iErr:= 0;
  iUpd:= 0;
  iWork:= 0;
  XL:= nil;
  WorkBook:= nil;
  with Cache.FDCA do try
    SetExecutePercent(UserID, ThreadData, 1);
    nodes:= AutoTreeNodesSys[constIsAuto];
    try
      OpenWorkBookNotVisible(FileName, XL, WorkBook); // открыть файл Excel для импорта
      SheetCount:= WorkBook.Worksheets.Count; //количество листов excel
      for SheetID:= 1 to SheetCount do try
        WorkSheet:= WorkBook.Sheets.Item[SheetID] as Excel_TLB._Worksheet;
        SheetName:= AnsiUpperCase(WorkSheet.Name);
        if pos('УЗЛЫ', SheetName)<1 then Continue;    // пропускаем ненужные листы

        GetWorkSheetCounts(WorkSheet, rows, ii); // получить кол-во строк и столбцов на листе
        if rows<2 then Continue;                // переходим к следующему листу
        if ii<13 then // проверяем кол-во столбцов
          raise Exception.Create(MessText(mtkNotEnoughParams)+' - мало столбцов');
        CheckStopExecute(UserID, ThreadData);
        Percent:= 90/rows;
//      1         2             3             4              5          6        7     индекс ячейки
// ('опция')+('уровень 1')+('уровень 2')+('уровень 3')+('уровень 4')+('Код')+('Главн.')+
//      8           9                 10             11        12         13           индекс ячейки
// ('Видим.')+('Конечный узел')+('Сист.наимен.')+('kodTD')+('ParTD')+('Результат')

        for iLine:= 2 to rows do try // считываем строки файла (1-я строка - заголовок)
          CheckStopExecute(UserID, ThreadData);
          SetExecutePercent(UserID, ThreadData, Percent);
          s:= GetCellStrValue(WorkSheet, CellSigns[1], iLine); // определяем опцию
          if (s='') then begin
            flAdd:= False;
            flUpd:= False;
          end else begin
            flAdd:= (s=sActionAdd);
            flUpd:= not flAdd and (s=sActionUpd);
          end;            // если опция отсутствует или недопустима - пропускаем
          if not flAdd and not flUpd then Continue;
          inc(iWork);
//------------------------------------------------------ обработка строки
          name1   := GetCellStrValue(WorkSheet, CellSigns[2], iLine);
          name2   := GetCellStrValue(WorkSheet, CellSigns[3], iLine);
          name3   := GetCellStrValue(WorkSheet, CellSigns[4], iLine);
          name4   := GetCellStrValue(WorkSheet, CellSigns[5], iLine);
          nodeORD := GetCellIntValue(WorkSheet, CellSigns[6], iLine); // код узла
          mainORD := GetCellIntValue(WorkSheet, CellSigns[7], iLine); // код главн.узла
          iVis    := GetCellIntValue(WorkSheet, CellSigns[8], iLine);
          flVis   := iVis=1;
          NodeName:= GetCellStrValue(WorkSheet, CellSigns[9], iLine);
          nameSys := GetCellStrValue(WorkSheet, CellSigns[10], iLine);
          nodeTD  := GetCellIntValue(WorkSheet, CellSigns[11], iLine); // код TecDoc узла
          ParTD   := GetCellIntValue(WorkSheet, CellSigns[12], iLine); // код TecDoc род.узла
          flGA    := NodeName<>'';
          if not flGA then begin // ищем наимен. неконечной ноды
            if (name4<>'') then NodeName:= name4
            else if (name3<>'') then NodeName:= name3
            else if (name2<>'') then NodeName:= name2
            else if (name1<>'') then NodeName:= name1;
          end;

          if flAdd then begin  // новая нода
            if (nodeORD>0) then raise Exception.Create(MessText(mtkNotValidParam)+' - Код');
            if (nodeTD<1) then raise Exception.Create(MessText(mtkNotValidParam)+' - kodTD');
            if (ParTD<0)  then raise Exception.Create(MessText(mtkNotValidParam)+' - ParTD');
            nodeORD:= Nodes.GetNodeIDByTDcodes(nodeTD, ParTD, flGA);
            if (nodeORD>0) and Nodes.NodeExists(nodeORD) then
              raise Exception.Create('такой узел уже есть');

            if ParTD<1 then ParORD:= 0                       // код ORD род.ноды
            else ParORD:= Nodes.GetNodeIDByTDcodes(ParTD, 0, False);
            nodeORD:= 0;

            s:= TreeNodeAdd(constIsAuto, ParORD, mainORD, NodeName, nameSys, UserID,
                 nodeORD, flVis, 0, nodeTD, flGA);       // Добавление узла
            if s<>'' then raise Exception.Create(s);

            node:= Nodes[nodeORD];
            SetCellIntValue(WorkSheet, CellSigns[6], iLine, nodeORD);         // вписываем Код
            if (node.MainCode<>mainORD) then
              SetCellIntValue(WorkSheet, CellSigns[7], iLine, node.MainCode); // вписываем Главн.
            inc(iAdd);
            SetCellStrValue(WorkSheet, CellSigns[1], iLine, '');              // убираем опцию
            SetCellStrValue(WorkSheet, CellSigns[13], iLine, 'добавлен');      // вписываем результат

          end else if flUpd then begin  // корректировка
            if (nodeORD<1) or not Nodes.NodeExists(nodeORD) then
              raise Exception.Create(MessText(mtkNotValidParam)+' - Код = '+IntToStr(nodeORD));
            if not flGA then raise Exception.Create(MessText(mtkNotValidParam)+' - Конечный узел');

            s:= Nodes.NodeEdit(nodeORD, mainORD, iVis, UserID, NodeName, ''); // NameSys не меняем !!!
            if s<>'' then raise Exception.Create(s);
            inc(iUpd);
            SetCellStrValue(WorkSheet, CellSigns[1], iLine, '');             // убираем опцию
            SetCellStrValue(WorkSheet, CellSigns[13], iLine, 'изменен');      // вписываем результат
          end;
        except
          on E: EBOBError do begin
            if (E.Message<>'') then SetCellStrValue(WorkSheet, CellSigns[13], iLine, '!!! '+E.Message); // вписываем сообщение
            raise EBOBError.Create('строка '+IntToStr(iLine)+': '+E.Message);
          end;
          on E: Exception do begin
            inc(iErr);
            prMessageLOGS(nmProc+': строка '+IntToStr(iLine)+' листа ['+WorkSheet.Name+'] - '+E.Message, 'import', False);
            if E.Message<>'' then SetCellStrValue(WorkSheet, CellSigns[13], iLine, '!!! '+E.Message); // вписываем сообщение
          end;
        end; // for iLine:= 2 to rows

        try                         //--------------------------- итоги по листу
          iLine:= rows+1;
          s:= CellSigns[1];
          SetCellStrValue(WorkSheet, s, iLine, '---------------------- '+FormatDateTime(cDateTimeFormatY4N, Now));
          inc(iLine);
          SetCellStrValue(WorkSheet, s, iLine, 'обработано:   '+IntToStr(iWork)+' строк');
          inc(iLine);
          if iAdd>0 then begin
            SetCellStrValue(WorkSheet, s, iLine, 'добавлено:   '+IntToStr(iAdd)+' узлов');
            inc(iLine);
          end;
          if iUpd>0 then begin
            SetCellStrValue(WorkSheet, s, iLine, 'изменено :   '+IntToStr(iUpd)+' узлов');
            inc(iLine);
          end;
          if iErr>0 then begin
            SetCellStrValue(WorkSheet, s, iLine, 'ошибки   :   '+IntToStr(iErr)+' узлов');
            inc(iLine);
          end;
          SetCellStrValue(WorkSheet, s, iLine, '----------------------');
        except
          on E: Exception do
            prMessageLOGS(nmProc+': ошибка в итогах на листе ['+WorkSheet.Name+'] '+E.Message, 'import', False);
        end;
        CheckStopExecute(UserID, ThreadData);
      except
        on E: EBOBError do raise Exception.Create('лист ['+WorkSheet.Name+']: '+E.Message);
        on E: Exception do
          prMessageLOGS(nmProc+': лист ['+WorkSheet.Name+'] '+E.Message, 'import', False);
      end; // for SheetID:= 1 to SheetCount
    finally
      SaveAndCloseWorkBook(XL, WorkBook);
    end;
  except
    on E: Exception do begin
      E.Message:= nmProc+': '+E.Message;
      prMessageLOGS(E.Message, 'import', False);
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
end;
//========== загрузка альтернативных значений инфо-текстов TecDoc из файла Excel
procedure prSetAlternativeInfoTexts(UserID: integer; FileName: string; ThreadData: TThreadData=nil);
const nmProc  = 'prSetAlternativeInfoTexts'; // имя процедуры/функции
      LogTest = 'import_test';
// обрабатываются только строки с опциями 1 и 2
// в обработанных строках в файл FileName в колонку опции записывается результат:
// 0= обработано, 1= уже есть, 21= не найден tmTD, 22= не совп. с текстом в базе (опция 1),
// 24= совпадение текстов в файле, 25= ошибка
var ORD_IBS, ibsN: TIBSQL;
    ORD_IBD: TIBDatabase;
    opt, txt, txtAlt, SheetName, s, mess: String;
    i, iLine, iErr, iAdd, iNot, iEx, iWork, SheetCount, rows, ii: Integer;
    XL: Excel_TLB.TExcelApplication;
    WorkBook: Excel_TLB._Workbook;
    WorkSheet: Excel_TLB._Worksheet;
  //---------------------------------
  procedure SaveToTestLog(iLine: Integer; txt, txtAlt, errtxt: String);
  begin
    prMessageLOGS(nmProc+': строка '+IntToStr(iLine), LogTest, False);
    prMessageLOGS(' errtxt= '+errtxt, LogTest, False);
    prMessageLOGS('    txt= '+txt, LogTest, False);
    prMessageLOGS(' txtAlt= '+txtAlt, LogTest, False);
  end;
  //---------------------------------
begin
  ORD_IBS:= nil;
  ibsN:= nil;
  XL:= nil;
  WorkBook:= nil;
  iAdd := 0;
  iErr := 0;
  iWork:= 0;
  iNot := 0;
  iEx  := 0;
  opt:= '';
  SheetName:= '';
  try try
    OpenWorkBookNotVisible(FileName, XL, WorkBook); // открыть файл Excel для импорта
    SheetCount:= WorkBook.Worksheets.Count;         // количество листов excel
    for i:= 1 to SheetCount do begin
      WorkSheet:= WorkBook.Sheets.Item[i] as Excel_TLB._Worksheet;
      SheetName:= AnsiUpperCase(WorkSheet.Name);
      if pos('ЗАМЕНЫ', SheetName)>0 then break else SheetName:= '';
    end;
    if SheetName='' then raise EBOBError.Create('в файле '+FileName+' нет листа "ЗАМЕНЫ"');

    GetWorkSheetCounts(WorkSheet, rows, ii); // получить кол-во строк и столбцов на листе
    if rows<2 then raise EBOBError.Create(MessText(mtkNotEnoughParams)+' - мало строк');
    if ii<6 then // проверяем кол-во столбцов
      raise EBOBError.Create(MessText(mtkNotEnoughParams)+' - мало столбцов');

    CheckStopExecute(UserID, ThreadData);
    ORD_IBD:= cntsOrd.GetFreeCnt('', '', '', True);
    if not Assigned(ORD_IBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    try
      ibsN:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite);
      ORD_IBS:= fnCreateNewIBSQL(ORD_IBD, 'ORD_IBS_'+nmProc, -1, tpWrite, true);
                                 // для простановки признака ненужности перевода
      ibsN.SQL.Text:= 'select Result from SetTextNotAlternative(:txt, '+intToStr(UserID)+')';
                                                      // для добавления перевода
      ORD_IBS.SQL.Text:= 'select Result, rText, ErrText'+
        ' from AddAlternativeText_new(:opt, :txt, :txtAlt, '+intToStr(UserID)+')';

      for iLine:= 2 to rows do try // считываем строки файла (1-я строка - заголовок)
        opt:= GetCellStrValue(WorkSheet, CellSigns[4], iLine); // опция
        // opt= '/1' - обр-ть, если pText=текст в базе, '/-1' - отметить текст, не треб.перевода,
        // opt= '/2' - обр-ть без проверки, '/3' - заменить альт.текст
        if (opt<>'/-1') and (opt<>'/1') and (opt<>'/2') and (opt<>'/3') then Continue;
        inc(iWork);
        txt:= GetCellStrValue(WorkSheet, CellSigns[2], iLine); // исх.текст

        if (opt='/-1') then begin // отмечаем текст, не требующий перевода
          if ibsN.Open then ibsN.Close;
          with ibsN.Transaction do if not InTransaction then StartTransaction;
          ibsN.ParamByName('txt').AsString:= txt;
          ibsN.ExecQuery;
          if (ibsN.Bof and ibsN.Eof) then raise Exception.Create('empty ibsN');
          opt:= ibsN.FieldByName('Result').AsString;
          with ibsN.Transaction do if InTransaction then
            if opt='0' then Commit else Rollback;
          ibsN.Close;

          if opt='0' then begin // обработано
            inc(iNot);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/0'); // вписываем результат: 0=обраб.
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, 'проставлен признак "-1" в базе'); // пишем комментарий
          end else if opt='-1' then begin // не найден текст
            inc(iErr);
            mess:= 'не найден текст';
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/-21'); // вписываем результат: -21=не найден
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем комментарий
            SaveToTestLog(iLine, txt, txtAlt, mess);
          end;

        end else begin            // добавляем перевод
          txtAlt:= GetCellStrValue(WorkSheet, CellSigns[3], iLine); // альтерн.текст - перевод
          if (txtAlt='') then begin
            inc(iErr);
            mess:= 'альтерн.текст пустой';
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/25'); // вписываем результат ошибки
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем текст ошибки
            SaveToTestLog(iLine, txt, txtAlt, mess);
            Continue;
          end;
          if (txt=txtAlt) then begin
            inc(iErr);
            mess:= 'альтерн.текст = текст';
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/24'); // вписываем результат совпадения текстов
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем результат
            SaveToTestLog(iLine, txt, txtAlt, mess);
            Continue;
          end;

          txtAlt:= StringReplace(txtAlt,   #9, ' ', [rfReplaceAll]); // убираем символы табуляции
          txtAlt:= StringReplace(txtAlt,  #10, ' ', [rfReplaceAll]); // убираем символы конца строки
          txtAlt:= StringReplace(txtAlt,  #13, ' ', [rfReplaceAll]); // убираем символы новой строки
          txtAlt:= StringReplace(txtAlt, '  ', ' ', [rfReplaceAll]); // убираем двойные пробелы

          if ORD_IBS.Open then ORD_IBS.Close;
          with ORD_IBS.Transaction do if not InTransaction then StartTransaction;
          ORD_IBS.ParamByName('opt').AsString:= copy(opt, 2, length(opt)-1);
          ORD_IBS.ParamByName('txt').AsString:= txt;
          ORD_IBS.ParamByName('txtAlt').AsString:= txtAlt;
          ORD_IBS.ExecQuery;
          if (ORD_IBS.Bof and ORD_IBS.Eof) then raise Exception.Create('empty ORD_IBS');
          opt := ORD_IBS.FieldByName('Result').AsString;
          txt := ORD_IBS.FieldByName('rText').AsString;
          mess:= ORD_IBS.FieldByName('ErrText').AsString;
          with ORD_IBS.Transaction do if InTransaction then
            if opt='0' then Commit else Rollback;
          ORD_IBS.Close;

          if opt='0' then begin // обработано
            inc(iAdd);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/0'); // вписываем результат: 0=обраб.
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, 'альтерн.текст записан в базу'); // пишем комментарий
          end else if opt='1' then begin // уже есть
            inc(iEx);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/-0'); // вписываем результат: -0= (уже есть)
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем комментарий
          end else if opt='-1' then begin // не найден tmTD
            inc(iErr);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/21'); // вписываем результат: 21=не найден
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем комментарий
            SaveToTestLog(iLine, txt, txtAlt, mess);
          end else if opt='-2' then begin // не совп. с текстом в базе (опция 1)
            inc(iErr);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/22'); // вписываем результат: 22=не совп.
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем комментарий
            SetCellStrValue(WorkSheet, CellSigns[6], iLine, txt);   // пишем текст из базы для анализа
            SaveToTestLog(iLine, txt, txtAlt, mess);
          end else if opt='-3' then begin // есть связка с др.текстом (опция 1,2)
            inc(iErr);
            SetCellStrValue(WorkSheet, CellSigns[4], iLine, '/23'); // вписываем результат: 23=есть др.связка
            SetCellStrValue(WorkSheet, CellSigns[5], iLine, mess);  // пишем комментарий
            SetCellStrValue(WorkSheet, CellSigns[6], iLine, txt);   // пишем текст из базы для анализа
            SaveToTestLog(iLine, txt, txtAlt, mess);
          end;
        end;
        CheckStopExecute(UserID, ThreadData);
      except
        on E: Exception do begin
          with ORD_IBS.Transaction do if InTransaction then Rollback;
          with ibsN.Transaction do if InTransaction then Rollback;
          prMessageLOGS(nmProc+': строка '+IntToStr(iLine)+' - '+E.Message, 'import', False);
          inc(iErr);
          if (opt='/-1') then s:= '/-25' else s:= '/25';
          SetCellStrValue(WorkSheet, CellSigns[4], iLine, s); // вписываем результат ошибки
          SetCellStrValue(WorkSheet, CellSigns[5], iLine, E.Message); // пишем текст ошибки
          SaveToTestLog(iLine, txt, txtAlt, E.Message);
        end;
      end; // for iLine:= 2 to rows
    finally
      prFreeIBSQL(ORD_IBS);
      prFreeIBSQL(ibsN);
      cntsOrd.SetFreeCnt(ORD_IBD, True);
    end;
  finally
    SaveAndCloseWorkBook(XL, WorkBook);
    if (iWork>0) then prMessageLOGS(nmProc+': обраб- '+IntToStr(iWork)+
      fnIfStr(iAdd>0, ', доб- '+IntToStr(iAdd), '')+
      fnIfStr(iNot>0, ', пр."-1"- '+IntToStr(iNot), '')+
      fnIfStr(iEx>0, ', дубл.- '+IntToStr(iEx), '')+
      fnIfStr(iErr>0, ', ош- '+IntToStr(iErr), ''), 'import', False);
  end;
  except
    on E: EBOBError do raise Exception.Create(E.Message);
    on E: Exception do prMessageLOGS(nmProc+': '+E.Message, 'import', False);
  end;
end;
//==================== загрузка/проверка параметров нескольких двигателей из TDT
function CheckEnginesFromTDT(var engCodes: Tai; pUserID: integer): string;
// предназначена для добавления/редактирования двигателей модели
// на входе в engCodes коды двигателей TecDoc, на выходе - коды ORD
const nmProc = 'CheckEnginesFromTDT'; // имя процедуры/функции
var i, ii, iErr, iAdd, iUpd, engORD, engTD, mfTD, mfORD, kodORD: integer;
    TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    KeyTabs: TarKeyTabs; // array of TKeyTab
    s, nf, pMark: string;
    eps: TEngParams;
    eng: TEngine;
begin
  TdtIBD:= nil;
  eps:= nil;
  iErr:= 0;
  iAdd:= 0;
  iUpd:= 0;
  if (Length(engCodes)<1) then Exit;
  try
    if (pUserID<1) then raise Exception.Create(MessText(mtkNotParams));
    SetLength(KeyTabs, 10);
    eps:= TEngParams.Create;
    with Cache.FDCA do try // заполняем имена полей для поиска соответствий
      FillKeTabRecNf(0, 'ENG_DESIGN'    , KeyTabs);  // Исполнение двигателя (KT 96)       (TYPEDIR=13)
      FillKeTabRecNf(1, 'ENG_FUEL_TYPE' , KeyTabs);  // Вид топлива (KT 88)                (TYPEDIR=12)
      FillKeTabRecNf(2, 'ENG_FUEL_MIXT' , KeyTabs);  // Подготовка топливной смеси (KT 97) (TYPEDIR=5)
      FillKeTabRecNf(3, 'ENG_ASPIR'     , KeyTabs);  // Подача воздуха (KT 99)             (TYPEDIR=14)
      FillKeTabRecNf(4, 'ENG_TYPE'      , KeyTabs);  // Вид двигателя (KT 80)              (TYPEDIR=3)
      FillKeTabRecNf(5, 'ENG_NORM'      , KeyTabs);  // Норма выхлопных газов (KT 63)      (TYPEDIR=15)
      FillKeTabRecNf(6, 'ENG_CYL_DESIGN', KeyTabs);  // Форма головки цилиндра (KT 79)     (TYPEDIR=16)
      FillKeTabRecNf(7, 'ENG_MANAG'     , KeyTabs);  // Управление двигателем (KT 77)      (TYPEDIR=17)
      FillKeTabRecNf(8, 'ENG_VAL_CNT'   , KeyTabs);  // Привод клапана (KT 78)             (TYPEDIR=18)
      FillKeTabRecNf(9, 'ENG_COOL_TYPE' , KeyTabs);  // Тип системы охлаждения (KT 76)     (TYPEDIR=19)

      TdtIBD:= cntsTDT.GetFreeCnt;
      if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
      TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

      engTD:= 155; // ENGINES
      s:= IntToStr(engTD);
      FillarKeyTabsFromTDT(KeyTabs, engTD, TdtIBS); // вынимаем в KeyTabs нужные списки TDT

      TdtIBS.SQL.Clear;
      TdtIBS.SQL.Add('select ENG_MF_ID, ENG_MARK, ENG_MOD_FR, ENG_MOD_TO,');
      TdtIBS.SQL.Add(' ENG_KW_FR, ENG_KW_TO, ENG_HP_FR, ENG_HP_TO, ENG_VAL, ENG_CYL,');
      TdtIBS.SQL.Add(' ENG_COMP_FR, ENG_COMP_TO, ENG_CC_TEC_FR, ENG_CC_TEC_TO,');
      TdtIBS.SQL.Add(' ENG_RPM_KW_FR, ENG_RPM_KW_TO, ENG_RPM_TORQ_FR, ENG_RPM_TORQ_TO,');
      for i:= Low(KeyTabs) to High(KeyTabs) do begin
        nf:= KeyTabs[i].FieldNameTDT;
        TdtIBS.SQL.Add(' (select key_to from get_key_code ('+s+', '+nf+', "'+nf+'")) '+nf+',');
      end;
      TdtIBS.SQL.Add(' ENG_CRANK, ENG_BORE, ENG_STROKE, ENG_SALES_DESC from ENGINES');
      TdtIBS.SQL.Add(' where ENG_ID=:eng');

      for i:= Low(engCodes) to High(engCodes) do try
        engTD:= engCodes[i];
        engORD:= 0;
        with TdtIBS.Transaction do if not InTransaction then StartTransaction;
        TdtIBS.ParamByName('eng').AsInteger:= engTD;
        try
          TdtIBS.ExecQuery;
          if (TdtIBS.Bof and TdtIBS.Eof) then raise Exception.Create('не найден двигатель в TDT');
          mfTD:= TdtIBS.FieldByName('ENG_MF_ID').AsInteger;
          mfORD:= Manufacturers.GetManufIDByTDcode(mfTD); // ищем произв.
          if (mfORD<1) then Exception.Create('не найден производитель в ORD, mfTD='+IntToStr(mfTD));
          pMark:= TdtIBS.FieldByName('ENG_MARK').AsString;
          with eps do begin
            Clear;
            pYearFrom   := TdtIBS.FieldByName('ENG_MOD_FR').AsInteger div 100; // Год выпуска от
            pMonFrom    := TdtIBS.FieldByName('ENG_MOD_FR').AsInteger mod 100; // Месяц выпуска от
            pYearTo     := TdtIBS.FieldByName('ENG_MOD_TO').AsInteger div 100; // Год выпуска до
            pMonTo      := TdtIBS.FieldByName('ENG_MOD_TO').AsInteger mod 100; // Месяц выпуска до
            pCompFrom   := TdtIBS.FieldByName('ENG_COMP_FR').AsInteger;        // Компрессор * 100 от
            pCompTo     := TdtIBS.FieldByName('ENG_COMP_TO').AsInteger;        // Компрессор * 100 до
            pRPMtorqFrom:= TdtIBS.FieldByName('ENG_RPM_TORQ_FR').AsInteger;    // Момент вращения (Nm) при [об/мин] от
            pRPMtorqTo  := TdtIBS.FieldByName('ENG_RPM_TORQ_TO').AsInteger;    // Момент вращения (Nm) при [об/мин] до
            pBore       := TdtIBS.FieldByName('ENG_BORE').AsInteger;           // Расточка * 1000
            pStroke     := TdtIBS.FieldByName('ENG_STROKE').AsInteger;         // Ход поршня * 1000
            pKWfrom     := TdtIBS.FieldByName('ENG_KW_FR').AsInteger;          // Мощность кВт от
            pRPMKWfrom  := TdtIBS.FieldByName('ENG_RPM_KW_FR').AsInteger;      // при [об/мин] от
            pKWto       := TdtIBS.FieldByName('ENG_KW_TO').AsInteger;          // Мощность кВт до
            pRPMKWto    := TdtIBS.FieldByName('ENG_RPM_KW_TO').AsInteger;      // при [об/мин] до
            pHPfrom     := TdtIBS.FieldByName('ENG_HP_FR').AsInteger;          // Мощность ЛС от
            pHPto       := TdtIBS.FieldByName('ENG_HP_TO').AsInteger;          // Мощность ЛС до
            pCCtecFrom  := TdtIBS.FieldByName('ENG_CC_TEC_FR').AsInteger;      // Тех.обьем в куб.см. от
            pCCtecTo    := TdtIBS.FieldByName('ENG_CC_TEC_TO').AsInteger;      // Тех.обьем в куб.см. до
            pVal        := TdtIBS.FieldByName('ENG_VAL').AsInteger;            // Количество клапанов
            pCyl        := TdtIBS.FieldByName('ENG_CYL').AsInteger;            // Количество цилиндров
            pCrank      := TdtIBS.FieldByName('ENG_CRANK').AsInteger;          // Кол-во подшипников коленвала
            pSalesDesc  := TdtIBS.FieldByName('ENG_SALES_DESC').AsString;      // Обозначение продажи
            for ii:= Low(KeyTabs) to High(KeyTabs) do begin // Исполнение двигателя .. Тип системы охлаждения
              kodORD:= GetInfoCode(TdtIBS.FieldByName(KeyTabs[ii].FieldNameTDT).AsInteger, pUserID, KeyTabs[ii]);
              if kodORD<1 then Continue;
              case ii of
                0: pDesign     := kodORD;     // Код, Исполнение двигателя (KT 96)       (TYPEDIR=13)
                1: pFuelType   := kodORD;     // Код, Вид топлива (KT 88)                (TYPEDIR=12)
                2: pFuelMixt   := kodORD;     // Код, Подготовка топливной смеси (KT 97) (TYPEDIR=5)
                3: pAspir      := kodORD;     // Код, Подача воздуха (KT 99)             (TYPEDIR=14)
                4: pType       := kodORD;     // Код, Вид двигателя (KT 80)              (TYPEDIR=3)
                5: pNorm       := kodORD;     // Код, Норма выхлопных газов (KT 63)      (TYPEDIR=15)
                6: pCylDesign  := kodORD;     // Код, Форма головки цилиндра (KT 79)     (TYPEDIR=16)
                7: pManag      := kodORD;     // Код, Управление двигателем (KT 77)      (TYPEDIR=17)
                8: pValCnt     := kodORD;     // Код, Привод клапана (KT 78)             (TYPEDIR=18)
                9: pCoolType   := kodORD;     // Код, Тип системы охлаждения (KT 76)     (TYPEDIR=19)
              end; // case
            end; // for ii
          end; // with eps
          s:= '';
          with Engines do begin
            if FindEngineByTDcode(engTD, eng) then engORD:= eng.ID;
            if (engORD<1) then begin
              s:= AddEngine(engORD, constIsAuto, engTD, mfORD, pUserID, pMark, eps);
              if (s='') then Inc(iAdd);
            end else begin
              s:= EditEngine(engORD, engTD, mfORD, pUserID, pMark, eps);
              if (s='') then Inc(iUpd);
            end;
          end; //  with Engines
          if (s<>'') then raise Exception.Create(s);
        finally
          TdtIBS.Close;
          engCodes[i]:= engORD;
        end; // for
      except
        on E: Exception do begin
          inc(iErr);
          with TdtIBS.Transaction do if InTransaction then Rollback;
          prMessageLOGS(nmProc+': код='+IntToStr(engTD)+' - '+E.Message, 'import', False);
        end;
      end;
    except
      on E: Exception do begin
        E.Message:= nmProc+': '+E.Message;
        prMessageLOGS(E.Message, 'import', False);
        raise Exception.Create(E.Message);
      end;
    end;
  finally
    prFreeIBSQL(TdtIBS);
    cntsTDT.SetFreeCnt(TdtIBD);
    ClearArKeyTabs(KeyTabs);
    prFree(eps);
  end; // with Cache.FDCA
  s:= '';
  if (iAdd>0) then s:= s+' добавлено: '+IntToStr(iAdd);
  if (iUpd>0) then s:= s+' проверено: '+IntToStr(iUpd);
  if (iErr>0) then s:= s+' ошибок: '+IntToStr(iErr);
  if (s<>'') then prMessageLOGS(nmProc+': '+s, 'import', False);
end;
//====================== пакетная загрузка/проверка параметров двигателей из TDT
function CheckEnginesFromTDT(pUserID: integer): string;
const nmProc = 'CheckEnginesFromTDT'; // имя процедуры/функции
var i: integer;
    engCodes: Tai;
begin
  with Cache.FDCA.Engines do try try
    SetLength(engCodes, ItemsList.Count);
    for i:= 0 to High(engCodes) do engCodes[i]:= TEngine(ItemsList[i]).TDCode;
    CheckEnginesFromTDT(engCodes, pUserID);
  except
    on E: Exception do begin
      E.Message:= nmProc+': '+E.Message;
      prMessageLOGS(E.Message, 'import', False);
      raise Exception.Create(E.Message);
    end;
  end;
  finally
    SetLength(engCodes, 0);
  end;
end;
(*//================================== загрузка моделей авто из TDT из файла Excel
procedure prSetNewAutoModelFromTDT(UserID: integer; FileName: string; ThreadData: TThreadData=nil);
const nmProc = 'prSetNewAutoModelFromTDT'; // имя процедуры/функции
var mlORD, mTD, mORD, iAdd, iUpd, iErr, iNot, i, ii, iLine: integer;
    fVis, flAdd, flUpd, flDel: Boolean;
    pName, ss: string;
    arMpsORD: TarMps;
    TimeProc: TDateTime;
    TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    KeyTabs: TarKeyTabs; // Tai: индекс - код TDT, значение - код ORD
    ADOConnection: TADOConnection;
    ADOTable: TADOTable;
    mps: TModelParams;
    marks: TStringList;
begin
  TimeProc:= Now;
  iAdd:= 0;
  iUpd:= 0;
  iErr:= 0;
  iNot:= 0;
  flAdd:= False;
  flUpd:= False;
  flDel:= False;
  TdtIBD:= nil;
  TdtIBS:= nil;
  ADOConnection:= nil;
  marks:= TStringList.Create;
  SetLength(KeyTabs, 9);
  with Cache.FDCA do try try // заполняем имена полей для поиска соответствий
    FillKeTabRecNf(0, 'MT_BT' , KeyTabs);  // Тип кузова
    FillKeTabRecNf(1, 'MT_DR' , KeyTabs);  // Тип привода
    FillKeTabRecNf(2, 'MT_ENG', KeyTabs);  // Тип двигателя
    FillKeTabRecNf(3, 'MT_FT' , KeyTabs);  // Тип топлива
    FillKeTabRecNf(4, 'MT_FF' , KeyTabs);  // Система впрыска
    FillKeTabRecNf(5, 'MT_BRT', KeyTabs);  // Тип тормозной системы
    FillKeTabRecNf(6, 'MT_BRS', KeyTabs);  // Тормозная система
    FillKeTabRecNf(7, 'MT_CT' , KeyTabs);  // Тип катализатора
    FillKeTabRecNf(8, 'MT_TT' , KeyTabs);  // Вид коробки передач

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

    FillarKeyTabsFromTDT(KeyTabs, 120, TdtIBS); // вынимаем в KeyTabs нужные списки TDT

    try
      CoInitialize(nil);
      ADOConnection:= CreateADOConnection(ExpandFileName(FileName), atExcel2003); // подключаемся к файлу Excel как к БД
      ADOConnection.Open;
      ADOConnection.BeginTrans;

      ADOTable:= CreateADOTable(ADOConnection, '['+ModelSheetName+'$]'); // лист книги как таблица
      ADOTable.Open;
      if ADOTable.FieldCount<(icResMod+1) then // проверяем кол-во столбцов
        raise Exception.Create(MessText(mtkNotEnoughParams)+' файла');

      for i:= 0 to ADOTable.FieldCount-1 do // символьные поля
        if (i in [0, icNameTDMod, icNameTDMod+1, icCommMod, icResMod]) then
          ADOTable.Fields[i].SetFieldType(ftString);
    except
      on E: Exception do begin
        prMessageLOGS(nmProc+': ошибка ADOConnection '+E.Message, 'import', False);
        raise Exception.Create(E.Message);
      end;
    end;

    iLine:= 0;
    while not ADOTable.Eof do begin
      CheckStopExecute(UserID, ThreadData);
      try                              // считываем параметры 1-й строки файла
        if copy(ADOTable.Fields[0].AsString, 1, 6)='время:' then begin // старое время убираем
          SaveValueADO(0, '', ADOTable);
          ADOTable.Next;
          Continue;
        end else begin
          flAdd:= ADOTable.Fields[0].AsString=sActionAdd;
          flUpd:= ADOTable.Fields[0].AsString=sActionUpd;
          flDel:= ADOTable.Fields[0].AsString=sActionDel;
          if not (flAdd or flUpd or flDel) then begin // ненужные строки пропускаем
            ADOTable.Next;
            Continue;
          end;
        end;

        mlORD:= fnStrToIntDef(ADOTable.Fields[icKodML].AsString, 0);    // ID мод.ряда
        mORD := fnStrToIntDef(ADOTable.Fields[icKodMod].AsString, 0);   // ID модели
        mTD  := fnStrToIntDef(ADOTable.Fields[icKodTDMod].AsString, 0); // код TecDoc модели
        pName:= ADOTable.Fields[icNameTDMod].AsString;
        fVis:= ADOTable.Fields[icVisMod].AsString='1';
        if (mlORD<1) or (flAdd and ((mTD<1) or (pName=''))) // если не хватает параметров
          or (flUpd and ((mORD<1) or (pName='') or (mTD<1))) then
          raise Exception.Create(MessText(mtkNotEnoughParams));

        if not flDel then begin // остальное считываем только для добавления или изменения
          for ii:= 0 to icModMpsV do
            arMpsORD[ii]:= fnStrToIntDef(ADOTable.Fields[icModMps+ii].AsString, 0);
          for ii:= Low(KeyTabs) to High(KeyTabs) do  // в ссылочных полях - коды TD !!!
            arMpsORD[ii+9]:= GetInfoCode(fnStrToIntDef(ADOTable.Fields[icModMps+ii+9].AsString, 0), UserID, KeyTabs[ii]);
        end;
        if mORD<1 then mORD:= ModelLines[mlORD].GetMLModelIDByTDcode(mTD);
        ss:= '';
        if Models.ModelExists(mORD) then with Models[mORD] do begin // если модель есть
          if flDel then
            ss:= SetModelVisible(False)
          else begin
            MakeMpsFromArray(arMpsORD, mps);
            GetEngMarks(mTD, UserID, marks, TdtIBS); // маркировки двигателей
            ss:= ModelEdit(pName, fVis, IsTop, UserID, mps, -1, mTD, marks);
          end;
          if ss=MessText(mtkNotParams) then begin
            if flAdd then ss:= 'уже есть' else ss:= MessText(mtkNotChanges);
            SaveValueADO(0, '', ADOTable);
            inc(iNot);
          end else if (ss='') then begin
            if flDel then ss:= 'снята видимость' else ss:= 'изменена';
            SaveValueADO(0, '', ADOTable);
            inc(iUpd);
          end else raise Exception.Create(ss);

        end else if not flDel then begin // добавляем новую модель
          MakeMpsFromArray(arMpsORD, mps);
          GetEngMarks(mTD, UserID, marks, TdtIBS); // маркировки двигателей
          ss:= Models.ModelAdd(mORD, pName, fVis, False, UserID, mlORD, mps, -1, mTD, marks);
          if (ss='') then begin
            ss:= 'добавлена';
            SaveValueADO(0, '', ADOTable);
            inc(iAdd);
          end else raise Exception.Create(ss);

        end else raise Exception.Create('не найдена'); // если не нашли для удаления

        if (ADOTable.Fields[icKodMod].AsString='') and (mORD>0) then
          SaveValueADO(icKodMod, IntToStr(mORD), ADOTable);  // вписываем код модели
        if ss<>'' then SaveValueADO(icResMod, ss, ADOTable); // вписываем результат
      except
        on E: Exception do begin
          inc(iErr);
          prMessageLOGS(nmProc+': ошибка в строке '+IntToStr(iLine)+' '+E.Message, 'import', False);
          if E.Message<>'' then SaveValueADO(icResMod, E.Message, ADOTable); // вписываем сообщение
        end;
      end;
      ADOTable.Next;
      inc(iLine);
    end;
    try
      AddRecordADO('-----------', ADOTable);                                    // итоги
      AddRecordADO('обработано:   '+IntToStr(iAdd+iUpd+iErr+iNot)+' строк', ADOTable);
      AddRecordADO('добавлено :   '+IntToStr(iAdd)+' строк', ADOTable);
      AddRecordADO('изменено  :   '+IntToStr(iUpd)+' строк', ADOTable);
      AddRecordADO('проверено :   '+IntToStr(iNot)+' строк', ADOTable);
      AddRecordADO('ошибки    :   '+IntToStr(iErr)+' строк', ADOTable);
      AddRecordADO('-----------', ADOTable);
      AddRecordADO('время     : '+GetLogTimeStr(TimeProc), ADOTable);
    except
      on E: Exception do prMessageLOGS(nmProc+': ошибка в итогах '+E.Message, 'import', False);
    end;

    ADOConnection.CommitTrans;
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    DestroyADOTable(ADOTable);
    DestroyADOConnection(ADOConnection);
    prFreeIBSQL(TdtIBS);
    cntsTDT.SetFreeCnt(TdtIBD);
    CoUnInitialize;
    ClearArKeyTabs(KeyTabs);
    prFreeAndNilStrListWithObj(marks);
  end;
end;
//========================================== загрузка производителей авто из TDT
function fnSetNewAutoManufFromTDT(UserID: integer; FileName: string; ThreadData: TThreadData=nil): TStringList; // must Free Result
// возвращает отчет
const nmProc = 'fnSetNewAutoManufFromTDT'; // имя процедуры/функции
var mfORD, mfTD, iAdd, iUpd, iErr, iNot, i: integer;
    fVis, fTop, flAdd, flUpd, flDel: Boolean;
    pName, ss: string;
    lstFrom, lst: TStringList;
    TimeProc: TDateTime;
begin
  Result:= TStringList.Create;
  TimeProc:= Now;
  lst:= TStringList.Create;
  lstFrom:= nil;
  iAdd:= 0;
  iUpd:= 0;
  iErr:= 0;
  iNot:= 0;
  with Cache.FDCA.Manufacturers do try try
    lstFrom:= fnStringsLogFromFile(FileName); // набор строк из файла
    Result.Capacity:= Result.Capacity+lstFrom.Count;
    if Assigned(lstFrom) then for i:= 0 to lstFrom.Count-1 do try
      lst.Clear;
      lst:= fnSplit(';', lstFrom[i]); // разбираем строку файла
      if lst.Count<icCommMF then  // добавляем пустые строки до нужной длины
        fnInsStringToListByIndex(lst, icCommMF, '');
      lst.Delimiter:= ';';
      ss:= '';
      fVis:= False;
      mfORD:= 0;
      flAdd:= lst[0]=sActionAdd;
      flUpd:= lst[0]=sActionUpd;
      flDel:= lst[0]=sActionDel;
      if flAdd or flUpd or flDel then begin   // fVis здесь используем как флаг нехватки параметров
        if flAdd then fVis:= (lst[icKodTDMF]='') or ((lst[icNameMF]='') and (lst[icNameTDMF]=''))
        else if flUpd then fVis:= (lst[icKodMF]='') or (lst[icNameMF]='') or (lst[icKodTDMF]='')
        else if flDel then fVis:= (lst[icKodMF]='');
        if fVis then begin
          ss:= MessText(mtkNotEnoughParams);
          inc(iErr);
        end else begin // считываем параметры 1-й строки файла
          mfORD:= StrToIntDef(lst[icKodMF], 0);
          mfTD:= StrToIntDef(lst[icKodTDMF], 0);
          pName:= lst[icNameMF];
          fVis:= lst[icVisMF]='1'; // если наше наимен. пустое - берем наимен.(TD)
          if (pName='') and (lst[icNameTDMF]<>'') then pName:= lst[icNameTDMF];
          if mfORD<1 then mfORD:= GetManufIDByTDcode(mfTD);

          if ManufExists(mfORD) or ManufExistsByName(pName, mfORD) then begin // если произв. есть
            fTop:= Items[mfORD].CheckIsTop(constIsAuto);
            if flDel then fVis:= False;
            ss:= ManufEdit(mfORD, constIsAuto, UserID, fTop, fVis, pName, mfTD);
            if ss=MessText(mtkNotParams) then begin
              fnChangeStringOfList(lst, 0, '');
              if flAdd then ss:= 'уже есть' else ss:= MessText(mtkNotChanges);
              inc(iNot);
            end else if (ss='') then begin
              fnChangeStringOfList(lst, 0, '');
              if flDel then ss:= 'снята видимость' else ss:= 'изменен';
              inc(iUpd);
            end else inc(iErr);

          end else if flDel then begin // если не нашли для удаления
            ss:= 'не найден';
            inc(iErr);

          end else begin  // добавляем нового произв.
            ss:= ManufAdd(mfORD, pName, constIsAuto, UserID, False, fVis, mfTD);
            if (ss='') then begin
              fnChangeStringOfList(lst, 0, '');
              ss:= 'добавлен';
              inc(iAdd);
            end else inc(iErr);
          end;
        end; // if fVis then ... else
        if (lst[icKodMF]='') and (mfORD>0) then // вписываем код произв.
          fnChangeStringOfList(lst, icKodMF, IntToStr(mfORD));
      end; // if flAdd or flUpd or flDel
      if ss<>'' then fnInsStringToListByIndex(lst, icCommMF+1, ss); // дописываем результат
      Result.Add(lst.DelimitedText);
    except
      on E: Exception do begin
        lst.Add('error: '+E.Message);
        Result.Add(lst.DelimitedText);
      end;
    end; // for i:= 0 to lstFrom.Count-1
    Result.Add(cDelim);                         // итоги
    Result.Add('Обработано:;'+IntToStr(iAdd+iUpd+iErr+iNot)+'; строк');
    Result.Add('добавлено:;'+IntToStr(iAdd)+'; строк');
    Result.Add('изменено:;'+IntToStr(iUpd)+'; строк');
    Result.Add('проверено:;'+IntToStr(iNot)+'; строк');
    Result.Add('ошибки:;'+IntToStr(iErr)+'; строк');
    Result.Add(cDelim);
    Result.Add('время; '+FloatToStr(RoundTo((Now-TimeProc)*60*60*24,-5))+'; сек');
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA.Manufacturers
  finally
    prFree(lst);
    prFree(lstFrom);
  end;
end;
//=============================================== загрузка мод.рядов авто из TDT
function fnSetNewAutoModelLineFromTDT(UserID: integer; FileName: string; ThreadData: TThreadData=nil): TStringList; // возвращает отчет
const nmProc = 'fnSetNewAutoModelLineFromTDT'; // имя процедуры/функции
var mlORD, mlTD, mfORD, iAdd, iUpd, iErr, iNot, iDel, i, yFrom, yTo, mFrom, mTo, ordFrom, ordTo: integer;
    fVis, flAdd, flUpd, flDel: Boolean;
    pName, ss: string;
    lstFrom, lst: TStringList;
    TimeProc: TDateTime;
begin
  Result:= TStringList.Create;
  TimeProc:= Now;
  lst:= TStringList.Create;
  lstFrom:= nil;
  iAdd:= 0;
  iUpd:= 0;
  iErr:= 0;
  iNot:= 0;
  iDel:= 0;
  with Cache.FDCA do try try
    lstFrom:= fnStringsLogFromFile(FileName); // набор строк из файла
    Result.Capacity:= Result.Capacity+lstFrom.Count;
    if Assigned(lstFrom) then for i:= 0 to lstFrom.Count-1 do try
      lst.Clear;
      lst:= fnSplit(';', lstFrom[i]); // разбираем 1 строку файла
      if lst.Count<icCommML then  // добавляем пустые строки до нужной длины
        fnInsStringToListByIndex(lst, icCommML, ''); 
      lst.Delimiter:= ';';
      ss:= '';
      mlORD:= 0;
      flAdd:= lst[0]=sActionAdd;
      flUpd:= lst[0]=sActionUpd;
      flDel:= lst[0]=sActionDel;
      if flAdd or flUpd or flDel then begin
        fVis:= (lst[icKodMF]=''); // здесь используем как флаг нехватки параметров
        if not fVis then
          if flAdd then fVis:= (lst[icKodTDML]='') or (lst[icNameTDML]='')
          else if flUpd then fVis:= (lst[icKodML]='') or (lst[icNameML]='') or (lst[icKodTDML]='')
          else if flDel then fVis:= (lst[icKodML]='');

        if fVis then begin
          ss:= MessText(mtkNotEnoughParams);
          inc(iErr);
        end else begin
          yFrom:= 0; // считываем параметры 1-й строки файла
          mFrom:= 0;
          yTo:= 0;
          mTo:= 0;
          mfORD:= StrToIntDef(lst[icKodMF], 0); // ID произв.
          mlORD   := StrToIntDef(lst[icKodML], 0);
          mlTD    := StrToIntDef(lst[icKodTDML], 0);
          pName:= lst[icNameML];
          ordFrom:= StrToIntDef(lst[icFromML], 0);
          ordTo:= StrToIntDef(lst[icToML], 0);
          fVis:= lst[icVisML]='1';  // если наши колонки пустые - берем колонки (TD)
          if flAdd then begin
            if (pName='') and (lst[icNameTDML]<>'') then pName:= lst[icNameTDML];
            if (ordFrom<1) and (mlTD>0) then ordFrom:= StrToIntDef(lst[icFromTDML], 0);
            if (ordTo<1) and (mlTD>0) then ordTo:= StrToIntDef(lst[icToTDML], 0);
          end;
          if ordFrom>0 then yFrom:= ordFrom div 100;
          if yFrom>0 then mFrom:= ordFrom mod 100;
          if ordTo>0 then yTo:= ordTo div 100;
          if yTo>0 then mTo:= ordTo mod 100;
          if mlORD<1 then mlORD:= Manufacturers[mfORD].GetMfMLineIDByTDcode(mlTD);

          if ModelLines.ModelLineExists(mlORD) then begin // если мод.ряд есть

            if flDel and (ModelLines[mlORD].ModelsCount<1) then begin
              ss:= Manufacturers[mfORD].ModelLineDel(mlORD);
              if (ss='') then begin
                fnChangeStringOfList(lst, 0, '');
                ss:= 'удален';
                inc(iDel);
              end else inc(iErr);

            end else begin
              if flDel then fVis:= False;
              ss:= Manufacturers[mfORD].ModelLineEdit(mlORD, yFrom, mFrom,
                yTo, mTo, UserID, ModelLines[mlORD].IsTop, fVis, pName, mlTD);

              if ss=MessText(mtkNotParams) then begin
                fnChangeStringOfList(lst, 0, '');
                if flAdd then ss:= 'уже есть' else ss:= MessText(mtkNotChanges);
                inc(iNot);
              end else if (ss='') then begin
                fnChangeStringOfList(lst, 0, '');
                if flDel then ss:= 'снята видимость' else ss:= 'изменен';
                inc(iUpd);
              end else inc(iErr);
            end;

          end else if flDel then begin // если не нашли для удаления
            ss:= 'не найден';
            inc(iErr);

          end else begin // добавляем новый мод.ряд
            ss:= Manufacturers[mfORD].ModelLineAdd(mlORD, pName, constIsAuto,
              mFrom, yFrom, mTo, yTo, UserID, False, fVis, mlTD);
            if (ss='') then begin
              fnChangeStringOfList(lst, 0, '');
              ss:= 'добавлен';
              inc(iAdd);
            end else inc(iErr);
          end;
        end; // if fVis then ... else
        if (lst[icKodML]='') and (mlORD>0) then // вписываем код мод.ряда
          fnChangeStringOfList(lst, icKodML, IntToStr(mlORD));
      end; // if flAdd or flUpd or flDel
      if ss<>'' then fnInsStringToListByIndex(lst, icCommML+1, ss); // дописываем результат
      Result.Add(lst.DelimitedText);
    except
      on E: Exception do begin
        lst.Add('error: '+E.Message);
        Result.Add(lst.DelimitedText);
      end;
    end; // for i:= 0 to lstFrom.Count-1
    Result.Add(cDelim);                         // итоги
    Result.Add('Обработано:;'+IntToStr(iAdd+iUpd+iErr+iNot)+'; строк');
    Result.Add('добавлено:;'+IntToStr(iAdd)+'; строк');
    Result.Add('удалено:;'+IntToStr(iDel)+'; строк');
    Result.Add('изменено:;'+IntToStr(iUpd)+'; строк');
    Result.Add('проверено:;'+IntToStr(iNot)+'; строк');
    Result.Add('ошибки:;'+IntToStr(iErr)+'; строк');
    Result.Add(cDelim);
    Result.Add('время; '+FloatToStr(RoundTo((Now-TimeProc)*60*60*24,-5))+'; сек');
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    prFree(lst);
    prFree(lstFrom);
  end;
end;  *)

//******************************************************************************
//                 загрузка информации по товару
//******************************************************************************
//========================================== имена файлов рисунков товара из TDT
function LoadWareGraFileNamesFromTDT(WareID, UserID: Integer): String;
const nmProc = 'LoadWareGraFileNamesFromTDT'; // имя процедуры/функции
var TdtIBD: TIBDatabase;
    TdtIBS: TIBSQL;
    headID, pSupID, pType, kt, ke, fID, fCount, res: integer;
    s: string;
    Ware: TWareInfo;
    arTDfiles: TarWareFileOpts;
begin
  Result:= '';
//  TdtIBD:= nil;
  TdtIBS:= nil;
  kt:= 141;
  pType:= 0;
  fCount:= 0;
  SetLength(arTDfiles, 10);
  with Cache do try
    Ware:= GetWare(WareID);
    with Ware do if (ArticleTD='') or (ArtSupTD<1) then
      raise EBOBError.Create(MessText(mtkNotEnoughParams))
    else begin
      s:= ArticleTD;
      pSupID:= ArtSupTD; // SupID TecDoc (DS_MF_ID !!!)
    end;

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    try
      TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
      TdtIBS.SQL.Text:= 'select rHeadID, rHeadName, rFileName, rSupID'+
        ' from GetArtGraFileNames(:aArticle, '+IntToStr(pSupID)+')';
      TdtIBS.ParamByName('aArticle').AsString:= s;
      TdtIBS.ExecQuery;
      while not TdtIBS.Eof do begin
        ke:= TdtIBS.FieldByName('rHeadID').AsInteger;
        s:= TdtIBS.FieldByName('rHeadName').AsString;
        with FDCA.TypesInfoModel do // ищем заголовок в кеше по кодам TDT
          if not FindInfoItemByTDcodes(headID, pType, ke, kt) then begin
            // добавляем новый заголовок в кеш и в базу (pType - из FindInfoItemByTDcodes)
            s:= AddInfoModelItem(headID, pType, ke, kt, s, UserID);
            if (s<>'') then raise Exception.Create('AddInfoModelItem error: '+s);
          end;

        s:= TdtIBS.FieldByName('rFileName').AsString;    // имя файла с расширением
        pSupID:= TdtIBS.FieldByName('rSupID').AsInteger; // SupID TecDoc (DS_ID !!!)
        fID:= SearchWareFileBySupAndName(pSupID, s); // ищем код файла
        if fID<1 then begin // не нашли - добавляем
          s:= AddWareFile(fID, s, pSupID, headID, UserID, soTecDocBatch);
          if (s<>'') then raise Exception.Create('AddWareFile error: '+s);
        end;

        if fCount>High(arTDfiles) then setLength(arTDfiles, fCount+10);
        arTDfiles[fCount].SupID   := fID; // здесь - код файла
        arTDfiles[fCount].FileName:= TdtIBS.FieldByName('rFileName').AsString;
        inc(fCount);

        if (fID>0) then begin
          res:= resAdded; // добавляем в кеш линк товара с файлом
          s:= CheckWareFileLink(res, fID, WareID, soTecDocBatch, UserID);
          if (res=resError) then prMessageLOGS(nmProc+': add WareFileLink error('+
                                 IntToStr(WareID)+'): '+s, 'import', False);
        end;
        TestCssStopException;
        TdtIBS.Next;
      end;
    finally
      prFreeIBSQL(TdtIBS);
      cntsTDT.SetFreeCnt(TdtIBD);
    end;

    for kt:= Ware.FileLinks.ListLinks.Count-1 downto 0 do begin
      fID:= GetLinkID(Ware.FileLinks.ListLinks[kt]);   // ID файла
      pType:= 0; // здесь - признак наличия
      for ke:= 0 to fCount-1 do if arTDfiles[ke].SupID=fID then begin
        pType:= 1;
        break;
      end; // for ke:= 0 to fCount-1
      if pType=1 then Continue; // если нашли
      if GetLinkSrc(Ware.FileLinks.ListLinks[kt])<>soTecDocBatch then Continue; // если не TD

      res:= resDeleted; // удаляем из кеша линк товара с файлом
      s:= CheckWareFileLink(res, fID, WareID, soTecDocBatch);
      if (res=resError) then prMessageLOGS(nmProc+': del WareFileLink error('+IntToStr(WareID)+'): '+s, 'import', False);
    end; // for kt:= 0 to Ware.FileLinks.ListLinks.Count-1
  except
    on E: EBOBError do Result:= nmProc+': '+E.Message;
    on E: Exception do begin
      Result:= nmProc+': load error';
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
    end;
  end;
  SetLength(arTDfiles, 0);
end;
//============================================= доп.инф. по товару и ноде из TDT
procedure LoadWareNodeInfoTextFromTDT(WareID, pSupMFTD, nodeID, UserID, pSrc: Integer;
         pArticleTD: String; TdtIBS, ordIBS, ordIBSr: TIBSQL; ThreadData: TThreadData=nil);
const nmProc = 'LoadWareNodeInfoTextFromTDT'; // имя процедуры/функции
var j, gaID, pType, kt, ke, txtCount: integer;
    s, tm, ss, skod: string;
    arTXT: TarTextInfo;
begin
  kt:= 72;
  pType:= 0;
  gaID:= 0;
  txtCount:= 0;
  setLength(arTXT, 10);
  try try
    with Cache.FDCA.AutoTreeNodesSys[constIsAuto][nodeID] do if IsGATD then gaID:= SubCode;
    if (gaID<1) then Exit;
    with ordIBS.Transaction do if not InTransaction then StartTransaction;
    if ordIBS.SQL.Text='' then
      ordIBS.SQL.Text:= 'select linkID, errLink from AddNodeWareTextLink_new('+   // new txt
        ':NodeID, :WareID, :typeID, :pSupMFTD, :tmTD, :pText, :UserID, :pSrc)';
      ordIBS.ParamByName('NodeID').AsInteger:= NodeID;
      ordIBS.ParamByName('WareID').AsInteger:= WareID;
      ordIBS.ParamByName('pSupMFTD').AsInteger:= pSupMFTD;
      ordIBS.ParamByName('UserID').AsInteger:= UserID;
      ordIBS.ParamByName('pSrc').AsInteger:= pSrc;

    with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    if TdtIBS.SQL.Text='' then
      TdtIBS.SQL.Text:= 'select rINFTYPE, rTM, rTXT, rTYPEname'+
        ' from GetArtGATexts(:xart, :pSupMFTD, :gaID)';
    TdtIBS.ParamByName('xart').AsString:= pArticleTD;
    TdtIBS.ParamByName('pSupMFTD').AsInteger:= pSupMFTD;
    TdtIBS.ParamByName('gaID').AsInteger:= gaID;
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      ke:= TdtIBS.FieldByName('rINFTYPE').AsInteger;
      s:= TdtIBS.FieldByName('rTYPEname').AsString;
      with Cache.FDCA do begin       // ищем вид информации в кеше по кодам TDT
        pType:= 11;
        if not TypesInfoModel.FindInfoItemByTDcodes(j, pType, ke, kt) then begin
          // добавляем новый вид информации в кеш и в базу (pType - из FindInfoItemByTDcodes)
          ss:= TypesInfoModel.AddInfoModelItem(j, pType, ke, kt, s, UserID);
          if (ss<>'') then raise Exception.Create('add error: '+ss);
        end;
      end;
      pType:= j;

      s:= '';                // собираем строку текстового модуля
      while not TdtIBS.Eof and (ke=TdtIBS.FieldByName('rINFTYPE').AsInteger) do begin
        tm:= TdtIBS.FieldByName('rTM').AsString;
        while not TdtIBS.Eof and (ke=TdtIBS.FieldByName('rINFTYPE').AsInteger)
          and (tm=TdtIBS.FieldByName('rTM').AsString) do begin
          s:= s+' '+TdtIBS.FieldByName('rTXT').AsString;
          CheckStopExecute(UserID, ThreadData);
          TdtIBS.Next;
        end;
        s:= trim(s);
//        s:= CheckTextFirstUpAndSpaces(s); // проверка заглавной буквы и пробелов текста      // new txt
        if txtCount>High(arTXT) then setLength(arTXT, txtCount+10);
        arTXT[txtCount].ldmw    := 0; // эдесь - код линка текста
        arTXT[txtCount].supTD   := 0; // эдесь - признак наличия в нашей базе
        arTXT[txtCount].infotype:= pType;
        arTXT[txtCount].tmTD    := tm;
        arTXT[txtCount].text    := s;
        arTXT[txtCount].search  := AnsiUpperCase(StringReplace(s, ' ', '', [rfReplaceAll]));
        try                           // добавляем в базу
          with ordIBS.Transaction do if not InTransaction then StartTransaction;
          ordIBS.ParamByName('typeID').AsInteger:= pType;
          ordIBS.ParamByName('tmTD').AsString:= tm;
          ordIBS.ParamByName('pText').AsString:= s;
          ordIBS.ExecQuery;
          if (ordIBS.Eof and ordIBS.Bof) or (ordIBS.Fields[0].AsInteger<1) then
            raise Exception.Create('error add text link Node='+IntToStr(NodeID)+
              ' Ware='+IntToStr(WareID)+' tmTD='+tm+' txt='+s);

          arTXT[txtCount].ldmw:= ordIBS.Fields[0].AsInteger; // код линка текста
          with ordIBS.Transaction do if (ordIBS.Fields[1].AsInteger=0) then Commit
          else Rollback; // если линк уже был в базе
        except
          on E: Exception do begin
            ordIBS.Transaction.Rollback;
            prMessageLOGS(nmProc+'('+IntToStr(WareID)+'): '+E.Message, 'import', False);
          end;
        end;
        inc(txtCount);
        ordIBS.Close;
      end; // while ... and (ke=
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
    end;

    ss:= '';         // доп.инф. по товару и ноде из ORD (источник - TecDoc)
    with ordIBSr.Transaction do if not InTransaction then StartTransaction;
    if ordIBSr.SQL.Text='' then
      ordIBSr.SQL.Text:= 'select LWNTCODE, LWNTinfotype, WITTMTD, ITSEARCH'+  // new txt
        ' from LinkWareNodeText left join WareInfoTexts on WITCODE=LWNTWIT'+
        ' left join INFOTEXTS on ITCODE=WITTEXTCODE'+      // new txt
        ' where LWNTnodeID=:NodeID and LWNTwareID=:WareID and WITSUPTD=:SUPTD'+
        ' and LWNTSRCLECODE in ('+IntToStr(soTecDocBatch)+', '+IntToStr(soTDparts)+')';
    ordIBSr.ParamByName('NodeID').AsInteger:= NodeID;
    ordIBSr.ParamByName('WareID').AsInteger:= WareID;
    ordIBSr.ParamByName('SUPTD').AsInteger:= pSupMFTD;
    ordIBSr.ExecQuery;
    while not ordIBSr.Eof do begin  // ищем связки, кот.ушли из TD
      kt   := ordIBSr.FieldByName('LWNTCODE').AsInteger;
      pType:= ordIBSr.FieldByName('LWNTinfotype').AsInteger;
      tm   := ordIBSr.FieldByName('WITTMTD').AsString;
      s    := ordIBSr.FieldByName('ITSEARCH').AsString;
      skod := ordIBSr.FieldByName('LWNTCODE').AsString;
      for j:= 0 to txtCount-1 do if (arTXT[j].ldmw=kt) or
        ((arTXT[j].infotype=pType) and (arTXT[j].tmTD=tm) and (arTXT[j].search=s)) then begin
          skod:= '';           // если есть такой текст в TD - очищаем skod
          break;
        end;
      if skod<>'' then ss:= ss+fnIfStr(ss='', '', ',')+skod; // собираем строку кодов ненайденных связок
      CheckStopExecute(UserID, ThreadData);
      ordIBSr.Next;
    end;
    ordIBSr.Close;

    if ss<>'' then try  // если нашли связки, кот.ушли из TD - удаляем
      fnSetTransParams(ordIBSr.Transaction, tpWrite, True);
      try
        ordIBSr.SQL.Text:= 'delete from LinkWareNodeText where LWNTCODE in ('+ss+')';
        ordIBSr.ExecQuery;
        ordIBSr.Transaction.Commit;
      except
        on E: Exception do begin
          ordIBSr.Transaction.Rollback;
          prMessageLOGS(nmProc+'(del)('+IntToStr(WareID)+'): '+E.Message, 'import', False);
        end;
      end;
    finally
      ordIBSr.Close;
      fnSetTransParams(ordIBSr.Transaction, tpRead);
      ordIBSr.SQL.Text:= '';
    end;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do prMessageLOGS(nmProc+': error WareNode texts('+IntToStr(WareID)+'): '+E.Message, 'import', False);
  end;
  finally
    with ordIBS.Transaction do if InTransaction then Rollback;
    ordIBS.Close;
    TdtIBS.Close;
    setLength(arTXT, 0);
  end;
end;
//========================================== загрузка критериев товара из TecDoc
procedure LoadWareCrisFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;
          WareID, pSupMFTD, UserID: Integer; pArticleTD: String; ThreadData: TThreadData=nil);
const nmProc = 'LoadWareCrisFromTDT'; // имя процедуры/функции
// TdtIBS, ordIBS, ordIBSr передаются для увеличения скорости обработки
var j, pCriTD: Integer;
    s, criName, criValue, criValueUp: String;
    flNotEx: Boolean;
    ArCris: TarCriInfo;
begin
  SetLength(ArCris, 100);
  j:= 0;
  ordIBSr.Close;
  try
    with ordIBSr.Transaction do if not InTransaction then StartTransaction;
    ordIBSr.SQL.Text:= 'select LWCVCODE, WCRITDCODE, WCVSVALUE from LINKWARECRIVALUES'+
      ' left join WARECRIVALUES on WCVSCODE=LWCVWCVSCODE'+
      ' left join WARECRITERIES on WCRICODE=WCVSWCRICODE'+
      ' where LWCVWARECODE='+IntToStr(WareID)+' and LWCVWRONG="F"'+
      ' and LWCVSRCLECODE in ('+IntToStr(soTecDocBatch)+', '+IntToStr(soTDparts)+')';
    ordIBSr.ExecQuery;
    while not ordIBSr.Eof do begin // критерии товара из ORD
      if Length(ArCris)<(j+1) then SetLength(ArCris, j+100);
      ArCris[j].ldmw:=  ordIBSr.FieldByName('LWCVCODE').AsInteger; // здесь - код связки
      ArCris[j].CRITD:= ordIBSr.FieldByName('WCRITDCODE').AsInteger;
      ArCris[j].ValueUp:= AnsiUpperCase(ordIBSr.FieldByName('WCVSVALUE').AsString);
      inc(j);
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      ordIBSr.Next;
    end;
    ordIBSr.Close;
    if Length(ArCris)>j then SetLength(ArCris, j);

    try
      ordIBS.SQL.Clear;
      TdtIBS.Close;
      with TdtIBS.Transaction do if not InTransaction then StartTransaction;
      TdtIBS.SQL.Text:= 'select xCri_ID, xCri_desc, xCri_val'+
        ' from GETARTICLECriteries(:art_nr, '+IntToStr(pSupMFTD)+')';
      TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
      TdtIBS.ExecQuery;
      while not TdtIBS.Eof do begin
        pCriTD:= TdtIBS.FieldByName('xCri_ID').AsInteger;
        criName:= TdtIBS.FieldByName('xCri_desc').AsString;
        criValue:= TdtIBS.FieldByName('xCri_val').AsString; // значение критерия
        criValueUp:= AnsiUpperCase(criValue);
        flNotEx:= True;
        for j:= Low(ArCris) to High(ArCris) do with ArCris[j] do
          if (CRITD=pCriTD) and (ValueUp=criValueUp) then begin
            flNotEx:= False;
            ldmw:= 0; // обнуляем код связки
            break;
          end;
        if flNotEx then begin
          s:= Cache.CheckWareCriValueLink(WareID, pCriTD, UserID, soTecDocBatch, CriName, criValue, ordIBS);
          if (s<>'') and (s<>'exists') then
            prMessageLOGS(nmProc+': error add ware Cri link: '+s, 'import', False);
        end;
        CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
        TdtIBS.Next;
      end;

      s:= ''; // собираем коды линков, кот.ушли из TD
      for j:= Low(ArCris) to High(ArCris) do with ArCris[j] do
        if ldmw>0 then s:= s+fnIfStr(s='', '', ',')+IntToStr(ldmw);

      if s<>'' then try
        ordIBS.Close;     // удаляем линки, кот.ушли из TD
        with ordIBS.Transaction do if not InTransaction then StartTransaction;
        ordIBS.SQL.Text:= 'delete from LINKWARECRIVALUES where LWCVCODE in ('+s+')';
        ordIBS.ExecQuery;
        ordIBS.Transaction.Commit;
      except
        on E: Exception do begin
          ordIBS.Transaction.Rollback;
          prMessageLOGS(nmProc+': error del old ware criteries('+IntToStr(WareID)+'): '+E.Message, 'import', False);
        end;
      end;
    except
      on E: EBOBError do raise EBOBError.Create(E.Message);
      on E: Exception do prMessageLOGS(nmProc+': error add ware criteries('+IntToStr(WareID)+'): '+E.Message, 'import', False);
    end;
  finally
    TdtIBS.Close;
    ordIBS.Close;
    ordIBSr.Close;
    SetLength(ArCris, 0);
  end;
end;
//============================== загрузка связок товара из TDT по 1-му источнику
procedure LoadLinkListsFromTDT(TdtIBS: TIBSQL; WareID, UserID, pSrc: Integer;
          var arInfo: TArLinkInfo; var ii, addLink3: Integer; ThreadData: TThreadData=nil);
const nmProc = 'LoadLinkListsFromTDT'; // имя процедуры/функции
var nodeTD, pNodeORD, modTD, pModORD, mlTD, pMlORD, mfTD, pMfORD, res, i, j, iLinkORD, iLagt: Integer;
    s: String;
    pNodLinks: TNodeLinks; // для удобства
    DupNodeCodes: Tai;
begin
  with TdtIBS.Transaction do if not InTransaction then StartTransaction;
  TdtIBS.ExecQuery;
  with Cache.FDCA do try
    while not TdtIBS.Eof do begin
      nodeTD:= TdtIBS.FieldByName('xGA').AsInteger;  // код TD ноды GA
      pNodeORD:= AutoTreeNodesSys[constIsAuto].GetMainNodeIDByTDcode(nodeTD); // все связки 3 - на главную ноду
  //      if (pNodeORD<1) or not AutoTreeNodesSys[constIsAuto][pNodeORD].Visible then begin
      if (pNodeORD<1) then begin // видимость нод не учитываем !!! если не нашли - прокручиваем
        prMessageLOGS(nmProc+': not found nodeTD= '+IntToStr(nodeTD), 'import', False);
        while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger) do TdtIBS.Next;
        Continue;
      end;
      setlength(DupNodeCodes, 0); // список кодов видимых дублирующих нод
      DupNodeCodes:= AutoTreeNodesSys[constIsAuto].GetDuplicateNodeCodes(pNodeORD, True);

      while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger) do begin // 1 нода
        mfTD  := TdtIBS.FieldByName('xMf').AsInteger; // код TD произв.авто
        pMfORD:= Manufacturers.GetManufIDByTDcode(mfTD);
                                            // произв.нет или невидим - прокручиваем
        if (pMfORD<1) or not Manufacturers[pMfORD].CheckIsVisible(constIsAuto) then begin 
          while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger)
            and (mfTD=TdtIBS.FieldByName('xMf').AsInteger) do TdtIBS.Next;
          Continue;
        end;

        while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger) // 1 производитель
          and (mfTD=TdtIBS.FieldByName('xMf').AsInteger) do begin
          mlTD  := TdtIBS.FieldByName('xMs').AsInteger; // код TD модельного ряда
          pMlORD:= Manufacturers[pMfORD].GetMfMLineIDByTDcode(mlTD);
                                              // м.р. нет или невидим - прокручиваем
          if (pMlORD<1) or not ModelLines[pMlORD].IsVisible then begin
            while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger)
              and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
              and (mlTD=TdtIBS.FieldByName('xMs').AsInteger) do TdtIBS.Next;
            Continue;
          end;

          while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger) // 1 мод.ряд
            and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
            and (mlTD=TdtIBS.FieldByName('xMs').AsInteger) do begin
            modTD := TdtIBS.FieldByName('xMT').AsInteger; // код TD модели
            pModORD:= ModelLines[pMlORD].GetMLModelIDByTDcode(modTD);
                                              // модели нет или невидима - прокручиваем
            if (pModORD<1) or not Models[pModORD].IsVisible then begin
              while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger)
                and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
                and (mlTD=TdtIBS.FieldByName('xMs').AsInteger)
                and (modTD=TdtIBS.FieldByName('xMT').AsInteger) do TdtIBS.Next;
              Continue;
            end;

            iLinkORD:= -1; // ищем связку ORD в массиве arInfo
            for i:= 0 to High(arInfo) do
              if (arInfo[i].nodeORD=pNodeORD) and (arInfo[i].modORD=pModORD) then begin
                iLinkORD:= i;
                break;
              end;

            if (iLinkORD<0) then begin //-------- если не нашли - добавляем связки
              iLinkORD:= ii;               // проверяем связку 2 с нодой nodeORD
              pNodLinks:= Models[pModORD].NodeLinks; // связки 2 модели modORD
              if not pNodLinks.LinkExists(pNodeORD) then begin
                s:= CheckModelNodeLinkDup(pModORD, pNodeORD, '0', Res, pSrc, userID);
                if res=resError then begin         // если ошибка - прокручиваем
                  prMessageLOGS(nmProc+': '+s, 'import', False);
                  while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger)
                    and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
                    and (mlTD=TdtIBS.FieldByName('xMs').AsInteger)
                    and (modTD=TdtIBS.FieldByName('xMT').AsInteger) do TdtIBS.Next;
                  Continue;
                end;
              end;
                      // проверяем связку 2 на дублирующие ноды (на всяк.случай)
              for i:= Low(DupNodeCodes) to High(DupNodeCodes) do
                if not pNodLinks.LinkExists(DupNodeCodes[i]) then begin
                  s:= CheckModelNodeLinkDup(pModORD, DupNodeCodes[i], '0', Res, pSrc, userID);
                  if res=resError then prMessageLOGS(nmProc+': '+s, 'import', False);
                end;
              // проверяем связку 3 модели modORD и ноды nodeORD с товаром WareID
              if not pNodLinks.DoubleLinkExists(pNodeORD, WareID) then begin
                res:= resAdded;
                s:= CheckWareModelNodeLink(WareID, pModORD, pNodeORD, res, pSrc, userID);
                if res=resError then begin         // если ошибка - прокручиваем
                  prMessageLOGS(nmProc+': '+s, 'import', False);
                  while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger)
                    and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
                    and (mlTD=TdtIBS.FieldByName('xMs').AsInteger)
                    and (modTD=TdtIBS.FieldByName('xMT').AsInteger) do TdtIBS.Next;
                  Continue;
                end else if res=resAdded then inc(addLink3);
              end;
                                                // новую связку ORD - в массив
              if High(arInfo)<iLinkORD then setlength(arInfo, iLinkORD+100);
              with arInfo[iLinkORD] do begin
                nodeORD:= pNodeORD;
                nodTD  := nodeTD;
                modORD := pModORD;
                modelTD:= modTD;
                Src    := pSrc;
                ldmw   := 0;
                SetLength(PartNums, 0);
                SetLength(PartLagts, 0);
                SetLength(PartLists, 0);
                SetLength(TextLists, 0);
              end;
              inc(ii);
            end; // if iLinkORD<0
                                        // собираем коды связок TD на связку ORD
            j:= Length(arInfo[iLinkORD].PartLagts);
            // может быть несколько одинаковых связок с разными порциями условий
            while not TdtIBS.Eof and (nodeTD=TdtIBS.FieldByName('xGA').AsInteger) // 1 модель
              and (mfTD=TdtIBS.FieldByName('xMf').AsInteger)
              and (mlTD=TdtIBS.FieldByName('xMs').AsInteger)
              and (modTD=TdtIBS.FieldByName('xMT').AsInteger) do begin
              iLagt:= TdtIBS.FieldByName('xlagt').AsInteger;
              with arInfo[iLinkORD] do   // запоминаем порции условий
                if fnInIntArray(iLagt, PartLagts)<0 then begin
                  setlength(PartNums, j+1);
                  PartNums[j]:= 0;
                  setlength(PartLagts, j+1);
                  PartLagts[j]:= iLagt;
                  setlength(PartLists, j+1);
                  PartLists[j]:= TStringList.Create;
                  setlength(TextLists, j+1);
                  TextLists[j]:= TStringList.Create;
                  inc(j);
                end; // with arInfo[iLinkORD]

              CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
              TdtIBS.Next;
            end; // while ... and (modTD=
          end; // while ... and (mlTD=
        end; // while ... and (mfTD=
      end; // while ... and (nodeTD=
    end;
  finally
    TdtIBS.Close;
    setlength(DupNodeCodes, 0); 
  end;
end;
//=============================== загрузка связок товара с двигателями из TecDoc
function LoadWareEngLinksUsesFromTDT( WareID, UserID: Integer;
         var addLinkEng: Integer; ThreadData: TThreadData=nil; CheckArt: Boolean=True): String;
const nmProc = 'LoadWareEngLinksUsesFromTDT'; // имя процедуры/функции
var i, j, jj, ii, ij, ji, aCount, uCount, pEngTD, pGA, pLage, pCriTD, pEngORD,
      pNodeORD, DelUses, AddUses, iUse, pSupMFTD, DelCount: Integer;
    criValue, pArticleTD: String;
    flNotEx, flag, fl: Boolean;
    ArCris: array of TCriInfo;
    arEngLinks: array of TEngLinkInfo;
    Nodes: TAutoTreeNodes;
    Engns: TEngines;
    TdtIBD, ordIBD, ordIBDr: TIBDatabase;
    TdtIBS, ordIBS, ordIBSr: TIBSQL;
    ErrUseNums: Tai; // номера порций условий для удаления
begin
  Result:= '';
  SetLength(arEngLinks, 0);
  SetLength(ArCris, 0);
  SetLength(ErrUseNums, 0); // номера порций условий для удаления
  addLinkEng:= 0;
  AddUses:= 0;
  DelUses:= 0;
  DelCount:= 0;
  tdtIBD:= nil;
  tdtIBS:= nil;
  ordIBD:= nil;
  ordIBDr:= nil;
  ordIBS:= nil;
  ordIBSr:= nil;
  try try
    with Cache.GetWare(WareID) do begin
      if (ArticleTD='') or (ArtSupTD<1) then
        raise EBOBError.Create(MessText(mtkNotEnoughParams));
      pArticleTD:= ArticleTD;
      pSupMFTD:= ArtSupTD; // SupID TecDoc (DS_MF_ID !!!)
    end;

//    prMessageLOGS('      load engine links', 'import_test', False);
//----------------------------------------------------------------------- связки
    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

    if CheckArt then begin
      TdtIBS.SQL.Text:= 'select art_id from articles'+
        ' left join data_suppliers on ds_id=art_sup_id'+
        ' where art_nr=:art_nr and ds_mf_id='+IntToStr(pSupMFTD);
      TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
      TdtIBS.ExecQuery;
      if (TdtIBS.Bof and TdtIBS.Eof) or (TdtIBS.Fields[0].AsInteger<1) then // если артикула в TD нет
        raise Exception.Create('не найден артикул '+pArticleTD);
      TdtIBS.Close;
    end;

    TdtIBS.SQL.Text:= 'select rGA, rEng, rlage from GETARTICLEGAENGINES'+
      '(:art_nr, '+IntToStr(pSupMFTD)+') order by rGA, rEng';
    TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
    TdtIBS.ExecQuery;
    if TdtIBS.Bof and TdtIBS.Eof then Exit; // если связок нет - выходим

    ordIBD:= cntsORD.GetFreeCnt;
    if not Assigned(ordIBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpWrite, true);
    ordIBS.SQL.Text:= 'select * from AddEngNodeWareLink(:xEng, :xNode, '+
      IntToStr(WareID)+', '+IntToStr(UserID)+', '+IntToStr(soTecDocBatch)+')';

    ordIBDr:= cntsORD.GetFreeCnt; // только для чтения
    if not Assigned(ordIBDr) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    ordIBSr:= fnCreateNewIBSQL(ordIBDr, 'ordIBSr_'+nmProc, -1, tpRead, true);

    ordIBSr.SQL.Text:= 'select LENTRNACODE, LENDENGCODE, LENWCODE, TRNAMAINCODE'+ // выбираем связки из ORD
      ' from LINKENGINENODE left join LINKENGNODEWARE on LENWLENCODE=LENCODE'+
      ' left join TREENODESAUTO on TRNACODE=LENTRNACODE'+
      ' where LENWWARECODE='+IntToStr(WareID);
    ordIBSr.ExecQuery;
    j:= 0;
    while not ordIBSr.Eof do begin // связи товара из ORD
      if Length(arEngLinks)<(j+1) then SetLength(arEngLinks, j+100);
      with arEngLinks[j] do begin
        nodeORD:= ordIBSr.FieldByName('TRNAMAINCODE').AsInteger;
        engORD := ordIBSr.FieldByName('LENDENGCODE').AsInteger;
        xLenw  := ordIBSr.FieldByName('LENWCODE').AsInteger;
        SetLength(PartLages, 0);
        SetLength(PartNums, 0);   // номера порций условий
        SetLength(ArUseParts, 0); // порции условий
      end;
      inc(j);
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      ordIBSr.Next;
    end;
    ordIBSr.Close;
    aCount:= j;

    Nodes:= Cache.FDCA.AutoTreeNodesSys[constIsAuto];
    Engns:= Cache.FDCA.Engines;

    while not TdtIBS.Eof do begin
      pGA   := TdtIBS.FieldByName('rGA').AsInteger;
      pNodeORD:= Nodes.GetMainNodeIDByTDcode(pGA); // ищем ноду
      if (pNodeORD<1) then begin // если не нашли - прокручиваем
        prMessageLOGS(nmProc+': not found nodeTD= '+IntToStr(pGA), 'import', False);
        while not TdtIBS.Eof and (pGA=TdtIBS.FieldByName('rGA').AsInteger) do TdtIBS.Next;
        Continue;
      end;

      pEngTD:= TdtIBS.FieldByName('rEng').AsInteger;
      pEngORD:= Engns.GetIDBySubCode(pEngTD); // ищем двигатель
      if (pEngORD<1) then begin // если у нас такого нет - прокручиваем
        while not TdtIBS.Eof and (pGA=TdtIBS.FieldByName('rGA').AsInteger)
          and (pEngTD=TdtIBS.FieldByName('rEng').AsInteger) do TdtIBS.Next;
        Continue;
      end;

      while not TdtIBS.Eof and (pGA=TdtIBS.FieldByName('rGA').AsInteger)
        and (pEngTD=TdtIBS.FieldByName('rEng').AsInteger) do begin
        pLage := TdtIBS.FieldByName('rlage').AsInteger;
        flNotEx:= True;
        for j:= 0 to aCount-1 do with arEngLinks[j] do // ищем связку
          if (nodeORD=pNodeORD) and (engORD=pEngORD) then begin
            prAddItemToIntArray(pLage, PartLages); // собираем коды для условий
            flNotEx:= False;
            break;
          end;
        if flNotEx then try // если не нашли - добавляем
          with ordIBS.Transaction do if not InTransaction then StartTransaction;
          ordIBS.ParamByName('xEng').AsInteger:= pEngORD;
          ordIBS.ParamByName('xNode').AsInteger:= pNodeORD;
          ordIBS.ExecQuery;
          if (ordIBS.Eof and ordIBS.Bof) then i:= 0 else i:= ordIBS.Fields[0].AsInteger;
          if (i<1) then raise Exception.Create('empty link code');
          with ordIBS.Transaction do if InTransaction then Commit;
          j:= aCount;
          if Length(arEngLinks)<(j+1) then SetLength(arEngLinks, j+100);
          with arEngLinks[j] do begin
            nodeORD:= pNodeORD;     // запоминаем новую связку
            engORD := pEngORD;
            xLenw  := i;
            SetLength(PartLages, 1);
            PartLages[0]:= pLage;
            SetLength(PartNums, 0);   // номера порций условий
            SetLength(ArUseParts, 0); // порции условий
          end;
          inc(aCount);
          inc(addLinkEng);
          j:= Engns.GetEngine(pEngORD).EngMFau;
          if Cache.FDCA.Manufacturers.ManufExists(j) then
            with Cache.FDCA.Manufacturers[j] do
              if not MfHasEngWares then MfHasEngWares:= true;
        except
          on E: Exception do begin
            with ordIBS.Transaction do if InTransaction then Rollback;
            prMessageLOGS(nmProc+': error add ware/node/eng link '+IntToStr(WareID)+'/'+
              IntToStr(pNodeORD)+'/'+IntToStr(pEngORD)+': '+E.Message, 'import', False);
          end;
        end;
        ordIBS.Close;
        TdtIBS.Next;
      end;
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
    end;
    TdtIBS.Close;
    ordIBS.SQL.Clear;

    for j:= 0 to aCount-1 do with arEngLinks[j] do begin  // заготовки массивов
      i:= Length(PartLages);
      SetLength(PartNums, i);   // номера порций условий
      SetLength(ArUseParts, i); // порции условий
      for i:= 0 to High(PartNums) do PartNums[i]:= 0;
      for i:= 0 to High(ArUseParts) do SetLength(ArUseParts[i], 0); // 1 порция условий
    end;

//--------------------------------------------------------------- условия из TDT
//      with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    TdtIBS.SQL.Text:= 'select rCri_ID, rCri_desc, rCri_val'+
      ' from GETARTICLEGAENGUSES(:lage)';
    for j:= 0 to aCount-1 do with arEngLinks[j] do begin
      for i:= 0 to High(PartLages) do begin
        TdtIBS.ParamByName('lage').AsInteger:= PartLages[i];
        TdtIBS.ExecQuery;
        uCount:= 0;
        while not TdtIBS.Eof do begin // условия из TDT
          if High(ArUseParts[i])<uCount then SetLength(ArUseParts[i], uCount+100);
          with ArUseParts[i][uCount] do begin
            CRITD:= TdtIBS.FieldByName('rCri_ID').AsInteger;    // код TD критерия
            CriName:= TdtIBS.FieldByName('rCri_desc').AsString; // нужно для записи в базу
//              CriNameUp:= AnsiUpperCase(CriName);
            Value:= TdtIBS.FieldByName('rCri_val').AsString;    // значение критерия
            if Value='' then ValueUp:= '' else ValueUp:= AnsiUpperCase(Value);
          end;
          inc(uCount);
          TdtIBS.Next;
        end;
        TdtIBS.Close;
        if Length(ArUseParts[i])>uCount then SetLength(ArUseParts[i], uCount);
      end; // for i:= 0 to High(xlages)
      //---------------------------------- проверяем дубликаты порций условий TD
      if length(PartLages)>1 then begin
        for jj:= 0 to High(PartLages) do begin
          if (Length(ArUseParts[jj])<1) then Continue;

          for ji:= jj+1 to High(PartLages) do begin
            if (Length(ArUseParts[jj])<>Length(ArUseParts[ji])) then Continue;

            flag:= False; // признак несовпадения массивов
            for i:= Low(ArUseParts[jj]) to High(ArUseParts[jj]) do begin // сверяем ArUseParts
              fl:= False; // признак - нашли элемент
              for ii:= Low(ArUseParts[ji]) to High(ArUseParts[ji]) do begin // ищем элемент jj-го массива в ji-том массиве
                fl:= (ArUseParts[jj][i].CRITD=ArUseParts[ji][ii].CRITD) and
                     (ArUseParts[jj][i].ValueUp=ArUseParts[ji][ii].ValueUp);
                if fl then Break;
              end; // for ii:= 0 to
              if fl then Continue; // нашли - продолжаем сверку элементов

              flag:= True; // что-то не нашли - прекращаем сверку элементов
              Break;
            end; // for i:= 0 to
            if flag then Continue; // что-то не нашли

            //--------------------- ArUseParts[jj] = ArUseParts[ji]
            SetLength(ArUseParts[ji], 0);  // чистим дубликат
            PartLages[ji]:= 0;
          end; // for ji:= jj+1 to ...
        end; // for jj:= 0 to
      end; // if length(PartLages)>1
    end; //  for j:= 0 to aCount-1

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

//--------------------------------------------------------------- условия из ORD
//      with ordIBSr.Transaction do if not InTransaction then StartTransaction;
    ordIBSr.SQL.Text:= 'select WCRITDCODE, WCVSVALUE, LENWUPART'+
      ' from LINKENGNODEWAREUSAGE'+
      ' left join WARECRIVALUES on WCVSCODE=LENWUWCVSCODE'+
      ' left join WARECRITERIES on WCRICODE=WCVSWCRICODE'+
      ' where LENWULENWCODE=:lenw order by LENWUPART';

    with ordIBS.Transaction do if not InTransaction then StartTransaction;
    ordIBS.SQL.Text:= 'delete from LINKENGNODEWAREUSAGE'+ // для удаления ненайденных порций
      ' where LENWULENWCODE=:lenw and LENWUPART=:part';

    for j:= 0 to aCount-1 do with arEngLinks[j] do begin
      ordIBSr.ParamByName('lenw').AsInteger:= xLenw; // 1 связка 3
      ordIBSr.ExecQuery;
      while not ordIBSr.Eof do begin // условия из ORD
        iUse:= ordIBSr.FieldByName('LENWUPART').AsInteger;
        uCount:= 0;                     // 1 порция из ORD - в ArCris
        DelCount:= 0;          // чистим массив номеров порций условий ORD для удаления
        while not ordIBSr.Eof and (iUse=ordIBSr.FieldByName('LENWUPART').AsInteger) do begin
          if High(ArCris)<uCount then SetLength(ArCris, uCount+100);
          with ArCris[uCount] do begin
            CRITD:= ordIBSr.FieldByName('WCRITDCODE').AsInteger;
            Value:= ordIBSr.FieldByName('WCVSVALUE').AsString;
            if Value='' then ValueUp:= '' else ValueUp:= AnsiUpperCase(Value);
          end;
          inc(uCount);
          CheckStopExecute(UserID, ThreadData);
          ordIBSr.Next;
        end; // while ... and (iUse=
//------------------------------------------------------- проверяем 1 порцию ORD
        for jj:= 0 to High(ErrUseNums) do ErrUseNums[jj]:= 0;

        pLage:= -1;         // ищем такую же порцию в arEngLinks[j].ArUseParts
        for jj:= 0 to High(ArUseParts) do begin
          if (PartNums[jj]>0) or (Length(ArUseParts[jj])<1) then Continue; // порция уже найдена
                                      // кол-во условий в порциях не совпадает
          if Length(ArUseParts[jj])<>uCount then Continue;

          pLage:= -1;                              // проверяем 1 порцию TDT
          for ii:= 0 to High(ArUseParts[jj]) do with ArUseParts[jj][ii] do begin
            pCriTD:= CRITD;     // берем 1 условие из порции TDT
            criValue:= ValueUp;
            pLage:= -1;
//            if uCount>0 then
            for ij:= 0 to uCount-1 do // ищем такое же условие в ArCris
              if (ArCris[ij].CRITD=pCriTD) and (ArCris[ij].ValueUp=criValue) then begin
                pLage:= ij; // нашли соответствие
                break;
              end;
            if pLage<0 then break; // какое-то условие не нашли - проверку прекращаем
          end; // for ii:= 0 to High(arEngLinks[j].ArUseParts[jj])

          if pLage>-1 then begin  // если все условия нашли
            if fnInIntArray(iUse, PartNums)<0 then PartNums[jj]:= iUse;
            SetLength(ArUseParts[jj], 0);          // чистим
            break;
          end;
        end; // for jj:= 0 to High(arEngLinks[j].ArUseParts)

        if (pLage<0) and (fnInIntArray(iUse, ErrUseNums)<0) then begin // порцию ORD в TDT не нашли
          if High(ErrUseNums)<DelCount then SetLength(ErrUseNums, DelCount+10); // номера порций условий ORD для удаления
          ErrUseNums[DelCount]:= iUse;
          inc(DelCount);
        end;
//------------------------------------------------------- проверили 1 порцию ORD
      end; // while not ordIBSr.Eof
      ordIBSr.Close;

//-------------------------------------- если надо удалять порции условий из ORD
      if DelCount>0 then begin
        with ordIBS.Transaction do if not InTransaction then StartTransaction;
        ordIBS.ParamByName('lenw').AsInteger:= xLenw;
        for jj:= 0 to DelCount-1 do if (ErrUseNums[jj]>0) then try
          with ordIBS.Transaction do if not InTransaction then StartTransaction;
          ordIBS.ParamByName('part').AsInteger:= ErrUseNums[jj];
          ordIBS.ExecQuery;
          with ordIBS.Transaction do if InTransaction then Commit;
          inc(DelUses);
        except
          on E: Exception do begin
            with ordIBS.Transaction do if InTransaction then Rollback;
            prMessageLOGS(nmProc+': error del eng use part '+IntToStr(ErrUseNums[jj])+': '+E.Message, 'import', False);
          end;
        end;
      end; // if DelCount>0
    end; // for j:= 0 to aCount-1 do with arEngLinks[j] do

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

//--------------------------------------------- пишем новые порции условий в ORD
    with ordIBS.Transaction do if not InTransaction then StartTransaction;
    ordIBS.SQL.Text:= 'select * from ADDENGNODEWAREPARTUSAGELINK(:xEng, :xNode, '+
      IntToStr(WareID)+', :part, :criTD, :CriName, :CriValue, '+
      IntToStr(UserID)+', '+IntToStr(soTecDocBatch)+')';

    for j:= 0 to aCount-1 do with arEngLinks[j] do begin
      if Length(ArUseParts)<1 then Continue;

      for jj:= 0 to High(ArUseParts) do begin
        if (PartNums[jj]>0) or (Length(ArUseParts[jj])<1) then Continue;

        with ordIBS.Transaction do if not InTransaction then StartTransaction;
        ordIBS.ParamByName('xEng').AsInteger := EngORD;
        ordIBS.ParamByName('xNode').AsInteger:= NodeORD;

        for ij:= 0 to High(ArUseParts[jj]) do with ArUseParts[jj][ij] do begin
          try
            with ordIBS.Transaction do if not InTransaction then StartTransaction;
            ordIBS.ParamByName('criTD').AsInteger  := CRITD;
            ordIBS.ParamByName('CriName').AsString := CriName;
            ordIBS.ParamByName('CriValue').AsString:= Value; // значение критерия
            ordIBS.ParamByName('part').AsInteger   := PartNums[jj];
            ordIBS.ExecQuery;
            if (ordIBS.Bof and ordIBS.Eof) then raise Exception.Create('empty ordIBS');
            if ordIBS.FieldByName('ERRLINK').AsInteger<0 then raise Exception.Create('exists');
            if ordIBS.FieldByName('ERRLINK').AsInteger>0 then raise Exception.Create('wrong');
            if ordIBS.FieldByName('PARTID').AsInteger<1 then raise Exception.Create('empty PartID');

            if PartNums[jj]<1 then PartNums[jj]:= ordIBS.FieldByName('PARTID').AsInteger; // номер новой порции
            with ordIBS.Transaction do if InTransaction then Commit;
            inc(AddUses);
          except
            on E: Exception do begin
              with ordIBS.Transaction do if InTransaction then Rollback;
              if E.Message<>'exists' then
                prMessageLOGS(nmProc+': error add Lenw/criTD/CriValue '+ IntToStr(xLenw)+'/'+
                  IntToStr(CRITD)+'/'+Value+': '+E.Message, 'import', False);
            end;
          end;
          ordIBS.Close;
        end; // for ij:= 0 to High(ArUseParts[jj])
      end; // for i:= 0 to High(ArUseParts)
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
    end; //  for j:= 0 to aCount-1
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do begin
      Result:= nmProc+': '+E.Message;
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, 'error', E.Message, '', false, 'import');
    end;
  end;
  finally
    prFreeIBSQL(TdtIBS);
    cntsTDT.SetFreeCnt(TdtIBD);
    prFreeIBSQL(ordIBS);
    cntsORD.SetFreeCnt(ordIBD);
    prFreeIBSQL(ordIBSr);
    cntsORD.SetFreeCnt(ordIBDr);
    SetLength(ArCris, 0);
    for i:= 0 to High(arEngLinks) do begin
      SetLength(arEngLinks[i].PartLages, 0);
      SetLength(arEngLinks[i].PartNums, 0);
      for j:= 0 to High(arEngLinks[i].ArUseParts) do
        SetLength(arEngLinks[i].ArUseParts[j], 0);
      SetLength(arEngLinks[i].ArUseParts, 0);
    end;
    SetLength(arEngLinks, 0);
    SetLength(ErrUseNums, 0); // номера порций условий для удаления
  end;
//  if (addLinkEng>0) or (AddUses>0) or (DelUses>0) then
//    prMessageLOGS(nmProc+':'+fnIfStr(addLinkEng>0, ' add '+IntToStr(addLinkEng)+' eng links', '')+
//      fnIfStr(AddUses>0, ' add '+IntToStr(AddUses)+' eng uses', '')+
//      fnIfStr(DelUses>0, ' del '+IntToStr(DelUses)+' eng use parts', ''), 'import', False);
end;
//================================== загрузка порций условий и текстов из TecDoc
procedure LoadModelNodeWareUseAndTextListsFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;
          WareID, pSupMFTD, UserID: Integer; var arInfo: TArLinkInfo;
          ThreadData: TThreadData=nil; CheckTexts: Boolean=False);
const nmProc = 'LoadModelNodeWareUseAndTextListsFromTDT'; // имя процедуры/функции
// TdtIBS, ordIBS, ordIBSr передаются для увеличения скорости обработки
var ii, criTD, jj, ke, kt, pType, j, i, ResCode: Integer;
    s, ss, criName, usValue, tm: String;
    ErrUseNums, ErrTxtNums: Tai;
    flag: Boolean;
begin
  kt:= 72;
  pType:= 0;
  SetLength(ErrUseNums, 0);  // массив номеров порций условий, кот.надо удалять
  SetLength(ErrTxtNums, 0);  // массив номеров порций текстов, кот.надо удалять
  try
    ordIBSr.Close;
    ordIBSr.SQL.Clear;
    ordIBS.Close;
    ordIBS.SQL.Clear;
    TdtIBS.Close;
  //------------------------------------------- из TDT порция условий к связке 3
    with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    TdtIBS.SQL.Text:= 'select xCri_ID, xCri_desc, xCri_val'+
      ' from GetArticleGATypeUsesNew(:xlagt)';
    TdtIBS.Prepare;
    for ii:= 0 to High(arInfo) do with arInfo[ii] do begin
      if (ldmw<1) or (length(PartLagts)<1) then Continue;

      for jj:= 0 to High(PartLagts) do try // перебираем связки TD
        if PartLists[jj].Count>0 then PartLists[jj].Clear;
        try
          TdtIBS.ParamByName('xlagt').AsInteger:= PartLagts[jj];
          TdtIBS.ExecQuery;
          while not TdtIBS.Eof do begin
            criTD:= TdtIBS.FieldByName('xCri_ID').AsInteger;
            criName:= TdtIBS.FieldByName('xCri_desc').AsString;
            usValue:= TdtIBS.FieldByName('xCri_val').AsString;  // значение условия
            PartLists[jj].AddObject(criName+cStrValueDelim+usValue, Pointer(criTD)); // формируем списки условий
            TdtIBS.Next;
          end;
          CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
        except
          on E: EBOBError do raise EBOBError.Create(E.Message);
          on E: Exception do prMessageLOGS(nmProc+': mod='+IntToStr(modORD)+
            ', node='+IntToStr(nodeORD)+': '+E.Message, 'import', False);
        end;
      finally
        TdtIBS.Close;
      end; // for jj:= 0 to High(PartLagts)
    end; // for ii:= 0 to High(arInfo)

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

  //------------------------------------------- из TDT порция текстов к связке 3
    with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    TdtIBS.SQL.Text:= 'select rINFTYPE, rTM, rTXT, rTYPEname'+
                      ' from GetArtGAMtTextPart(:xLAGT)';
    TdtIBS.Prepare;
    for ii:= 0 to High(arInfo) do with arInfo[ii] do begin
      if (ldmw<1) or (length(PartLagts)<1) then Continue;

      for jj:= 0 to High(PartLagts) do begin // перебираем связки TD
        if TextLists[jj].Count>0 then PartLists[jj].Clear;
        try
          with TdtIBS.Transaction do if not InTransaction then StartTransaction;
          TdtIBS.ParamByName('xLAGT').AsInteger:= PartLagts[jj];
          TdtIBS.ExecQuery;
          while not TdtIBS.Eof do begin
            ke:= TdtIBS.FieldByName('rINFTYPE').AsInteger;
            s:= TdtIBS.FieldByName('rTYPEname').AsString;
            with Cache.FDCA do begin  // ищем вид информации в кеше по кодам TDT
              pType:= 11;
              j:= 0;
              if not TypesInfoModel.FindInfoItemByTDcodes(j, pType, ke, kt) then begin
                // добавляем новый вид информации в кеш и в базу (pType - из FindInfoItemByTDcodes)
                ss:= TypesInfoModel.AddInfoModelItem(j, pType, ke, kt, s, UserID);
                if (ss<>'') then raise Exception.Create('add error: '+ss);
              end;
            end;
            pType:= j;
            while not TdtIBS.Eof and (ke=TdtIBS.FieldByName('rINFTYPE').AsInteger) do begin
              tm:= TdtIBS.FieldByName('rTM').AsString;
              s:= '';                        // собираем текстовый модуль в строку
              while not TdtIBS.Eof and (ke=TdtIBS.FieldByName('rINFTYPE').AsInteger)
                and (tm=TdtIBS.FieldByName('rTM').AsString) do begin
                s:= s+' '+TdtIBS.FieldByName('rTXT').AsString;
                TdtIBS.Next;
              end;
//              s:= CheckTextFirstUpAndSpaces(s); // проверка заглавной буквы и пробелов текста     // new txt
              s:= trim(s); // <IntToStr(код типа текста)>=<идентификатор TecDoc>+cSpecDelim+<текст>
              s:= IntToStr(pType)+cStrValueDelim+tm+cSpecDelim+s;
              TextLists[jj].AddObject(s, Pointer(pSupMFTD)); // формируем список
            end; // while not TdtIBS.Eof and (ke=
          end; // while not TdtIBS.Eof
        except
          on E: Exception do prMessageLOGS(nmProc+': mod='+IntToStr(modORD)+
            ', node='+IntToStr(nodeORD)+': '+E.Message, 'import', False);
        end;
        TdtIBS.Close;
      end; // for jj:= 0 to High(PartLagts)
    end; // for ii:= 0 to High(arInfo)

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

    for ii:= 0 to High(arInfo) do with arInfo[ii] do begin
      if (ldmw<1) or (length(PartLagts)<1) then Continue;

      //--------------------------------------- проверяем дубликаты связок TD
      if length(PartLagts)>1 then begin

        for jj:= 0 to High(PartLagts) do begin
          if PartLists[jj].Count>1 then PartLists[jj].Sort;
          if TextLists[jj].Count>1 then TextLists[jj].Sort;
        end;

        for jj:= 0 to High(PartLagts) do begin
          if (PartLists[jj].Count<1) and (TextLists[jj].Count<1) then Continue;

          for j:= jj+1 to High(PartLagts) do begin
            if (PartLists[jj].Count<>PartLists[j].Count) or
              (TextLists[jj].Count<>TextLists[j].Count) then Continue;

            flag:= False;
            if PartLists[jj].Count>0 then
            for i:= 0 to PartLists[jj].Count-1 do begin // сверяем PartLists
              flag:= (PartLists[jj][i]<>PartLists[j][i]) or
                     (Integer(PartLists[jj].Objects[i])<>Integer(PartLists[j].Objects[i]));
              if flag then Break;
            end; // for i:= 0 to
            if flag then Continue;

            if (TextLists[jj].Count>0) then
            for i:= 0 to TextLists[jj].Count-1 do begin // сверяем TextLists
              flag:= ((TextLists[jj][i]<>TextLists[j][i]) or
                     (Integer(TextLists[jj].Objects[i])<>Integer(TextLists[j].Objects[i])));
              if flag then Break;
            end; // for i:= 0 to
            if flag then Continue;

            // PartLists[jj] = PartLists[j] and TextLists[jj] = TextLists[j]
            PartLists[j].Clear;  // чистим дубликат
            PartLists[j].Delimiter:= LCharGood;
            TextLists[j].Clear;
            TextLists[j].Delimiter:= LCharGood;
            PartLagts[j]:= 0;
          end; // for j:= jj+1 to ...
        end; // for jj:= 0 to
      end; // if length(PartLagts)>1

      //---------------------------------------- ищем номера порций в нашей базе
      s:= Cache.FindModelNodeWareUseAndTextListNumbers(modORD, nodeORD, WareID,
          PartLists, TextLists, PartNums, ErrUseNums, ErrTxtNums, True, CheckTexts);
      if s<>'' then raise Exception.Create(s);

      //------------------------ удаляем ненайденные порции условий в нашей базе
      for jj:= 0 to High(ErrUseNums) do if ErrUseNums[jj]>0 then begin
        s:= Cache.DelModelNodeWareUseListLinks(modORD, nodeORD, WareID, ErrUseNums[jj]);
        if s<>'' then prMessageLOGS(nmProc+': error del use link('+IntToStr(WareID)+'): '+s, 'import', False);
      end;

      //------------------------ удаляем ненайденные порции текстов в нашей базе
      for jj:= 0 to High(ErrTxtNums) do if ErrTxtNums[jj]>0 then begin
        ResCode:= resDeleted;
        s:= Cache.CheckModelNodeWareTextListLinks(ResCode, modORD, nodeORD,
                            WareID, nil, UserID, Src, ErrTxtNums[jj]);
        if ResCode=resError then
          prMessageLOGS(nmProc+': error del txt link('+IntToStr(WareID)+'): '+s, 'import', False);
      end;

      for jj:= 0 to High(PartNums) do begin // чистим все, что не надо заливать
        with PartLists[jj] do if (Delimiter=LCharGood) and (Count>0) then Clear;
        with TextLists[jj] do if (Delimiter=LCharGood) and (Count>0) then Clear;
      end; // for jj:= 0 to High(PartNums)

      for jj:= 0 to High(PartNums) do begin
        j:= 0;
        //------------------------------------ добавляем новую порцию условий
        if (PartLists[jj].Count>0) then begin
          s:= Cache.AddModelNodeWareUseListLinks(modORD, nodeORD, WareID, UserID, Src, PartLists[jj], j);
          if (s='') or (s='exists') then
            PartNums[jj]:= StrToIntDef(PartLists[jj].Strings[0], 0) // номер новой порции
          else //raise Exception.Create(s);
           prMessageLOGS(nmProc+': error add use link: '+s, 'import', False);
        end;
        //------------------------------------ добавляем новую порцию текстов
        if (TextLists[jj].Count>0) then begin
          ResCode:= resAdded;
          s:= Cache.CheckModelNodeWareTextListLinks(ResCode, modORD, nodeORD,
                              WareID, TextLists[jj], UserID, Src, PartNums[jj]);
          if ResCode=resError then
            prMessageLOGS(nmProc+': error add txt link: '+s, 'import', False);
        end;
      end; // for jj:= 0 to High(PartNums)

      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
    end; // for ii:= 0 to High(arInfo)
  finally
    with ordIBS.Transaction do if InTransaction then Rollback;
    ordIBS.Close;
    ordIBSr.Close;
    TdtIBS.Close;
    SetLength(ErrUseNums, 0);
    SetLength(ErrTxtNums, 0);
  end;
end;
//=========================================== загрузка аналогов товара из TecDoc
procedure LoadWareCrossFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;
          WareID, pSupMFTD, UserID: Integer; pArticleTD: String; ThreadData: TThreadData=nil);
const nmProc = 'LoadWareCrossFromTDT'; // имя процедуры/функции
// TdtIBS, ordIBS, ordIBSr передаются для увеличения скорости обработки
var j, pCrossMF, ResCode, i, k, jj: Integer;
    s, crossArt, sWare: String;
    ArArtCross: array of TCrossArtInfo;
    flCrossFromGB: Boolean;
    IBS: TIBSQL;
    ibd: TIBDatabase;
begin
  SetLength(ArArtCross, 0);
  ordIBSr.Close;
  j:= 0;
  sWare:= IntToStr(WareID);
  flCrossFromGB:= (Cache.GetConstItem(pcCrossAnalogsFromOrder).IntValue=0);
  IBS:= nil;
  try
    if not flCrossFromGB then begin
      with ordIBSr.Transaction do if not InTransaction then StartTransaction;
      ordIBSr.SQL.Text:= 'select WATDARTSUP, WATDARTICLE'+
        ' from LinkWareAnalogs left join WAREARTICLETD on WATDWARECODE=LWAANALOG'+
        ' where LWAWARECODE='+sWare+' and LWASRCCODE='+IntToStr(soTecDocBatch)+
        ' group by WATDARTSUP, WATDARTICLE';
      ordIBSr.ExecQuery;
      while not ordIBSr.Eof do begin // артикулы аналогов товара из ORD
        if Length(ArArtCross)<(j+1) then SetLength(ArArtCross, j+100);
        ArArtCross[j].supMF  := ordIBSr.FieldByName('WATDARTSUP').AsInteger; // код supMF
        ArArtCross[j].article:= ordIBSr.FieldByName('WATDARTICLE').AsString; // артикул TD
//        SetLength(ArArtCross[j].arWares, 0);
        inc(j);
        ordIBSr.Next;
      end;
      ordIBSr.Close;

    end else begin // кроссы из Grossbee
      ibd:= cntsGRB.GetFreeCnt;
      if not Assigned(ibd) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
      try
        ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, true);
        IBS.SQL.Text:= 'select PMWAWAREANALOGCODE from PMWAREANALOGS'+
          ' left join AnalitDict on ANDTCODE=PMWASOURCECODE'+
          ' where PMWAWARECODE='+sWare+' and (AnDtSyncCode-'+ // только источник-TecDoc
          Cache.GetConstItem(pcCrossAnalogsDeltaSync).StrValue+')='+IntToStr(soTecDocBatch);
        IBS.ExecQuery;
        while not IBS.Eof do begin // собираем артикулы кроссов товара из Grossbee
          k:= IBS.FieldByName('PMWAWAREANALOGCODE').AsInteger; // код товара-кросса
          if not Cache.WareExist(k) then begin
            pCrossMF:= 0;
            crossArt:= '';
          end else with Cache.GetWare(k) do begin
            pCrossMF:= ArtSupTD;
            crossArt:= ArticleTD;
          end;
          if (pCrossMF>0) and (crossArt<>'') then begin // если артикул определен
            jj:= -1;
            for i:= 0 to High(ArArtCross) do
              if (ArArtCross[i].supMF=pCrossMF) and (ArArtCross[i].article=crossArt) then begin
                jj:= i;
                break;
              end;
            if (jj<0) then begin // если такого артикула еще нет в массиве - добавляем
              if Length(ArArtCross)<(j+1) then SetLength(ArArtCross, j+100);
              ArArtCross[j].supMF  := pCrossMF; // код supMF
              ArArtCross[j].article:= crossArt; // артикул TD
//              SetLength(ArArtCross[j].arWares, 0); // коды товаров артикула
//              jj:= j;
              inc(j);
            end;
//            prAddItemToIntArray(k, ArArtCross[jj].arWares);
          end; // if (pCrossMF>0) and (crossArt<>'')
          IBS.Next;
        end;
      finally
        prFreeIBSQL(ibs);
        cntsGRB.SetFreeCnt(ibd);
      end;
    end;
    if Length(ArArtCross)>j then SetLength(ArArtCross, j);

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
    try
      ordIBSr.SQL.Clear;
      ordIBS.SQL.Clear;
      TdtIBS.Close;
      with TdtIBS.Transaction do if not InTransaction then StartTransaction;
      TdtIBS.SQL.Text:= 'select crossMF, crossNR'+
        ' from get_art_cross('+IntToStr(pSupMFTD)+', :art_nr)';
      TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
      TdtIBS.ExecQuery;
      while not TdtIBS.Eof do begin
        pCrossMF:= TdtIBS.FieldByName('crossMF').AsInteger;
        crossArt:= TdtIBS.FieldByName('crossNR').AsString;
//        jj:= -1;
        for j:= 0 to High(ArArtCross) do
          if (ArArtCross[j].supMF=pCrossMF) and (ArArtCross[j].article=crossArt) then begin
            ArArtCross[j].supMF:= 0; // обнуляем код артикула, аналоги по кот.есть в ORD
//            jj:= j;
            break;
          end;

        ResCode:= resAdded;
        s:= Cache.CheckWareArtCrossLinks(WareID, CrossArt, pCrossMF, ResCode, soTecDocBatch, UserID, ordIBSr);
        if (ResCode=resError) then
          prMessageLOGS(nmProc+': error add Cross(ware='+sWare+'): '+s, 'import', False);
        TdtIBS.Next;
      end;
      TdtIBS.Close;
      TdtIBS.SQL.Clear;

      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      ordIBSr.SQL.Clear;
      // удаляем "правильные" связки артикулов, кот.ушли из TD, а артикулы остались
      for j:= 0 to High(ArArtCross) do begin
        if (ArArtCross[j].supMF<1) then Continue;

        with TdtIBS.Transaction do if not InTransaction then StartTransaction;
        if TdtIBS.SQL.Text='' then TdtIBS.SQL.Text:= 'select count(ART_ID)'+
          ' from ARTICLES left join DATA_SUPPLIERS on DS_ID=ART_SUP_ID'+
          ' where ART_NR=:art_nr and DS_MF_ID='+IntToStr(ArArtCross[j].supMF);
        TdtIBS.ParamByName('art_nr').AsString:= ArArtCross[j].article;
        TdtIBS.ExecQuery;
        i:= TdtIBS.Fields[0].AsInteger;
        TdtIBS.Close;
        if i<1 then Continue; // если артикула в TD нет - оставляем

        ResCode:= resDeleted;
        s:= Cache.CheckWareArtCrossLinks(WareID, ArArtCross[j].article, ArArtCross[j].supMF, ResCode, soTecDocBatch, 0, ordIBSr);
        if ResCode=resError then
          prMessageLOGS(nmProc+': error del Cross(ware='+sWare+'): '+s, 'import', False);
      end;

    except
      on E: EBOBError do raise EBOBError.Create(E.Message);
      on E: Exception do prMessageLOGS(nmProc+': error load crosses(ware='+sWare+'): '+E.Message, 'import', False);
    end;
  finally
    TdtIBS.Close;
    ordIBS.Close;
    ordIBSr.Close;
//    for j:= 0 to High(ArArtCross) do SetLength(ArArtCross[j].arWares, 0);
    SetLength(ArArtCross, 0);
  end;
end;
//============================ загрузка аналогов товара (+ по заменам) из TecDoc
procedure LoadWareCrossesFromTDT(TdtIBS, ordIBS, ordIBSr: TIBSQL;
          WareID, pSupMFTD, UserID: Integer; pArticleTD: String; ThreadData: TThreadData=nil);
const nmProc = 'LoadWareCrossesFromTDT'; // имя процедуры/функции
      StrLimit = 240;
// TdtIBS, ordIBS, ordIBSr передаются для увеличения скорости обработки
var j, i, k, src: Integer;
    sWare, sUser, s: String;
    ArArtCross: array of TCrossArtInfo;
    flag: Boolean;
    IBS: TIBSQL;
    ibd: TIBDatabase;
    CrossList1, CrossList2, CrossDel1, CrossDel2: TIntegerList;
    ware, analog: TWareInfo;
    arListsSql: TASL;
    //---------------------------------------------
    procedure NewListSQL(var jj: Integer; kind: Integer=1);
    begin
      if (jj>-1) then arListsSql[jj].Add('end');
      inc(jj);
      SetLength(arListsSql, jj+1);
      arListsSql[jj]:= TStringList.Create;
      if kind=0 then begin
        arListsSql[jj].Add('execute block returns (rWare integer, rSrc integer) as begin');
      end else begin
        arListsSql[jj].Add('execute block returns (rWare integer, rSrc integer, rAdd integer)');
        arListsSql[jj].Add('as declare variable err integer; begin');
      end;
    end;
    //---------------------------------------------
begin
  SetLength(ArArtCross, 0);
  ordIBSr.Close;
  SetLength(arListsSql, 0);
  j:= 0;
  sWare:= IntToStr(WareID);
  sUser:= IntToStr(UserID);
  if not Cache.WareExist(WareID) then Exit;
  ware:= Cache.GetWare(WareID, True);
  IBS:= nil;
  CrossList1:= TIntegerList.Create; // коды кроссов с источником soTecDocBatch
  CrossList2:= TIntegerList.Create; // коды кроссов с источником soTDsupersed
  CrossDel1 := TIntegerList.Create; // коды кроссов для удаления с источником soTecDocBatch
  CrossDel2 := TIntegerList.Create; // коды кроссов для удаления с источником soTDsupersed
  try try
    TdtIBS.Close; //--------------------------- кроссы-артикулы (+ замены) из TD
    with TdtIBS.Transaction do if not InTransaction then StartTransaction;
    TdtIBS.SQL.Text:= 'select distinct crossMF, crossNR, BySupersed'+
      ' from get_art_crosses_new('+IntToStr(pSupMFTD)+', :art_nr)'+
      ' order by crossMF, crossNR, BySupersed';
    TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
    TdtIBS.ExecQuery;
    while not TdtIBS.Eof do begin
      k:= TdtIBS.FieldByName('crossMF').AsInteger;
      s:= TdtIBS.FieldByName('crossNR').AsString;
      flag:= (k=pSupMFTD) and (s=pArticleTD);
      if not flag then for i:= 0 to High(ArArtCross) do begin    // проверяем дубликаты
        flag:= (ArArtCross[i].supMF=k) and (ArArtCross[i].article=s);
        if flag then break;
      end;
      if not flag then begin
        if Length(ArArtCross)<(j+1) then SetLength(ArArtCross, j+100);
        ArArtCross[j].supMF  := k; // код supMF
        ArArtCross[j].article:= s; // артикул TD
        if (TdtIBS.FieldByName('BySupersed').AsInteger=1) then
          ArArtCross[j].src:= soTDsupersed
        else ArArtCross[j].src:= soTecDocBatch;
        inc(j);
      end;
      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      TdtIBS.Next;
    end;
    TdtIBS.Close;
    TdtIBS.SQL.Clear;
    if Length(ArArtCross)>j then SetLength(ArArtCross, j);

//------------------------------------- коды товаров-кроссов по артикулам из ORD
    j:= -1;
    NewListSQL(j, 0);
    for i:= 0 to High(ArArtCross) do begin
      if (arListsSql[j].Count>StrLimit) then NewListSQL(j, 0);
      arListsSql[j].Add(' rSrc='+IntToStr(ArArtCross[i].src)+';');
      arListsSql[j].Add(' for select WATDWARECODE from WAREARTICLETD'+
                        ' left join WareOptions on wowarecode=WATDWARECODE');
      arListsSql[j].Add('  where WATDARTICLE="'+ArArtCross[i].article+'"'+
                        '   and WATDARTSUP='+IntToStr(ArArtCross[i].supMF)+' and WOARHIVED="F"');
      arListsSql[j].Add(' into :rWare do if (rWare is not null and rWare>0) then suspend;');
    end;
    arListsSql[j].Add('end');

    with ordIBSr.Transaction do if not InTransaction then StartTransaction;
    ordIBSr.Close;
    ordIBSr.ParamCheck:= False;
    for j:= 0 to High(arListsSql) do begin
      ordIBSr.SQL.Clear;
      ordIBSr.SQL.AddStrings(arListsSql[j]);
      ordIBSr.ExecQuery;
      while not ordIBSr.Eof do begin
        k:= ordIBSr.Fields[0].AsInteger;  // берем только неархивные и не ИНФО
        if (k<>WareID) and Cache.WareExist(k) then with Cache.GetWare(k) do
          if not IsArchive and not IsINFOgr then
            if (ordIBSr.Fields[1].AsInteger=soTDsupersed) then
              CrossList2.Add(k)     // коды кроссов с источником soTDsupersed
            else CrossList1.Add(k); // коды кроссов с источником soTecDocBatch
        CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
        ordIBSr.Next;
      end;
      ordIBSr.Close;
    end;
    ordIBSr.SQL.Clear;
    ordIBSr.ParamCheck:= True;
    for i:= 0 to High(arListsSql) do prFree(arListsSql[i]);
    SetLength(arListsSql, 0);

//----------------------------- проверяем существующие товары-кроссы из Grossbee
    ibd:= cntsGRB.GetFreeCnt;
    if not Assigned(ibd) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    try
      ibs:= fnCreateNewIBSQL(ibd, 'ibs_'+nmProc, -1, tpRead, true);
      IBS.SQL.Text:= 'select PMWAWAREANALOGCODE, PMWAISWRONG, (AnDtSyncCode-'+
        Cache.GetConstItem(pcCrossAnalogsDeltaSync).StrValue+') as Src'+
        ' from PMWAREANALOGS left join AnalitDict on ANDTCODE=PMWASOURCECODE'+
        ' where PMWAWARECODE='+sWare;
      IBS.ExecQuery;
      while not IBS.Eof do begin // коды кроссов товара из Grossbee
        k:= IBS.FieldByName('PMWAWAREANALOGCODE').AsInteger; // код товара-кросса
        src:= ibs.FieldByName('Src').AsInteger;              // источник из GrossBee
        flag:= ibs.FieldByName('PMWAISWRONG').AsString='F';

        i:= CrossList1.IndexOf(k); // ищем в 1-м списке
        if (i>-1) then CrossList1.Delete(i) // если нашли - не добавляем
        else begin
          i:= CrossList2.IndexOf(k); // ищем в 2-м списке
          if (i>-1) then CrossList2.Delete(i); // если нашли - не добавляем
        end;
        if (i>-1) then begin  // такой кросс в GrossBee есть (источник неважен)
          if flag then Ware.CheckAnalogLink(k, src, True); // добавить в кеш, если его там нет
          IBS.Next;
          Continue;
        end;

        if not flag or not (src in [soTecDocBatch, soTDsupersed]) then begin
          IBS.Next;    // проверяем, надо ли удалять, только правильные TD-связи
          Continue;
        end;

        analog:= nil;
        flag:= (k<>WareId); // аналог <> товар
        if flag then begin
          analog:= Cache.GetWare(k);                        // не архив или инфо
          flag:= Assigned(analog) and not ((analog=NoWare) or analog.IsArchive or analog.IsINFOgr);
        end;

        if not flag or not Assigned(analog) then begin // аналог = товар, архив и инфо - удалять
          if (src=soTDsupersed) then CrossDel2.Add(k) else CrossDel1.Add(k);
          IBS.Next;
          Continue;
        end;

        if (analog.ArtSupTD<1) or (analog.ArticleTD='') then begin
          IBS.Next;    // товар не связан с TD (старый артикул) - не проверяем
          Continue;
        end;
                                         // проверяем существование артикула TD
        if TdtIBS.SQL.Text='' then TdtIBS.SQL.Text:= 'select art_id from articles'+
          ' left join data_suppliers on DS_ID=ART_SUP_ID where art_nr=:art and ds_mf_id=:mf';
        TdtIBS.ParamByName('art').AsString:= Ware.ArticleTD;
        TdtIBS.ParamByName('mf').AsInteger:= Ware.ArtSupTD;
        TdtIBS.ExecQuery;
        flag:= not (TdtIBS.Eof and TdtIBS.Bof) and (TdtIBS.Fields[0].AsInteger>0);
        TdtIBS.Close;

        if flag then  // удаляем, если артикул в TD есть, а связь ушла
          if (src=soTDsupersed) then CrossDel2.Add(k) else CrossDel1.Add(k);

        CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
        IBS.Next;
      end;
      IBS.Close;

      flag:= (CrossList1.Count>0) or // признак необходимости изменений
        (CrossList2.Count>0) or (CrossDel1.Count>0) or (CrossDel2.Count>0);

      if flag then begin
        //------------------------- готовим порции текстов SQL для записи в базу
        j:= -1;
        NewListSQL(j);
        //----------------------------------------------------------- добавление
        if (CrossList1.Count>0) then begin // источник soTecDocBatch
          s:= ' rAdd=1; rSrc='+IntToStr(Cache.FDCA.GetSourceGBcode(soTecDocBatch))+';';
          for i:= 0 to CrossList1.Count-1 do begin
            if (arListsSql[j].Count>StrLimit) then NewListSQL(j);
            if (i=0) or (arListsSql[j].Count=2) then arListsSql[j].Add(s);
            arListsSql[j].Add(' select rCrossID, errLink from Vlad_CSS_AddWareCross(');
            arListsSql[j].Add(sWare+', '+IntToStr(CrossList1[i])+', '+sUser+', :rSrc)');
            arListsSql[j].Add(' into :rWare, :err; if (err=0 and rWare>0) then suspend;');
          end;
          CrossList1.Clear;
        end;
        if (CrossList2.Count>0) then begin // источник soTDsupersed
          s:= ' rAdd=1; rSrc='+IntToStr(Cache.FDCA.GetSourceGBcode(soTDsupersed))+';';
          for i:= 0 to CrossList2.Count-1 do begin
            if (arListsSql[j].Count>StrLimit) then NewListSQL(j);
            if (i=0) or (arListsSql[j].Count=2) then arListsSql[j].Add(s);
            arListsSql[j].Add(' select rCrossID, errLink from Vlad_CSS_AddWareCross(');
            arListsSql[j].Add(sWare+', '+IntToStr(CrossList2[i])+', '+sUser+', :rSrc)');
            arListsSql[j].Add(' into :rWare, :err; if (err=0 and rWare>0) then suspend;');
          end;
          CrossList2.Clear;
        end;
        //------------------------------------------------------------- удаление
        if (CrossDel1.Count>0) then begin  // источник soTecDocBatch
          s:= ' rAdd=0; rSrc='+IntToStr(Cache.FDCA.GetSourceGBcode(soTecDocBatch))+';';
          for i:= 0 to CrossDel1.Count-1 do begin
            if (arListsSql[j].Count>StrLimit) then NewListSQL(j);
            if (i=0) or (arListsSql[j].Count=2) then arListsSql[j].Add(s);
            arListsSql[j].Add(' select rCrossID from Vlad_CSS_DelWareCross(');
            arListsSql[j].Add(sWare+', '+IntToStr(CrossDel1[i])+', :rSrc)');
            arListsSql[j].Add(' into :rWare; if (rWare>0) then suspend;');
          end;
          CrossDel1.Clear;
        end;
        if (CrossDel2.Count>0) then begin  // источник soTDsupersed
          s:= ' rAdd=0; rSrc='+IntToStr(Cache.FDCA.GetSourceGBcode(soTDsupersed))+';';
          for i:= 0 to CrossDel2.Count-1 do begin
            if (arListsSql[j].Count>StrLimit) then NewListSQL(j);
            if (i=0) or (arListsSql[j].Count=2) then arListsSql[j].Add(s);
            arListsSql[j].Add(' select rCrossID from Vlad_CSS_DelWareCross(');
            arListsSql[j].Add(sWare+', '+IntToStr(CrossDel2[i])+', :rSrc)');
            arListsSql[j].Add(' into :rWare; if (rWare>0) then suspend;');
          end;
          CrossDel2.Clear;
        end;
        arListsSql[j].Add('end');

        //-------------------- запись в базу добавлений/удалений товаров-кроссов
        fnSetTransParams(ibs.Transaction, tpWrite, True);
        IBS.ParamCheck:= False;
        for j:= 0 to High(arListsSql) do begin
          IBS.SQL.Clear;
          IBS.SQL.AddStrings(arListsSql[j]);
          IBS.ExecQuery;
          while not IBS.Eof do begin
            if (IBS.FieldByName('rAdd').AsInteger=1) then begin // факт. добавление
              Src:= Cache.FDCA.GetSourceByGBcode(IBS.FieldByName('rSrc').AsInteger);
              if (Src=soTDsupersed) then
                CrossList2.Add(IBS.FieldByName('rWare').AsInteger)
              else CrossList1.Add(IBS.FieldByName('rWare').AsInteger);
            end else
              CrossDel1.Add(IBS.FieldByName('rWare').AsInteger); // факт. удаление

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
            IBS.Next;
          end;
          IBS.Close;
        end; // for j:= 0 to High(arListsSql)
        IBS.Transaction.Commit;   // запись в базу
      end;
    finally
      prFreeIBSQL(ibs);
      cntsGRB.SetFreeCnt(ibd);
    end;

    if flag then begin //-------------------------------- отрабатываем кеш
      for i:= 0 to CrossList1.Count-1 do       // добавляем источник soTecDocBatch
        Ware.CheckAnalogLink(CrossList1[i], soTecDocBatch, True);
      for i:= 0 to CrossList2.Count-1 do       // добавляем источник soTDsupersed
        Ware.CheckAnalogLink(CrossList2[i], soTDsupersed, True);
      for i:= 0 to CrossDel1.Count-1 do Ware.DelAnalogLink(CrossDel1[i], True); // удаляем
      if (CrossList1.Count>0) or (CrossList2.Count>0) then Ware.SortAnalogsByName;
    end;
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do prMessageLOGS(nmProc+': error load crosses(ware='+sWare+'): '+E.Message, 'import', False);
  end;
  finally
    TdtIBS.Close;
    ordIBS.Close;
    ordIBSr.Close;
    SetLength(ArArtCross, 0);
    for i:= 0 to High(arListsSql) do prFree(arListsSql[i]);
    SetLength(arListsSql, 0);
    prFree(CrossList1);
    prFree(CrossList2);
    prFree(CrossDel1);
    prFree(CrossDel2);
  end;
end;
//======= загрузка связок, порций критериев и текстов, файлов и ОН товара из TDT
function LoadWareLinksUsesCrisTextsFromTDT(WareID, UserID: Integer;
         var addLink3, addLinkON: Integer; ThreadData: TThreadData=nil;
         OnlyON: Boolean=False; CheckTexts: Boolean=False; WithEng: Boolean=True;
         OnlyCross: Boolean=False; CheckArt: Boolean=False): String;
// addLink3 - кол-во новых связок 3, addLinkON - кол-во новых связок с ориг.№
const nmProc = 'LoadWareLinksUsesCrisTextsFromTDT'; // имя процедуры/функции
var res, criTD, ii, linCount, i, pSupMFTD, NodeID, ModID, iLdmw, addLinkEng: Integer;
    TimeProc, LocalTime: TDateTime;
    TdtIBD, ordIBD, ordIBDr: TIBDatabase;
    TdtIBS, ordIBS, ordIBSr: TIBSQL;
    s, pArticleTD, sName, ss: String;
    fl, flINFO, flSleep: Boolean;
    arInfo: TArLinkInfo;
    NodeCodes: Tai;
    arWareONums: TarWareOnumOpts;
begin
  TimeProc:= Now;
  LocalTime:= TimeProc;
  Result:= '';
  flSleep:= not flDebug and fnGetActionTimeEnable(caeOnlyWorkTime);
//  TdtIBD:= nil;
//  ordIBD:= nil;
//  ordIBDr:= nil;
  TdtIBS:= nil;
  ordIBS:= nil;
  ordIBSr:= nil;
  setlength(arWareONums, 0);
  addLink3:= 0;
  addLinkON:= 0;
  try
    with Cache.GetWare(WareID) do begin
      if (ArticleTD='') or (ArtSupTD<1) then
        raise EBOBError.Create(MessText(mtkNotEnoughParams)); // or Exit  ???
      pArticleTD:= ArticleTD;
      pSupMFTD:= ArtSupTD; // SupID TecDoc (DS_MF_ID !!!)
      sName:= Name;
      flINFO:= IsINFOgr;
    end;

    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
    try
      TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);

      if CheckArt then begin
        TdtIBS.SQL.Text:= 'select art_id, DS_BRA from articles'+
          ' left join data_suppliers on ds_id=art_sup_id'+
          ' where art_nr=:art_nr and ds_mf_id='+IntToStr(pSupMFTD);
        TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
        TdtIBS.ExecQuery;
        if (TdtIBS.Bof and TdtIBS.Eof) or (TdtIBS.Fields[0].AsInteger<1) then begin
          TdtIBS.Close;
          TdtIBS.SQL.Text:= 'select DS_BRA from data_suppliers'+
            ' where ds_mf_id='+IntToStr(pSupMFTD);
          TdtIBS.ExecQuery;
          raise Exception.Create('не найден артикул TD;'+pArticleTD+';'+TdtIBS.Fields[0].AsString); // если артикула в TD нет
        end;
        TdtIBS.Close;
      end;
      prMessageLOGS('begin load supID='+IntToStr(pSupMFTD)+' article '+pArticleTD, 'import_test', False);

      CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      ordIBD:= cntsORD.GetFreeCnt;
      if not Assigned(ordIBD) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
      try
        ordIBDr:= cntsORD.GetFreeCnt; // только для чтения
        if not Assigned(ordIBDr) then raise EBOBError.Create(MessText(mtkErrConnectToDB));
        try
          ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpWrite);
          ordIBSr:= fnCreateNewIBSQL(ordIBDr, 'ordIBSr_'+nmProc);

//------------------------------------------------------ связки (не ИНФО-товары)
          if not OnlyON and not OnlyCross and not flINFO then try
            setlength(arInfo, 100);
            setlength(NodeCodes, 0);
        //-------------------- проверяем / заполняем нужные связки 2 и 3 из TecDoc
            ii:= 0;
            TdtIBS.SQL.Text:= 'select xGA, xMf, xMs, xMT, xlagt'+
              ' from GETARTICLEGATYPESNew(:art_nr, '+IntToStr(pSupMFTD)+')'+
              ' order by xGA, xMf, xMs';
            TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
            LoadLinkListsFromTDT(TdtIBS, WareID, UserID, soTecDocBatch, arInfo, ii, addLink3, ThreadData);

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

        //--- проверяем / заполняем нужные связки 2 и 3 из TecDoc по спецификациям
            TdtIBS.SQL.Text:= 'select xGA, xMf, xMs, xMT, xlagt'+
              ' from GETpartGATYPES(:art_nr, '+IntToStr(pSupMFTD)+')'+
              ' order by xGA, xMf, xMs';
            TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
            LoadLinkListsFromTDT(TdtIBS, WareID, UserID, soTDparts, arInfo, ii, addLink3, ThreadData);

            linCount:= ii;
            SetLength(arInfo, linCount);

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
            CheckSleepProc(LocalTime, flSleep); // в рабочее время - задержка процесса пропорционально длительности

        //-------------------------------------------------------- инфо по связкам
            if linCount>0 then begin
              with ordIBSr.Transaction do if not InTransaction then StartTransaction;
              ordIBSr.SQL.Text:= 'select ldmwcode, LDEMDMOSCODE, LDEMTRNACODE'+
                ' from LINKDETAILMODEL inner join LINKDETMODWARE on ldmwldemcode=ldemcode'+
                ' and LDMWWARECODE=:WareID where LDMWWRONG="F" and LDEMWRONG="F"';
              ordIBSr.ParamByName('WareID').AsInteger:= WareID;
              ordIBSr.ExecQuery;
              while not ordIBSr.Eof do begin // проставляем коды связок 3
                NodeID:= ordIBSr.FieldByName('LDEMTRNACODE').AsInteger;
                ModID := ordIBSr.FieldByName('LDEMDMOSCODE').AsInteger;
                iLdmw := ordIBSr.FieldByName('ldmwcode').AsInteger;
                for ii:= 0 to linCount-1 do with arInfo[ii] do
                  if (ldmw<1) and (nodeORD=NodeID) and (modORD=ModID) then ldmw:= iLdmw;
                ordIBSr.Next;
              end;
              ordIBSr.Close;

              CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

              //--------- проверяем / заполняем порции условий и текстов из TecDoc
              LoadModelNodeWareUseAndTextListsFromTDT(TdtIBS, ordIBS, ordIBSr,
                WareID, pSupMFTD, UserID, arInfo, ThreadData, CheckTexts);

              CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

              ordIBS.SQL.Clear;
              ordIBSr.SQL.Clear; // здесь используется в цикле
              TdtIBS.SQL.Clear;
              setlength(NodeCodes, linCount);
              for ii:= 0 to linCount-1 do with arInfo[ii] do //  для отсева повторений нод
                NodeCodes[ii]:= fnIfInt(fnInIntArray(nodeORD, NodeCodes)<0, nodeORD, 0);
              for ii:= 0 to linCount-1 do with arInfo[ii] do if (NodeCodes[ii]>0) then
                LoadWareNodeInfoTextFromTDT(WareID, pSupMFTD, nodeORD, UserID,
                  Src, pArticleTD, TdtIBS, ordIBS, ordIBSr, ThreadData);

              CheckSleepProc(LocalTime, flSleep); // в рабочее время - задержка процесса пропорционально длительности
            end; // if linCount>0

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

        //------------- проверяем / заполняем связи товара с двигателями из TecDoc
            if WithEng then begin
              ss:= LoadWareEngLinksUsesFromTDT(WareID, UserID, addLinkEng, ThreadData, False);
              if ss<>'' then prMessageLOGS(nmProc+': error eng links '+ss, 'import', False);

              CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
              CheckSleepProc(LocalTime, flSleep); // в рабочее время - задержка процесса пропорционально длительности
            end;

  //------------------------------------------ файлы рисунков/документов по товару
            s:= LoadWareGraFileNamesFromTDT(WareID, UserID);
            if s<>'' then fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, 'error Ware FileNames', s, '', false, 'import');
            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

  //------------------------------ проверяем / заполняем критерии товара из TecDoc
            LoadWareCrisFromTDT(TdtIBS, ordIBS, ordIBSr, WareID, pSupMFTD, UserID, pArticleTD, ThreadData);

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
            CheckSleepProc(LocalTime, flSleep); // в рабочее время - задержка процесса пропорционально длительности

          finally
            for i:= 0 to High(arInfo) do begin
              setLength(arInfo[i].PartNums, 0);
              setLength(arInfo[i].PartLagts, 0);
              for ii:= 0 to High(arInfo[i].PartLists) do
                if Assigned(arInfo[i].PartLists[ii]) then prFree(arInfo[i].PartLists[ii]);
              setLength(arInfo[i].PartLists, 0);
              for ii:= 0 to High(arInfo[i].TextLists) do
                if Assigned(arInfo[i].TextLists[ii]) then prFree(arInfo[i].TextLists[ii]);
              setLength(arInfo[i].TextLists, 0);
            end;
            setlength(arInfo, 0);
            setlength(NodeCodes, 0);
          end; // if not OnlyON and not OnlyCross and not flINFO

//-------------------------------- проверяем / заполняем кроссы товара из TecDoc
          if not OnlyON then begin
            if (Cache.GetConstItem(pcCrossAnalogsFromOrder).IntValue=1) then
              LoadWareCrossFromTDT(TdtIBS, ordIBS, ordIBSr, WareID, pSupMFTD, UserID, pArticleTD, ThreadData)
            else
              LoadWareCrossesFromTDT(TdtIBS, ordIBS, ordIBSr, WareID, pSupMFTD, UserID, pArticleTD, ThreadData);

            CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
            CheckSleepProc(LocalTime, flSleep); // в рабочее время - задержка процесса пропорционально длительности
          end; // if not OnlyON
        finally
          prFreeIBSQL(ordIBSr);
          cntsORD.SetFreeCnt(ordIBDr);
        end;
      finally
        prFreeIBSQL(ordIBS);
        cntsORD.SetFreeCnt(ordIBD);
      end;
    finally
      prFreeIBSQL(TdtIBS);
      cntsTDT.SetFreeCnt(TdtIBD);
    end;
//-------------------------------------- поиск оригинальных номеров товара в TDT
    if not OnlyCross and not flINFO then try
      arWareONums:= fnGetWareONumsFromTDT(WareID, pSupMFTD, pArticleTD);
      ss:= '';
      with Cache.FDCA do for i:= Low(arWareONums) to high(arWareONums) do begin
        with arWareONums[i] do if mfau>0 then begin
          res:= resAdded;
          criTD:= 0;
          s:= CheckOrigNumLink(res, WareID, mfau, criTD, ONum, soTecDocBatch, userID);
          fl:= res<>resError;
          if not fl then fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc,
            'error', s, '', false, 'import');
          if res=resAdded then inc(addLinkON);

        end else if (pos(mfName, ss)<1) then
          ss:= ss+fnIfStr(ss='', '', ',')+mfName; // не найденные произв.ОН

        CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
      end;

      if ss<>'' then begin // не найденные произв.ОН
        prMessageLOGS(fnMakeAddCharStr(IntToStr(WareID), 10, True)+'- '+ss, 'import_notmfon', False);
        Exception.Create('нет произв.ОН: '+ss);
      end;
    finally
      setlength(arWareONums, 0);
    end; // if not OnlyCross

    prMessageLOGS('  end load  ware='+IntToStr(WareID)+' '+sName, 'import_test', False);
  except
    on E: EBOBError do raise EBOBError.Create(E.Message);
    on E: Exception do begin
      Result:= nmProc+': '+E.Message;
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, 'error', E.Message, '', false, 'import');
    end;
  end;

  CheckSleepProc(TimeProc, flSleep); // в рабочее время - задержка процесса пропорционально длительности
end;
//===== пакетная загрузка связок, критериев, текстов, файлов и ОН товаров из TDT
function AddLoadWaresInfoFromTDT(UserID: Integer; ThreadData: TThreadData=nil; filter_data: String=''): TStringList; // must Free Result
const nmProc = 'AddLoadWaresInfoFromTDT'; // имя процедуры/функции
      RepAddLoads = 'rep_add_loads_'; // шаблон файлов отчетов
      StopMess = 'пакетная загрузка остановлена: ';
//      sZero:= ' -     0 связ.,     0 ориг.н.';
// в ini-файле в секции [reports] параметры:
// LastAddLoadWare: =0 - пред.загрузка закончена,
//   >0 - код последнего обработанного товара, загрузка прервана,
//   =-1 - загрузка закончена, но отчеты не отправлены
// addWares - список кодов товаров через запятую, если не задан - все товары
var i, j, MgID, addLink3, addLinkON, istart, iPercent,
      addLinkEng, addLink3a, addLinkONa, addLinkEnga, userAdm: Integer;
    s, nFile, nFile1, repPath, str, From, ss: string;
    BadTextSups: Tai; // массив кодов произв. для замены инфо-текстов
    Ware: TWareInfo;
    pIniFile: TIniFile;
    flag, OnlyON, OnlyEng, SendRep, OnlyCross, flSelfStart: Boolean;
    ListFiles, Body: TStringList;
    TimeProc: TDateTime;
    Percent: Single;
  //------------------------------------------------------- загрузка по 1 товару
  procedure AddLoadWare(WareID: integer);
  var rep_file: textfile;
  begin
    try
      flag:= (Length(BadTextSups)>0) and (fnInIntArray(Ware.ArtSupTD, BadTextSups)>-1); // произв. для замены инфо-текстов
      addLink3:= 0;
      addLinkON:= 0;
      addLinkEng:= 0; //----------------- загрузка всех параметров товара из TDT
      if not OnlyEng then s:= LoadWareLinksUsesCrisTextsFromTDT(WareID, UserID,
        addLink3, addLinkON, ThreadData, OnlyON, flag, False, OnlyCross, True);
      if (s='') and not OnlyCross and not OnlyON and not Ware.IsINFOgr then
        s:= LoadWareEngLinksUsesFromTDT(WareID, UserID, addLinkEng, ThreadData, OnlyEng);

      if (addLink3>0) or (addLinkON>0) or (addLinkEng>0) or (s<>'') then begin // пишем в отчет, если добавилось что-то или были ошибки
        addLink3a:= addLink3a+addLink3;
        addLinkONa:= addLinkONa+addLinkON;
        addLinkEnga:= addLinkEnga+addLinkEng;
        str:= fnMakeAddCharStr(Ware.Name, 60, True)+' - '+
              fnMakeAddCharStr(IntToStr(addLink3), 5)+' связ. '+
              fnMakeAddCharStr(IntToStr(addLinkON), 5)+' ориг.н. '+
              fnMakeAddCharStr(IntToStr(addLinkEng), 5)+' связ.двиг.';
        if (s<>'') then begin
          prMessageLOGS(nmProc+': error wareID='+IntToStr(WareID)+' - ошибки загрузки: '+str+#10+s, 'import', False);
          s:= StringReplace(StringReplace(s, #13, ' ', [rfReplaceAll]), #10, ' ', [rfReplaceAll]);
          prMessageLOGS(';'+IntToStr(WareID)+';'+s, 'import_err_wares', False); // собираем коды сбойных товаров
        end else try
          MgID:= Ware.ManagerID;
          nFile:= repPath+RepAddLoads+IntToStr(MgID); // файл отчета о пакетной загрузке прод.менеджера MgID
          flag:= not FileExists(nFile);
          try
            AssignFile(rep_file, nFile); // назначаем файл отчета
            if flag then ReWrite(rep_file) else Append(rep_file);
            writeln(rep_file, str); // записываем строку по товару в файл
            Flush(rep_file);
          finally
            closefile(rep_file); // закрываем файл отчета
          end;
        except
          on E: Exception do fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc,
            'error save to repfile: wareID='+IntToStr(WareID), E.Message, '', false, 'import')
        end;
      end;
      Cache.SaveNewConstValue(pcLastAddLoadWare, userAdm, IntToStr(WareID)); // записываем код обработанного товара
    except
      on E: EBOBError do raise EBOBError.Create(E.Message);
      on E: Exception do raise Exception.Create(StopMess+'error wareID='+IntToStr(WareID)+' - '+E.Message);
    end;

    if flSelfStart then begin // проверки в режиме автозапуска
      if (Cache.GetConstItem(pcSelfStartAddLoadWare).IntValue<>1) then // режим
        raise Exception.Create(StopMess+'last wareID='+IntToStr(WareID)+' - выключен режим автозапуска');
      if not fnGetActionTimeEnable(caeSmallWork) then                  // доступное время
        raise Exception.Create(StopMess+'last wareID='+IntToStr(WareID)+' - запретный период времени');
    end;

    CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы
  end;
  //-----------------------------------------------------
begin
  Result:= TStringList.Create; // отчет для администратора
  pIniFile:= TINIFile.Create(nmIniFileBOB);
  From:= pIniFile.ReadString('mail', 'SysAdresFrom', '');
  Body:= TStringList.Create;
  setlength(BadTextSups, 0);
  ListFiles:= nil;
  addLink3a:= 0;
  addLinkONa:= 0;
  addLinkEnga:= 0;
  userAdm:= Cache.GetConstItem(pcEmplORDERAUTO).IntValue;
  flSelfStart:= (filter_data=cSelfStart);
  TimeProc:= Now;
  try try                       // массив кодов произв. для замены инфо-текстов
    with fnSplit(',', pIniFile.ReadString('reports', 'BadTextSups', '')) do try
      if Count>0 then begin
        setlength(BadTextSups, Count);
        for j:= 0 to Count-1 do BadTextSups[j]:= StrToIntDef(Strings[j], 0);
      end;
    finally Free; end;

    repPath:= fnTestDirEnd(pIniFile.ReadString('mail', DirRepFiles, DirRepFilesDef), False); // путь к папке д/файлов отчетов
    if not DirectoryExists(repPath) then CreateDir(repPath);
    repPath:= fnTestDirEnd(repPath);

    istart:= Cache.GetConstItem(pcLastAddLoadWare).IntValue;
    SendRep:= (pIniFile.ReadInteger('reports', 'SendRep', 0)=1);  // True - отправлять отчеты

    if istart>-1 then begin //--------------------------------------- загрузка
      SetExecutePercent(UserID, ThreadData, 1);

      OnlyON:= pIniFile.ReadInteger('reports', 'OnlyON', 0)=1;
      OnlyEng:= pIniFile.ReadInteger('reports', 'OnlyEng', 0)=1;
      OnlyCross:= pIniFile.ReadInteger('reports', 'OnlyCross', 0)=1;
      s:= pIniFile.ReadString('reports', 'addWares', ''); // список кодов товаров
      if s<>'' then begin // если задан список кодов товаров
        ListFiles:= fnSplit(',', s);
        if ListFiles.Count>0 then begin // определяем, с какого кода начинать
          j:= ListFiles.IndexOf(IntToStr(istart));
          if j>-1 then istart:= j+1 else istart:= 0;
        end else istart:= 0;

      end else if istart=0 then istart:= 1 // новая полная загрузка
      else istart:= istart+1; // полная загрузка прерывалась, начинаем со следующего кода

      if flSelfStart then
        prMessageLOGS(nmProc+': .......... автозапуск загрузки данных из TecDoc', 'import', False);
      ss:= '';
      if s='' then begin //------------------------------------- полная загрузка
        prMessageLOGS(nmProc+': .......... начинаю пакетную загрузку данных из TecDoc', 'import', False);
        iPercent:= 0;
        Percent:= 90*1000/(High(Cache.arWareInfo)-istart);
        for i:= istart to High(Cache.arWareInfo) do begin
          if Cache.WareExist(i) then begin
            Ware:= Cache.GetWare(i, True);
            if (Ware<>NoWare) and not Ware.IsArchive
              and (Ware.ArtSupTD>0) and (Ware.ArticleTD<>'') then
              AddLoadWare(i); // загрузка по 1 товару
          end;
          if iPercent>=1000 then begin               // отображение процентов
            SetExecutePercent(UserID, ThreadData, Percent);
            iPercent:= 0;
          end else inc(iPercent);
        end; // for

      end else try  //--------------------------------------- загрузка по списку
        prMessageLOGS(nmProc+': .......... начинаю загрузку данных из TecDoc по списку кодов', 'import', False);
        Percent:= 90/(ListFiles.Count-istart);
        for i:= istart to ListFiles.Count-1 do begin // здесь в ListFiles список кодов товаров
          j:= StrToIntDef(ListFiles[i], 0);
          if Cache.WareExist(j) then Ware:= Cache.GetWare(j, True) else Ware:= NoWare;
          if (Ware=NoWare) or Ware.IsArchive or (Ware.ArtSupTD<1) or (Ware.ArticleTD='') then begin
            if (Ware=NoWare) then ss:= ss+#10'not found ware id='+IntToStr(j)
            else if Ware.IsArchive then ss:= ss+#10'archived ware id='+IntToStr(j)+' - '+Ware.Name
            else if (Ware.ArtSupTD<1) or (Ware.ArticleTD='') then
              ss:= ss+#10'not found TD link ware id='+IntToStr(j)+' - '+Ware.Name;
          end else
            AddLoadWare(j); // загрузка по 1 товару
          SetExecutePercent(UserID, ThreadData, Percent); // отображение процентов
        end; // for
      finally
        if ss<>'' then prMessageLOGS(nmProc+'(load ListWares): '+ss, 'import', False);
      end;

      if SendRep then istart:= -1 else istart:= 0; // в ini-файл признак - 0 - окончание загрузки, -1 - отчеты не отправлены
      Cache.SaveNewConstValue(pcLastAddLoadWare, userAdm, IntToStr(istart)); // записываем признак
      prMessageLOGS(nmProc+': ...... окончание загрузки данных из TecDoc', 'import', False);

      j:= 0;
      s:= Cache.CheckWareFiles(j); // удаление неиспользуемых файлов рисунков
      if s<>'' then prMessageLOGS(nmProc+': '+s, 'import', False);
      if j>0 then prMessageLOGS(nmProc+': удалено строк неиспользуемых файлов - '+IntToStr(j), 'import', False);

      if (addLink3a>0) or (addLinkONa>0) or (addLinkEnga>0) then
        Result.Add(nmProc+': load - '+
          fnMakeAddCharStr(IntToStr(addLink3a), 5)+' links, '+
          fnMakeAddCharStr(IntToStr(addLinkONa), 5)+' ON,'+
          fnMakeAddCharStr(IntToStr(addLinkEnga), 5)+' eng links');
      Result.Add(nmProc+': time = '+FloatToStr(RoundTo((Now-TimeProc)*60*60*24,-5))+' sec');
    end; // загрузка

    if (istart<0) and SendRep then begin //------------------ рассылка отчетов
      flag:= True; // признак нормального окончания рассылки
      ListFiles:= fnListAllFiles(RepAddLoads+'*', repPath); // список файлов отчетов
      for i:= 0 to ListFiles.Count-1 do begin // идем по списку файлов отчетов

        CheckStopExecute(UserID, ThreadData); // проверка остановки процесса или системы

        nFile:= ListFiles[i];
        nFile1:= repPath+'err_'+RepAddLoads+IntToStr(MgID);
        istart:= length(repPath)+length(RepAddLoads)+1;
        s:= copy(nFile, istart, length(nFile));
        MgID:= StrToIntDef(s, 0);
        if (MgID<1) or not Cache.EmplExist(MgID) then begin
          ss:= 'не найден менеджер, id='+IntToStr(MgID);
          fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, ss, '', '', false, 'import');
          DeleteFile(nFile1);
          RenameFile(nFile, nFile1);
          flag:= False;
          Continue;
        end;

        str:= Cache.arEmplInfo[MgID].Mail;
        if (str='') then begin
          ss:= 'В базе нет адреса менеджера, id='+IntToStr(MgID);
          fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, ss, '', '', false, 'import');
          DeleteFile(nFile1);
          RenameFile(nFile, nFile1);
          flag:= False;
          Continue;
        end;

        Body.Clear;
        Body.AddStrings(fnStringsLogFromFile(nFile));
        if Body.Count>0 then begin
          if Body.Count>1 then Body.Sort; // сортируем

          Result.Add(' ');                // в отчет для администратора
          Result.Add(' '+Cache.arEmplInfo[MgID].EmplLongName);
          Result.Add(' ');
          Result.Capacity:= Result.Capacity+Body.Count;
          for j:= 0 to Body.Count-1 do Result.Add(Body[j]);

          ss:= n_SysMailSend(str, 'отчет о загрузке данных из TecDoc', Body, nil, From, '', True);
          if ss='' then begin
            ss:= 'отправлен отчет для менеджера, id='+IntToStr(MgID);
            fnWriteToLogPlus(ThreadData, lgmsInfo, nmProc, ss, '', '', false, 'import');
//            DeleteFile(nFile);
            nFile1:= repPath+'send_'+RepAddLoads+IntToStr(MgID); // для отладки
            DeleteFile(nFile1);                                  // для отладки
            RenameFile(nFile, nFile1);                           // для отладки
          end else begin
            ss:= 'ошибка отправки отчета для менеджера, id='+IntToStr(MgID)+': '+ss;
            fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, ss, '', '', false, 'import');
            DeleteFile(nFile1);
            RenameFile(nFile, nFile1);
            flag:= False;
          end;
        end; // if Body.Count>0
      end; // for

      Cache.SaveNewConstValue(pcLastAddLoadWare, userAdm, '0'); // записываем признак окончания загрузки
    end;
  except
    on E: EBOBError do begin
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, 'error', E.Message, '', false, 'import');
      Result.Add(' '+E.Message);
      raise EBOBError.Create(E.Message);
    end;
    on E: Exception do begin
      fnWriteToLogPlus(ThreadData, lgmsSysError, nmProc, 'error', E.Message, '', false, 'import');
      Result.Add(' '+E.Message);
      Result.Insert(0, GetMessageFromSelf);
//      ss:= n_SysMailSend(fnGetSysAdresVlad(caeOnlyDayLess), 'Error load', Result, nil, From, '', True);
//      Result.Clear;
    end;
  end;
  finally
    prFree(ListFiles);
    prFree(Body);
    prFree(pIniFile);
    setlength(BadTextSups, 0);
  end;
end;

//******************************************************************************
//                 вспомагательные и проверочные функции
//******************************************************************************
//----------------------------------- проверка артиклей на Upper в WAREARTICLETD
function TestUpperWareArticleFromTDT: TStringList; // must Free Result
const nmProc = 'TestUpperWareArticleFromTDT'; // имя процедуры/функции
var TdtIBD, ordIBD: TIBDatabase;
    TdtIBS, ordIBS: TIBSQL;
    i: integer;
    s: string;
begin
  Result:= TStringList.Create;
  TdtIBD:= nil;
  ordIBD:= nil;
  TdtIBS:= nil;
  ordIBS:= nil;
  try try
    TdtIBD:= cntsTDT.GetFreeCnt;
    if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
    TdtIBS.SQL.Text:= 'select art_nr from articles'+
      ' where art_sup_id = (select DS_ID from DATA_SUPPLIERS where DS_MF_ID = :mf)'+
      ' and ( art_nr = :art1 or upper(art_nr) = :art2 or lower(art_nr) = :art3 )';
    TdtIBS.Prepare;

    ordIBD:= cntsORD.GetFreeCnt;
    if not Assigned(ordIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpWrite, true);
    ordIBS.SQL.Text:= 'update WAREARTICLETD set WATDARTICLE=:ARTnew'+
      ' where WATDARTICLE=:ARTold and WATDARTSUP=:ARTsup';
    ordIBS.Prepare;

    for i:= Low(cache.arWareInfo) to High(cache.arWareInfo) do
      if Cache.WareExist(i) then with Cache.GetWare(i) do try
        if IsArchive then continue;
        if (ArticleTD='') or (ArtSupTD<1) then continue;
        if (ArticleTD=LowerCase(ArticleTD)) and (ArticleTD=UpperCase(ArticleTD)) then continue;
//        if (ArticleTD=LowerCase(ArticleTD)) then continue;

        TdtIBS.ParamByName('mf').AsInteger:= ArtSupTD; // SupID TecDoc (DS_MF_ID !!!)
        TdtIBS.ParamByName('art1').AsString:= ArticleTD;
        TdtIBS.ParamByName('art2').AsString:= ArticleTD;
        TdtIBS.ParamByName('art3').AsString:= ArticleTD;
        TdtIBS.ExecQuery;
        if not (TdtIBS.Bof and TdtIBS.Eof) and (TdtIBS.Fields[0].AsString <> ArticleTD) then
          with ordIBS.Transaction do begin
            if not InTransaction then StartTransaction;
            ordIBS.Close;
            ordIBS.ParamByName('ARTsup').AsInteger:= ArtSupTD;
            ordIBS.ParamByName('ARTold').AsString:= ArticleTD;
            ordIBS.ParamByName('ARTnew').AsString:= TdtIBS.Fields[0].AsString;
            ordIBS.ExecQuery;                      // заменяем в базе
            Commit;
            s:= 'SupMF='+fnMakeAddCharStr(IntToStr(ArtSupTD), 5, True)+
              ' rewrite article '+fnMakeAddCharStr(ArticleTD, 25, True)+
              ' -> '+TdtIBS.Fields[0].AsString;
            ArticleTD:= TdtIBS.Fields[0].AsString; // заменяем в кеше
            Result.Add(s);
            prMessageLOGn(s, 'art_rewrite.txt');
          end;
        TdtIBS.Close;
      except
        on E: Exception do Result.Add('error article '+ArticleTD+': '+E.Message);
      end;
  except
    on E: Exception do Result.Add( nmProc+': '+E.Message);
  end;
  finally
    prFreeIBSQL(ordIBS);
    cntsORD.SetFreeCnt(ordIBD);
    prFreeIBSQL(TdtIBS);
    cntsTDT.SetFreeCnt(TdtIBD);
  end;
end;
//----------------------------------------------------- проверка связок артиклей
function TestNotLoadArticleLinksFromTDT(supliers: String=''): String;
const nmProc = 'TestNotLoadArticleLinksFromTDT'; // имя процедуры/функции
var TdtIBD, ordIBD: TIBDatabase;
    TdtIBS, ordIBS, ordIBSa: TIBSQL;
    i, pSupMFTD, pWareID, pModID, pMLid, pMFid: integer;
    s, pArticleTD, sName, sWare, sf, nf, nf1, sVis: string;
    Ware: TWareInfo;
begin
  Result:= '';
  TdtIBD:= nil;
  ordIBD:= nil;
  TdtIBS:= nil;
  ordIBS:= nil;
  ordIBSa:= nil;
  try
    try
      ordIBD:= cntsORD.GetFreeCnt;
      if not Assigned(ordIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
      ordIBSa:= fnCreateNewIBSQL(ordIBD, 'ordIBSa_'+nmProc);
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpRead, true);
      ordIBSa.SQL.Text:= 'select WATDARTSUP, WATDARTICLE, WATDWARECODE'+
        ' from WAREARTICLETD'+
        fnIfStr(supliers='', '', ' where WATDARTSUP in ('+supliers+')')+
        ' order by WATDARTSUP, WATDARTICLE';

      ordIBS.SQL.Text:= 'select count(ldemtrnacode)'+
        ' from LINKDETAILMODEL, LINKDETMODWARE, DIRMODELS'+
        ' where LDMWLDEMCODE=LDEMCODE and DMOSCODE=LDEMDMOSCODE'+
        ' and LDMWWARECODE=:WareID and DMOSTDCODE=:mt';
      ordIBS.Prepare;

      TdtIBD:= cntsTDT.GetFreeCnt;
      if not Assigned(TdtIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
      TdtIBS:= fnCreateNewIBSQL(TdtIBD, 'TdtIBS_'+nmProc, -1, tpRead, true);
      TdtIBS.SQL.Text:= 'select c, xMT, ms_mf_id, ms_mf_descr, ms_id, ms_descr,'+
        ' mt_descr, mt_from, mt_to, ms_from'+
        ' from ( select count(xGA) c, xMT from GETARTICLEGATYPESNew(:art_nr, :SupMF) group by xMT )'+
        ' left join model_types on mt_id = xMT'+
        ' left join model_series on ms_id = mt_ms_id'+
        ' order by ms_mf_descr, ms_descr, mt_descr';
      TdtIBS.Prepare;

      sf:= FormatDateTime('_mm_dd_hhmm', Now)+'.txt';
      ordIBSa.ExecQuery;
      while not ordIBSa.Eof do begin
        pWareID:= ordIBSa.FieldByName('WATDWARECODE').AsInteger;
        Ware:= Cache.GetWare(pWareID);
        if Ware.IsSale then begin
          ordIBSa.Next;
          Continue;
        end;
        pSupMFTD:= ordIBSa.FieldByName('WATDARTSUP').AsInteger;
        pArticleTD:= ordIBSa.FieldByName('WATDARTICLE').AsString;
        sWare:= ordIBSa.FieldByName('WATDWARECODE').AsString;
        sName:= Copy(Ware.Name, 1, 40);

        nf:= 'loads\NotLoad_'+Ware.GrpName+sf;
        nf1:= 'loads\Load_'+Ware.GrpName+sf;
        if not FileExists(nf) then begin
          s:= fnMakeAddCharStr(' код.т.GR', 10)+'  '+fnMakeAddCharStr('  товар', 42, True)+
            fnMakeAddCharStr('  произв.', 17, True)+fnMakeAddCharStr('  мод.ряд', 42, True)+
            fnMakeAddCharStr('  модель', 42, True)+fnMakeAddCharStr('  от', 10, True)+
            fnMakeAddCharStr('  до', 10, True)+fnMakeAddCharStr('код.м.TD ', 10)+'вид.пр.мр.м.';
          prMessageLOGn(s, nf);
        end;
        if not FileExists(nf1) then begin
          s:= fnMakeAddCharStr(' код.т.GR', 10)+'  '+fnMakeAddCharStr('  товар', 42, True)+
            fnMakeAddCharStr('  произв.', 17, True)+fnMakeAddCharStr('  мод.ряд', 42, True)+
            fnMakeAddCharStr('  модель', 42, True)+fnMakeAddCharStr('  от', 10, True)+
            fnMakeAddCharStr('  до', 10, True)+fnMakeAddCharStr('загружено', 10);
          prMessageLOGn(s, nf1);
          prMessageLOGn(' ', nf1);
        end;

        prMessageLOGn(' ', nf);
        TdtIBS.ParamByName('art_nr').AsString:= pArticleTD;
        TdtIBS.ParamByName('SupMF').AsInteger:= pSupMFTD;
        TdtIBS.ExecQuery;
        if (TdtIBS.Bof and TdtIBS.Eof) then begin
          s:= fnMakeAddCharStr(sWare, 10)+'  '+fnMakeAddCharStr(sName, 42, True)+'Not links in TecDoc';
          prMessageLOGn(s, nf);
          TdtIBS.Close;
          TestCssStopException;
          ordIBSa.Next;
          Continue;
        end;

        while not TdtIBS.Eof do begin
          if TdtIBS.FieldByName('ms_from').AsInteger<198001 then begin
            TdtIBS.Next;
            Continue;
          end;
          ordIBS.ParamByName('WareID').AsInteger:= pWareID;
          ordIBS.ParamByName('mt').AsInteger:= TdtIBS.FieldByName('xMT').AsInteger;
          ordIBS.ExecQuery;
          if (ordIBS.Bof and TdtIBS.Eof) then i:= 0 else i:= ordIBS.Fields[0].AsInteger;
          ordIBS.Close;
          if (i<1) then begin
            pMFid:= Cache.FDCA.Manufacturers.GetManufIDByTDcode(TdtIBS.FieldByName('ms_mf_id').AsInteger);
            if pMFid<1 then sVis:= '- - -'
            else begin
              sVis:= fnIfStr(Cache.FDCA.Manufacturers[pMFid].CheckIsVisible(1), '1', '0');
              pMLid:= Cache.FDCA.Manufacturers[pMFid].GetMfMLineIDByTDcode(TdtIBS.FieldByName('ms_id').AsInteger);
              if pMLid<1 then sVis:= sVis+' - -'
              else begin
                sVis:= sVis+' '+fnIfStr(Cache.FDCA.ModelLines[pMLid].IsVisible, '1', '0');
                pModID:= Cache.FDCA.ModelLines[pMLid].GetMLModelIDByTDcode(TdtIBS.FieldByName('xMT').AsInteger);
                if pModID<1 then sVis:= sVis+' -'
                else sVis:= sVis+' '+fnIfStr(Cache.FDCA.Models[pModID].IsVisible, '1', '0');
              end;
            end;

            s:= fnMakeAddCharStr(sWare, 10)+'  '+fnMakeAddCharStr(sName, 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('ms_mf_descr').AsString, 1, 15), 17, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('ms_descr').AsString, 1, 40), 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_descr').AsString, 1, 40), 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_from').AsString, 1, 8), 10, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_to').AsString, 1, 8), 10, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('xMT').AsString, 1, 9), 10)+
              fnMakeAddCharStr(sVis, 12);
            prMessageLOGn(s, nf);
          end else begin
            s:= fnMakeAddCharStr(sWare, 10)+'  '+fnMakeAddCharStr(sName, 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('ms_mf_descr').AsString, 1, 15), 17, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('ms_descr').AsString, 1, 40), 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_descr').AsString, 1, 40), 42, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_from').AsString, 1, 8), 10, True)+
              fnMakeAddCharStr(Copy(TdtIBS.FieldByName('mt_to').AsString, 1, 8), 10, True)+
              fnMakeAddCharStr(IntToStr(i)+' links', 10);
            prMessageLOGn(s, nf1);
          end;
          TestCssStopException;
          TdtIBS.Next;
        end;
        TdtIBS.Close;
  //      Application.ProcessMessages;
        TestCssStopException;
        ordIBSa.Next;
      end;
      Result:= 'обработано '+supliers;
    finally
      prFreeIBSQL(ordIBS);
      prFreeIBSQL(ordIBSa);
      cntsORD.SetFreeCnt(ordIBD);
      prFreeIBSQL(TdtIBS);
      cntsTDT.SetFreeCnt(TdtIBD);
    end;
  except
    on E: Exception do Result:= nmProc+': '+E.Message;
  end;
end;

//******************************************************************************
//                         импорт - администрирование баз
//******************************************************************************
//======================= удаление моделей авто из базы ORD по файлу Excel (xls)
procedure prDeleteAutoModels(UserID: integer; FileName: string; ThreadData: TThreadData=nil);
// структура файла: имя листа - 'удалить модели'(нельзя менять),
// столбцы - произв.;мод.ряд;м.р.вид.;м.р.от;м.р.до;модель;м.вид.;м.от;м.до;код м.р.;код.мод.;результат (можно менять)
// обрабатывается 11-й столбец, результат записывается в 12-й столбец
const nmProc = 'prDeleteAutoModels'; // имя процедуры/функции
      iDelModID = 10; iResDelMod = 11;
var mORD, iDel, iErr, i, iLine, Del2, Del3, Delut, Delen, delTxt, delCriV, delEng: integer;
    ss: string;
    TimeProc: TDateTime;
    ordIBD: TIBDatabase;
    ordIBS: TIBSQL;
    ADOConnection: TADOConnection;
    ADOTable: TADOTable;
  //--------------------------------------------- запись значения в ячейку index
  procedure SaveValueADO(index: Word; txt: String);
  begin
    ADOTable.Edit;
    ADOTable.Fields[index].Value:= txt;
    ADOTable.Post;
  end;
  //------------------------------------ добавление строки и запись в 0-ю ячейку
  procedure AddRecordADO(S: String);
  begin
    ADOTable.Append;
    ADOTable.Fields[0].Value:= S;
    ADOTable.Post;
  end;
  //---------------------------------------------
begin
  TimeProc:= Now;
  iDel:= 0;
  iErr:= 0;
  Del2:= 0;
  Del3:= 0;
  Delut:= 0;
  Delen:= 0;
  delTxt:= 0;
  delCriV:= 0;
  delEng:= 0;
  ordIBS:= nil;
//  ordIBD:= nil;
  ADOConnection:= nil;
  ADOTable:= nil;
  with Cache.FDCA do try try
    ordIBD:= cntsORD.GetFreeCnt;
    if not Assigned(ordIBD) then raise Exception.Create(MessText(mtkErrConnectToDB));
    try
      ordIBS:= fnCreateNewIBSQL(ordIBD, 'ordIBS_'+nmProc, -1, tpWrite, True);
      ordIBS.ParamCheck:= False; // запоминаем кол-во записей в таблицах
      ordIBS.SQL.Add('execute block returns (Del2 integer, Del3 integer, Delut integer,');
      ordIBS.SQL.Add('  Delen integer, delTxt integer, delCriV integer, delEng integer)');
      ordIBS.SQL.Add('as declare variable xcount integer = 0; begin');
      ordIBS.SQL.Add('  del2 = 0; del3 = 0; delut = 0; delen = 0;');
      ordIBS.SQL.Add('  delTxt = 0; delCriV = 0; delEng = 0;');
      ordIBS.SQL.Add('  select count(*) from linkdetailmodel into :del2;');
      ordIBS.SQL.Add('  select count(*) from linkdetmodware into :del3;');
      ordIBS.SQL.Add('  select count(*) from linkwaremodelnodeusage into :delut;');
      ordIBS.SQL.Add('  select count(*) from linkwarenodemodeltext into :xcount;');
      ordIBS.SQL.Add('  if (xcount>0) then delut=delut+xcount;');
      ordIBS.SQL.Add('  select count(*) from linkmodelsengines into :delen;');
      ordIBS.SQL.Add('  select count(*) from wareinfotexts into :delTxt;');
      ordIBS.SQL.Add('  select count(*) from warecrivalues into :delCriV;');
      ordIBS.SQL.Add('  select count(*) from direngines into :delEng;');
      ordIBS.SQL.Add('  suspend; end');
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) then begin
        Del2    := ordIBS.Fields[0].AsInteger;
        Del3    := ordIBS.Fields[1].AsInteger;
        Delut   := ordIBS.Fields[2].AsInteger;
        Delen   := ordIBS.Fields[3].AsInteger;
        delTxt  := ordIBS.Fields[4].AsInteger;
        delCriV := ordIBS.Fields[5].AsInteger;
        delEng  := ordIBS.Fields[6].AsInteger;
      end;
      ordIBS.Close;

      ordIBS.SQL.Clear; // готовим текст для удаления 1-й модели
      ordIBS.SQL.Add('execute block returns (DelModel integer) as declare variable MLine integer = 0;');
      ordIBS.SQL.Add('  declare variable ldem integer = 0; declare variable ldmw integer = 0; begin');
      ordIBS.SQL.Add('  DelModel = 0;'); // в цикле меняем
      ordIBS.SQL.Add('  if (exists(select * from dirmodels m where m.dmoscode=:DelModel)) then begin');
      ordIBS.SQL.Add('    select m.dmosdrmlcode from dirmodels m where m.dmoscode=:DelModel into:MLine;');
      ordIBS.SQL.Add('    if (exists(select * from linkdetailmodel where ldemdmoscode=:DelModel)) then begin');
      ordIBS.SQL.Add('      for select l.ldemcode from linkdetailmodel l where l.ldemdmoscode=:DelModel into :ldem do begin');
      ordIBS.SQL.Add('        if (exists(select * from linkdetmodware lw where lw.ldmwldemcode=:ldem)) then begin');
      ordIBS.SQL.Add('          for select lw.ldmwcode from linkdetmodware lw where lw.ldmwldemcode=:ldem into :ldmw do begin');
      ordIBS.SQL.Add('            if (exists(select * from linkwaremodelnodeusage u where u.lwmnuldmwcode=:ldmw)) then');
      ordIBS.SQL.Add('              delete from linkwaremodelnodeusage u where u.lwmnuldmwcode=:ldmw;');
      ordIBS.SQL.Add('            if (exists(select * from linkwarenodemodeltext u where u.lwnmtldmw=:ldmw)) then');
      ordIBS.SQL.Add('              delete from linkwarenodemodeltext u where u.lwnmtldmw=:ldmw; end');
      ordIBS.SQL.Add('          delete from linkdetmodware lw where lw.ldmwldemcode=:ldem; end end');
      ordIBS.SQL.Add('      delete from linkdetailmodel l where l.ldemdmoscode=:DelModel; end');
      ordIBS.SQL.Add('    if (exists(select * from linkmodelsengines u where u.lmendmoscode=:DelModel)) then');
      ordIBS.SQL.Add('      delete from linkmodelsengines u where u.lmendmoscode=:DelModel;');
      ordIBS.SQL.Add('    delete from dirmodels m where m.dmoscode=:DelModel; ');
      ordIBS.SQL.Add('    if (not(exists(select * from dirmodels m where m.dmosdrmlcode=:MLine))) then begin');
      ordIBS.SQL.Add('      update dirmodellines ml set ml.drmlisvisible="F" where ml.drmlcode=:MLine; end end');
      ordIBS.SQL.Add('  suspend; end');
      try
        CoInitialize(nil);
        ADOConnection:= CreateADOConnection(ExpandFileName(FileName), atExcel2003); // подключаемся к файлу Excel как к БД
        ADOConnection.Open;
        ADOConnection.BeginTrans;

        ADOTable:= CreateADOTable(ADOConnection, '[удалить модели$]'); // лист книги как таблица
        ADOTable.Open;
        if ADOTable.FieldCount<(iResDelMod+1) then // проверяем кол-во столбцов
          raise Exception.Create(MessText(mtkNotEnoughParams)+' файла');

        for i:= 0 to ADOTable.FieldCount-1 do // символьные поля
          if (i in [0, 1, 5, iResDelMod]) then ADOTable.Fields[i].SetFieldType(ftString);
      except
        on E: Exception do begin
          prMessageLOGS(nmProc+': ошибка ADOConnection '+E.Message, 'import', False);
          raise Exception.Create(E.Message);
        end;
      end;

      iLine:= 0;
      while not ADOTable.Eof do begin
        try                              // считываем параметры 1-й строки файла
          if copy(ADOTable.Fields[0].AsString, 1, 6)='время:' then begin // старое время убираем
            SaveValueADO(0, '');
            ADOTable.Next;
            Continue;
          end;

          mORD:= fnStrToIntDef(ADOTable.Fields[iDelModID].AsString, 0);   // ID модели
          if (mORD<1) then raise Exception.Create(MessText(mtkNotEnoughParams));  // если не хватает параметров
          if not Models.ModelExists(mORD) then
            raise Exception.Create('не найдена'); // если не нашли для удаления

          ss:= '';
          with ordIBS.Transaction do if not InTransaction then StartTransaction;
          ordIBS.SQL[2]:= '  DelModel = '+IntToStr(mORD)+';';
          ordIBS.ExecQuery;                                  // удаляем
          if (ordIBS.Bof and ordIBS.Eof) or (ordIBS.Fields[0].AsInteger<>mORD) then
            raise Exception.Create('error execute block');
          SaveValueADO(iResDelMod, 'удалена'); // вписываем результат
          with ordIBS.Transaction do if InTransaction then Commit;
          inc(iDel);
        except
          on E: Exception do begin
            with ordIBS.Transaction do if InTransaction then Rollback;
            inc(iErr);
            prMessageLOGS(nmProc+': ошибка в строке '+IntToStr(iLine)+' '+E.Message, 'import', False);
            if E.Message<>'' then SaveValueADO(iResDelMod, E.Message); // вписываем сообщение
          end;
        end;
        ordIBS.Close;
        CheckStopExecute(UserID, ThreadData);
        ADOTable.Next;
        inc(iLine);
      end;

      with ordIBS.Transaction do if not InTransaction then StartTransaction;
      ordIBS.SQL.Clear; // вычисляем, сколько записей удалили, и чистим справочники
      ordIBS.SQL.Add('execute block returns (Del2 integer, Del3 integer, Delut integer,');
      ordIBS.SQL.Add('  Delen integer, delTxt integer, delCriV integer, delEng integer)');
      ordIBS.SQL.Add('as declare variable xcount integer = 0; begin');
      ordIBS.SQL.Add('  del2 = 0; del3 = 0; delut = 0; delen = 0;');
      ordIBS.SQL.Add('  delTxt = 0; delCriV = 0; delEng = 0;');
      ordIBS.SQL.Add('  select count(*) from linkdetailmodel into :del2;');
      ordIBS.SQL.Add('  select count(*) from linkdetmodware into :del3;');
      ordIBS.SQL.Add('  select count(*) from linkwaremodelnodeusage into :delut;');
      ordIBS.SQL.Add('  select count(*) from linkwarenodemodeltext into :xcount;');
      ordIBS.SQL.Add('  if (xcount>0) then delut=delut+xcount;');
      ordIBS.SQL.Add('  select count(*) from linkmodelsengines into :delen;');
      ordIBS.SQL.Add('  for select e.dengcode from direngines e into :xcount do');
      ordIBS.SQL.Add('    if (not(exists(select * from linkmodelsengines u where u.lmendengcode=:xcount))) then');
      ordIBS.SQL.Add('      delete from direngines u where u.dengcode=:xcount;');
      ordIBS.SQL.Add('  for select t.witcode from wareinfotexts t into :xcount do');
      ordIBS.SQL.Add('    if ((not(exists(select * from linkwarenodemodeltext u where u.lwnmtwit=:xcount))) and');
      ordIBS.SQL.Add('      (not(exists(select * from linkwarenodetext u1 where u1.lwntwit=:xcount)))) then');
      ordIBS.SQL.Add('      delete from wareinfotexts u where u.witcode=:xcount;');
      ordIBS.SQL.Add('  for select t.wcvscode from warecrivalues t into :xcount do');
      ordIBS.SQL.Add('    if ((not(exists(select * from linkwarecrivalues u where u.lwcvwcvscode=:xcount))) and');
      ordIBS.SQL.Add('      (not(exists(select * from linkwaremodelnodeusage u1 where u1.lwmnuwcvscode=:xcount)))) then');
      ordIBS.SQL.Add('      delete from warecrivalues u where u.wcvscode=:xcount;');
      ordIBS.SQL.Add('  select count(*) from wareinfotexts into :delTxt;');
      ordIBS.SQL.Add('  select count(*) from warecrivalues into :delCriV;');
      ordIBS.SQL.Add('  select count(*) from direngines into :delEng;');
      ordIBS.SQL.Add('  suspend; end');
      ordIBS.ExecQuery;
      if not (ordIBS.Bof and ordIBS.Eof) then begin
        Del2    := Del2    -ordIBS.Fields[0].AsInteger;
        Del3    := Del3    -ordIBS.Fields[1].AsInteger;
        Delut   := Delut   -ordIBS.Fields[2].AsInteger;
        Delen   := Delen   -ordIBS.Fields[3].AsInteger;
        delTxt  := delTxt  -ordIBS.Fields[4].AsInteger;
        delCriV := delCriV -ordIBS.Fields[5].AsInteger;
        delEng  := delEng  -ordIBS.Fields[6].AsInteger;
      end;
    finally
      prFreeIBSQL(ordIBS);
      cntsORD.SetFreeCnt(ordIBD);
    end;

    try
      AddRecordADO('-----------');                                    // итоги
      AddRecordADO('обработано:   '+IntToStr(iDel+iErr)+' строк');
      AddRecordADO('ошибки    :   '+IntToStr(iErr)+' строк');
      if iDel>0     then AddRecordADO('удалено   :   '+IntToStr(iDel)+' моделей');
      if Del2>0     then AddRecordADO('удалено   :   '+IntToStr(Del2)+' связок 2');
      if Del3>0     then AddRecordADO('удалено   :   '+IntToStr(Del3)+' связок 3');
      if Delut>0    then AddRecordADO('удалено   :   '+IntToStr(Delut)+' условий');
      if Delen>0    then AddRecordADO('удалено   :   '+IntToStr(Delen)+' марк.');
      if delTxt>0    then AddRecordADO('удалено   :   '+IntToStr(delTxt)+' текстов');
      if delCriV>0   then AddRecordADO('удалено   :   '+IntToStr(delCriV)+' зн.крит.');
      if delEng>0    then AddRecordADO('удалено   :   '+IntToStr(delEng)+' двиг.');
      AddRecordADO('-----------');
      AddRecordADO('время     : '+GetLogTimeStr(TimeProc));
    except
      on E: Exception do prMessageLOGS(nmProc+': ошибка в итогах '+E.Message, 'import', False);
    end;
  except
    on E: Exception do begin
      prMessageLOGS(nmProc+': '+E.Message, 'import', False);
      E.Message:= nmProc+': '+E.Message;
      raise Exception.Create(E.Message);
    end;
  end; // with Cache.FDCA
  finally
    if assigned(ADOConnection) then begin
      ADOConnection.CommitTrans;
      DestroyADOConnection(ADOConnection);
    end;
    DestroyADOTable(ADOTable);
    CoUnInitialize;
    if iDel>0 then begin
      FillDirEngines(False);
      FillDirModels(False);
      FillDirModelLines(False);
    end;
  end;
end;

//******************************************************************************
{procedure ClearSearchArticle;
var i: Integer;
begin
  SetLength(arSearchArticleMF, 0);
  for i:= 0 to High(arSearchArticleLists) do prFree(arSearchArticleLists[i]);
  SetLength(arSearchArticleLists, 0);
end; }
initialization
begin
//  SetLength(arSearchArticleMF, 0);
//  SetLength(arSearchArticleLists, 0);
end;
finalization
begin
//  ClearSearchArticle;
end;

//******************************************************************************
{ синхронизация -  Группа 3.
+ - Связь товара с информационным файлом (рисунки, pdf-файлы).
+ - Связки товара с критериями.
+ - Привязка инфотекстов к связкам  товар-узел.
1 - Привязки критериев к связкам-3 по моделям.
1 - Привязки инфотекстов к связкам-3 по моделям.
1 - Привязки критериев к связкам-3 по двигателям.}
end.
